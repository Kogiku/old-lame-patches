diff -r -c -N encoder/COPYING lame3.13/COPYING
*** encoder/COPYING	Wed Dec 31 17:00:00 1969
--- lame3.13/COPYING	Thu May  6 13:37:52 1999
***************
*** 0 ****
--- 1,340 ----
+ 		    GNU GENERAL PUBLIC LICENSE
+ 		       Version 2, June 1991
+ 
+  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  Everyone is permitted to copy and distribute verbatim copies
+  of this license document, but changing it is not allowed.
+ 
+ 			    Preamble
+ 
+   The licenses for most software are designed to take away your
+ freedom to share and change it.  By contrast, the GNU General Public
+ License is intended to guarantee your freedom to share and change free
+ software--to make sure the software is free for all its users.  This
+ General Public License applies to most of the Free Software
+ Foundation's software and to any other program whose authors commit to
+ using it.  (Some other Free Software Foundation software is covered by
+ the GNU Library General Public License instead.)  You can apply it to
+ your programs, too.
+ 
+   When we speak of free software, we are referring to freedom, not
+ price.  Our General Public Licenses are designed to make sure that you
+ have the freedom to distribute copies of free software (and charge for
+ this service if you wish), that you receive source code or can get it
+ if you want it, that you can change the software or use pieces of it
+ in new free programs; and that you know you can do these things.
+ 
+   To protect your rights, we need to make restrictions that forbid
+ anyone to deny you these rights or to ask you to surrender the rights.
+ These restrictions translate to certain responsibilities for you if you
+ distribute copies of the software, or if you modify it.
+ 
+   For example, if you distribute copies of such a program, whether
+ gratis or for a fee, you must give the recipients all the rights that
+ you have.  You must make sure that they, too, receive or can get the
+ source code.  And you must show them these terms so they know their
+ rights.
+ 
+   We protect your rights with two steps: (1) copyright the software, and
+ (2) offer you this license which gives you legal permission to copy,
+ distribute and/or modify the software.
+ 
+   Also, for each author's protection and ours, we want to make certain
+ that everyone understands that there is no warranty for this free
+ software.  If the software is modified by someone else and passed on, we
+ want its recipients to know that what they have is not the original, so
+ that any problems introduced by others will not reflect on the original
+ authors' reputations.
+ 
+   Finally, any free program is threatened constantly by software
+ patents.  We wish to avoid the danger that redistributors of a free
+ program will individually obtain patent licenses, in effect making the
+ program proprietary.  To prevent this, we have made it clear that any
+ patent must be licensed for everyone's free use or not licensed at all.
+ 
+   The precise terms and conditions for copying, distribution and
+ modification follow.
+ 
+ 		    GNU GENERAL PUBLIC LICENSE
+    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+ 
+   0. This License applies to any program or other work which contains
+ a notice placed by the copyright holder saying it may be distributed
+ under the terms of this General Public License.  The "Program", below,
+ refers to any such program or work, and a "work based on the Program"
+ means either the Program or any derivative work under copyright law:
+ that is to say, a work containing the Program or a portion of it,
+ either verbatim or with modifications and/or translated into another
+ language.  (Hereinafter, translation is included without limitation in
+ the term "modification".)  Each licensee is addressed as "you".
+ 
+ Activities other than copying, distribution and modification are not
+ covered by this License; they are outside its scope.  The act of
+ running the Program is not restricted, and the output from the Program
+ is covered only if its contents constitute a work based on the
+ Program (independent of having been made by running the Program).
+ Whether that is true depends on what the Program does.
+ 
+   1. You may copy and distribute verbatim copies of the Program's
+ source code as you receive it, in any medium, provided that you
+ conspicuously and appropriately publish on each copy an appropriate
+ copyright notice and disclaimer of warranty; keep intact all the
+ notices that refer to this License and to the absence of any warranty;
+ and give any other recipients of the Program a copy of this License
+ along with the Program.
+ 
+ You may charge a fee for the physical act of transferring a copy, and
+ you may at your option offer warranty protection in exchange for a fee.
+ 
+   2. You may modify your copy or copies of the Program or any portion
+ of it, thus forming a work based on the Program, and copy and
+ distribute such modifications or work under the terms of Section 1
+ above, provided that you also meet all of these conditions:
+ 
+     a) You must cause the modified files to carry prominent notices
+     stating that you changed the files and the date of any change.
+ 
+     b) You must cause any work that you distribute or publish, that in
+     whole or in part contains or is derived from the Program or any
+     part thereof, to be licensed as a whole at no charge to all third
+     parties under the terms of this License.
+ 
+     c) If the modified program normally reads commands interactively
+     when run, you must cause it, when started running for such
+     interactive use in the most ordinary way, to print or display an
+     announcement including an appropriate copyright notice and a
+     notice that there is no warranty (or else, saying that you provide
+     a warranty) and that users may redistribute the program under
+     these conditions, and telling the user how to view a copy of this
+     License.  (Exception: if the Program itself is interactive but
+     does not normally print such an announcement, your work based on
+     the Program is not required to print an announcement.)
+ 
+ These requirements apply to the modified work as a whole.  If
+ identifiable sections of that work are not derived from the Program,
+ and can be reasonably considered independent and separate works in
+ themselves, then this License, and its terms, do not apply to those
+ sections when you distribute them as separate works.  But when you
+ distribute the same sections as part of a whole which is a work based
+ on the Program, the distribution of the whole must be on the terms of
+ this License, whose permissions for other licensees extend to the
+ entire whole, and thus to each and every part regardless of who wrote it.
+ 
+ Thus, it is not the intent of this section to claim rights or contest
+ your rights to work written entirely by you; rather, the intent is to
+ exercise the right to control the distribution of derivative or
+ collective works based on the Program.
+ 
+ In addition, mere aggregation of another work not based on the Program
+ with the Program (or with a work based on the Program) on a volume of
+ a storage or distribution medium does not bring the other work under
+ the scope of this License.
+ 
+   3. You may copy and distribute the Program (or a work based on it,
+ under Section 2) in object code or executable form under the terms of
+ Sections 1 and 2 above provided that you also do one of the following:
+ 
+     a) Accompany it with the complete corresponding machine-readable
+     source code, which must be distributed under the terms of Sections
+     1 and 2 above on a medium customarily used for software interchange; or,
+ 
+     b) Accompany it with a written offer, valid for at least three
+     years, to give any third party, for a charge no more than your
+     cost of physically performing source distribution, a complete
+     machine-readable copy of the corresponding source code, to be
+     distributed under the terms of Sections 1 and 2 above on a medium
+     customarily used for software interchange; or,
+ 
+     c) Accompany it with the information you received as to the offer
+     to distribute corresponding source code.  (This alternative is
+     allowed only for noncommercial distribution and only if you
+     received the program in object code or executable form with such
+     an offer, in accord with Subsection b above.)
+ 
+ The source code for a work means the preferred form of the work for
+ making modifications to it.  For an executable work, complete source
+ code means all the source code for all modules it contains, plus any
+ associated interface definition files, plus the scripts used to
+ control compilation and installation of the executable.  However, as a
+ special exception, the source code distributed need not include
+ anything that is normally distributed (in either source or binary
+ form) with the major components (compiler, kernel, and so on) of the
+ operating system on which the executable runs, unless that component
+ itself accompanies the executable.
+ 
+ If distribution of executable or object code is made by offering
+ access to copy from a designated place, then offering equivalent
+ access to copy the source code from the same place counts as
+ distribution of the source code, even though third parties are not
+ compelled to copy the source along with the object code.
+ 
+   4. You may not copy, modify, sublicense, or distribute the Program
+ except as expressly provided under this License.  Any attempt
+ otherwise to copy, modify, sublicense or distribute the Program is
+ void, and will automatically terminate your rights under this License.
+ However, parties who have received copies, or rights, from you under
+ this License will not have their licenses terminated so long as such
+ parties remain in full compliance.
+ 
+   5. You are not required to accept this License, since you have not
+ signed it.  However, nothing else grants you permission to modify or
+ distribute the Program or its derivative works.  These actions are
+ prohibited by law if you do not accept this License.  Therefore, by
+ modifying or distributing the Program (or any work based on the
+ Program), you indicate your acceptance of this License to do so, and
+ all its terms and conditions for copying, distributing or modifying
+ the Program or works based on it.
+ 
+   6. Each time you redistribute the Program (or any work based on the
+ Program), the recipient automatically receives a license from the
+ original licensor to copy, distribute or modify the Program subject to
+ these terms and conditions.  You may not impose any further
+ restrictions on the recipients' exercise of the rights granted herein.
+ You are not responsible for enforcing compliance by third parties to
+ this License.
+ 
+   7. If, as a consequence of a court judgment or allegation of patent
+ infringement or for any other reason (not limited to patent issues),
+ conditions are imposed on you (whether by court order, agreement or
+ otherwise) that contradict the conditions of this License, they do not
+ excuse you from the conditions of this License.  If you cannot
+ distribute so as to satisfy simultaneously your obligations under this
+ License and any other pertinent obligations, then as a consequence you
+ may not distribute the Program at all.  For example, if a patent
+ license would not permit royalty-free redistribution of the Program by
+ all those who receive copies directly or indirectly through you, then
+ the only way you could satisfy both it and this License would be to
+ refrain entirely from distribution of the Program.
+ 
+ If any portion of this section is held invalid or unenforceable under
+ any particular circumstance, the balance of the section is intended to
+ apply and the section as a whole is intended to apply in other
+ circumstances.
+ 
+ It is not the purpose of this section to induce you to infringe any
+ patents or other property right claims or to contest validity of any
+ such claims; this section has the sole purpose of protecting the
+ integrity of the free software distribution system, which is
+ implemented by public license practices.  Many people have made
+ generous contributions to the wide range of software distributed
+ through that system in reliance on consistent application of that
+ system; it is up to the author/donor to decide if he or she is willing
+ to distribute software through any other system and a licensee cannot
+ impose that choice.
+ 
+ This section is intended to make thoroughly clear what is believed to
+ be a consequence of the rest of this License.
+ 
+   8. If the distribution and/or use of the Program is restricted in
+ certain countries either by patents or by copyrighted interfaces, the
+ original copyright holder who places the Program under this License
+ may add an explicit geographical distribution limitation excluding
+ those countries, so that distribution is permitted only in or among
+ countries not thus excluded.  In such case, this License incorporates
+ the limitation as if written in the body of this License.
+ 
+   9. The Free Software Foundation may publish revised and/or new versions
+ of the General Public License from time to time.  Such new versions will
+ be similar in spirit to the present version, but may differ in detail to
+ address new problems or concerns.
+ 
+ Each version is given a distinguishing version number.  If the Program
+ specifies a version number of this License which applies to it and "any
+ later version", you have the option of following the terms and conditions
+ either of that version or of any later version published by the Free
+ Software Foundation.  If the Program does not specify a version number of
+ this License, you may choose any version ever published by the Free Software
+ Foundation.
+ 
+   10. If you wish to incorporate parts of the Program into other free
+ programs whose distribution conditions are different, write to the author
+ to ask for permission.  For software which is copyrighted by the Free
+ Software Foundation, write to the Free Software Foundation; we sometimes
+ make exceptions for this.  Our decision will be guided by the two goals
+ of preserving the free status of all derivatives of our free software and
+ of promoting the sharing and reuse of software generally.
+ 
+ 			    NO WARRANTY
+ 
+   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+ FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+ OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+ PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+ OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+ TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+ PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+ REPAIR OR CORRECTION.
+ 
+   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+ WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+ REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+ INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+ OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+ TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+ YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+ PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGES.
+ 
+ 		     END OF TERMS AND CONDITIONS
+ 
+ 	    How to Apply These Terms to Your New Programs
+ 
+   If you develop a new program, and you want it to be of the greatest
+ possible use to the public, the best way to achieve this is to make it
+ free software which everyone can redistribute and change under these terms.
+ 
+   To do so, attach the following notices to the program.  It is safest
+ to attach them to the start of each source file to most effectively
+ convey the exclusion of warranty; and each file should have at least
+ the "copyright" line and a pointer to where the full notice is found.
+ 
+     <one line to give the program's name and a brief idea of what it does.>
+     Copyright (C) 19yy  <name of author>
+ 
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+ 
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+ 
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ 
+ 
+ Also add information on how to contact you by electronic and paper mail.
+ 
+ If the program is interactive, make it output a short notice like this
+ when it starts in an interactive mode:
+ 
+     Gnomovision version 69, Copyright (C) 19yy name of author
+     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+     This is free software, and you are welcome to redistribute it
+     under certain conditions; type `show c' for details.
+ 
+ The hypothetical commands `show w' and `show c' should show the appropriate
+ parts of the General Public License.  Of course, the commands you use may
+ be called something other than `show w' and `show c'; they could even be
+ mouse-clicks or menu items--whatever suits your program.
+ 
+ You should also get your employer (if you work as a programmer) or your
+ school, if any, to sign a "copyright disclaimer" for the program, if
+ necessary.  Here is a sample; alter the names:
+ 
+   Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+   `Gnomovision' (which makes passes at compilers) written by James Hacker.
+ 
+   <signature of Ty Coon>, 1 April 1989
+   Ty Coon, President of Vice
+ 
+ This General Public License does not permit incorporating your program into
+ proprietary programs.  If your program is a subroutine library, you may
+ consider it more useful to permit linking proprietary applications with the
+ library.  If this is what you want to do, use the GNU Library General
+ Public License instead of this License.
diff -r -c -N encoder/Dll/BladeMP3EncDLL.c lame3.13/Dll/BladeMP3EncDLL.c
*** encoder/Dll/BladeMP3EncDLL.c	Wed Dec 31 17:00:00 1969
--- lame3.13/Dll/BladeMP3EncDLL.c	Sat Jun 19 00:17:40 1999
***************
*** 0 ****
--- 1,491 ----
+ /*
+  *	Blade DLL Interface for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "BladeMP3EncDLL.h"
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <string.h>
+ #include <time.h>
+ #include <assert.h>
+ #include "common.h"
+ #include "version.h"
+ #include "VbrTag.h"
+ 
+ 
+ const int MAJORVERSION=0;
+ const int MINORVERSION=21;
+ 
+ static short int InputBuffer[2][1152];
+ 
+ int nBladeBufferSize;
+ 
+ extern encodeframe();
+ extern void InitFormatBitStream(void);
+ extern void InitReservoir(void);
+ extern int sfb21;
+ extern int fast_mode;
+ extern int gpsycho;
+ extern int force_ms;
+ extern int VBR_q;
+ extern int g_bWriteVbrTag;
+ 
+ // Local variables
+ static int		nPsychoModel=2;
+ static BOOL		bFirstFrame=TRUE;
+ static DWORD	dwSampleBufferSize=0;
+ 
+ 
+ #ifdef _DEBUG
+ void dump_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath);
+ #endif
+ 
+ // Taken from main.c
+ static char			original_file_name[MAX_NAME_SIZE];
+ static char			encoded_file_name[MAX_NAME_SIZE];
+ static int			stereo, error_protection;
+ static layer		info;
+ 
+ 
+ // Variables that we "borrow" from Musicin.c
+ extern frame_params		fr_ps;
+ extern unsigned long	num_samples;
+ extern int				gtkflag;
+ extern Bit_stream_struc bs;
+ extern int firstcall;
+ extern III_side_info_t l3_side;
+ 
+ 
+ extern void parse_args(int argc,char** argv,frame_params* fr_ps,int* psy,
+ 					unsigned long* num_samples,char* inPath,char* outPath);
+ 
+ extern void III_FlushBitstream();
+ 
+ static void InitParams()
+ {
+     // clear buffers
+     memset(InputBuffer, 0,sizeof(InputBuffer));
+  
+     memset(&bs, 0, sizeof(Bit_stream_struc));
+     memset(&fr_ps, 0, sizeof(frame_params));
+ 	memset(&l3_side,0x00,sizeof(III_side_info_t));
+ 
+     fr_ps.header = &info;
+     fr_ps.tab_num = -1;             /* no table loaded */
+     fr_ps.alloc = NULL;
+     info.version = MPEG_AUDIO_ID;   /* =1   Default: MPEG-1 */
+ 
+ 	bFirstFrame=TRUE;
+ 	firstcall = 1;
+ 
+ 	InitFormatBitStream();
+ 	InitReservoir();
+ 
+ }
+ 
+ #define NORMAL_QUALITY 0
+ #define LOW_QUALITY 1
+ #define HIGH_QUALITY 2
+ 
+ #define GPL_PSYCHOMODEL 0
+ #define ISO_PSYCHOMODEL 1
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream)
+ {
+ #define MAX_ARGV 20
+ 
+ 	char	strTmp[255];
+ 	int		nDllArgC=0;
+ 	char	DllArgV[20][80];
+ 	char*	argv[MAX_ARGV];
+ 	int		i;
+ 	int		nCRC=pbeConfig->format.mp3.bCRC;
+ 	int		nVBR;
+ 	int		nQuality;
+ 
+ 	// Get VBR setting from fourth nibble
+ 	nVBR=(nCRC>>12)&0x0F;
+ 	// Get Quality from third nibble
+ 	nQuality=(nCRC>>8)&0x0F;
+ 	// Get model from lower nibble (to be compatible with standard definition)
+ 	nCRC=(nCRC&0x01);
+ 
+ 	for (i=0;i<MAX_ARGV;i++)
+ 		argv[i]=DllArgV[i];
+ 
+ 	// Clear the external and local paramters
+ 	InitParams();
+ 
+ 	// Clear argument array
+ 	memset(&DllArgV[0][0],0x00,sizeof(DllArgV));
+ 
+ 	// Not used, always assign stream 1
+ 	*phbeStream=1;
+ 
+ 	// Set MP3 buffer size
+ 	*dwBufferSize=BUFFER_SIZE*2;
+ 
+ 
+ 	// Set number of input samples depending on the number of samples
+ 	if ((pbeConfig->format.mp3.byMode&0x0F)== BE_MP3_MODE_MONO)
+ 	{
+ 		// Mono channel, thus MPEGFRAMSIZE samples needed
+ 		*dwSamples=1152;
+ 	}
+ 	else
+ 	{
+ 		// For Stereo.Joint stereo and dual channel, need 2*MPEGFRAMESIZE samples
+ 		*dwSamples=1152*2;
+ 	}
+ 
+ 	// Set the input sample buffer size, so we know what we can expect
+ 	dwSampleBufferSize=*dwSamples;
+ 	
+ 	// --------------- Set arguments for ParseArg function -------------------------
+ 
+ 	// Set zero argument, the filename
+ 	strcpy(DllArgV[nDllArgC++],"LameDLLEncoder");
+ 
+   	switch (pbeConfig->format.mp3.byMode)
+ 	{
+ 		case BE_MP3_MODE_STEREO:
+ 			strcpy(DllArgV[nDllArgC++],"-ms");
+ 		break;
+ 		case BE_MP3_MODE_JSTEREO:
+ 			strcpy(DllArgV[nDllArgC++],"-mj");
+ 		break;
+ 		case BE_MP3_MODE_MONO:
+ 			strcpy(DllArgV[nDllArgC++],"-mm");
+ 		break;
+ 		case BE_MP3_MODE_DUALCHANNEL:
+ 			strcpy(DllArgV[nDllArgC++],"-mf");
+ 		break;
+ 		default:
+ 			return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ 	}
+ 
+ 	switch (nQuality)
+ 	{
+ 		case NORMAL_QUALITY:	// Nothing special
+ 		break;
+ 		case LOW_QUALITY:		// -f flag
+ 			strcpy(DllArgV[nDllArgC++],"-f");
+ 		break;
+ 		case HIGH_QUALITY:		// -k flag for high qualtiy
+ 			strcpy(DllArgV[nDllArgC++],"-k");
+ 		break;
+ 	}
+ 
+ 	if (nVBR)
+ 	{
+ 		// 0=no vbr 1..10 is VBR quality setting -1
+ 		sprintf(DllArgV[nDllArgC++],"-v");
+ 		sprintf(DllArgV[nDllArgC++],"-V%d",nVBR-1);
+ 	}
+ 
+ 	// Set frequency
+ 	sprintf(strTmp,"-s %f",pbeConfig->format.mp3.dwSampleRate/1000.0);
+ 	strcpy(DllArgV[nDllArgC++],strTmp);
+ 
+ 	// Set bitrate
+ 	sprintf(strTmp,"-b %d",pbeConfig->format.mp3.wBitrate);
+ 	strcpy(DllArgV[nDllArgC++],strTmp);
+ 	
+ 	// Set copyright flag?
+     if (pbeConfig->format.mp3.bCopyright)
+ 		strcpy(DllArgV[nDllArgC++],"-c");
+ 
+ 	// Do we have to tag  it as non original 
+     if (!pbeConfig->format.mp3.bOriginal)
+ 		strcpy(DllArgV[nDllArgC++],"-o");
+ 
+ 	// Add CRC?
+     if (nCRC)
+ 		strcpy(DllArgV[nDllArgC++],"-p");
+ 
+ 	// Add input filename
+ 	strcpy(DllArgV[nDllArgC++],"NULL.wav");
+ 
+ 	// Add output filename
+ 	strcpy(DllArgV[nDllArgC++],"NULL.mp3");
+ 
+ 	// Set the encoder variables
+ 	parse_args(nDllArgC,argv,&fr_ps,&nPsychoModel,&num_samples, original_file_name,encoded_file_name);
+ 
+ 	// Set private bit?
+ 	if (pbeConfig->bPrivate)
+ 	{
+ 		info.extension = 0;
+ 	}
+ 	else
+ 	{
+ 		info.extension = 1;
+ 	}
+ 
+ 
+     hdr_to_frps(&fr_ps);
+ 
+     stereo = fr_ps.stereo;
+ 
+     error_protection = info.error_protection;
+ 
+     if (info.lay != 3)
+ 	{
+ 		printf("Only Layer 3 supported\n");
+ 		return BE_ERR_INVALID_FORMAT_PARAMETERS;
+     }
+     if ( nPsychoModel != 2 )
+ 	{
+ 		fprintf( stderr, "Sorry, psycho model 1 not available for layer3\n" );
+ 		return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ 	}
+ 
+ #ifdef _DEBUG
+ 	dump_config(&fr_ps,&nPsychoModel,original_file_name,encoded_file_name);
+ #endif
+ 
+ 	// Everything went OK, thus return SUCCESSFUL
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 	// Set output buffer
+ 	bs.pbtOutBuf=pOutput;
+ 	bs.nOutBufPos=0;
+ 
+ 	// Crank out the last part of the buffer
+ 	if (fr_ps.header->lay == 3 )
+ 		III_FlushBitstream();
+ 
+ 	// close the stream
+ 	close_bit_stream_w( &bs );
+ 
+    // Number of bytes in output buffer
+ 	*pdwOutput=bs.nOutBufPos;
+ 
+ 	// Everything went OK, thus return SUCCESSFUL
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream)
+ {
+ 	// DeInit encoder
+ //	return DeInitEncoder();
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion)
+ {
+ 	// DLL Release date
+ 	char lpszDate[20];
+ 	char lpszTemp[5];
+ 
+ 
+ 	// Set DLL interface version
+ 	pbeVersion->byDLLMajorVersion=MAJORVERSION;
+ 	pbeVersion->byDLLMinorVersion=MINORVERSION;
+ 
+ 	// Set Engine version number (Same as Lame version)
+ 	pbeVersion->byMajorVersion=LAME_MAJOR_VERSION;
+ 	pbeVersion->byMinorVersion=LAME_MINOR_VERSION;
+ 
+ 	// Get compilation date
+ 	strcpy(lpszDate,__DATE__);
+ 
+ 	// Get the first three character, which is the month
+ 	strncpy(lpszTemp,lpszDate,3);
+ 
+ 	// Set month
+ 	if (strcmp(lpszTemp,"Jan")==0)	pbeVersion->byMonth=1;
+ 	if (strcmp(lpszTemp,"Feb")==0)	pbeVersion->byMonth=2;
+ 	if (strcmp(lpszTemp,"Mar")==0)	pbeVersion->byMonth=3;
+ 	if (strcmp(lpszTemp,"Apr")==0)	pbeVersion->byMonth=4;
+ 	if (strcmp(lpszTemp,"May")==0)	pbeVersion->byMonth=5;
+ 	if (strcmp(lpszTemp,"Jun")==0)	pbeVersion->byMonth=6;
+ 	if (strcmp(lpszTemp,"Jul")==0)	pbeVersion->byMonth=7;
+ 	if (strcmp(lpszTemp,"Aug")==0)	pbeVersion->byMonth=8;
+ 	if (strcmp(lpszTemp,"Sep")==0)	pbeVersion->byMonth=9;
+ 	if (strcmp(lpszTemp,"Oct")==0)	pbeVersion->byMonth=10;
+ 	if (strcmp(lpszTemp,"Nov")==0)	pbeVersion->byMonth=11;
+ 	if (strcmp(lpszTemp,"Dec")==0)	pbeVersion->byMonth=12;
+ 
+ 	// Get day of month string (char [4..5])
+ 	pbeVersion->byDay=atoi(lpszDate+4);
+ 
+ 	// Get year of compilation date (char [7..10])
+ 	pbeVersion->wYear=atoi(lpszDate+7);
+ 
+ 	memset(pbeVersion->zHomepage,0x00,BE_MAX_HOMEPAGE);
+ 
+ 	strcpy(pbeVersion->zHomepage,"http://www.surf.to/cdex");
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 	int iSampleIndex;
+ 
+ 	// Set output buffer
+ 	bs.pbtOutBuf=pOutput;
+ 	bs.nOutBufPos=0;
+ 
+ 	// Is this the last (incomplete) frame
+ 	if (nSamples<dwSampleBufferSize)
+ 	{
+ 		// Padd with zeros
+ 		memset(pSamples+nSamples,0x00,(dwSampleBufferSize-nSamples)*sizeof(SHORT));
+ 	}
+ 
+ 	// Set buffer size, in number of bytes
+ 	nBladeBufferSize=nSamples*sizeof(SHORT);
+ 
+ 	if (stereo==2)
+ 	{
+ 		for (iSampleIndex=0;iSampleIndex<1152;iSampleIndex++)
+ 		{
+ 			// Copy new sample data into InputBuffer
+ 			InputBuffer[0][iSampleIndex]=*pSamples++;
+ 			InputBuffer[1][iSampleIndex]=*pSamples++;
+ 		}
+ 	}
+ 	else
+ 	{
+ 		// Mono, only put it data into buffer[0] (=left channel)
+ 		for (iSampleIndex=0;iSampleIndex<1152;iSampleIndex++)
+ 		{
+ 			// Copy new sample data into InputBuffer
+ 			InputBuffer[0][iSampleIndex]=*pSamples++;
+ 		}
+ 	}
+ 
+ 
+ 	// Encode it
+ 	encodeframe(InputBuffer);
+ 
+ 	// Set number of output bytes
+ 	*pdwOutput=bs.nOutBufPos;
+ 
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR beWriteVBRHeader(LPCSTR lpszFileName)
+ {
+ 	if (g_bWriteVbrTag)
+ 	{
+ 		// Calculate relative quality of VBR stream 
+ 		// 0=best, 100=worst
+ 		int nQuality=VBR_q*100/9;
+ 
+ 		// Write Xing header again
+ 		return PutVbrTag((LPSTR)lpszFileName,nQuality);
+ 	}
+ 	return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ }
+ 
+ 
+ BOOL APIENTRY DllMain(HANDLE hModule, 
+                       DWORD  ul_reason_for_call, 
+                       LPVOID lpReserved)
+ {
+     switch( ul_reason_for_call )
+ 	{
+ 		case DLL_PROCESS_ATTACH:
+ //	MessageBox(NULL,"Attach","",MB_OK);
+ 			OutputDebugString("Attach Process \n");
+ 		break;
+ 		case DLL_THREAD_ATTACH:
+ 			OutputDebugString("Attach Thread \n");
+ 		break;
+ 		case DLL_THREAD_DETACH:
+ 			OutputDebugString("Attach DeThread \n");
+ 		break;
+ 		case DLL_PROCESS_DETACH:
+ 			OutputDebugString("Process DeThread \n");
+ //	MessageBox(NULL,"Detach","",MB_OK);
+ 		break;
+     }
+     return TRUE;
+ }
+ 
+ 
+ #ifdef _DEBUG
+ void dump_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
+ {
+ 	layer *info = fr_ps->header;
+ 	char strTmp[255];
+ 
+ 	OutputDebugString("Encoding configuration:\n");
+ 
+ 	sprintf(strTmp,"Algorithm=%s\n", version_names[info->version]);
+ 	OutputDebugString(strTmp);
+ 
+ 	if(info->mode != MPG_MD_JOINT_STEREO)
+ 	{
+ 		sprintf(strTmp,"Layer=%s   mode=%s   extn=%d   psy model=%d\n",layer_names[info->lay-1], mode_names[info->mode],info->mode_ext, *psy);
+ 		OutputDebugString(strTmp);
+ 	}
+ 	else
+ 	{
+ 		sprintf(strTmp,"Layer=%s   mode=%s   extn=data dependant   psy model=%d\n",layer_names[info->lay-1], mode_names[info->mode], *psy);
+ 		OutputDebugString(strTmp);
+ 	}
+ 
+ 	sprintf(strTmp,"samp frq=%.1f kHz   total bitrate=%d kbps\n",s_freq[info->version][info->sampling_frequency],bitrate[info->version][info->lay-1][info->bitrate_index]);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",info->emphasis, info->copyright, info->original,((info->error_protection) ? "on" : "off"));
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"16 Khz cut off is %s\n",(sfb21)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Fast mode is %s\n",(fast_mode)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Force ms %s\n",(force_ms)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"GPsycho acoustic model is %s\n",(gpsycho)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 
+ 	sprintf(strTmp,"input file: '%s'   output file: '%s'\n", inPath, outPath);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Encoding %s to %s\n",inPath,outPath);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Encoding as %.1f kHz %d kbps %s MPEG-1 LayerIII file\n",s_freq[info->version][info->sampling_frequency],bitrate[info->version][info->lay-1][info->bitrate_index],mode_names[info->mode]);
+ 	OutputDebugString(strTmp);
+ }
+ 
+ 
+ void DispErr(LPSTR strErr)
+ {
+ 	MessageBox(NULL,strErr,"",MB_OK);
+ }
+ 
+ #endif
diff -r -c -N encoder/Dll/BladeMP3EncDLL.def lame3.13/Dll/BladeMP3EncDLL.def
*** encoder/Dll/BladeMP3EncDLL.def	Wed Dec 31 17:00:00 1969
--- lame3.13/Dll/BladeMP3EncDLL.def	Sat Jun 12 23:02:03 1999
***************
*** 0 ****
--- 1,9 ----
+ LIBRARY  MP3ENC.DLL
+ EXPORTS
+ 
+ beInitStream		@1
+ beEncodeChunk		@2
+ beDeinitStream		@3
+ beCloseStream		@4
+ beVersion			@5
+ beWriteVBRHeader	@6
\ No newline at end of file
diff -r -c -N encoder/Dll/BladeMP3EncDLL.h lame3.13/Dll/BladeMP3EncDLL.h
*** encoder/Dll/BladeMP3EncDLL.h	Wed Dec 31 17:00:00 1969
--- lame3.13/Dll/BladeMP3EncDLL.h	Tue Jun 15 18:31:36 1999
***************
*** 0 ****
--- 1,150 ----
+ /*
+ 
+ 	bladedll.h
+ 
+     +++++++++++++++++++++++++++
+ 	+   Blade's Encoder DLL   +
+ 	+++++++++++++++++++++++++++
+ 
+     ------------------------------------------------------
+ 	- Version 1.00 (7 November 1998) - Jukka Poikolainen -
+ 	------------------------------------------------------
+ 
+ 	Initial version
+ 	
+ 	------------------------------------------------------
+ 	- Version x.xx (x xxxxxxxx xxxx) - xxxxx xxxxxxxxxxx -
+ 	------------------------------------------------------
+ 
+ */
+ 
+ #ifndef ___BLADEDLL_H_INCLUDED___
+ #define ___BLADEDLL_H_INCLUDED___
+ 
+ #pragma pack(push)
+ #pragma pack(1)
+ 
+ /* encoding formats */
+ 
+ #define		BE_CONFIG_MP3			0										
+ 
+ /* type definitions */
+ 
+ typedef		unsigned long			HBE_STREAM;
+ typedef		HBE_STREAM				*PHBE_STREAM;
+ typedef		unsigned long			BE_ERR;
+ 
+ /* error codes */
+ 
+ #define		BE_ERR_SUCCESSFUL					0x00000000
+ #define		BE_ERR_INVALID_FORMAT				0x00000001
+ #define		BE_ERR_INVALID_FORMAT_PARAMETERS	0x00000002
+ #define		BE_ERR_NO_MORE_HANDLES				0x00000003
+ #define		BE_ERR_INVALID_HANDLE				0x00000004
+ 
+ /* other constants */
+ 
+ #define		BE_MAX_HOMEPAGE			256
+ 
+ /* format specific variables */
+ 
+ #define		BE_MP3_MODE_STEREO		0
+ #define		BE_MP3_MODE_JSTEREO		1
+ #define		BE_MP3_MODE_DUALCHANNEL	2
+ #define		BE_MP3_MODE_MONO		3
+ 
+ #ifdef _BLADEDLL
+ #undef FLOAT
+ 	#include <Windows.h>
+ #endif
+ 
+ typedef struct	{
+ 	
+ 	DWORD	dwConfig;			// BE_CONFIG_XXXXX
+ 								// Currently only BE_CONFIG_MP3 is supported
+ 	union	{
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;	// 48000, 44100 and 32000 allowed
+ 			BYTE	byMode;			// BE_MP3_MODE_STEREO, BE_MP3_MODE_DUALCHANNEL, BE_MP3_MODE_MONO
+ 			WORD	wBitrate;		// 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256 and 320 allowed
+ 			BOOL	bPrivate;		
+ 			BOOL	bCRC;
+ 			BOOL	bCopyright;
+ 			BOOL	bOriginal;
+ 
+ 			} mp3;					// BE_CONFIG_MP3
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;
+ 			BYTE	byMode;
+ 			WORD	wBitrate;
+ 			BYTE	byEncodingMethod;
+ 
+ 		} aac;
+ 
+ 	} format;
+ 		
+ } BE_CONFIG, *PBE_CONFIG;
+ 
+ typedef struct	{
+ 
+ 	// BladeEnc DLL Version number
+ 
+ 	BYTE	byDLLMajorVersion;
+ 	BYTE	byDLLMinorVersion;
+ 
+ 	// BladeEnc Engine Version Number
+ 
+ 	BYTE	byMajorVersion;
+ 	BYTE	byMinorVersion;
+ 
+ 	// DLL Release date
+ 
+ 	BYTE	byDay;
+ 	BYTE	byMonth;
+ 	WORD	wYear;
+ 
+ 	// BladeEnc	Homepage URL
+ 
+ 	CHAR	zHomepage[BE_MAX_HOMEPAGE + 1];	
+ 
+ } BE_VERSION, *PBE_VERSION;			
+ 
+ #ifndef _BLADEDLL
+ 
+ typedef BE_ERR	(*BEINITSTREAM)		(PBE_CONFIG, PDWORD, PDWORD, PHBE_STREAM);
+ typedef BE_ERR	(*BEENCODECHUNK)	(HBE_STREAM, DWORD, PSHORT, PBYTE, PDWORD);
+ typedef BE_ERR	(*BEDEINITSTREAM)	(HBE_STREAM, PBYTE, PDWORD);
+ typedef BE_ERR	(*BECLOSESTREAM)	(HBE_STREAM);
+ typedef VOID	(*BEVERSION)		(PBE_VERSION);
+ 
+ #define	TEXT_BEINITSTREAM	"beInitStream"
+ #define	TEXT_BEENCODECHUNK	"beEncodeChunk"
+ #define	TEXT_BEDEINITSTREAM	"beDeinitStream"
+ #define	TEXT_BECLOSESTREAM	"beCloseStream"
+ #define	TEXT_BEVERSION		"beVersion"
+ 
+ /*	
+ 	BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ 	BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ 	VOID	beVersion(PBE_VERSION pbeVersion);		
+ */
+ 	
+ #else
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion);
+ 
+ #endif
+ 
+ #pragma pack(pop)
+ 
+ #endif
diff -r -c -N encoder/Dll/MP3EncDll.dsp lame3.13/Dll/MP3EncDll.dsp
*** encoder/Dll/MP3EncDll.dsp	Wed Dec 31 17:00:00 1969
--- lame3.13/Dll/MP3EncDll.dsp	Sat Jun 12 23:02:20 1999
***************
*** 0 ****
--- 1,275 ----
+ # Microsoft Developer Studio Project File - Name="MP3EncDll" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+ 
+ CFG=MP3EncDll - Win32 Debug
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak" CFG="MP3EncDll - Win32 Debug"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "MP3EncDll - Win32 Release" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE "MP3EncDll - Win32 Debug" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE "MP3EncDll - Win32 Pentium II Release" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ MTL=midl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "MP3EncDll - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MT /W3 /GX /O2 /Ob2 /I "..\\" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL" /YX /FD -Qmem -Qip /c
+ # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:"..\..\mp3enc.dll"
+ 
+ !ELSEIF  "$(CFG)" == "MP3EncDll - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MTd /W3 /Gm /GX /Zi /Od /I "..\\" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL" /YX /FD /c
+ # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:"..\..\mp3enc.dll" /pdbtype:sept
+ # SUBTRACT LINK32 /map
+ 
+ !ELSEIF  "$(CFG)" == "MP3EncDll - Win32 Pentium II Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "MP3EncDl"
+ # PROP BASE Intermediate_Dir "MP3EncDl"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "MP3EncDl"
+ # PROP Intermediate_Dir "MP3EncDl"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /Zp2 /MT /W3 /GX /O2 /Ob2 /I "..\..\lame" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "DLLCOMPILE" /D "LAYER3" /Fp"Release/MP3EncDll.pch" /YX /FD /Qmem /Qipo /c
+ # ADD CPP /nologo /G6 /Zp2 /MT /W3 /GX /O2 /Ob2 /I "..\\" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL" /D BS_FORMAT= /Fp"Release/MP3EncDll.pch" /YX /FD /Qmem /Qipo /Qxi /c
+ # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386 /out:"..\..\cdex\mp3enc.dll"
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:"..\..\cdex\mp3enc.dll"
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "MP3EncDll - Win32 Release"
+ # Name "MP3EncDll - Win32 Debug"
+ # Name "MP3EncDll - Win32 Pentium II Release"
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.def
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\common.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\common.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\encode.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\huffman.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3psy.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3psy.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\loop-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\loop.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\loop.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\mdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\mdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\musicin.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\psy.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\sqrttab.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\subs.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\subs.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\wavheader.h
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/Dll/MP3EncDll.dsw lame3.13/Dll/MP3EncDll.dsw
*** encoder/Dll/MP3EncDll.dsw	Wed Dec 31 17:00:00 1969
--- lame3.13/Dll/MP3EncDll.dsw	Sun Jun  6 16:19:39 1999
***************
*** 0 ****
--- 1,29 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "MP3EncDll"=.\MP3EncDll.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/INSTALL lame3.13/INSTALL
*** encoder/INSTALL	Wed Jan 22 02:43:12 1997
--- lame3.13/INSTALL	Wed Jun 16 22:40:32 1999
***************
*** 1,16 ****
! Building the MPEG audio encoding software:
  
! If you have gnu make and are on a Unix-type system, you should only have to
  type:
  
! ./configure
! make
  
- This will create a Makefile customized to your environment, overwriting the
- previous Makefile, using Makefile.in as a template.
  
! For other systems you may have to modify the Makefile. Some flags of
! interest are:
  
  BS_FORMAT
    Set to BINARY to work with most MPEG audio decoders (and save space). You
--- 1,87 ----
! LAME 3.1x    6/99 Mark Taylor (www.sulaco.org/mp3)
  
! =======================================================================
! Building the MPEG audio encoding software:
! =======================================================================
! If you are reading this, you have already applied the patch to the
! dist10 ISO demonstration source.  If you do not have GTK 1.1.16 or
! higher, or do not want the graphical frame analyzer (it uses a lot of
! memory), edit the Makefile and dont define GTK and GTKLIBS.  Now just
  type:
  
! % make
! 
! If it doesn't work, figure out why and send me the fix!  
! 
! LAME has built in support for raw pcm, aiff and wav formats.  
! If you have trouble with this, or want to encode from other
! sound formats, you can now compile LAME with Erik de Castro Lopo's
! libsndfile.  To use libsndfile in LAME:
! 
!   1. install libsndfile (see http://www.zip.com.au/~erikd/libsndfile/).  
!   2. set SNDLIB and LIBSNDFILE as shown in the LAME Makefile.  
!   3. make clean ; make
! 
! Thanks to Albert Faber for the libsndfile support!
! 
! 
! 
! =======================================================================
! To encode:
! =======================================================================
! % lame sample.wav  sample.mp3      
! 
! Variable Bitrate (VBR): 
! % lame -v sample.wav sample.mp3
! 
! VBR and specialized mid/side masking thresholds:
! % lame -v -m f sample.wav sample.mp3
! 
! For more options, just type:
! 
! % lame
! 
! Scripts are included to run lame on multiple files:
! 
! bach script:  mlame     Run "mlame -h" for instructions.
! sh script:    auenc     Run auenc for instructions
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! =======================================================================
! Portability
! =======================================================================
! LAME 3.x has been run on many platforms - see the Makefile.
! 
! 
! =======================================================================
! BUGS:
! =======================================================================
! .wav files are assumed to be 44.1kHz stereo.  (i.e. from a CD)
! .wav file reading in broken on non-Linux versions of UNIX.
! 
! I haven't tried .aiff files, but pcm files will work on all platforms:
! (default is XINU format) but try with and without -x.
! 
! To convert a 44.1kHz .wav file to a LAME readable pcm file, use:
! % sox sample.wav  -t raw -x -w -s -c 2 -r 44100 sample.pcm
! 
! 
! 
! 
  
  
! =======================================================================
! Information from the ISO README
! =======================================================================
! Some other flags of interest are:
  
  BS_FORMAT
    Set to BINARY to work with most MPEG audio decoders (and save space). You
diff -r -c -N encoder/Makefile lame3.13/Makefile
*** encoder/Makefile	Wed Jan 22 02:43:23 1997
--- lame3.13/Makefile	Thu Jun 24 18:30:41 1999
***************
*** 1,68 ****
! # Generated automatically from Makefile.in by configure.
! ############################################################################
! ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
! ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
! ##
! ## $Id: Makefile,v 1.2 1996/08/14 23:18:34 rowlands Exp $
! ##
! ## Makefile for encoder. Requies GNU make.
! ##
! ## $Log: Makefile,v $
! ## Revision 1.2  1996/08/14 23:18:34  rowlands
! ## Cleanups.
! ##
! ## Revision 1.2  1996/02/14 05:18:05  rowlands
! ## Cleanups.
! ##
! ## Revision 1.1  1996/02/14 04:04:23  rowlands
! ## Initial revision
! ##
! ## Received from Mike Coleman
! ############################################################################
  
  CC = gcc
  
  c_sources = \
  	common.c \
  	encode.c \
  	formatBitstream.c \
  	huffman.c \
- 	ieeefloat.c \
  	l3bitstream.c \
  	l3psy.c \
  	loop.c \
  	mdct.c \
  	musicin.c \
  	portableio.c \
- 	psy.c \
  	reservoir.c \
  	subs.c \
! 	tonal.c
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
- NINT_SWITCH = 
- 
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
- 
- PGM = encode
- 
- LIBS =  -lm
- 
  
  %.o: %.c 
  	$(CC) $(CC_SWITCHES) -c $< -o $@
  
  %.d: %.c
! 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
  
  
! $(PGM):	$(OBJ) Makefile
! 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
  
  clean:
! 	-rm $(OBJ) $(DEP)
  
  tags: TAGS
  
--- 1,198 ----
! # Makefile for LAME 3.x
! #
! # LAME is reported to work under:  
! # Linux (i86), Sun, SGI, NetBSD 1.3.2 (StrongARM), 
! # Compaq Alpha, FreeBSD (i86), OS2 Warp, BeOS, Amiga and even VC++ 
! # Macintosh PPC
! #
! #
! UNAME = $(shell uname)
! ARCH = $(shell uname -m)
  
+ 
+ # defaults:
+ PGM = lame
  CC = gcc
+ CC_OPTS = -O 	
+ GTK = 
+ GTKLIBS = 
+ SNDLIB = 
+ LIBSNDFILE =
+ LIBS = -lm 
+ MAKEDEP = -M
+ NINT_SWITCH = 
+ 
+ 
+ 
+ ##########################################################################
+ #define these to use Erik de Castro Lopo's libsndfile 
+ # http://www.zip.com.au/~erikd/libsndfile/
+ ##########################################################################
+ #SNDLIB = -DLIBSNDFILE
+ #LIBSNDFILE=-lsndfile 
+ # if libsndfile is in a custom location, try:
+ #LIBSNDFILE=-L $(LIBSNDHOME) -lsndfile  -I $(LIBSNDHOME)
+ 
+ 
+ 
+ 
+ 
+ 
+ ##########################################################################
+ # set this (and run make clean) to make a binary that is distributable
+ # i.e. frame analyzier only, which doesn't produce a .mp3 file
+ ##########################################################################
+ #DISTRIB = -DDISTRIB
+ #PGM = mp3x
+ 
+ 
+ 
+ 
+ ##########################################################################
+ # LINUX   
+ ##########################################################################
+ ifeq ($(UNAME),Linux)
+    # remove these if you do not have GTK, or dont want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk-config --cflags`
+    GTKLIBS = `gtk-config --libs` 
+ #  for debugging:
+ #   CC_OPTS = -UNDEBUG  -O -Wall -g -DABORTFP 
+ # these options work very well with egcs-990524
+ #   CC = egcs
+ #   CC_OPTS =    -O9 -fomit-frame-pointer -march=pentium \
+ #                  -mcpu=pentium -ffast-math -funroll-loops \
+ #                  -fprofile-arcs -fbranch-probabilities
+ 
+ 
+ 
+ ##########################################################################
+ # LINUX on Digital/Compaq Alpha CPUs
+ ##########################################################################
+ ifeq ($(ARCH),alpha)
+ # double is faster than float on Alpha
+ CC_OPTS =       -O4 -Wall -fomit-frame-pointer -ffast-math -funroll-loops \
+                 -mfp-regs -fschedule-insns -fschedule-insns2 \
+                 -finline-functions \
+                 -DFLOAT=double
+ # standard Linux libm
+ LIBS	=	-lm  
+ # optimized libffm (free fast math library)
+ #LIBS	=	-lffm  
+ # Compaq's fast math library
+ #LIBS    =       -lcpml 
+ endif
+ endif
+ 
+ 
+ 
+ ##########################################################################
+ # FreeBSD
+ ##########################################################################
+ ifeq ($(UNAME),FreeBSD)
+    # remove these if you do not have GTK, or dont want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk12-config --cflags`
+    GTKLIBS = `gtk12-config --libs` 
+ endif
+ 
+ 
+ ##########################################################################
+ # SunOS
+ ##########################################################################
+ ifeq ($(UNAME),SunOS) 
+    CC = cc
+    MAKEDEP = -xM
+ endif
+ 
+ 
+ ##########################################################################
+ # SGI
+ ##########################################################################
+ ifeq ($(UNAME),IRIX64) 
+    CC = cc	
+ endif
+ 
+ 
+ ##########################################################################
+ # Compaq Alpha running Dec Unix (OSF)
+ ##########################################################################
+ ifeq ($(UNAME),OSF1)
+    CC = cc
+    CC_OPTS = -fast -O3 -std -g3 -non_shared
+    NINT_SWITCH = -DHAVE_NINT
+ endif
+ 
+ ##########################################################################
+ # BeOS
+ ##########################################################################
+ ifeq ($(UNAME),BeOS)
+    CC = $(BE_C_COMPILER)
+    LIBS =
+ ifeq ($(ARCH),BePC)
+    CC_OPTS = -O9 -fomit-frame-pointer -march=pentium \
+    -mcpu=pentium -ffast-math -funroll-loops \
+    -fprofile-arcs -fbranch-probabilities
+ else
+    CC_OPTS = -opt all
+    MAKEDEP = -make
+ endif
+ endif
+ 
+ ##########################################################################
+ # OS/2 
+ ##########################################################################
+ # defaults work fine except for:
+ # PGM = lame.exe
+ # and remove all the above statments having to do with non OS/2 systems
+ 
  
+ 
+ 
+ CC_SWITCHES = -DNDEBUG $(CC_OPTS)  $(DISTRIB) $(SNDLIB) $(GTK)  -DBS_FORMAT=BINARY $(NINT_SWITCH) 
  c_sources = \
  	common.c \
  	encode.c \
  	formatBitstream.c \
+ 	get_audio.c \
+         gtkanal.c \
+         gpkplotting.c \
  	huffman.c \
  	l3bitstream.c \
+ 	ieeefloat.c \
  	l3psy.c \
  	loop.c \
  	mdct.c \
  	musicin.c \
  	portableio.c \
  	reservoir.c \
  	subs.c \
! 	tables.c \
!         VbrTag.c \
!         version.c \
! mpglib/common.c \
! mpglib/dct64_i386.c \
! mpglib/decode_i386.c \
! mpglib/layer3.c \
! mpglib/tabinit.c \
! mpglib/interface.c \
! mpglib/main.c \
! 
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
  
  %.o: %.c 
  	$(CC) $(CC_SWITCHES) -c $< -o $@
  
  %.d: %.c
! 	$(SHELL) -ec '$(CC) $(MAKEDEP)  $(CC_SWITCHES)  $< | sed '\''s;$*.o;& $@;g'\'' > $@'
  
  
! $(PGM):	$(OBJ) Makefile 
! 	$(CC) -o $(PGM) $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS)
  
  clean:
! 	-rm $(OBJ) $(DEP) $(PGM)
  
  tags: TAGS
  
***************
*** 70,72 ****
--- 200,216 ----
  	etags -T ${c_sources}
  
  -include $(DEP)
+ 
+ test8: $(PGM)
+ 	./lame /home/mt/mp3/test/castanets.wav
+ 	cmp -l /home/mt/mp3/test/castanets.wav.mp3 /home/mt/mp3/test/castanets.ref8.mp3 | head
+ test9: $(PGM)
+ 	./lame /home/mt/mp3/test/castanets.wav
+ 	cmp -l /home/mt/mp3/test/castanets.wav.mp3 /home/mt/mp3/test/castanets.ref9.mp3 | head
+ testf: $(PGM)
+ 	./lame -m f /home/mt/mp3/test/castanets.wav
+ 	cmp -l /home/mt/mp3/test/castanets.wav.mp3 /home/mt/mp3/test/castanets.mf.mp3 | head
+ testg: $(PGM)
+ 	./lame -g /home/mt/mp3/test/castanets.wav
+ 	cmp -l /home/mt/mp3/test/castanets.wav.mp3 /home/mt/mp3/test/castanets.ref8.mp3
+ 
diff -r -c -N encoder/Makefile.in lame3.13/Makefile.in
*** encoder/Makefile.in	Wed Jan 22 02:43:12 1997
--- lame3.13/Makefile.in	Wed Dec 31 17:00:00 1969
***************
*** 1,68 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
- ##
- ## $Id: Makefile.in,v 1.2 1996/02/14 05:18:05 rowlands Exp $
- ##
- ## Makefile for encoder. Requies GNU make.
- ##
- ## $Log: Makefile.in,v $
- ## Revision 1.2  1996/02/14 05:18:05  rowlands
- ## Cleanups.
- ##
- ## Revision 1.1  1996/02/14 04:04:23  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ############################################################################
- 
- CC = gcc
- 
- c_sources = \
- 	common.c \
- 	encode.c \
- 	formatBitstream.c \
- 	huffman.c \
- 	ieeefloat.c \
- 	l3bitstream.c \
- 	l3psy.c \
- 	loop.c \
- 	mdct.c \
- 	musicin.c \
- 	portableio.c \
- 	psy.c \
- 	reservoir.c \
- 	subs.c \
- 	tonal.c
- 
- OBJ = $(c_sources:.c=.o)
- DEP = $(c_sources:.c=.d)
- 
- NINT_SWITCH = @NINTSW@
- 
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
- 
- PGM = encode
- 
- LIBS = @LIBS@ @MATHLIBS@
- 
- 
- %.o: %.c 
- 	$(CC) $(CC_SWITCHES) -c $< -o $@
- 
- %.d: %.c
- 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
- 
- 
- $(PGM):	$(OBJ) Makefile
- 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
- 
- clean:
- 	-rm $(OBJ) $(DEP)
- 
- tags: TAGS
- 
- TAGS: ${c_sources}
- 	etags -T ${c_sources}
- 
- -include $(DEP)
--- 0 ----
diff -r -c -N encoder/README lame3.13/README
*** encoder/README	Wed Dec 31 17:00:00 1969
--- lame3.13/README	Thu May 20 11:40:00 1999
***************
*** 0 ****
--- 1,29 ----
+                        LAME 3.0x
+                LAME Ain't an MP3 Encoder
+                  www.sulaco.org/mp3
+ 
+ Written by Mike Cheng (www.uq.net.au/~zzmcheng).  Modified
+ and maintained by Mark Taylor (www.sulaco.org/mp3).
+ 
+ This is a patch agains the ISO MPEG1 demonstration source.  The
+ modifications are distributed under the GNU GENERAL PUBLIC LICENSE
+ (see the file COPYING for details).
+ 
+ The graphical frame analyzer uses the MPGLIB decoding engine, written by:
+ Michael Hipp (email: Michael.Hipp@student.uni-tuebingen.de) 
+ and released under a more restrictive agreement.  
+ 
+ Various components of the patch are:
+ 
+ Copyrights (c) 1999 by Mark Taylor: new psy-model, quantization and bit allocation 
+ Copyrights (c) 1998 by Michael Cheng:  new transforms and many other improvements
+ Copyrights (c) 1995,1996,1997 by Michael Hipp: mpglib
+ 
+ 
+ The ISO demonstration source (distrubuted seperatly) has its own
+ patent, copyright and distrubtion issues.  The code is freely
+ available, but any comercial use (including distributing free
+ encoders) requires a license agreement from FhG.
+ 
+ 
+ 
diff -r -c -N encoder/README.WINGTK lame3.13/README.WINGTK
*** encoder/README.WINGTK	Wed Dec 31 17:00:00 1969
--- lame3.13/README.WINGTK	Mon May 24 21:14:01 1999
***************
*** 0 ****
--- 1,55 ----
+ 
+ If you got the LAME source from http://www.sulaco.org/mp3, the
+ libraries and binaries mentioned below are not included.  You will
+ need to get the GLIB and GTK developer libraries, available from:
+ http://user.sgic.fi/~tml/gimp/win32/ 
+ (or see http://www.gtk.org, and click on the GTK under win32 link).
+ 
+ -Mark Taylor 
+ 
+ 
+ *************************************************************************** 
+ 
+ 
+ 
+ May 24,1999
+ 
+ Release notes MP3X for WIN2
+ 
+ Installation instructions:
+ 
+ Copy the DLL files: (in GtkWin32Dll.zip)
+ 
+ gdk-1.3.dll
+ glib-1.2.dll
+ gtk-1.3.dll
+ gmodule-1.2.dll
+ 
+ 
+ either into the current working direcory you are running LAME, or 
+ copy them in the windows system directory. 
+ 
+ 
+ This is basically it, you can run LAME with the Graphic Psyco Analysis as follows:
+ 
+ Lame -g my.wav
+ 
+ (just enter Lame at the dos prompt to get all the options) Of course you can ommit the 
+ -g optiont to use lame without GPA.
+ 
+ 
+ 
+ How to compile Lame with GPA for Windows 32 platforms
+ 
+ In order to compile Lame with the Graphic Psyco Analysis (GPA) with MSVC, you have to have the 
+ proper GTK and GLIB include files and lib files. I've put these files together in a 
+ zip file (named GtkWin32Lib.zip). Unzip these files into the Lame source directory, make
+ sure you unpack it with the directory options. The files are created in the WinGTK subdirecory
+ Furthermore, you should have at least Lame version 3.05 beta 2.
+ Open the project files in MSVC 5, and just hit the build button. There will be a few warnings,
+ but you can ignore them.
+ 
+ 
+ 
+ Albert L. Faber
+ 
diff -r -c -N encoder/TODO lame3.13/TODO
*** encoder/TODO	Wed Dec 31 17:00:00 1969
--- lame3.13/TODO	Thu Jun 24 18:31:48 1999
***************
*** 0 ****
--- 1,17 ----
+ Does stdin work when LAME is compiled to use libsndfile?
+ 
+ make use of subblock_gain 
+    slow, but best way: loop over all possible subblock_gains and
+    see which combination gives best distortion?  But I dont know
+    if I trust calc_noise for short blocks.  
+ 
+ true mid/side masking thresholds in jstereo mode.  requires computing
+ left,right, mid & side thresholds for all frames.
+ 
+ 10Hz high-pass filter
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/VbrTag.c lame3.13/VbrTag.c
*** encoder/VbrTag.c	Wed Dec 31 17:00:00 1969
--- lame3.13/VbrTag.c	Mon Jun 21 12:19:04 1999
***************
*** 0 ****
--- 1,479 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include <stdio.h>
+ #include <memory.h>
+ #include <float.h>
+ #include <math.h>
+ #include "VbrTag.h"
+ #include "version.h"
+ 
+ #ifdef _DEBUG
+ //  #define DEBUG_VBRTAG
+ #endif
+ 
+ 
+ int SizeOfEmptyFrame[2][2]=
+ {
+ 	{32,17},
+ 	{17,9},
+ };
+ 
+ static BYTE pbtStreamBuffer[216];   
+ static long g_Position[NUMTOCENTRIES];
+ static int nZeroStreamSize=0;
+ static int TotalFrameSize=0;
+ static char	VBRTag[]={"Xing"};
+ //static char	VBRTag[]={"Lame"};
+ 
+ 
+ int* pVbrFrames=NULL;
+ int nVbrNumFrames=0;
+ int nVbrFrameBufferSize=0;
+ 
+ /****************************************************************************
+  * AddVbrFrame: Add VBR entry, used to fill the VBR the TOC entries
+  * Paramters:
+  *	nStreamPos: how many bytes did we write to the bitstream so far
+  *				(in Bytes NOT Bits)
+  ****************************************************************************
+ */
+ void AddVbrFrame(int nStreamPos)
+ {
+ 	// Simple exponential growing buffer
+ 	if (pVbrFrames==NULL || nVbrFrameBufferSize==0)
+ 	{
+ 		// Start with 100 frames
+ 		nVbrFrameBufferSize=100;
+ 
+ 		// Allocate them 
+ 		pVbrFrames=(int*)malloc(nVbrFrameBufferSize*sizeof(int));
+ 	}
+ 
+ 	// Is buffer big enough to store this new frame
+ 	if (nVbrNumFrames==nVbrFrameBufferSize)
+ 	{
+ 		// Guess not, double th e buffer size
+ 		nVbrFrameBufferSize*=2;
+ 
+ 		// Allocate new buffer
+ 		pVbrFrames=(int*)realloc(pVbrFrames,nVbrFrameBufferSize*sizeof(int));
+ 	}
+ 
+ 	// Store values
+ 	pVbrFrames[nVbrNumFrames++]=nStreamPos;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ static int ExtractI4(unsigned char *buf)
+ {
+ 	int x;
+ 	// big endian extract
+ 	x = buf[0];
+ 	x <<= 8;
+ 	x |= buf[1];
+ 	x <<= 8;
+ 	x |= buf[2];
+ 	x <<= 8;
+ 	x |= buf[3];
+ 	return x;
+ }
+ 
+ void CreateI4(unsigned char *buf, int nValue)
+ {
+ 	// big endian create
+ 	buf[0]=(nValue>>24)&0xff;
+ 	buf[1]=(nValue>>16)&0xff;
+ 	buf[2]=(nValue>> 8)&0xff;
+ 	buf[3]=(nValue    )&0xff;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf)
+ {
+ 	int			i, head_flags;
+ 	int			h_id, h_mode, h_sr_index;
+ 	static int	sr_table[4] = { 44100, 48000, 32000, 99999 };
+ 
+ 	// get Vbr header data
+ 	pTagData->flags = 0;     // clear to null incase fail
+ 
+ 	// get selected MPEG header data
+ 	h_id       = (buf[1] >> 3) & 1;
+ 	h_sr_index = (buf[2] >> 2) & 3;
+ 	h_mode     = (buf[3] >> 6) & 3;
+ 
+ 	// determine offset of header
+ 	if( h_id ) 
+ 	{
+ 		// mpeg1
+ 		if( h_mode != 3 )	buf+=(32+4);
+ 		else				buf+=(17+4);
+ 	}
+ 	else
+ 	{
+ 		// mpeg2
+ 		if( h_mode != 3 ) buf+=(17+4);
+ 		else              buf+=(9+4);
+ 	}
+ 
+ 	if( buf[0] != VBRTag[0] ) return 0;    // fail
+ 	if( buf[1] != VBRTag[1] ) return 0;    // header not found
+ 	if( buf[2] != VBRTag[2] ) return 0;
+ 	if( buf[3] != VBRTag[3] ) return 0;
+ 
+ 	buf+=4;
+ 
+ 	pTagData->h_id = h_id;
+ 
+ 	pTagData->samprate = sr_table[h_sr_index];
+ 
+ 	if( h_id == 0 )
+ 		pTagData->samprate >>= 1;
+ 
+ 	head_flags = pTagData->flags = ExtractI4(buf); buf+=4;      // get flags
+ 
+ 	if( head_flags & FRAMES_FLAG )
+ 	{
+ 		pTagData->frames   = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & BYTES_FLAG )
+ 	{
+ 		pTagData->bytes = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & TOC_FLAG )
+ 	{
+ 		if( pTagData->toc != NULL )
+ 		{
+ 			for(i=0;i<NUMTOCENTRIES;i++)
+ 				pTagData->toc[i] = buf[i];
+ 		}
+ 		buf+=NUMTOCENTRIES;
+ 	}
+ 
+ 	pTagData->vbr_scale = -1;
+ 
+ 	if( head_flags & VBR_SCALE_FLAG )
+ 	{
+ 		pTagData->vbr_scale = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ #ifdef DEBUG_VBRTAG
+ 	printf("\n\n********************* VBR TAG INFO *****************\n");
+ 	printf("tag         :%s\n",VBRTag);
+ 	printf("head_flags  :%d\n",head_flags);
+ 	printf("bytes       :%d\n",pTagData->bytes);
+ 	printf("frames      :%d\n",pTagData->frames);
+ 	printf("VBR Scale   :%d\n",pTagData->vbr_scale);
+ 	printf("toc:\n");
+ 	if( pTagData->toc != NULL )
+ 	{
+ 		for(i=0;i<NUMTOCENTRIES;i++)
+ 		{
+ 			if( (i%10) == 0 ) printf("\n");
+ 			printf(" %3d", (int)(pTagData->toc[i]));
+ 		}
+ 	}
+ 	printf("\n***************** END OF VBR TAG INFO ***************\n");
+ #endif
+ 	return 1;       // success
+ }
+ 
+ 
+ /****************************************************************************
+  * InitVbrTag: Initializes the header, and write empty frame to stream
+  * Paramters:
+  *				fpStream: pointer to output file stream
+  *				nVersion: 0= MPEG1 1=MPEG2
+  *				nMode	: Channel Mode: 0=STEREO 1=JS 2=DS 3=MONO
+  ****************************************************************************
+ */
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion, int nMode, int SampIndex)
+ {
+ 	int i;
+ 
+ 	// Clear Frame position array variables
+ 	pVbrFrames=NULL;
+ 	nVbrNumFrames=0;
+ 	nVbrFrameBufferSize=0;
+ 
+ 	// Clear struct
+ 	memset(g_Position,0x00,sizeof(g_Position));
+ 
+ 	// Clear stream buffer
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	// Set TOC values to 255
+ 	for (i=0;i<NUMTOCENTRIES;i++)
+ 	{
+ 		g_Position[i]=-1;
+ 	}
+ 
+ 
+ 
+ 	// Reserve the proper amount of bytes
+ 	if (nMode==3)
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][1]+4;
+ 	}
+ 	else
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][0]+4;
+ 	}
+ 
+ 
+ 	// Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).
+         // what do they do at 48kHz?  frame not big enough for Xing header.
+ 	// let's always embed Xing header inside a 64kbs layer III frame.  
+ 	// this gives us enough room for a LAME version string too.
+ 	// size determined by sampling frequency (MPEG1)
+ 	// 32kHz:    216 bytes@48kbs    288bytes@ 64kbs    
+ 	// 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)
+ 	// 48kHz:    144 bytes          192
+ 	// 
+ 	// MPEG 2 values are half the above.  Need to go to a 128kbs frame
+ 	// to have room for the table of contents.  not yet supported.
+ 	if (nVersion == 0 ) {
+ 	  int tot;
+ #define XING64
+ #ifdef XING64
+ 	  int framesize[3]={208,192,288};
+ #else
+ 	  int framesize[3]={156,144,216}; 
+ #endif
+ 	  if (SampIndex==3) {
+ 	    fprintf(stderr,"illegal sampling frequency index\n");
+ 	    exit(-1);
+ 	  }
+ 	  TotalFrameSize= framesize[SampIndex];
+ 	  tot = (nZeroStreamSize+VBRHEADERSIZE);
+ #ifdef XING64
+ 	  tot += 20;  /* extra 20 bytes for LAME & version string */
+ #endif
+ 	  if (TotalFrameSize < tot ) {
+ 	    fprintf(stderr,"Xing VBR header problem...use -t\n");
+ 	    exit(-1);
+ 	  }
+ 	}
+ 	if (nVersion == 1) {
+ 	  fprintf(stderr,"MPEG 2 Xing VBR header not supported. use -t\n");
+ 	  exit(-1);
+ 	}
+ 
+ 
+ 	// Put empty bytes into the bitstream
+ 	for (i=0;i<TotalFrameSize;i++)
+ 	{
+ 		// Write a byte to the bitstream
+ 		putbits(pBs,0,8);
+ 	}
+ 
+ 	/* flush buffer to mp3 file */
+ #ifndef _BLADEDLL
+ 	empty_buffer(pBs, 1+pBs->buf_byte_idx);
+ 	pBs->buf[pBs->buf_byte_idx] = 0;  
+ #endif
+ 
+ 
+ 	// Success
+ 	return 0;
+ }
+ 
+ 
+ 
+ /****************************************************************************
+  * PutVbrTag: Write final VBR tag to the file
+  * Paramters:
+  *				lpszFileName: filename of MP3 bit stream
+  *				nVbrScale	: encoder quality indicator (0..100)
+  ****************************************************************************
+ */
+ int PutVbrTag(char* lpszFileName,int nVbrScale)
+ {
+ 	int			i;
+ 	long		lFileSize=0;
+ 	int			nStreamIndex=0;
+ 	char abyte;
+ 	BYTE		btToc[NUMTOCENTRIES];
+ 	FILE*		fpStream=NULL;
+ 	char str1[80];
+ 
+ 
+ 	if (nVbrNumFrames==0 || pVbrFrames==NULL)
+ 		return -1;
+ 
+ 	// Open the bitstream again
+ 	fpStream=fopen(lpszFileName,"rb+");
+ 
+ 	// Assert stream is valid
+ 	if (fpStream==NULL)
+ 		return -1;
+ 
+ 	// Clear stream buffer
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	// Seek to end of file
+ 	fseek(fpStream,0,SEEK_END);
+ 
+ 	// Get file size
+ 	lFileSize=ftell(fpStream);
+ 	
+ 	// Seek to first real frame
+ 	fseek(fpStream,TotalFrameSize,SEEK_SET);
+ 
+ 	// Read the header (first valid frame)
+ 	fread(pbtStreamBuffer,4,1,fpStream);
+ 
+ 	/* the default VBR header.  48kbs layer III, no padding, no crc */
+ 	/* but sampling freq, mode andy copyright/copy protection taken */
+ 	/* from first valid frame */
+ 	pbtStreamBuffer[0]=(char) 0xff;    
+ 	pbtStreamBuffer[1]=(char) 0xfb;    
+ 	abyte = pbtStreamBuffer[2] & (char) 0x0c;   
+ #ifdef XING64
+ 	pbtStreamBuffer[2]=(char) 0x50 | abyte;     /* 64kbs frame */
+ #else
+ 	pbtStreamBuffer[2]=(char) 0x30 | abyte;  /* 48kbs frame */
+ #endif
+ 
+ 	// Seek to the beginning of the stream
+ 	fseek(fpStream,0,SEEK_SET);
+ 
+ 	// Clear all TOC entries
+ 	memset(btToc,0,sizeof(btToc));
+ 
+ 	// Set unassigned toc value with its neighbor value
+ 	for (i=0;i<nVbrNumFrames;i++)
+ 	{
+ 		// Calculate percentage
+ 		int nPercent= i*(NUMTOCENTRIES-1)/nVbrNumFrames;
+ 
+ 		// Calculate relative file postion, normalized to 0..255
+ 		float fRelStreamPos=255*(float)pVbrFrames[i]/(float)lFileSize;
+ 
+ 		// Just to be safe
+ 		if (nPercent>=NUMTOCENTRIES ) nPercent=NUMTOCENTRIES-1;
+ 		if (fRelStreamPos>255) fRelStreamPos=255;
+ 
+ 		// Assign toc entry value
+ 		btToc[nPercent]=(BYTE)fRelStreamPos;
+ 	}
+ 
+ 	// Fix up empty fields (if we have less than 100 frames)
+ 	for (i=1;i<NUMTOCENTRIES ;i++)
+ 	{
+ 		if (btToc[i]==0)
+ 			btToc[i]=btToc[i-1];
+ 	}
+ 
+ 
+ 	// Start writing the tag after the zero frame
+ 	nStreamIndex=nZeroStreamSize;
+ 
+ 	// Put Vbr tag
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[0];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[1];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[2];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[3];
+ 
+ 	// Put header flags
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],FRAMES_FLAG+BYTES_FLAG+TOC_FLAG+VBR_SCALE_FLAG);
+ 	nStreamIndex+=4;
+ 
+ 	// Put Total Number of frames
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrNumFrames);
+ 	nStreamIndex+=4;
+ 
+ 	// Put Total file size
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],lFileSize);
+ 	nStreamIndex+=4;
+ 
+ 	// Put TOC
+ 	memcpy(&pbtStreamBuffer[nStreamIndex],btToc,sizeof(btToc));
+ 	nStreamIndex+=sizeof(btToc);
+ 
+ 	// Put VBR SCALE
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrScale);
+ 	nStreamIndex+=4;
+ 
+ 	// Put LAME id
+ 	sprintf(str1,"LAME%s",get_lame_version());
+ 	strncpy((char *)&pbtStreamBuffer[nStreamIndex],str1,(size_t) 20);
+ 	nStreamIndex+=20;
+ 
+ 
+ #ifdef DEBUG_VBRTAG
+ {
+ 	VBRTAGDATA TestHeader;
+ 	GetVbrTag(&TestHeader,pbtStreamBuffer);
+ }
+ #endif
+ 
+ 	// Put it all to disk again
+ 	if (fwrite(pbtStreamBuffer,TotalFrameSize,1,fpStream)!=1)
+ 	{
+ 		// Could not write header
+ 		return -1;
+ 	}
+ 
+ 	// CLose bitstream 
+ 	fclose(fpStream);
+ 
+ 	// Save to delete the frame buffer
+ 	free(pVbrFrames);
+ 	pVbrFrames=NULL;
+ 
+ 	return 0;       // success
+ }
+ 
+ /*-------------------------------------------------------------*/
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent)
+ {
+ // interpolate in TOC to get file seek point in bytes
+ int a, seekpoint;
+ float fa, fb, fx;
+ 
+ 
+ if( percent < 0.0f )   percent = 0.0f;
+ if( percent > 100.0f ) percent = 100.0f;
+ 
+ a = (int)percent;
+ if( a > 99 ) a = 99;
+ fa = TOC[a];
+ if( a < 99 ) {
+     fb = TOC[a+1];
+ }
+ else {
+     fb = 256.0f;
+ }
+ 
+ 
+ fx = fa + (fb-fa)*(percent-a);
+ 
+ seekpoint = (int)((1.0f/256.0f)*fx*file_bytes); 
+ 
+ 
+ return seekpoint;
+ }
+ /*-------------------------------------------------------------*/
diff -r -c -N encoder/VbrTag.c.rej lame3.13/VbrTag.c.rej
*** encoder/VbrTag.c.rej	Wed Dec 31 17:00:00 1969
--- lame3.13/VbrTag.c.rej	Mon Jun 21 12:13:55 1999
***************
*** 0 ****
--- 1,5 ----
+ ***************
+ *** 422
+ -       strncpy(&pbtStreamBuffer[nStreamIndex],str1,(size_t) 20);
+ --- 422 -----
+ +       strncpy((char *)&pbtStreamBuffer[nStreamIndex],str1,(size_t) 20);
diff -r -c -N encoder/VbrTag.h lame3.13/VbrTag.h
*** encoder/VbrTag.h	Wed Dec 31 17:00:00 1969
--- lame3.13/VbrTag.h	Tue Jun 15 16:46:52 1999
***************
*** 0 ****
--- 1,86 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #ifndef VRBTAG_H_INCLUDED
+ #define VRBTAG_H_INCLUDED
+ 
+ /* -----------------------------------------------------------
+  * A Vbr header may be present in the ancillary
+  * data field of the first frame of an mp3 bitstream
+  * The Vbr header (optionally) contains
+  *      frames      total number of audio frames in the bitstream
+  *      bytes       total number of bytes in the bitstream
+  *      toc         table of contents
+ 
+  * toc (table of contents) gives seek points
+  * for random access
+  * the ith entry determines the seek point for
+  * i-percent duration
+  * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes
+  * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes
+  */
+ 
+ #include "l3bitstream.h"
+ 
+ #define FRAMES_FLAG     0x0001
+ #define BYTES_FLAG      0x0002
+ #define TOC_FLAG        0x0004
+ #define VBR_SCALE_FLAG  0x0008
+ 
+ #define NUMTOCENTRIES 100
+ 
+ #define FRAMES_AND_BYTES (FRAMES_FLAG | BYTES_FLAG)
+ #ifndef BYTE
+ typedef unsigned char BYTE;
+ #endif
+ 
+ // structure to receive extracted header
+ // toc may be NULL
+ typedef struct
+ {
+     int		h_id;			// from MPEG header, 0=MPEG2, 1=MPEG1
+     int		samprate;		// determined from MPEG header
+     int		flags;			// from Vbr header data
+     int		frames;			// total bit stream frames from Vbr header data
+     int		bytes;			// total bit stream bytes from Vbr header data
+     int		vbr_scale;		// encoded vbr scale from Vbr header data
+     BYTE	toc[NUMTOCENTRIES];		// may be NULL if toc not desired
+ }   VBRTAGDATA;
+ 
+ //    4 bytes for Header Tag
+ //    4 bytes for Header Flags
+ //  100 bytes for entry (NUMTOCENTRIES)
+ //    4 bytes for FRAME SIZE
+ //    4 bytes for STREAM_SIZE
+ //    4 bytes for VBR SCALE. a VBR quality indicator: 0=best 100=worst
+ //   20 bytes for LAME tag.  for example, "LAME3.12 (beta 6)"
+ // ___________
+ //  140 bytes
+ 
+ #define VBRHEADERSIZE (NUMTOCENTRIES+4+4+4+4+4)
+ 
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf);
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent);
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion,int nMode, int SampIndex);
+ int PutVbrTag(char* lpszFileName,int nVbrScale);
+ void AddVbrFrame(int nStreamPos);
+ 
+ 
+ #endif
diff -r -c -N encoder/auenc lame3.13/auenc
*** encoder/auenc	Wed Dec 31 17:00:00 1969
--- lame3.13/auenc	Mon Jun 14 23:24:36 1999
***************
*** 0 ****
--- 1,39 ----
+ #!/bin/sh
+ # 
+ # auenc -- version 0.1
+ #
+ # A wrapper for lame to encode multiple files.  By default, a .wav
+ # extension is removed and replaced by .mp3 .
+ #
+ # (C) 1999 Gerhard Wesp <gwesp@cosy.sbg.ac.at> under the GPL.
+ 
+ # set the variables below according to your taste
+ LAME=/usr/bin/lame
+ LAME_OPTS="-S -h -v -V 0 -b 256" # high quality, silent operation
+ 
+ if [ $# -lt 1 ] ; then
+   exec 1>&2
+   cat << _EOF_
+ usage: $0 [options] file...
+ options:
+   -d --delete: delete original file after successful encoding
+ _EOF_
+   exit 1
+ fi
+ 
+ unset DELETE
+ case "$1" in ( -d | --delete )
+   DELETE=1
+   shift ;;
+ esac
+ 
+ for f in $* ; do
+   if ! $LAME $LAME_OPTS "$f" `basename "$f" .wav`.mp3 ; then
+     exec 1>&2
+     echo "encoding of $f failed, aborting..."
+     exit 1
+   fi
+   if [ -n "$DELETE" ] ; then
+     rm -f "$f"
+   fi
+ done
diff -r -c -N encoder/common.c lame3.13/common.c
*** encoder/common.c	Wed Jan 22 02:43:13 1997
--- lame3.13/common.c	Wed Jun 23 21:49:39 1999
***************
*** 13,94 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
!  *          Davis Pan                                                 *
!  * 5/10/91  W. Joseph Carter    Created this file for all common      *
!  *                              functions and global variables.       *
!  *                              Ported to Macintosh and Unix.         *
!  *                              Added Jean-Georges Fritsch's          *
!  *                              "bitstream.c" package.                *
!  *                              Added routines to handle AIFF PCM     *
!  *                              sound files.                          *
!  *                              Added "mem_alloc()" and "mem_free()"  *
!  *                              routines for memory allocation        *
!  *                              portability.                          *
!  *                              Added routines to convert between     *
!  *                              Apple SANE extended floating point    *
!  *                              format and IEEE double precision      *
!  *                              floating point format.  For AIFF.     *
!  * 02jul91 dpwe (Aware Inc)     Moved allocation table input here;    *
!  *                              Tables read from subdir TABLES_PATH.  *
!  *                              Added some debug printout fns (Write*)*
!  * 7/10/91 Earle Jennings       replacement of the one float by FLOAT *
!  *                              port to MsDos from MacIntosh version  *
!  * 8/ 5/91 Jean-Georges Fritsch fixed bug in open_bit_stream_r()      *
!  *10/ 1/91 S.I. Sudharsanan,    Ported to IBM AIX platform.           *
!  *         Don H. Lee,                                                *
!  *         Peter W. Farrett                                           *
!  *10/3/91  Don H. Lee           implemented CRC-16 error protection   *
!  *                              newly introduced functions are        *
!  *                              I_CRC_calc, II_CRC_calc and           *
!  *                              update_CRC. Additions and revisions   *
!  *                              are marked with dhl for clarity       *
!  *10/18/91 Jean-Georges Fritsch fixed bug in update_CRC(),            *
!  *                              II_CRC_calc() and I_CRC_calc()        *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  * 3/20/92 Jean-Georges Fritsch  fixed bug in start-of-frame search   *
!  * 6/15/92 Juan Pineda          added refill_buffer(bs) "n"           *
!  *                              initialization                        *
!  * 7/08/92 Susanne Ritscher     MS-DOS, MSC6.0 port fixes             *
!  * 7/27/92 Mike Li               (re-)Port to MS-DOS                  *
!  * 8/19/92 Soren H. Nielsen     Fixed bug in I_CRC_calc and in        *
!  *                              II_CRC_calc.  Added function: new_ext *
!  *                              for better MS-DOS compatability       *
!  * 3/10/93 Kevin Peterson       changed aiff_read_headers to handle   *
!  *                              chunks in any order.  now returns     *
!  *                              position of sound data in file.       *
!  * 3/31/93 Jens Spille          changed IFF_* string compares to use  *
!  *                              strcmp()                              *
!  * 5/30/93 Masahiro Iwadare     removed the previous modification     *
!  *                              for UNIX.                             *
!  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
!  *         Daniel Lauzon, and                                         *
!  *         Bill Truerniet                                             *
!  *--------------------------------------------------------------------*
!  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
!  *                              Changed for 1 pass decoding.          *
!  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
!  *--------------------------------------------------------------------*
!  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
!  *--------------------------------------------------------------------*
!  *  7/14/94 Juergen Koller      rewind of bitbuffer added             *
!  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
!  *  7/11/95 Soeren H. Nielsen   Changes for MPEG-2 LSF Layer I and II *
!  *--------------------------------------------------------------------*
!  * 8/02/95  mc@fivebats.com     Added code to determine byte-order,   *
!  *                              fixes to AIFF routines. Modified Mac  *
!  *                              code to work with new Apple headers   *
!  **********************************************************************/
  
  /***********************************************************************
  *
--- 13,19 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
! 
  
  /***********************************************************************
  *
***************
*** 99,105 ****
--- 24,32 ----
  #include    "common.h"
  #include	<string.h> /* 1995-07-11 shn */
  #include	<ctype.h>
+ #include	<assert.h>
  #include <stdlib.h>
+ #include <errno.h>
  
  /***********************************************************************
  *
***************
*** 152,292 ****
  *
  ***********************************************************************/
  
- /* The system uses a variety of data files.  By opening them via this
-    function, we can accommodate various locations. */
- 
- FILE *OpenTableFile(name)
- char *name;
- {
-     char fulname[80];
-     char *envdir;
-     FILE *f;
-     
-     fulname[0] = '\0';
-     
- #ifdef TABLES_PATH
-     strcpy(fulname, TABLES_PATH);   /* default relative path for tables */
- #endif /* TABLES_PATH */          /* (includes terminal path seperator */
-     
- #ifdef UNIX                       /* envir. variables for UNIX only */
- {
-     char *getenv();
-     
-     envdir = getenv(MPEGTABENV);   /* check for environment */
-     if(envdir != NULL)
- 	strcpy(fulname, envdir);
-     strcat(fulname, PATH_SEPARATOR);  /* add a "/" on the end */
- }
- #endif /* UNIX */
- 
- strcat(fulname, name);
- if( (f=fopen(fulname,"r"))==NULL ) {
-     fprintf(stderr,"OpenTable: could not find %s\n", fulname);
-     
- #ifdef UNIX
-     if(envdir != NULL)
- 	fprintf(stderr,"Check %s directory '%s'\n",MPEGTABENV, envdir);
-           else
-             fprintf(stderr,"Check local directory './%s' or setenv %s\n",
-                     TABLES_PATH, MPEGTABENV);
- #else /* not unix : no environment variables */
- 
- #ifdef TABLES_PATH
-             fprintf(stderr,"Check local directory './%s'\n",TABLES_PATH);
- #endif /* TABLES_PATH */
- 
- #endif /* UNIX */
- 
-     }
-     return f;
- }
  
  /***********************************************************************
! *
! * Read one of the data files ("alloc_*") specifying the bit allocation/
! * quatization parameters for each subband in layer II encoding
! *
! **********************************************************************/
! 
! int read_bit_alloc(table, alloc)        /* read in table, return # subbands */
! int table;
! al_table *alloc;
! {
!         unsigned int a, b, c, d, i, j;
!         FILE *fp;
!         char name[16], t[80];
!         int sblim;
! 
!         strcpy(name, "alloc_0");
! 
!         switch (table) {
!                 case 0 : name[6] = '0';         break;
!                 case 1 : name[6] = '1';         break;
!                 case 2 : name[6] = '2';         break;
!                 case 3 : name[6] = '3';         break;
! 		case 4 : name[6] = '4';		break; /* LSF, added 1995-07-11 shn */
!                 default : name[6] = '0';
!         }
! 
!         if (!(fp = OpenTableFile(name))) {
!                 printf("Please check bit allocation table %s\n", name);
!                 exit(1);
!         }
! 
!         printf("using bit allocation table %s\n", name);
! 
!         fgets(t, 80, fp);
!         sscanf(t, "%d\n", &sblim);
!         while (!feof(fp)) {
!                 fgets(t, 80, fp);
!                 sscanf(t, "%d %d %d %d %d %d\n", &i, &j, &a, &b, &c, &d);
!                         (*alloc)[i][j].steps = a;
!                         (*alloc)[i][j].bits  = b;
!                         (*alloc)[i][j].group = c;
!                         (*alloc)[i][j].quant = d;
!         }
!         fclose(fp);
!         return sblim;
  }
  
- /***********************************************************************
- *
- * Using the decoded info the appropriate possible quantization per
- * subband table is loaded
- *
- **********************************************************************/
  
- int pick_table(fr_ps)   /* choose table, load if necess, return # sb's */
- frame_params *fr_ps;
- {
-         int table, lay, ws, bsp, br_per_ch, sfrq;
-         int sblim = fr_ps->sblimit;     /* return current value if no load */
  
-         lay = fr_ps->header->lay - 1;
-         bsp = fr_ps->header->bitrate_index;
-         br_per_ch = bitrate[fr_ps->header->version][lay][bsp] / fr_ps->stereo;
-         ws = fr_ps->header->sampling_frequency;
-         sfrq = s_freq[fr_ps->header->version][ws];
-         /* decision rules refer to per-channel bitrates (kbits/sec/chan) */
- 	if (fr_ps->header->version == MPEG_AUDIO_ID) { /* MPEG-1 */
- 	    if ((sfrq == 48 && br_per_ch >= 56) ||
- 		(br_per_ch >= 56 && br_per_ch <= 80)) table = 0;
- 	    else if (sfrq != 48 && br_per_ch >= 96) table = 1;
- 	    else if (sfrq != 32 && br_per_ch <= 48) table = 2;
- 	    else table = 3;
- 	}
- 	else { /* MPEG-2 LSF */
- 	    table = 4;
- 	}
-         if (fr_ps->tab_num != table) {
-            if (fr_ps->tab_num >= 0)
-               mem_free((void **)&(fr_ps->alloc));
-            fr_ps->alloc = (al_table FAR *) mem_alloc(sizeof(al_table),
-                                                          "alloc");
-            sblim = read_bit_alloc(fr_ps->tab_num = table, fr_ps->alloc);
-         }
-         return sblim;
- }
  
  int js_bound(lay, m_ext)
  int lay, m_ext;
--- 79,128 ----
  *
  ***********************************************************************/
  
  
  /***********************************************************************
!  * compute bitsperframe and mean_bits for a layer III frame 
!  **********************************************************************/
! void getframebits(layer *info, int stereo, int *bitsPerFrame, int *mean_bits) {
!   int whole_SpF;
!   double bit_rate,samp;
!   int samplesPerFrame,bitsPerSlot;
!   int sideinfo_len;
!   int mode_gr;
!   
!   samp =      s_freq[info->version][info->sampling_frequency];
!   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
!   samplesPerFrame = info->version == 1 ? 1152 : 576;
!   bitsPerSlot = 8;
!   mode_gr = (info->version == 1) ? 2 : 1;  /* mode_gr = 2 */
!   
!   /* determine the mean bitrate for main data */
!   sideinfo_len = 32;
!   if ( info->version == 1 )
!     {   /* MPEG 1 */
!       if ( stereo == 1 )
! 	sideinfo_len += 136;
!       else
! 	sideinfo_len += 256;
!     }
!   else
!     {   /* MPEG 2 */
!       if ( stereo == 1 )
! 	sideinfo_len += 72;
!       else
! 	sideinfo_len += 136;
!     }
!   
!   if (info->error_protection) sideinfo_len += 16;
!   
!   
!   whole_SpF =  (samplesPerFrame /samp)*(bit_rate /  (double)bitsPerSlot);
!   *bitsPerFrame = 8 * whole_SpF + (info->padding * 8);
!   *mean_bits = (*bitsPerFrame - sideinfo_len) / mode_gr;
  }
  
  
  
  
  int js_bound(lay, m_ext)
  int lay, m_ext;
***************
*** 308,314 ****
  
      fr_ps->actual_mode = hdr->mode;
      fr_ps->stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
!     if (hdr->lay == 2)          fr_ps->sblimit = pick_table(fr_ps);
      else                        fr_ps->sblimit = SBLIMIT;
      if(hdr->mode == MPG_MD_JOINT_STEREO)
          fr_ps->jsbound = js_bound(hdr->lay, hdr->mode_ext);
--- 144,152 ----
  
      fr_ps->actual_mode = hdr->mode;
      fr_ps->stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
!     if (hdr->lay == 2){    
! 	  printf("Only Layer 3 supported\n");
! 	  exit(-1);}
      else                        fr_ps->sblimit = SBLIMIT;
      if(hdr->mode == MPG_MD_JOINT_STEREO)
          fr_ps->jsbound = js_bound(hdr->lay, hdr->mode_ext);
***************
*** 317,322 ****
--- 155,161 ----
      /* alloc, tab_num set in pick_table */
  }
  
+ 
  void WriteHdr(fr_ps, s)
  frame_params *fr_ps;
  FILE *s;
***************
*** 338,432 ****
     fflush(s);
  }
  
- void WriteBitAlloc(bit_alloc, f_p, s)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *f_p;
- FILE *s;
- {
- int i,j;
- int st = f_p->stereo;
- int sbl = f_p->sblimit;
- int jsb = f_p->jsbound;
- 
-     fprintf(s, "BITA ");
-     for(i=0; i<sbl; ++i) {
-         if(i == jsb) fprintf(s,"-");
-         for(j=0; j<st; ++j)
-             fprintf(s, "%1x", bit_alloc[j][i]);
-     }
-     fprintf(s, "\n");   fflush(s);
- }
  
- void WriteScale(bit_alloc, scfsi, scalar, fr_ps, s)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT], scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int stereo  = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- int lay     = fr_ps->header->lay;
- int i,j,k;
- 
-         if(lay == 2) {
-             fprintf(s, "SFSI ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%d",scfsi[k][i]);
-             fprintf(s, "\nSCFs ");
-             for (k=0;k<stereo;k++) {
-                 for (i=0;i<sblimit;i++)
-                     if (bit_alloc[k][i])
-                         switch (scfsi[k][i]) {
-                           case 0: for (j=0;j<3;j++)
-                                   fprintf(s,"%2d%c",scalar[k][j][i],
-                                           (j==2)?';':'-');
-                                   break;
-                           case 1:
-                           case 3: fprintf(s,"%2d-",scalar[k][0][i]);
-                                   fprintf(s,"%2d;",scalar[k][2][i]);
-                                   break;
-                           case 2: fprintf(s,"%2d;",scalar[k][0][i]);
-                         }
-                 fprintf(s, "\n");
-             }
-         }
-         else{   /* lay == 1 */
-             fprintf(s, "SCFs ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%2d;",scalar[k][0][i]);
-             fprintf(s, "\n");
-         }
- }
- 
- void WriteSamples(ch, sample, bit_alloc, fr_ps, s)
- int ch;
- unsigned int FAR sample[SBLIMIT];
- unsigned int bit_alloc[SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int i;
- int stereo = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- 
-         fprintf(s, "SMPL ");
-         for (i=0;i<sblimit;i++)
-                 if ( bit_alloc[i] != 0)
-                     fprintf(s, "%d:", sample[i]);
-         if(ch==(stereo-1) )     fprintf(s, "\n");
-         else                    fprintf(s, "\t");
- }
- 
- int NumericQ(s) /* see if a string lookd like a numeric argument */
- char *s;
- {
- char    c;
- 
-     while( (c = *s++)!='\0' && isspace((int)c)) /* strip leading ws */
-         ;
-     if( c == '+' || c == '-' )
-         c = *s++;               /* perhaps skip leading + or - */
-     return isdigit((int)c);
- }
  
  int BitrateIndex(layr, bRate, version)   /* convert bitrate in kbps to index */
  int     layr;           /* 1 or 2 */
--- 177,183 ----
***************
*** 484,489 ****
--- 235,242 ----
  *  Allocate number of bytes of memory equal to "block".
  *
  *******************************************************************************/
+ /* exit(0) changed to exit(1) on memory allocation
+  * error -- 1999/06 Alvaro Martinez Echevarria */
  
  void  FAR *mem_alloc(block, item)
  unsigned long   block;
***************
*** 492,520 ****
  
      void    *ptr;
  
! #ifdef  MACINTOSH
!     ptr = NewPtr(block);
! #endif
! 
! #ifdef MSC60
!     /*ptr = (void FAR *) _fmalloc((unsigned int)block);*/ /* far memory, 92-07-08 sr */
!     ptr = (void FAR *) malloc((unsigned int)block); /* far memory, 93-08-24 ss */
! #endif
  
- #if ! defined (MACINTOSH) && ! defined (MSC60)
-     ptr = (void FAR *) malloc(block);
- #endif
  
      if (ptr != NULL){
- #ifdef  MSC60
-         _fmemset(ptr, 0, (unsigned int)block); /* far memory, 92-07-08 sr */
- #else
          memset(ptr, 0, block);
- #endif
      }
      else{
          printf("Unable to allocate %s\n", item);
!         exit(0);
      }
      return(ptr);
  }
--- 245,261 ----
  
      void    *ptr;
  
!     /* what kind of shit does ISO put out?  */
!     ptr = (void FAR *) malloc(block/*<<1*/); /* allocate twice as much memory as needed. fixes dodgy
! 					    memory problem on most systems */
  
  
      if (ptr != NULL){
          memset(ptr, 0, block);
      }
      else{
          printf("Unable to allocate %s\n", item);
!         exit(1);
      }
      return(ptr);
  }
***************
*** 531,563 ****
  {
  
      if (*ptr_addr != NULL){
- #ifdef  MACINTOSH
-         DisposPtr(*ptr_addr);
- #else
          free(*ptr_addr);
- #endif
          *ptr_addr = NULL;
      }
  
  }
  
- /*******************************************************************************
- *
- *  Check block of memory all equal to a single byte, else return FALSE
- *
- *******************************************************************************/
- 
- int memcheck(array, test, num)
- char *array;
- int test;       /* but only tested as a char (bottom 8 bits) */
- int num;
- {
-  int i=0;
- 
-    while (array[i] == test && i<num) i++;
-    if (i==num) return TRUE;
-    else return FALSE;
- }
  
  /*****************************************************************************
  *
--- 272,283 ----
***************
*** 601,606 ****
--- 321,328 ----
      }
  }
  
+ 
+ #ifndef LIBSNDFILE
  /*****************************************************************************
   *
   *  Read Audio Interchange File Format (AIFF) headers.
***************
*** 671,723 ****
      return sound_position;
  }
  
! /*****************************************************************************
!  *
!  *  Seek past some Audio Interchange File Format (AIFF) headers to sound data.
!  *
!  *****************************************************************************/
  
! int aiff_seek_to_sound_data( FILE *file_ptr )
! {
! 	if ( fseek(file_ptr, AIFF_FORM_HEADER_SIZE + AIFF_SSND_HEADER_SIZE, SEEK_SET) != 0 )
!         return(-1);
!     return(0);
  }
  
- /*******************************************************************************
-  *
-  *  Write Audio Interchange File Format (AIFF) headers.
-  *
-  *******************************************************************************/
  
! int aiff_write_headers( FILE *file_ptr, IFF_AIFF *aiff_ptr )
! {
!     int chunkSize;
!     int sampleBytes = (aiff_ptr->sampleSize / 8) + (aiff_ptr->sampleSize % 8 ? 1 : 0);
!     
!     if ( fseek(file_ptr, 0L, SEEK_SET) != 0 )
!         return -1;
!     
!     /* write FORM chunk */
!     chunkSize = 8 + 18 + 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
!     Write32BitsHighLow( file_ptr, IFF_ID_FORM );
!     Write32BitsHighLow( file_ptr, chunkSize );
!     Write32BitsHighLow( file_ptr, IFF_ID_AIFF );
!     /* write COMM chunk */
!     Write32BitsHighLow( file_ptr, IFF_ID_COMM );
!     Write32BitsHighLow( file_ptr, 18 ); /* chunk size */
!     Write16BitsHighLow( file_ptr, aiff_ptr->numChannels );
!     Write32BitsHighLow( file_ptr, aiff_ptr->numSampleFrames );
!     Write16BitsHighLow( file_ptr, aiff_ptr->sampleSize );
!     WriteIeeeExtendedHighLow( file_ptr, aiff_ptr->sampleRate );
!     /* write SSND chunk header */
!     chunkSize = 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
!     Write32BitsHighLow( file_ptr, IFF_ID_SSND );
!     Write32BitsHighLow( file_ptr, chunkSize );
!     Write32BitsHighLow( file_ptr, 0 ); /* offset */
!     Write32BitsHighLow( file_ptr, 0 ); /* block size */
!     return 0;
! }
  
  /*****************************************************************************
  *
--- 393,428 ----
      return sound_position;
  }
  
! #include "wavheader.h"
! #define ENDSWAP_SHORT(x) ((((x)>>8)&0xFF)|(((x)&0xFF)<<8))
! #define ENDSWAP_INT(x) ((((x)>>24)&0xFF)|(((x)>>8)&0xFF00)|(((x)&0xFF00)<<8)|(((x)&0xFF)<<24))
! 
! void endswap_wave_fmt (WaveHeader *wavfmt) {
! 	wavfmt->main_chunk	= ENDSWAP_INT	(wavfmt->main_chunk);
! 	wavfmt->length		= ENDSWAP_INT	(wavfmt->length);
! 	wavfmt->chunk_type	= ENDSWAP_INT	(wavfmt->chunk_type);
! 
! 	wavfmt->sub_chunk	= ENDSWAP_INT	(wavfmt->sub_chunk);
! 	wavfmt->sc_len		= ENDSWAP_INT	(wavfmt->sc_len);
! 	wavfmt->format		= ENDSWAP_SHORT	(wavfmt->format);
! 	wavfmt->modus		= ENDSWAP_SHORT	(wavfmt->modus);
! 	wavfmt->sample_fq	= ENDSWAP_INT	(wavfmt->sample_fq);
! 	wavfmt->byte_p_sec	= ENDSWAP_INT	(wavfmt->byte_p_sec);
! 	wavfmt->byte_p_spl	= ENDSWAP_SHORT	(wavfmt->byte_p_spl);
! 	wavfmt->bit_p_spl	= ENDSWAP_SHORT	(wavfmt->bit_p_spl);
  
! 	wavfmt->data_chunk	= ENDSWAP_INT	(wavfmt->data_chunk);
! 	wavfmt->data_length	= ENDSWAP_INT	(wavfmt->data_length);
  }
  
  
! 
! 
! #endif
! 
! 
! 
! 
  
  /*****************************************************************************
  *
***************
*** 742,756 ****
  /*desalloc_buffer();   empty and close the buffer                         */
  /*back_track_buffer();     goes back N bits in the buffer                 */
  /*unsigned int get1bit();  read 1 bit from the bit stream                 */
- /*unsigned long getbits(); read N bits from the bit stream                */
- /*unsigned long byte_ali_getbits();   read the next byte aligned N bits from*/
- /*                                    the bit stream                        */
  /*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
  /*                            changing the buffer pointer                   */
  /*put1bit(); write 1 bit from the bit stream  */
  /*put1bit(); write 1 bit from the bit stream  */
  /*putbits(); write N bits from the bit stream */
- /*byte_ali_putbits(); write byte aligned the next N bits into the bit stream*/
  /*unsigned long sstell(); return the current bit stream length (in bits)    */
  /*int end_bs(); return 1 if the end of bit stream reached otherwise 0       */
  /*int seek_sync(); return 1 if a sync word was found in the bit stream      */
--- 447,457 ----
***************
*** 765,770 ****
--- 466,472 ----
     register int index=0;
     char val[2];
  
+ #ifndef _BLADEDLL
     while ((i>=0) && (!bs->eob)) {
  
        if (bs->format == BINARY)
***************
*** 808,855 ****
        }
  
      }
     return 0;
  }
  
- static char *he = "0123456789ABCDEF";
  
  /* empty the buffer to the output device when the buffer becomes full */
  void empty_buffer(bs, minimum)
  Bit_stream_struc *bs;   /* bit stream structure */
  int minimum;            /* end of the buffer to empty */
  {
!    register int i;
  
  #if BS_FORMAT == BINARY
!    for (i=bs->buf_size-1;i>=minimum;i--)
!       fwrite(&bs->buf[i], sizeof(unsigned char), 1, bs->pt);
  #else
     for (i=bs->buf_size-1;i>=minimum;i--) {
         char val[2];
         val[0] = he[((bs->buf[i] >> 4) & 0x0F)];
         val[1] = he[(bs->buf[i] & 0x0F)];
         fwrite(val, sizeof(char), 2, bs->pt);
!    }
  #endif
- fflush(bs->pt); /* NEW SS to assist in debugging*/
  
!    for (i=minimum-1; i>=0; i--)
         bs->buf[bs->buf_size - minimum + i] = bs->buf[i];
  
!    bs->buf_byte_idx = bs->buf_size -1 - minimum;
     bs->buf_bit_idx = 8;
  }
  
  /* open the device to write the bit stream into it */
! void open_bit_stream_w(bs, bs_filenam, size)
! Bit_stream_struc *bs;   /* bit stream structure */
! char *bs_filenam;       /* name of the bit stream file */
! int size;               /* size of the buffer */
! {
!    if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
        printf("Could not create \"%s\".\n", bs_filenam);
        exit(1);
!    }
     alloc_buffer(bs, size);
     bs->buf_byte_idx = size-1;
     bs->buf_bit_idx=8;
--- 510,621 ----
        }
  
      }
+ #endif
     return 0;
  }
  
  
  /* empty the buffer to the output device when the buffer becomes full */
+ /* mt 3/99: modified so we can call empty_buffer even if buffer is not full */
+ /* add error checking -- 1999/06 Alvaro Martinez Echevarria */
+ /* someone gimme a good reason for writing bytes one by
+  * one; changed -- 1999/06 Alvaro Martinez Echevarria */
  void empty_buffer(bs, minimum)
  Bit_stream_struc *bs;   /* bit stream structure */
  int minimum;            /* end of the buffer to empty */
  {
!    register int i,j;
!    unsigned char *tmpbuf;
  
+ #ifndef DISTRIB
  #if BS_FORMAT == BINARY
! 
!    #ifndef _BLADEDLL
!      tmpbuf=(unsigned char *)malloc(bs->buf_size-minimum);
!      if (tmpbuf==NULL) {
!        //fprintf(stderr,"error in malloc(): %s\n",sys_errlist[errno]);
!        perror("error in malloc()\n");
!        exit(1);
!      }
!      for (i=bs->buf_size-1,j=0;i>=minimum;i--,j++) {
!        tmpbuf[j]=bs->buf[i];
!      }
!      fwrite(tmpbuf,1,bs->buf_size-minimum,bs->pt);
!      if (ferror(bs->pt)) {
!        fprintf(stderr,"error en fwrite()\n");
!        exit(1);
!      }
!      free(tmpbuf);
!    #else
!      for (i=bs->buf_size-1;i>=minimum;i--) 
!      {
! 		if (bs->nOutBufPos<BUFFER_SIZE)
! 		{
! 			bs->pbtOutBuf[bs->nOutBufPos++]=bs->buf[i];
! 		}
! 		else
! 		{
! 			assert(0);
! 		}
!      }
!    #endif
! 
  #else
+    static char *he = "0123456789ABCDEF";
+ 
     for (i=bs->buf_size-1;i>=minimum;i--) {
         char val[2];
         val[0] = he[((bs->buf[i] >> 4) & 0x0F)];
         val[1] = he[(bs->buf[i] & 0x0F)];
         fwrite(val, sizeof(char), 2, bs->pt);
!        if (ferror(bs->pt)) {
!           fprintf(stderr,"error in fwrite()\n");
!           exit(1);
!        }
!    }
! #endif // BS_FORMAT==BINARY
! 
! 	#ifndef _BLADEDLL
! 		// NEW SS to assist in debugging
! 		// Only file for files, not for the output buffer
! 		if (fflush(bs->pt)!=0) {
!                   //fprintf(stderr,"error in fflush(): %s\n",sys_errlist[errno]);
! 		  perror("error in fflush(): \n");
!                   exit(1);
!                 }
! 	#endif
  #endif
  
!    /* for (i=minimum-1; i>=0; i--) */
!    for (i=minimum-1; i>=bs->buf_byte_idx+1; i--)
         bs->buf[bs->buf_size - minimum + i] = bs->buf[i];
  
!    /*   bs->buf_byte_idx = bs->buf_size -1 - minimum; */
!    bs->buf_byte_idx = bs->buf_size -1 - minimum + bs->buf_byte_idx + 1;
     bs->buf_bit_idx = 8;
  }
  
  /* open the device to write the bit stream into it */
! void open_bit_stream_w(	Bit_stream_struc* bs,	/* bit stream structure */
! 						char* bs_filenam,		/* name of the bit stream file */
! 						int size				/* size of the buffer */
! 						)
! {
! #ifdef _BLADEDLL
!   // Initialize output buffer
!   bs->pbtOutBuf=NULL;
!   bs->nOutBufPos=0;
! #else
!   if (!strcmp(bs_filenam, "-")) {
!     /* Write to standard output. */
!     bs->pt = stdout;
!   } else {
!     if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
        printf("Could not create \"%s\".\n", bs_filenam);
        exit(1);
!     }
!   }
! #endif
     alloc_buffer(bs, size);
     bs->buf_byte_idx = size-1;
     bs->buf_bit_idx=8;
***************
*** 859,949 ****
     bs->eobs = FALSE;
  }
  
- /* open the device to read the bit stream from it */
- void open_bit_stream_r(bs, bs_filenam, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- char *bs_filenam;       /* name of the bit stream file */
- int size;               /* size of the buffer */
- {
-    register unsigned long n;
-    register unsigned char flag = 1;
-    unsigned char val;
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    do {
-      n = fread(&val, sizeof(unsigned char), 1, bs->pt);
-      switch (val) {
-       case 0x30:
-       case 0x31:
-       case 0x32:
-       case 0x33:
-       case 0x34:
-       case 0x35:
-       case 0x36:
-       case 0x37:
-       case 0x38:
-       case 0x39:
-       case 0x41:
-       case 0x42:
-       case 0x43:
-       case 0x44:
-       case 0x45:
-       case 0x46:
-       case 0xa:  /* \n */
-       case 0xd:  /* cr */
-       case 0x1a:  /* sub */
-           break;
- 
-       default: /* detection of an binary character */
-           flag--;
-           break;
-      }
- 
-    } while (flag & n);
- 
-    if (flag) {
-       printf ("the bit stream file %s is an ASCII file\n", bs_filenam);
-       bs->format = ASCII;
-    }
-    else {
-       bs->format = BINARY;
-       printf ("the bit stream file %s is a BINARY file\n", bs_filenam);
-    }
- 
-    fclose(bs->pt);
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    alloc_buffer(bs, size);
-    bs->buf_byte_idx=0;
-    bs->buf_bit_idx=0;
-    bs->totbit=0;
-    bs->mode = READ_MODE;
-    bs->eob = FALSE;
-    bs->eobs = FALSE;
- }
- 
- /*close the device containing the bit stream after a read process*/
- void close_bit_stream_r(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    fclose(bs->pt);
-    desalloc_buffer(bs);
- }
  
  /*close the device containing the bit stream after a write process*/
  void close_bit_stream_w(bs)
  Bit_stream_struc *bs;   /* bit stream structure */
  {
     empty_buffer(bs, bs->buf_byte_idx);
     fclose(bs->pt);
     desalloc_buffer(bs);
  }
  
--- 625,644 ----
     bs->eobs = FALSE;
  }
  
  
  /*close the device containing the bit stream after a write process*/
  void close_bit_stream_w(bs)
  Bit_stream_struc *bs;   /* bit stream structure */
  {
+ 	// Flush last bytes
     empty_buffer(bs, bs->buf_byte_idx);
+ 
+ #ifndef _BLADEDLL
+    // Close the file
     fclose(bs->pt);
+ #endif // _BLADEDLL
+ 
+    // Deallocate all buffers
     desalloc_buffer(bs);
  }
  
***************
*** 966,994 ****
  
  int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
  int clearmask[9]={0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0};
- 
- void back_track_buffer(bs, N) /* goes back N bits in the buffer */
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;
- {
-    int tmp = N - (N/8)*8;
-    register int i;
- 
-    bs->totbit -= N;
-    for (i=bs->buf_byte_idx;i< bs->buf_byte_idx+N/8-1;i++) bs->buf[i] = 0;
-    bs->buf_byte_idx += N/8;
-    if ( (tmp + bs->buf_bit_idx) <= 8) {
-       bs->buf_bit_idx += tmp;
-    }
-    else {
-       bs->buf_byte_idx ++;
-       bs->buf_bit_idx += (tmp - 8);
-    }
-    bs->buf[bs->buf_byte_idx] &= clearmask[bs->buf_bit_idx];
- }
- 
  int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
  
  /*read 1 bit from the bit stream */
  unsigned int get1bit(bs)
  Bit_stream_struc *bs;   /* bit stream structure */
--- 661,669 ----
  
  int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
  int clearmask[9]={0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0};
  int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
  
+ #if 0
  /*read 1 bit from the bit stream */
  unsigned int get1bit(bs)
  Bit_stream_struc *bs;   /* bit stream structure */
***************
*** 1017,1022 ****
--- 692,698 ----
     bs->buf_bit_idx--;
     return(bit);
  }
+ #endif
  
  /*write 1 bit from the bit stream */
  void put1bit(bs, bit)
***************
*** 1036,1108 ****
     }
  }
  
- /*look ahead for the next N bits from the bit stream */
- unsigned long look_ahead(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
-  register int bit_idx = bs->buf_bit_idx;
-  register int byte_idx = bs->buf_byte_idx;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  while (j > 0) {
-     if (!bit_idx) {
-         bit_idx = 8;
-         byte_idx--;
-     }
-     k = MIN (j, bit_idx);
-     tmp = bs->buf[byte_idx]&putmask[bit_idx];
-     tmp = tmp >> (bit_idx-k);
-     val |= tmp << (j-k);
-     bit_idx -= k;
-     j -= k;
-  }
-  return(val);
- }
- 
- /*read N bit from the bit stream */
- unsigned long getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int i;
-  register int j = N;
-  register int k, tmp;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  bs->totbit += N;
-  while (j > 0) {
-    if (!bs->buf_bit_idx) {
-         bs->buf_bit_idx = 8;
-         bs->buf_byte_idx--;
-         if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
-              if (bs->eob)
-                 bs->eobs = TRUE;
-              else {
-                 for (i=bs->buf_byte_idx; i>=0;i--)
-                    bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
-                 refill_buffer(bs);
-                 bs->buf_byte_idx = bs->buf_size-1;
-              }
-         }
-    }
-    k = MIN (j, bs->buf_bit_idx);
-    tmp = bs->buf[bs->buf_byte_idx]&putmask[bs->buf_bit_idx];
-    tmp = tmp >> (bs->buf_bit_idx-k);
-    val |= tmp << (j-k);
-    bs->buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
  
  /*write N bits into the bit stream */
  void putbits(bs, val, N)
--- 712,717 ----
***************
*** 1118,1124 ****
  
   bs->totbit += N;
   while (j > 0) {
!    k = MIN(j, bs->buf_bit_idx);
     tmp = val >> (j-k);
     bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
     bs->buf_bit_idx -= k;
--- 727,733 ----
  
   bs->totbit += N;
   while (j > 0) {
!    k = Min(j, bs->buf_bit_idx);
     tmp = val >> (j-k);
     bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
     bs->buf_bit_idx -= k;
***************
*** 1133,1170 ****
   }
  }
  
- /*write N bits byte aligned into the bit stream */
- void byte_ali_putbits(bs, val, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-      putbits(bs, (unsigned int)0, (int)(8-aligning)); 
- 
-  putbits(bs, val, N);
- }
- 
- /*read the next bute aligned N bits from the bit stream */
- unsigned long byte_ali_getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-     getbits(bs, (int)(8-aligning));
- 
-  return(getbits(bs, N));
- }
  
  /*return the current bit stream length (in bits)*/
  unsigned long sstell(bs)
--- 742,747 ----
***************
*** 1182,1439 ****
    return(bs->eobs);
  }
  
- /*this function seeks for a byte aligned sync word in the bit stream and
-   places the bit stream pointer right after the sync.
-   This function returns 1 if the sync was found otherwise it returns 0  */
- int seek_sync(bs, sync, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- long sync;      /* sync word maximum 32 bits */
- int N;          /* sync word length */
- {
- #if defined(MACINTOSH) && !defined(__powerc)
-  double pow();
- #endif
-  unsigned long aligning, stell();
-  unsigned long val;
-  long maxi = (int)pow(2.0, (FLOAT)N) - 1;
- 
-  aligning = sstell(bs)%ALIGNING;
-  if (aligning)
-     getbits(bs, (int)(ALIGNING-aligning));
- 
-   val = getbits(bs, N);
-   while (((val&maxi) != sync) && (!end_bs(bs))) {
-         val <<= ALIGNING;
-         val |= getbits(bs, ALIGNING);
-   }
- 
-  if (end_bs(bs)) return(0);
-  else return(1);
- }
  /*****************************************************************************
  *
  *  End of bit_stream.c package
  *
  *****************************************************************************/
  
- /*****************************************************************************
- *
- *  CRC error protection package
- *
- *****************************************************************************/
- 
- void I_CRC_calc(fr_ps, bit_alloc, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int jsbound = fr_ps->jsbound;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<SBLIMIT;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], 4, crc);
- }
- 
- void II_CRC_calc(fr_ps, bit_alloc, scfsi, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int sblimit = fr_ps->sblimit;
-         int jsbound = fr_ps->jsbound;
-         al_table *alloc = fr_ps->alloc;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], (*alloc)[i][0].bits, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<stereo;k++)
-                         if (bit_alloc[k][i])
-                                 update_CRC(scfsi[k][i], 2, crc);
- }
- 
- void update_CRC(data, length, crc)
- unsigned int data, length, *crc;
- {
-         unsigned int  masking, carry;
- 
-         masking = 1 << length;
- 
-         while((masking >>= 1)){
-                 carry = *crc & 0x8000;
-                 *crc <<= 1;
-                 if (!carry ^ !(data & masking))
-                         *crc ^= CRC16_POLYNOMIAL;
-         }
-         *crc &= 0xffff;
- }
- 
- /*****************************************************************************
- *
- *  End of CRC error protection package
- *
- *****************************************************************************/
- 
- #ifdef  MACINTOSH
- /*****************************************************************************
- *
- *  Set Macintosh file attributes.
- *
- *****************************************************************************/
- void set_mac_file_attr( char fileName[MAX_NAME_SIZE], short vRefNum, OSType creator, OSType fileType)
- {
-     char pascal_fileName[MAX_NAME_SIZE];
-     FInfo fndrInfo;
-     OSErr anErr;
-     long dirID = 0L;
-     
-     CtoPstr(strcpy(pascal_fileName, fileName));
-     anErr = HGetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
-     if ( anErr != noErr )
-         return;
-     fndrInfo.fdCreator = creator;
-     fndrInfo.fdType = fileType;
-     anErr = HSetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
- }
- 
- #endif
- 
- 
- #ifdef  MS_DOS
- /* ------------------------------------------------------------------------
- new_ext()
- Puts a new extension name on a file name <filename>.
- Removes the last extension name, if any.
- 1992-08-19, 1995-06-12 shn
- ------------------------------------------------------------------------ */
- void
- new_ext(char *filename, char *extname, char *newname)
- {
-   int found, dotpos;
- 
-   /* First, strip the extension */
-   dotpos=strlen(filename); found=0;
-   do
-   {
-     switch (filename[dotpos])
-     {
-       case '.' : found=1; break;
-       case '\\':
-       case '/' :
-       case ':' : found=-1; break;
-       default  : dotpos--; if (dotpos<0) found=-1; break;
-     }
-   } while (found==0);
-   if (found==-1) strcpy(newname,filename);
-   if (found== 1) { strncpy(newname,filename,dotpos); newname[dotpos]='\0'; }
-   strcat(newname,extname);
- }
- #endif
- 
- 
- 
- #define BUFSIZE 4096
- static unsigned long offset,totbit=0, buf_byte_idx=0;
- static unsigned int buf[BUFSIZE];
- static unsigned int buf_bit_idx=8;
- 
- /*return the current bit stream length (in bits)*/
- unsigned long hsstell()
- {
-   return(totbit);
- }
- 
- /* int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff}; */
- extern int putmask[9];
- 
- /*read N bit from the bit stream */
- unsigned long hgetbits(N)
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
- 
- /*
-  if (N > MAX_LENGTH)
-      printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- */
-  totbit += N;
-  while (j > 0) {
-    if (!buf_bit_idx) {
-         buf_bit_idx = 8;
-         buf_byte_idx++;
- 	if (buf_byte_idx > offset)
- 	  { printf("Buffer overflow !!\n");exit(3); }
-    }
-    k = MIN (j, buf_bit_idx);
-    tmp = buf[buf_byte_idx%BUFSIZE]&putmask[buf_bit_idx];
-    tmp = tmp >> (buf_bit_idx-k);
-    val |= tmp << (j-k);
-    buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
- 
- unsigned int hget1bit()
- {
- return(hgetbits(1));
- }
- 
- /*write N bits into the bit stream */
- void hputbuf(val, N)
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-   if (N != 8) { printf("Not Supported yet!!\n"); exit(-3); }
-   buf[offset % BUFSIZE] = val;
-   offset++;
- }
- 
- void rewindNbits( N )
- int N;
- {
-    totbit -= N;
-    buf_bit_idx += N;
-    while( buf_bit_idx >= 8 )
-    {  buf_bit_idx -= 8;
-       buf_byte_idx--;
-    }
- }
- 
- void rewindNbytes( N )
- int N;
- {
-    totbit -= N*8;
-    buf_byte_idx -= N;
- }
--- 759,767 ----
diff -r -c -N encoder/common.h lame3.13/common.h
*** encoder/common.h	Wed Jan 22 02:43:13 1997
--- lame3.13/common.h	Fri Jun 18 00:44:37 1999
***************
*** 10,71 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
!  *          Davis Pan                                                 *
!  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
!  *                              into "common.h" and "encoder.h".      *
!  *                              Ported to Macintosh and Unix.         *
!  *                              Added additional type definitions for *
!  *                              AIFF, double/SANE and "bitstream.c".  *
!  *                              Added function prototypes for more    *
!  *                              rigorous type checking.               *
!  * 27jun91  dpwe (Aware)        Added "alloc_*" defs & prototypes     *
!  *                              Defined new struct 'frame_params'.    *
!  *                              Changed info.stereo to info.mode_ext  *
!  *                              #define constants for mode types      *
!  *                              Prototype arguments if PROTO_ARGS     *
!  * 5/28/91  Earle Jennings      added MS_DOS definition               *
!  *                              MsDos function prototype declarations *
!  * 7/10/91  Earle Jennings      added FLOAT definition as double      *
!  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  *                              Modified some function prototypes.    *
!  *                              Changed BUFFER_SIZE back to 4096.     *
!  * 7/27/92  Michael Li          (re-)Ported to MS-DOS                 *
!  * 7/27/92  Masahiro Iwadare    Ported to Convex                      *
!  * 8/07/92  mc@tv.tek.com                                             *
!  * 8/10/92  Amit Gulati         Ported to the AIX Platform (RS6000)   *
!  *                              AIFF string constants redefined       *
!  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
!  *         Daniel Lauzon, and                                         *
!  *         Bill Truerniet                                             *
!  *--------------------------------------------------------------------*
!  * 4/23/92  J. Pineda           Added code for Layer III.             *
!  * 11/9/92  Amit Gulati         Added defines for layerIII stereo     *
!  *                              modes.                                *
!  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
!  *                              Changed for 1 pass decoding.          *
!  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
!  *--------------------------------------------------------------------*
!  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
!  *--------------------------------------------------------------------*
!  *  7/14/94 Juergen Koller      Fix for HPUX an IRIX in AIFF-Strings  *
!  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
!  *  7/11/95 Soeren H. Nielsen   Added defs. for MPEG-2 LSF            *
!  *--------------------------------------------------------------------*
!  * 8/02/95  mc@fivebats.com     Changes to AIFF stuff for portability *
!  *                              to little-endian machines             *
!  **********************************************************************/
  #ifndef COMMON_DOT_H
  #define COMMON_DOT_H
  /***********************************************************************
--- 10,16 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
! 
  #ifndef COMMON_DOT_H
  #define COMMON_DOT_H
  /***********************************************************************
***************
*** 75,128 ****
  ***********************************************************************/
  
  #if 0
- #define      UNIX            /* Unix conditional compile switch */
- #define      MACINTOSH       /* Macintosh conditional compile switch */
- #define      MS_DOS          /* IBM PC conditional compile switch */
- #define      MSC60           /* Compiled for MS_DOS with MSC v6.0 */
- #define      AIX             /* AIX conditional compile switch    */
  #define      CONVEX          /* CONVEX conditional compile switch */
  #endif
  
- #if defined(MSC60) 
- #ifndef MS_DOS
- #define MS_DOS
- #endif
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
- #ifdef  UNIX
- #define         TABLES_PATH     "tables"  /* to find data files */
- /* name of environment variable holding path of table files */
- #define         MPEGTABENV      "MPEGTABLES"
- #define         PATH_SEPARATOR  "/"        /* how to build paths */
- #endif  /* UNIX */
- 
- #ifdef  MACINTOSH
- #define      TABLES_PATH ":tables:"  /* where to find data files */
- #endif  /* MACINTOSH */
- 
  /* 
   * Don't define FAR to far unless you're willing to clean up the 
   * prototypes
   */
  #define FAR /*far*/
  
- #ifdef __STDC__
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
  #ifdef CONVEX
  #define SEEK_SET        0
  #define SEEK_CUR        1
  #define SEEK_END        2
  #endif
  
- /* MS_DOS and VMS do not define TABLES_PATH, so OpenTableFile will default
-    to finding the data files in the default directory */
  
  /***********************************************************************
  *
--- 20,40 ----
***************
*** 133,163 ****
  #include        <stdio.h>
  #include        <string.h>
  #include        <math.h>
  #include "portableio.h"
  #include "ieeefloat.h"
- 
- #ifdef  UNIX
- #include        <unistd.h>
- #endif  /* UNIX */
- 
- #ifdef __sgi
- #include	<stdlib.h>
  #endif
  
! #ifdef  MACINTOSH
! #include        <stdlib.h>
! #include        <console.h>
! #endif  /* MACINTOSH */
! 
! #ifdef  MS_DOS
  #include        <stdlib.h>
- #ifdef MSC60
- #include        <memory.h>
- #else
- #include        <alloc.h>
- #include        <mem.h>
- #endif  /* MSC60 */
- #endif  /* MS_DOS */
  
  #ifndef EXIT_SUCCESS
  #define EXIT_SUCCESS 0
--- 45,57 ----
  #include        <stdio.h>
  #include        <string.h>
  #include        <math.h>
+ #ifndef LIBSNDFILE
  #include "portableio.h"
  #include "ieeefloat.h"
  #endif
  
! /*#include        <unistd.h>*/
  #include        <stdlib.h>
  
  #ifndef EXIT_SUCCESS
  #define EXIT_SUCCESS 0
***************
*** 175,185 ****
  
  /* General Definitions */
  
! #ifdef  MS_DOS
! #define         FLOAT                   double
! #else
  #define         FLOAT                   float
  #endif
  #ifndef FALSE
  #define         FALSE                   0
  #endif
--- 69,78 ----
  
  /* General Definitions */
  
! #ifndef FLOAT
  #define         FLOAT                   float
  #endif
+ 
  #ifndef FALSE
  #define         FALSE                   0
  #endif
***************
*** 191,202 ****
--- 84,108 ----
  #define         NULL_CHAR               '\0'
  
  #define         MAX_U_32_NUM            0xFFFFFFFF
+ #ifdef M_PI
+ #define		PI			M_PI
+ #endif
  #ifndef PI
  #define         PI                      3.14159265358979
  #endif
+ #ifdef M_PI_4
+ #define		PI4			M_PI_4
+ #else
  #define         PI4                     PI/4
+ #endif
  #define         PI64                    PI/64
+ #ifdef M_LN10
+ #define		LN_TO_LOG10		(M_LN10/10)
+ #else
  #define         LN_TO_LOG10             0.2302585093
+ #endif
+ 
+ #define         SQRT2                   1.4142135623730951454746218587388284504414
  
  #define         VOL_REF_NUM             0
  #define         MPEG_AUDIO_ID           1
***************
*** 206,213 ****
  #define         MONO                    1
  #define         STEREO                  2
  #define         BITS_IN_A_BYTE          8
! #define         WORD                    16
! #define         MAX_NAME_SIZE           81
  #define         SBLIMIT                 32
  #define         SSLIMIT                 18
  #define         FFT_SIZE                1024
--- 112,118 ----
  #define         MONO                    1
  #define         STEREO                  2
  #define         BITS_IN_A_BYTE          8
! #define         MAX_NAME_SIZE           300
  #define         SBLIMIT                 32
  #define         SSLIMIT                 18
  #define         FFT_SIZE                1024
***************
*** 244,256 ****
  #define         ASCII           1
  
  #ifndef BS_FORMAT
! #define         BS_FORMAT       ASCII /* BINARY or ASCII = 2x bytes */
  #endif
  
! #define         BUFFER_SIZE     4096
  
! #define         MIN(A, B)       ((A) < (B) ? (A) : (B))
! #define         MAX(A, B)       ((A) > (B) ? (A) : (B))
  
  /***********************************************************************
  *
--- 149,162 ----
  #define         ASCII           1
  
  #ifndef BS_FORMAT
! /* #define         BS_FORMAT       ASCII  */ /* BINARY or ASCII = 2x bytes */
! #define         BS_FORMAT       BINARY
  #endif
  
! #define         BUFFER_SIZE     16384
  
! #define         Min(A, B)       ((A) < (B) ? (A) : (B))
! #define         Max(A, B)       ((A) > (B) ? (A) : (B))
  
  /***********************************************************************
  *
***************
*** 316,321 ****
--- 222,229 ----
      unsigned long   blockSize;
  } blockAlign;
  
+ 
+ #ifndef LIBSNDFILE
  typedef struct  IFF_AIFF_struct {
      short           numChannels;
      unsigned long   numSampleFrames;
***************
*** 324,329 ****
--- 232,239 ----
      unsigned long   sampleType;
      blockAlign      blkAlgn;
  } IFF_AIFF;
+ #endif
+ 
  
  enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
  extern enum byte_order NativeByteOrder;
***************
*** 331,336 ****
--- 241,248 ----
  /* "bit_stream.h" Type Definitions */
  
  typedef struct  bit_stream_struc {
+     unsigned char*		pbtOutBuf;   /* for .DLL code */
+     int 			nOutBufPos;  /* for .DLL code */
      FILE        *pt;            /* pointer to bit stream device */
      unsigned char *buf;         /* bit stream buffer */
      int         buf_size;       /* size of buffer (in number of bytes) */
***************
*** 368,491 ****
  
  /* The following functions are in the file "common.c" */
  
- #ifdef  PROTO_ARGS
- extern FILE           *OpenTableFile(char*);
- extern int            read_bit_alloc(int, al_table*);
- extern int            pick_table(frame_params*);
  extern int            js_bound(int, int);
  extern void           hdr_to_frps(frame_params*);
- extern void           WriteHdr(frame_params*, FILE*);
- extern void           WriteBitAlloc(unsigned int[2][SBLIMIT], frame_params*,
-                         FILE*);
- extern void           WriteScale(unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int[2][3][SBLIMIT],
-                         frame_params*, FILE*);
- extern void           WriteSamples(int, unsigned int FAR [SBLIMIT],
-                         unsigned int[SBLIMIT], frame_params*, FILE*);
- extern int            NumericQ(char*);
  extern int            BitrateIndex(int, int, int);
  extern int            SmpFrqIndex(long, int*);
- extern int            memcheck(char*, int, int);
  extern void           FAR *mem_alloc(unsigned long, char*);
  extern void           mem_free(void**);
  extern void           double_to_extended(double*, char[10]);
  extern void           extended_to_double(char[10], double*);
  extern int            aiff_read_headers(FILE*, IFF_AIFF*);
  extern int            aiff_seek_to_sound_data(FILE*);
  extern int            aiff_write_headers(FILE*, IFF_AIFF*);
  extern int            refill_buffer(Bit_stream_struc*);
  extern void           empty_buffer(Bit_stream_struc*, int);
  extern void           open_bit_stream_w(Bit_stream_struc*, char*, int);
- extern void           open_bit_stream_r(Bit_stream_struc*, char*, int);
- extern void           close_bit_stream_r(Bit_stream_struc*);
  extern void           close_bit_stream_w(Bit_stream_struc*);
  extern void           alloc_buffer(Bit_stream_struc*, int);
  extern void           desalloc_buffer(Bit_stream_struc*);
- extern void           back_track_buffer(Bit_stream_struc*, int);
- extern unsigned int   get1bit(Bit_stream_struc*);
  extern void           put1bit(Bit_stream_struc*, int);
- extern unsigned long  look_ahead(Bit_stream_struc*, int);
- extern unsigned long  getbits(Bit_stream_struc*, int);
  extern void           putbits(Bit_stream_struc*, unsigned int, int);
- extern void           byte_ali_putbits(Bit_stream_struc*, unsigned int, int);
- extern unsigned long  byte_ali_getbits(Bit_stream_struc*, int);
  extern unsigned long  sstell(Bit_stream_struc*);
  extern int            end_bs(Bit_stream_struc*);
- extern int            seek_sync(Bit_stream_struc*, long, int);
- extern void           I_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int*);
- extern void           II_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int*);
- extern void           update_CRC(unsigned int, unsigned int, unsigned int*);
  extern void           read_absthr(FLOAT*, int);
! extern unsigned int   hget1bit(); /* MI */
! extern unsigned long  hgetbits(int);
! extern unsigned long  hsstell();
! extern void           hputbuf(unsigned int,int);
  extern enum byte_order DetermineByteOrder();
  extern void SwapBytesInWords( short *loc, int words );
  
  
- #ifdef  MACINTOSH
- extern void           set_mac_file_attr(char[MAX_NAME_SIZE], short, OSType,
-                         OSType);
- #endif
- #ifdef MS_DOS
- extern void           new_ext(char *filename, char *extname, char *newname); 
- #endif
- 
- #else
- extern FILE           *OpenTableFile();
- extern int            read_bit_alloc();
- extern int            pick_table();
- extern int            js_bound();
- extern void           hdr_to_frps();
- extern void           WriteHdr();
- extern void           WriteBitAlloc();
- extern void           WriteScale();
- extern void           WriteSamples();
- extern int            NumericQ();
- extern int            BitrateIndex();
- extern int            SmpFrqIndex();
- extern int            memcheck();
- extern void           FAR *mem_alloc();
- extern void           mem_free();
- extern void           double_to_extended();
- extern void           extended_to_double();
- extern int            aiff_read_headers();
- extern int            aiff_seek_to_sound_data();
- extern int            aiff_write_headers();
- extern int            refill_buffer();
- extern void           empty_buffer();
- extern void           open_bit_stream_w();
- extern void           open_bit_stream_r();
- extern void           close_bit_stream_r();
- extern void           close_bit_stream_w();
- extern void           alloc_buffer();
- extern void           desalloc_buffer();
- extern void           back_track_buffer();
- extern unsigned int   get1bit();
- extern void           put1bit();
- extern unsigned long  look_ahead();
- extern unsigned long  getbits();
- extern void           putbits();
- extern void           byte_ali_putbits();
- extern unsigned long  byte_ali_getbits();
- extern unsigned long  sstell();
- extern int            end_bs();
- extern int            seek_sync();
- extern void           I_CRC_calc();
- extern void           II_CRC_calc();
- extern void           update_CRC();
- extern void           read_absthr();
- 
- extern unsigned int   hget1bit();
- extern unsigned long  hgetbits();
- extern unsigned long  hsstell();
- extern void           hputbuf();
  
- #ifdef MS_DOS
- extern void           new_ext(); 
- #endif
- #endif
  #endif
--- 280,317 ----
  
  /* The following functions are in the file "common.c" */
  
  extern int            js_bound(int, int);
  extern void           hdr_to_frps(frame_params*);
  extern int            BitrateIndex(int, int, int);
  extern int            SmpFrqIndex(long, int*);
  extern void           FAR *mem_alloc(unsigned long, char*);
  extern void           mem_free(void**);
  extern void           double_to_extended(double*, char[10]);
  extern void           extended_to_double(char[10], double*);
+ #ifndef LIBSNDFILE
  extern int            aiff_read_headers(FILE*, IFF_AIFF*);
  extern int            aiff_seek_to_sound_data(FILE*);
  extern int            aiff_write_headers(FILE*, IFF_AIFF*);
+ #endif
  extern int            refill_buffer(Bit_stream_struc*);
  extern void           empty_buffer(Bit_stream_struc*, int);
  extern void           open_bit_stream_w(Bit_stream_struc*, char*, int);
  extern void           close_bit_stream_w(Bit_stream_struc*);
  extern void           alloc_buffer(Bit_stream_struc*, int);
  extern void           desalloc_buffer(Bit_stream_struc*);
  extern void           put1bit(Bit_stream_struc*, int);
  extern void           putbits(Bit_stream_struc*, unsigned int, int);
  extern unsigned long  sstell(Bit_stream_struc*);
  extern int            end_bs(Bit_stream_struc*);
  extern void           read_absthr(FLOAT*, int);
! 
  extern enum byte_order DetermineByteOrder();
  extern void SwapBytesInWords( short *loc, int words );
  
+ extern int readframe();
+ extern int makeframe();
+ extern void 
+ getframebits(layer *info, int stereo, int *bitsPerFrame, int *mean_bits);
  
  
  #endif
diff -r -c -N encoder/configure lame3.13/configure
*** encoder/configure	Wed Jan 22 02:43:13 1997
--- lame3.13/configure	Wed Dec 31 17:00:00 1969
***************
*** 1,742 ****
- #!/bin/sh
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: configure,v 1.1 1996/02/14 04:06:24 rowlands Exp $
- ##
- ## $Log: configure,v $
- ## Revision 1.1  1996/02/14 04:06:24  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ##
- ############################################################################
- 
- # Guess values for system-dependent variables and create Makefiles.
- # Generated automatically using autoconf version 2.3 
- # Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.
- #
- # This configure script is free software; the Free Software Foundation
- # gives unlimited permission to copy, distribute and modify it.
- 
- # Defaults:
- ac_help=
- ac_default_prefix=/usr/local
- # Any additions from configure.in:
- 
- # Initialize some variables set by options.
- # The variables have the same names as the options, with
- # dashes changed to underlines.
- build=NONE
- cache_file=./config.cache
- exec_prefix=NONE
- host=NONE
- no_create=
- nonopt=NONE
- no_recursion=
- prefix=NONE
- program_prefix=NONE
- program_suffix=NONE
- program_transform_name=s,x,x,
- silent=
- site=
- srcdir=
- target=NONE
- verbose=
- x_includes=NONE
- x_libraries=NONE
- 
- # Initialize some other variables.
- subdirs=
- 
- ac_prev=
- for ac_option
- do
- 
-   # If the previous option needs an argument, assign it.
-   if test -n "$ac_prev"; then
-     eval "$ac_prev=\$ac_option"
-     ac_prev=
-     continue
-   fi
- 
-   case "$ac_option" in
-   -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
-   *) ac_optarg= ;;
-   esac
- 
-   # Accept the important Cygnus configure options, so we can diagnose typos.
- 
-   case "$ac_option" in
- 
-   -build | --build | --buil | --bui | --bu | --b)
-     ac_prev=build ;;
-   -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)
-     build="$ac_optarg" ;;
- 
-   -cache-file | --cache-file | --cache-fil | --cache-fi \
-   | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-     ac_prev=cache_file ;;
-   -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-   | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-     cache_file="$ac_optarg" ;;
- 
-   -disable-* | --disable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     eval "enable_${ac_feature}=no" ;;
- 
-   -enable-* | --enable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "enable_${ac_feature}='$ac_optarg'" ;;
- 
-   -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-   | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-   | --exec | --exe | --ex)
-     ac_prev=exec_prefix ;;
-   -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-   | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-   | --exec=* | --exe=* | --ex=*)
-     exec_prefix="$ac_optarg" ;;
- 
-   -gas | --gas | --ga | --g)
-     # Obsolete; use --with-gas.
-     with_gas=yes ;;
- 
-   -help | --help | --hel | --he)
-     # Omit some internal or obsolete options to make the list less imposing.
-     # This message is too long to be a string in the A/UX 3.1 sh.
-     cat << EOF
- Usage: configure [options] [host]
- Options: [defaults in brackets after descriptions]
- Configuration:
-   --cache-file=FILE       cache test results in FILE
-   --help                  print this message
-   --no-create             do not create output files
-   --quiet, --silent       do not print \`checking...' messages
-   --version               print the version of autoconf that created configure
- Directory and file names:
-   --prefix=PREFIX         install architecture-independent files in PREFIX
-                           [$ac_default_prefix]
-   --exec-prefix=PREFIX    install architecture-dependent files in PREFIX
-                           [same as prefix]
-   --srcdir=DIR            find the sources in DIR [configure dir or ..]
-   --program-prefix=PREFIX prepend PREFIX to installed program names
-   --program-suffix=SUFFIX append SUFFIX to installed program names
-   --program-transform-name=PROGRAM run sed PROGRAM on installed program names
- Host type:
-   --build=BUILD           configure for building on BUILD [BUILD=HOST]
-   --host=HOST             configure for HOST [guessed]
-   --target=TARGET         configure for TARGET [TARGET=HOST]
- Features and packages:
-   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-   --x-includes=DIR        X include files are in DIR
-   --x-libraries=DIR       X library files are in DIR
- --enable and --with options recognized:$ac_help
- EOF
-     exit 0 ;;
- 
-   -host | --host | --hos | --ho)
-     ac_prev=host ;;
-   -host=* | --host=* | --hos=* | --ho=*)
-     host="$ac_optarg" ;;
- 
-   -nfp | --nfp | --nf)
-     # Obsolete; use --without-fp.
-     with_fp=no ;;
- 
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c)
-     no_create=yes ;;
- 
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-     no_recursion=yes ;;
- 
-   -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-     ac_prev=prefix ;;
-   -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-     prefix="$ac_optarg" ;;
- 
-   -program-prefix | --program-prefix | --program-prefi | --program-pref \
-   | --program-pre | --program-pr | --program-p)
-     ac_prev=program_prefix ;;
-   -program-prefix=* | --program-prefix=* | --program-prefi=* \
-   | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-     program_prefix="$ac_optarg" ;;
- 
-   -program-suffix | --program-suffix | --program-suffi | --program-suff \
-   | --program-suf | --program-su | --program-s)
-     ac_prev=program_suffix ;;
-   -program-suffix=* | --program-suffix=* | --program-suffi=* \
-   | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-     program_suffix="$ac_optarg" ;;
- 
-   -program-transform-name | --program-transform-name \
-   | --program-transform-nam | --program-transform-na \
-   | --program-transform-n | --program-transform- \
-   | --program-transform | --program-transfor \
-   | --program-transfo | --program-transf \
-   | --program-trans | --program-tran \
-   | --progr-tra | --program-tr | --program-t)
-     ac_prev=program_transform_name ;;
-   -program-transform-name=* | --program-transform-name=* \
-   | --program-transform-nam=* | --program-transform-na=* \
-   | --program-transform-n=* | --program-transform-=* \
-   | --program-transform=* | --program-transfor=* \
-   | --program-transfo=* | --program-transf=* \
-   | --program-trans=* | --program-tran=* \
-   | --progr-tra=* | --program-tr=* | --program-t=*)
-     program_transform_name="$ac_optarg" ;;
- 
-   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-   | -silent | --silent | --silen | --sile | --sil)
-     silent=yes ;;
- 
-   -site | --site | --sit)
-     ac_prev=site ;;
-   -site=* | --site=* | --sit=*)
-     site="$ac_optarg" ;;
- 
-   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-     ac_prev=srcdir ;;
-   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-     srcdir="$ac_optarg" ;;
- 
-   -target | --target | --targe | --targ | --tar | --ta | --t)
-     ac_prev=target ;;
-   -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-     target="$ac_optarg" ;;
- 
-   -v | -verbose | --verbose | --verbos | --verbo | --verb)
-     verbose=yes ;;
- 
-   -version | --version | --versio | --versi | --vers)
-     echo "configure generated by autoconf version 2.3"
-     exit 0 ;;
- 
-   -with-* | --with-*)
-     ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "with_${ac_package}='$ac_optarg'" ;;
- 
-   -without-* | --without-*)
-     ac_package=`echo $ac_option|sed -e 's/-*without-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     eval "with_${ac_package}=no" ;;
- 
-   --x)
-     # Obsolete; use --with-x.
-     with_x=yes ;;
- 
-   -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-   | --x-incl | --x-inc | --x-in | --x-i)
-     ac_prev=x_includes ;;
-   -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-   | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-     x_includes="$ac_optarg" ;;
- 
-   -x-libraries | --x-libraries | --x-librarie | --x-librari \
-   | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-     ac_prev=x_libraries ;;
-   -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-     x_libraries="$ac_optarg" ;;
- 
-   -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
-     ;;
- 
-   *) 
-     if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
-       echo "configure: warning: $ac_option: invalid host type" 1>&2
-     fi
-     if test "x$nonopt" != xNONE; then
-       { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
-     fi
-     nonopt="$ac_option"
-     ;;
- 
-   esac
- done
- 
- if test -n "$ac_prev"; then
-   { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
- fi
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- # File descriptor usage:
- # 0 standard input
- # 1 file creation
- # 2 errors and warnings
- # 3 some systems may open it to /dev/tty
- # 4 used on the Kubota Titan
- # 6 checking for... messages and results
- # 5 compiler messages saved in config.log
- if test "$silent" = yes; then
-   exec 6>/dev/null
- else
-   exec 6>&1
- fi
- exec 5>./config.log
- 
- echo "\
- This file contains any messages produced by compilers while
- running configure, to aid debugging if configure makes a mistake.
- " 1>&5
- 
- # Strip out --no-create and --no-recursion so they do not pile up.
- # Also quote any args containing shell metacharacters.
- ac_configure_args=
- for ac_arg
- do
-   case "$ac_arg" in
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c) ;;
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
-   ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-   *) ac_configure_args="$ac_configure_args $ac_arg" ;;
-   esac
- done
- 
- # NLS nuisances.
- # Only set LANG and LC_ALL to C if already set.
- # These must not be set unconditionally because not all systems understand
- # e.g. LANG=C (notably SCO).
- if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
- if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
- 
- # confdefs.h avoids OS command line length limits that DEFS can exceed.
- rm -rf conftest* confdefs.h
- # AIX cpp loses on an empty file, so make sure it contains at least a newline.
- echo > confdefs.h
- 
- # A filename unique to this package, relative to the directory that
- # configure is in, which we can look for to find out if srcdir is correct.
- ac_unique_file=musicin.c
- 
- # Find the source files, if location was not specified.
- if test -z "$srcdir"; then
-   ac_srcdir_defaulted=yes
-   # Try the directory containing this script, then its parent.
-   ac_prog=$0
-   ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
-   test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
-   srcdir=$ac_confdir
-   if test ! -r $srcdir/$ac_unique_file; then
-     srcdir=..
-   fi
- else
-   ac_srcdir_defaulted=no
- fi
- if test ! -r $srcdir/$ac_unique_file; then
-   if test "$ac_srcdir_defaulted" = yes; then
-     { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
-   else
-     { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
-   fi
- fi
- srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
- 
- # Prefer explicitly selected file to automatically selected ones.
- if test -z "$CONFIG_SITE"; then
-   if test "x$prefix" != xNONE; then
-     CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-   else
-     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-   fi
- fi
- for ac_site_file in $CONFIG_SITE; do
-   if test -r "$ac_site_file"; then
-     echo "loading site script $ac_site_file"
-     . "$ac_site_file"
-   fi
- done
- 
- if test -r "$cache_file"; then
-   echo "loading cache $cache_file"
-   . $cache_file
- else
-   echo "creating cache $cache_file"
-   > $cache_file
- fi
- 
- ac_ext=c
- # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
- ac_cpp='$CPP $CPPFLAGS'
- ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5 2>&5'
- ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5 2>&5'
- 
- if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
-   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
-   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
-     ac_n= ac_c='
- ' ac_t='	'
-   else
-     ac_n=-n ac_c= ac_t=
-   fi
- else
-   ac_n= ac_c='\c' ac_t=
- fi
- 
- 
- 
- # Extract the first word of "gcc", so it can be a program name with args.
- set dummy gcc; ac_word=$2
- echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test -n "$CC"; then
-   ac_cv_prog_CC="$CC" # Let the user override the test.
- else
-   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
-   for ac_dir in $PATH; do
-     test -z "$ac_dir" && ac_dir=.
-     if test -f $ac_dir/$ac_word; then
-       ac_cv_prog_CC="gcc"
-       break
-     fi
-   done
-   IFS="$ac_save_ifs"
-   test -z "$ac_cv_prog_CC" && ac_cv_prog_CC="cc"
- fi
- fi
- CC="$ac_cv_prog_CC"
- if test -n "$CC"; then
-   echo "$ac_t""$CC" 1>&6
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.c <<EOF
- #ifdef __GNUC__
-   yes;
- #endif
- EOF
- if ${CC-cc} -E conftest.c 2>&5 | egrep yes >/dev/null 2>&1; then
-   ac_cv_prog_gcc=yes
- else
-   ac_cv_prog_gcc=no
- fi
- fi
- echo "$ac_t""$ac_cv_prog_gcc" 1>&6
- if test $ac_cv_prog_gcc = yes; then
-   GCC=yes
-   if test "${CFLAGS+set}" != set; then
-     echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc_g'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   echo 'void f(){}' > conftest.c
- if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-   ac_cv_prog_gcc_g=yes
- else
-   ac_cv_prog_gcc_g=no
- fi
- rm -f conftest*
- 
- fi
-     echo "$ac_t""$ac_cv_prog_gcc_g" 1>&6
-     if test $ac_cv_prog_gcc_g = yes; then
-       CFLAGS="-g -O"
-     else
-       CFLAGS="-O"
-     fi
-   fi
- else
-   GCC=
-   test "${CFLAGS+set}" = set || CFLAGS="-g"
- fi
- 
- 
- MATHLIBS="-lm"
- echo $ac_n "checking for -lieee""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_ieee'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lieee  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 485 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- main()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'ieee`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   MATHLIBS="$MATHLIBS -lieee"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- NINTSW=""
- echo $ac_n "checking for nint() in -lm""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_m'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lm  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 521 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- nint()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_m=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_m=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'m`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   NINTSW="-DHAVE_NINT"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- 
- trap '' 1 2 15
- cat > confcache <<\EOF
- # This file is a shell script that caches the results of configure
- # tests run on this system so they can be shared between configure
- # scripts and configure runs.  It is not useful on other systems.
- # If it contains results you don't want to keep, you may remove or edit it.
- #
- # By default, configure uses ./config.cache as the cache file,
- # creating it if it does not exist already.  You can give configure
- # the --cache-file=FILE option to use a different cache file; that is
- # what configure does when it calls configure scripts in
- # subdirectories, so they share the cache.
- # Giving --cache-file=/dev/null disables caching, for debugging configure.
- # config.status only pays attention to the cache file if you give it the
- # --recheck option to rerun configure.
- #
- EOF
- # Ultrix sh set writes to stderr and can't be redirected directly,
- # and sets the high bit in the cache file unless we assign to the vars.
- (set) 2>&1 |
-   sed -n "s/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=\${\1='\2'}/p" \
-   >> confcache
- if cmp -s $cache_file confcache; then
-   :
- else
-   if test -w $cache_file; then
-     echo "updating cache $cache_file"
-     cat confcache > $cache_file
-   else
-     echo "not updating unwritable cache $cache_file"
-   fi
- fi
- rm -f confcache
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- test "x$prefix" = xNONE && prefix=$ac_default_prefix
- # Let make expand exec_prefix.
- test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
- 
- # Any assignment to VPATH causes Sun make to only execute
- # the first set of double-colon rules, so remove it if not needed.
- # If there is a colon in the path, we need to keep it.
- if test "x$srcdir" = x.; then
-   ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
- fi
- 
- trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
- 
- # Transform confdefs.h into DEFS.
- # Protect against shell expansion while executing Makefile rules.
- # Protect against Makefile macro expansion.
- cat > conftest.defs <<\EOF
- s%#define \([A-Za-z_][A-Za-z0-9_]*\) \(.*\)%-D\1=\2%g
- s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
- s%\[%\\&%g
- s%\]%\\&%g
- s%\$%$$%g
- EOF
- DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
- rm -f conftest.defs
- 
- 
- # Without the "./", some shells look in PATH for config.status.
- : ${CONFIG_STATUS=./config.status}
- 
- echo creating $CONFIG_STATUS
- rm -f $CONFIG_STATUS
- cat > $CONFIG_STATUS <<EOF
- #! /bin/sh
- # Generated automatically by configure.
- # Run this file to recreate the current configuration.
- # This directory was configured as follows,
- # on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
- #
- # $0 $ac_configure_args
- #
- # Compiler output produced by configure, useful for debugging
- # configure, is in ./config.log if it exists.
- 
- ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
- for ac_option
- do
-   case "\$ac_option" in
-   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
-     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
-   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-     echo "$CONFIG_STATUS generated by autoconf version 2.3"
-     exit 0 ;;
-   -help | --help | --hel | --he | --h)
-     echo "\$ac_cs_usage"; exit 0 ;;
-   *) echo "\$ac_cs_usage"; exit 1 ;;
-   esac
- done
- 
- ac_given_srcdir=$srcdir
- 
- trap 'rm -fr `echo "Makefile" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
- 
- # Protect against being on the right side of a sed subst in config.status. 
- sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\\\&%]/\\\\&/g; 
-  s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
- $ac_vpsub
- $extrasub
- s%@CFLAGS@%$CFLAGS%g
- s%@CPPFLAGS@%$CPPFLAGS%g
- s%@CXXFLAGS@%$CXXFLAGS%g
- s%@DEFS@%$DEFS%g
- s%@LDFLAGS@%$LDFLAGS%g
- s%@LIBS@%$LIBS%g
- s%@exec_prefix@%$exec_prefix%g
- s%@prefix@%$prefix%g
- s%@program_transform_name@%$program_transform_name%g
- s%@CC@%$CC%g
- s%@MATHLIBS@%$MATHLIBS%g
- s%@NINTSW@%$NINTSW%g
- 
- CEOF
- EOF
- cat >> $CONFIG_STATUS <<EOF
- 
- CONFIG_FILES=\${CONFIG_FILES-"Makefile"}
- EOF
- cat >> $CONFIG_STATUS <<\EOF
- for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
-   # Support "outfile[:infile]", defaulting infile="outfile.in".
-   case "$ac_file" in
-   *:*) ac_file_in=`echo "$ac_file"|sed 's%.*:%%'`
-        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-   *) ac_file_in="${ac_file}.in" ;;
-   esac
- 
-   # Adjust relative srcdir, etc. for subdirectories.
- 
-   # Remove last slash and all that follows it.  Not all systems have dirname.
-   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-     # The file is in a subdirectory.
-     test ! -d "$ac_dir" && mkdir "$ac_dir"
-     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
-     # A "../" for each directory in $ac_dir_suffix.
-     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
-   else
-     ac_dir_suffix= ac_dots=
-   fi
- 
-   case "$ac_given_srcdir" in
-   .)  srcdir=.
-       if test -z "$ac_dots"; then top_srcdir=.
-       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
-   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
-   *) # Relative path.
-     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
-     top_srcdir="$ac_dots$ac_given_srcdir" ;;
-   esac
- 
-   echo creating "$ac_file"
-   rm -f "$ac_file"
-   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
-   case "$ac_file" in
-   *Makefile*) ac_comsub="1i\\
- # $configure_input" ;;
-   *) ac_comsub= ;;
-   esac
-   sed -e "$ac_comsub
- s%@configure_input@%$configure_input%g
- s%@srcdir@%$srcdir%g
- s%@top_srcdir@%$top_srcdir%g
- " -f conftest.subs $ac_given_srcdir/$ac_file_in > $ac_file
- fi; done
- rm -f conftest.subs
- 
- 
- 
- exit 0
- EOF
- chmod +x $CONFIG_STATUS
- rm -fr confdefs* $ac_clean_files
- test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
- 
--- 0 ----
diff -r -c -N encoder/doc/html/advanced.html lame3.13/doc/html/advanced.html
*** encoder/doc/html/advanced.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/advanced.html	Wed May 26 18:44:50 1999
***************
*** 0 ****
--- 1,54 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Advanced features</TITLE>
+ <META NAME="description" CONTENT="Advanced features">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="previous" HREF="node11.html">
+ <LINK REL="up" HREF="node10.html">
+ <LINK REL="next" HREF="node13.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H2><A NAME="SECTION00421000000000000000"> Overriding default settings</A> </H2>
+ <A NAME="override">&#160;</A>Many of the following features override the encoder's 
+ idea of best-quality settings. You should be aware that overriding the encoder 
+ default settings is something for experts. You might wreack the encoding quality 
+ in a number of ways without first noticing it. Also, the encoder is not guaranteed 
+ to run at all parameter combinations. <B>Proceed at your own risk!</B> 
+ <P> 
+ <DL> 
+   <DT><STRONG><TT>-k</TT><A NAME="fullbandwidth">&#160;</A></STRONG> 
+   <DD>Tells the encoder to use full bandwidth. By default, the encoder uses a 
+     16kHz bandwidth up to 64kbps per channel, and full bandwidth at higher bitrates. 
+     Increasing the bandwidth from the default setting might produces ringing artefacts 
+     at low bitrates. Use with care! 
+ </DL>
+ <DL> 
+   <DT><STRONG><TT>-O</TT><A NAME="isomodel">&#160;</A></STRONG> 
+   <DD>Uses the original ISO psycho-acoustic model instead of GPsycho. Used with 
+     <tt>-m s</tt>, it will produce the same output as the ISO code or the encoders 
+     based on it, like 8Hz, Blade or Lame 2.x<br>
+     It will reduce a lot the quality and should only be used for comparison tests. 
+   <dt>&nbsp;</dt>
+ </DL>
+ <H2><A NAME="SECTION00422000000000000000"> Tids &amp; bits</A> </H2>
+ <DL> 
+   <DT><STRONG><TT>-a</TT><A NAME="autoconvert">&#160;</A></STRONG> 
+   <DD>This switch tells the encoder to autoconvert a stereo input signal into 
+     one channel, producing mono output. The downmix is calculated as the sum of 
+     the left and right channel, attenuated by 6 dB. 
+   <DT><STRONG><TT>-f</TT><A NAME="extrafast">&#160;</A></STRONG> 
+   <DD>This switch forces the encoder to use the &quot;extra fast&quot; encoding 
+     mode. It will reduce a lot the quality of the output. This might be useful 
+     for real-time processing or streaming on slowest computers. 
+ </DL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/basics.html lame3.13/doc/html/basics.html
*** encoder/doc/html/basics.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/basics.html	Wed May 26 18:16:32 1999
***************
*** 0 ****
--- 1,134 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Basics</TITLE>
+ <META NAME="description" CONTENT="Basics">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node12.html">
+ <LINK REL="previous" HREF="node10.html">
+ <LINK REL="up" HREF="node10.html">
+ <LINK REL="next" HREF="node12.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1> Basics</H1>
+ <H2><A NAME="samplerate"> Samplerate</A> </H2>
+ Sample rate is the rate at which the samples are read from your sound card when 
+ you sample. Sample rate is directly linked to audio bandwidth achievable: A sound 
+ file with a sample rate of 8&nbsp;kHz does not contain frequencies beyond 4&nbsp;kHz. 
+ This means that you should always use the highest sample rate that your sound 
+ card supports when you sample a signal. 
+ <H2><A NAME="bitrate"> Bitrate</A> </H2>
+ The main parameter controlling the sound quality is the <I>bitrate</I> that the 
+ encoder runs at. In a nutshell, the higher the bitrate, the better the quality. 
+ <P> The bitrate of the bitstream output is selected via the <TT>-b</TT> switch. 
+   The bitrate is specified in bits/second. The bitrate is the total bitrate for 
+   all encoded channels, i.e. if you select <TT>-b</TT><TT> 128000</TT> and encode 
+   in stereo, both channels will be stuffed into one bitstream of 128000 bits/second. 
+ <P> The encoder supports bitrates of 32, 40, 48, 56, 64, 96, 112, 128, 160, 192, 
+   224, 256 and 320&nbsp;kBit/s. 
+ <P> 
+ <H2><A NAME="stereomode"> Stereo mode</A> </H2>
+ <P> 
+ <DL> 
+   <DT>&nbsp; 
+   <DT><STRONG><A NAME="stereo">&#160;</A>stereo</STRONG> 
+   <DD>In this mode, the encoder makes no use of potentially existing correlations 
+     between the two input channels. It can, however, negotiate the bit demand 
+     between both channel, i.e. give one channel more bits if the other contains 
+     silence. 
+     <P> 
+   <DT><STRONG><A NAME="jointstereo">&#160;</A>joint stereo</STRONG> 
+   <DD>In this mode, the encoder will make use of a correlation between both channels. 
+     The signal will be matrixed into a sum (&quot;mid&quot;) and difference (&quot;side&quot;) 
+     signal. For quasi-mono signals, this will give a significant gain in encoding 
+     quality. 
+     <P> This mode does not destroy phase information like IS stereo that may be 
+       used by other encoders and thus can be used to encode <i>DOLBY</i> <i>ProLogic</i> 
+       surround signals.
+   <DD><br>
+   <dt><strong><a name="force">&#160;force </a>joint stereo</strong> 
+   <dd>This mode will force MS joint stereo on all frames. It's faster and it uses 
+     some special mid &amp; side masking threshold.
+   <dt>&nbsp;</dt>
+   <dt><font face="Helvetica"><strong><a name="mono">&nbsp;</a>mono</strong></font></dt>
+   <dd><font face="Helvetica">The input will be encoded as a mono signal. If it 
+     was a stereo signal, it will be downsampled to mono.</font><BR>
+   </dd>
+ </DL>
+ <H2><A NAME="speed"> Encoding speed</A> </H2>
+ Several factors influence the speed of the encoder. They include: 
+ <P> 
+ <UL>
+   <LI> Number of channels in the output signal. If your output signal has only 
+     one channel, the encoder will run at twice the speed compared to stereo encoding. 
+   <LI> Output sample rate. If the encoder produces a file at 22.050&nbsp;kHz (that 
+     is, a file that contains 22050 samples per second), it runs at twice the speed 
+     compared to one that produces twice the number of samples per second (i.e. 
+     produces a 44.1&nbsp;kHz output). 
+   <LI> Quality of the psychoaccoustic model. You can tell the encoder to use a 
+     dummy psychoaccoustic model, but the quality will be lower. 
+ </UL>
+ <P> Version V3.04 of the encoder reaches realtime speed on a Pentium 166 when 
+   encoding at 64&nbsp;kBit/s, 22,050&nbsp;kHz, stereo. On a SUN Sparc Ultra-1 
+   (143 MHz) the performance is similar. 
+ <P> 
+ <H2><A NAME="input"> Input file specification</A> </H2>
+ The encoder can read AIFF, AIFF-C, WAV/RIFF, and raw PCM data files. While the 
+ first three only work from a file, plain PCM data can be fed into the encoder 
+ via a pipe. This is useful for live encoding (also known as <I>streaming</I>). 
+ <P> 
+ <H3><A NAME="filein"> Input from file: filename</A> </H3>
+ <DL> 
+   <DT><STRONG><TT> filename</TT></STRONG> 
+   <DD>will tell the encoder the filename it reads it input from. If the file is 
+     a RIFF/WAVE, or an AIFF/AIFC file, the encoder will automatically adapt to 
+     the sound file format. For other formats or plain PCM data, see below. 
+ </DL>
+ <H3><A NAME="stdin"> Piping data into the encoder</A> </H3>
+ <DL> 
+   <DT><STRONG><TT>-</TT></STRONG> 
+   <DD>tells the encoder to get its input from stdin rather than from a file. This 
+     only works when the input is plain pcm data (see below). 
+ </DL>
+ <H3>plain PCM data input </H3>
+ If the encoder gets its input as plain pcm data (or if it does not recognize the 
+ sound format by itself), you need to tell it all about the structure of the PCM 
+ stream, i.e. the samplerate. 
+ <DL> 
+   <DT><STRONG><TT>-s</TT><A NAME="samplerate">&#160;</A><TT> samplerate</TT></STRONG> 
+   <DD>The sample rate in the input file. The default is 44.1&nbsp;kHz. 
+   <DT><STRONG><TT>-x</TT><A NAME="bitswap">&#160;</A></STRONG> 
+   <DD>The input file is endian inversed compared to your platform. 
+ </DL>
+ For stereo files, the encoder assumes that the PCM data is interleaved and that 
+ the sample for the right channel follows that for the left channel. 
+ <P> As an example,<TT> -s 22050</TT> would be used to read a 22.05&nbsp;kHz. 
+ <P> Remember that this feature is only needed for input from files other than 
+   RIFF/WAV, AIFF and AIFC. 
+ <P> 
+ <H2><A NAME="output"> Output file specification</A> </H2>
+ The output is a plain Layer-3 stream wich can be piped into other applications. 
+ This is useful for live streaming. 
+ <P> 
+ <DL> 
+   <DT><A NAME="fileout"><STRONG><TT> filename</TT></STRONG></A> 
+   <DD>tells the encoder the filename of the file that the encoder will write the 
+     bitstream to. If the file does not exist, it is created; if it does exist, 
+     it will be overwritten. 
+ </DL>
+ <H3>Streaming data out of the encoder </H3>
+ <DL> 
+   <DT><STRONG><TT>-</TT><A NAME="stdout">&#160;</A></STRONG> 
+   <DD>tells the encoder to write its output into stdout rather than in a file. 
+ </DL>
+ </font> 
+ <p>&nbsp;</p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/contributors.html lame3.13/doc/html/contributors.html
*** encoder/doc/html/contributors.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/contributors.html	Sat May 29 12:10:14 1999
***************
*** 0 ****
--- 1,81 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <!-- saved from url=(0051)http://internet.roadrunner.com/~mt/mp3/history.html -->
+ <HTML><HEAD><TITLE>Contributors</TITLE>
+ <META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
+ <META content="MSHTML 5.00.2014.210" name=GENERATOR><link rel="stylesheet" href="lame.css"></HEAD>
+ <BODY aLink=#bbbbbb bgColor=#ffffff link=#888888 text=#000000 vLink=#555555>
+ <CENTER>
+   <H1>Contributors</H1>
+ </CENTER>
+ <HR>
+ <H4>The following people contributed to the LAME development:</H4>
+ <p> Lauri Ahonen<br>
+   Alex Ballegooy<br>
+   Gabriel Bouvigne<br>
+   Mike Cheng<br>
+   Goran Dokic<br>
+   James Droppo<br>
+   Joakim Enerstam <br>
+   Albert Faber<br>
+   Joseph Fourier<br>
+   Jani Frilander<br>
+   Steffan Haeuser<br>
+   Rafael W Luebbert<br>
+   Lars Magne Ingebrigtsen<br>
+   Scott Manley<br>
+   Chris Matrakidis<br>
+   Mike Oliphant<br>
+   Andr&eacute; Osterhues<br>
+   Jan Peman<br>
+   Jan Rafaj<br>
+   Nathan Slingerland<br>
+   Stephane Tavenard<br>
+   Mark Taylor<br>
+   Brad Threatt<br>
+   Warren Toomey<br>
+   Martin Weghofer </p>
+ <p>&nbsp;</p>
+ <h4>Original ISO contributors:</h4>
+ <p>Bill Aspromonte<br>
+   Shaun Astarabadi<br>
+   R. Bittner<br>
+   Karlheinz Brandenburg<br>
+   W. Joseph Carter<br>
+   Jack Chang<br>
+   Mike Coleman<br>
+   Johnathan Devine<br>
+   Ernst Eberlein<br>
+   Dan Ellis<br>
+   Peter Farrett<br>
+   Jean-Georges Fritsch<br>
+   Vlad Fruchter<br>
+   Hendrik Fuchs<br>
+   Bernhard Grill<br>
+   Amit Gulati<br>
+   Munsi Haque<br>
+   Chuck Hsiao<br>
+   Toshiyuki Ishino<br>
+   Masahiro Iwadare<br>
+   Earl Jennings<br>
+   James Johnston<br>
+   Leon v.d. Kerkhof<br>
+   Don Lee<br>
+   Mike Li<br>
+   Yu-Tang Lin<br>
+   Soren Neilsen<br>
+   Simao F. Campos Neto<br>
+   Mark Paley<br>
+   Davis Pan<br>
+   Tan Ah Peng<br>
+   Kevin Peterson<br>
+   Juan Pineda<br>
+   Ernst F. Schroeder<br>
+   Peter Siebert<br>
+   Jens Spille<br>
+   Sam Stewart<br>
+   Al Tabayoyon<br>
+   Kathy Wang<br>
+   Franz-Otto Witte<br>
+   Douglas Wong</p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/history.html lame3.13/doc/html/history.html
*** encoder/doc/html/history.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/history.html	Wed May 26 12:33:16 1999
***************
*** 0 ****
--- 1,150 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <!-- saved from url=(0051)http://internet.roadrunner.com/~mt/mp3/history.html -->
+ <HTML><HEAD><TITLE>History</TITLE>
+ <META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
+ <META content="MSHTML 5.00.2014.210" name=GENERATOR><link rel="stylesheet" href="lame.css"></HEAD>
+ <BODY aLink=#bbbbbb bgColor=#ffffff link=#888888 text=#000000 vLink=#555555>
+ <CENTER>
+   <H1>History</H1>
+ </CENTER>
+ <H4> 
+   <HR>
+ </H4>
+ <H4>3.05</H4>
+ <UL>
+   <LI>Fast mode (-f)&nbsp; disables psycho-acoustic model for real time encoding 
+     on older machines. 
+   <LI>New bit reservoir usage scheme to accommodate the new pre-echo detection 
+     formulas. 
+   <LI>Tuning of AWS and ENER_AWS pre-echo formulas by Gabriel Bouvigne and Mark 
+     Taylor.&nbsp;They work great!&nbsp;Now on by default. 
+   <LI>In jstereo, force blocktypes for left &amp; right channels to be identical.&nbsp; 
+     FhG does this, so we will too.</LI>
+   <LI>Patches to compile MP3x under win32 (Thanks to Albert Faber).</LI>
+   <LI>bin_serach_stepsize limited to -210 through 45.</LI>
+   <LI>Mid/side quantization now varies scalefactors independently. Can lead to 
+     better quantizations, but it is slower (twice as many quantizations to look 
+     at). Running with "-m f" does not need this and will at the old speed </LI>
+ </UL>
+ <H4>3.04</H4>
+ <UL>
+   <LI>Preliminary documentation from Gabriel Bouvigne. 
+   <LI>Even more speed improvements from Chris Matrakidis!&nbsp; Removed one FFT 
+     when using joint stereo, and many improvements in loop.c. 
+   <LI>"Fake" ms_stereo mode renamed "Force" ms_stereo since it forces mid/side 
+     stereo on all frames.&nbsp; For some music this is said to be a problem, but 
+     for most music mode is probably better than the default jstereo because it 
+     uses specialized mid/side channel masking thresholds. 
+   <LI>Small bugs in Force ms_stereo mode fixed. 
+   <LI>Compaq Alpha fixes from Nathan Slingerland. 
+   <LI>Some new experimental pre-echo detection formulas in l3psy.c (#ifdef AWS 
+     and #ifdef ENER_AWS, both off by default.&nbsp; Thanks to Gabriel Bouvigne 
+     and Andre Osterhues) 
+   <LI>Several bugs in the syncing of data displayed by mp3x (the frame analyzer) 
+     were fixed. 
+   <LI>Highq (-h) option added.&nbsp; This turns on things (just one so far) that 
+     should sound better but slow down LAME. </LI>
+ </UL>
+ <B>3.03</B> 
+ <UL>
+   <LI>Faster (20%) &amp; cleaner FFT (Thanks to Chris Matrakidis&nbsp; http://www.geocities.com/ResearchTriangle/8869/fft_summary.html) 
+   <LI>Mods so it works with VC++ (Thanks to Gabriel Bouvigne, www.mp3tech.org) 
+   <LI>MP3s marked "original" by default&nbsp; (Thanks to Gabriel Bouvigne, www.mp3tech.org) 
+   <LI>Can now be compiled into a BladeEnc compatible .DLL&nbsp;&nbsp; (Thanks 
+     to&nbsp; Albert Faber, CDex author) 
+   <LI>Patches for "silent mode" and stdin/stdout&nbsp; (Thanks to Lars Magne Ingebrigtsen) 
+   <LI>Fixed rare bug: if a long_block is sandwiched between two short_blocks, 
+     it must be changed to a short_block, but the short_block ratios have not been 
+     computed in l3psy.c.&nbsp; Now always compute short_block ratios just in case. 
+   <LI>Fixed bug with initial quantize step size when many coefficients are zero.&nbsp; 
+     (Thanks to Martin Weghofer). 
+   <LI>Bug fixed in MP3x display of audible distortion. 
+   <LI>Iimproved status display (Thanks to Lauri Ahonen). </LI>
+ </UL>
+ <H4>3.02</H4>
+ <UL>
+   <LI>Encoder could use ms_stereo even if channel 0 and 1 block types were different.&nbsp; 
+     (Thanks to Jan Rafaj) 
+   <LI>Added -k option to disable the 16kHz cutoff at 128kbs.&nbsp; This cutoff 
+     is never used at higher bitrates. (Thanks to Jan Rafaj) 
+   <LI>Modified pe bit allocation formula to make sense at bit rates other than 
+     128kbs. 
+   <LI>Fixed l3_xmin initialization problem which showed up under FreeBSD.&nbsp; 
+     (Thanks to Warren Toomey) </LI>
+ </UL>
+ <B>3.01</B> 
+ <UL>
+   <LI>max_name_size increased to 300&nbsp; (Thanks to Mike Oliphant) 
+   <LI>Patch to allow seeks on input file (Thanks to Scott Manley) 
+   <LI>Fixes for mono modes (Thanks to everyone who pointed this out) 
+   <LI>Overflow in calc_noise2 fixed 
+   <LI>Bit reservoir overflow when encoding lots of frames with all zeros&nbsp; 
+     (Thanks to Jani Frilander) </LI>
+ </UL>
+ <P><BR>
+   <B>3.0</B> 
+ <UL>
+   <LI>Added GPSYCHO (developed by Mark Taylor) 
+   <LI>Added MP3x (developed by Mark Taylor) </LI>
+ </UL>
+ <B>2.1f</B> 
+ <UL>
+   <LI>50% faster filter_subband() routine in encode.c contributed by James Droppo 
+ </UL>
+ <B>2.1e</B> 
+ <UL>
+   <LI>New command line switch <B>-a</B> auto-resamples a stereo input file to 
+     mono. 
+   <LI>New command line switch <B>-r</B> resamples from 44.1khz to 32khz [this 
+     switch doesn't work really well. Very tinny sounding output files. Has to 
+     do with the way I do the resampling probably] 
+   <LI>Both of these were put into the ISO code in the encode.c file, and are simply 
+     different ways of filling the input buffers from a file. </LI>
+ </UL>
+ <B>2.1d</B> 
+ <UL>
+   <LI>Fixed memory alloc in musicin.c (for l3_sb_sample) 
+   <LI>Added new command line switch (-x) to force swapping of byte order 
+   <LI>Cleaned up memory routines in l3psy.c. All the mem_alloc() and free() routines 
+     where changed so that it was only done <I>once</I> and not every single time 
+     the routine was called. 
+   <LI>Added a compile time switch -DTIMER that includes all timing info. It's 
+     a switch for the time being until some other people have tested on their system. 
+     Timing code has a tendency to do different things on different platforms. 
+   </LI>
+ </UL>
+ <B>2.1b</B> 
+ <UL>
+   <LI>Fixed up bug: all PCM files were being read as WAV. 
+   <LI>Played with the mem_alloc routine to fix crash under amigaos (just allocating 
+     twice as much memory as needed). Might see if we can totally do without this 
+     routine. Individual malloc()s where they are needed instead 
+   <LI>Put Jan Peman's quality switch back in. This reduces quality via the '-q&nbsp;<INT>' 
+     switch. Fun speedup which is mostly harmless if you're not concerned with 
+     quality. 
+   <LI>Compiling with amiga-gcc works fine </LI>
+ </UL>
+ <B>2.1a</B> 
+ <UL>
+   <LI>Version 2.1a released. User input/output has been cleaned up a bit. WAV 
+     file reading is there in a very rudimentary sense ie the program will recognize 
+     the header and skip it, but not read it. The WAV file is assumed to be 16bit 
+     stereo 44.1khz. </LI>
+ </UL>
+ <B>2.1</B> 
+ <UL>
+   <LI>All tables now incorporated into the exe. Thanks to <B>Lars Magne Ingebrigtseni</B>(larsi@ifi.uio.no) 
+   </LI>
+ </UL>
+ <b>2.0</b> 
+ <ul>
+   <li>LAME is built from the ISO source code (dist10), and incorporates modifications 
+     from Mike Cheng and the 8Hz effort. The output file from LAME v2.0 is <I>identical</I> 
+     to the output of the ISO encoder.</li>
+ </ul>
+ <b>1.0</b> 
+ <ul>
+   <li>LAME v1.0 is based on work from the 8Hz effort.</li>
+ </ul>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/index.html lame3.13/doc/html/index.html
*** encoder/doc/html/index.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/index.html	Wed May 26 18:54:44 1999
***************
*** 0 ****
--- 1,81 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>L.A.M.E. V3 Next Generation High-End MPEG Layer III Encoding</TITLE>
+ <META NAME="description" CONTENT="MP3EncV3.1 Next Generation High-End MPEG Layer-3 Encoding">
+ <META NAME="keywords" CONTENT="mp3enc">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node1.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <P> 
+ <H1 ALIGN="CENTER"><FONT SIZE="+4"><i>LAME</i> V3.05 <BR>
+   </FONT> 
+   <P><FONT SIZE="+4"> <BR>
+     </font> <BIG>Next Generation High-End MPEG&nbsp;Layer&nbsp;III Encoding <BR>
+     </BIG> 
+ </H1>
+ <P ALIGN="CENTER"><STRONG>Open Source Project <BR>
+   <A HREF="http://www.sulaco.org/mp3">http://www.sulaco.org/mp3</A> </STRONG></P>
+ <P ALIGN="LEFT"></P>
+ <P> 
+ <DIV ALIGN="LEFT"> 
+   <P> 
+ </DIV>
+ <BR>
+ <HR>
+ <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A HREF="node5.html#SECTION00300000000000000000"> For the impatient</A> 
+     <UL>
+       <LI><A HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+         <UL>
+           <LI><A HREF="node6.html#SECTION00311000000000000000"> The purpose of 
+             audio compression</A> 
+           <LI><A HREF="node6.html#SECTION00312000000000000000"> The two parts 
+             of audio compression</A> 
+           <LI><A HREF="node6.html#SECTION00313000000000000000"> Compression ratios, 
+             bitrate and quality</A> 
+         </UL>
+       <LI><A HREF="node7.html#SECTION00320000000000000000"> Some examples</A> 
+       <LI><A HREF="switchs.html"> Command line switch reference</A> 
+     </UL>
+   <LI> <i>LAME</i> Features 
+     <UL>
+       <LI><A HREF="basics.html"> Basics</A> 
+         <UL>
+           <LI><A HREF="basics.html#samplerate"> Samplerate</A> 
+           <LI><A HREF="basics.html#bitrate"> Bitrate</A> 
+           <LI><A HREF="basics.html#stereomode"> Stereo mode</A> 
+           <LI><A HREF="basics.html#speed"> Encoding speed</A> 
+           <LI><A HREF="basics.html#input"> Input file specification</A> 
+             <UL>
+               <LI><A HREF="basics.html#filein"> Input from file: filename</A> 
+               <LI><A HREF="basics.html#stdin"> Piping data into the encoder</A> 
+               <LI><A HREF="basics.html#chap-pcm"> plain PCM data input</A> 
+             </UL>
+           <LI><A HREF="basics.html#output"> Output file specification</A> 
+             <UL>
+               <LI><A HREF="basics.html#stdout"> Streaming data out of the encoder</A> 
+             </UL>
+         </UL>
+       <LI><A HREF="advanced.html"> Advanced features</A> 
+         <UL>
+           <LI><A HREF="advanced.html#SECTION00421000000000000000"> Overriding 
+             default settings</A> 
+           <LI><A HREF="advanced.html#SECTION00422000000000000000"> Tids &amp; 
+             bits</A> 
+         </UL>
+     </UL>
+   <LI><a href="history.html">History</a> 
+   <LI><a href="contributors.html">Contributors</a><BR>
+ </UL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/lame.css lame3.13/doc/html/lame.css
*** encoder/doc/html/lame.css	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/lame.css	Mon Mar 23 20:59:20 1998
***************
*** 0 ****
--- 1,24 ----
+ BODY {
+         font-family: Arial, Helvetica, sans-serif;
+         position: absolute;
+         padding-left: 1cm;
+         margin-left: 1cm;
+      }
+ 
+ h1, h2, h3 {
+         margin-left: -1cm; text-align: left
+         }
+ 
+ TABLE { text-align: left; font-family: Arial, Helvetica, sans-serif;}
+ TH {background-color: #C0C0C0}
+ TD {font-family: Arial, Helvetica, sans-serif;}
+ 
+ SMALL.TINY		{ font-size : xx-small }
+ SMALL.SCRIPTSIZE	{ font-size : xx-small }
+ SMALL.FOOTNOTESIZE	{ font-size : x-small  }
+ SMALL.SMALL		{ font-size : small    }
+ BIG.LARGE		{ font-size : large    }
+ BIG.XLARGE		{ font-size : x-large  }
+ BIG.XXLARGE		{ font-size : xx-large }
+ BIG.HUGE		{ font-size : xx-large }
+ BIG.XHUGE		{ font-size : xx-large }
diff -r -c -N encoder/doc/html/node10.html lame3.13/doc/html/node10.html
*** encoder/doc/html/node10.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node10.html	Fri May 21 14:40:14 1999
***************
*** 0 ****
--- 1,72 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>MP3Enc Features</TITLE>
+ <META NAME="description" CONTENT="MP3Enc Features">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node13.html">
+ <LINK REL="previous" HREF="node5.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node11.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html194"
+  HREF="node11.html">Basics</A> |<B> Up:</B> <A NAME="tex2html190"
+  HREF="index.html">LAME V3 Next Generation High-End</A> |<B> Previous:</B> <A NAME="tex2html184"
+  HREF="node9.html">Bugfixes and changes between</A> |<A HREF=node1.html><B> Table 
+   of Contents </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00400000000000000000"> <i>LAME</i> Features</A> </H1>
+ <BR>
+ <HR>
+ <!--Table of Child-Links--> <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A NAME="tex2html195"
+  HREF="node11.html#SECTION00410000000000000000"> Basics</A> 
+     <UL>
+       <LI><A NAME="tex2html196"
+  HREF="node11.html#SECTION00411000000000000000"> Samplerate</A> 
+       <LI><A NAME="tex2html197"
+  HREF="node11.html#SECTION00412000000000000000"> Bitrate</A> 
+       <LI><A NAME="tex2html198"
+  HREF="node11.html#SECTION00413000000000000000"> Stereo mode</A> 
+       <LI><A NAME="tex2html199"
+  HREF="node11.html#SECTION00414000000000000000"> Encoding speed</A> 
+       <LI><A NAME="tex2html200"
+  HREF="node11.html#SECTION00415000000000000000"> Input file specification</A> 
+         <UL>
+           <LI><A NAME="tex2html201"
+  HREF="node11.html#SECTION00415100000000000000"> Input from file: filename</A> 
+           <LI><A NAME="tex2html202"
+  HREF="node11.html#SECTION00415200000000000000"> Piping data into the encoder</A> 
+           <LI><A NAME="tex2html203"
+  HREF="node11.html#SECTION00415300000000000000"> plain PCM data input</A> 
+         </UL>
+       <LI><A NAME="tex2html204"
+  HREF="node11.html#SECTION00416000000000000000"> Output file specification</A> 
+         <UL>
+           <LI><A NAME="tex2html205"
+  HREF="node11.html#SECTION00416100000000000000"> Streaming data out of the encoder</A> 
+         </UL>
+     </UL>
+   <LI><A NAME="tex2html206"
+  HREF="node12.html#SECTION00420000000000000000"> Advanced features</A> 
+     <UL>
+       <LI><A NAME="tex2html207"
+  HREF="node12.html#SECTION00421000000000000000"> Overriding default settings</A> 
+       <LI><A NAME="tex2html208"
+  HREF="node12.html#SECTION00422000000000000000"> Tids &amp; bits</A> 
+     </UL>
+ </UL>
+ <!--End of Table of Child-Links--> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node11.html lame3.13/doc/html/node11.html
*** encoder/doc/html/node11.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node11.html	Fri May 21 14:31:46 1999
***************
*** 0 ****
--- 1,184 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Basics</TITLE>
+ <META NAME="description" CONTENT="Basics">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node12.html">
+ <LINK REL="previous" HREF="node10.html">
+ <LINK REL="up" HREF="node10.html">
+ <LINK REL="next" HREF="node12.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html220"
+  HREF="node12.html">Advanced features</A> |<B> Up:</B> <A NAME="tex2html216"
+  HREF="node10.html">LAME Features</A> |<B> Previous:</B> <A NAME="tex2html210"
+  HREF="node10.html">LAME Features</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> <!--Table of Child-Links--> <A NAME="CHILD_LINKS"><strong>Subsections</strong></A> 
+ <UL>
+   <LI><A NAME="tex2html221"
+  HREF="node11.html#SECTION00411000000000000000"> Samplerate</A> 
+   <LI><A NAME="tex2html222"
+  HREF="node11.html#SECTION00412000000000000000"> Bitrate</A> 
+   <LI><A NAME="tex2html223"
+  HREF="node11.html#SECTION00413000000000000000"> Stereo mode</A> 
+   <LI><A NAME="tex2html224"
+  HREF="node11.html#SECTION00414000000000000000"> Encoding speed</A> 
+   <LI><A NAME="tex2html225"
+  HREF="node11.html#SECTION00415000000000000000"> Input file specification</A> 
+     <UL>
+       <LI><A NAME="tex2html226"
+  HREF="node11.html#SECTION00415100000000000000"> Input from file: filename</A> 
+       <LI><A NAME="tex2html227"
+  HREF="node11.html#SECTION00415200000000000000"> Piping data into the encoder</A> 
+       <LI><A NAME="tex2html228"
+  HREF="node11.html#SECTION00415300000000000000"> plain PCM data input</A> 
+     </UL>
+   <LI><A NAME="tex2html229"
+  HREF="node11.html#SECTION00416000000000000000"> Output file specification</A> 
+     <UL>
+       <LI><A NAME="tex2html230"
+  HREF="node11.html#SECTION00416100000000000000"> Streaming data out of the encoder</A> 
+     </UL>
+ </UL>
+ <!--End of Table of Child-Links--> 
+ <HR>
+ <H1><A NAME="SECTION00410000000000000000"> Basics</A> </H1>
+ <H2><A NAME="SECTION00411000000000000000"> Samplerate</A> </H2>
+ Sample rate <A NAME="152">&#160;</A>is the rate at which the samples are read 
+ from your sound card when you sample. Sample rate is directly linked to audio 
+ <A NAME="153">&#160;</A>bandwidth achievable: A sound file with a sample rate 
+ of 8&nbsp;kHz does not contain frequencies beyond 4&nbsp;kHz. This means that 
+ you should always use the highest sample rate that your sound card supports when 
+ you sample a signal. 
+ <H2><A NAME="SECTION00412000000000000000"> Bitrate</A> </H2>
+ The main parameter controlling the sound quality is the <A NAME="404">&#160;</A><I>bitrate</I> 
+ that the encoder runs at. In a nutshell, the higher the bitrate, the better the 
+ quality. 
+ <P> The bitrate of the encoder is linked to the samplerate that the encoded file 
+   will have. 
+ <P><A NAME="switch-br">&#160;</A>The bitrate of the bitstream output is selected 
+   via the <TT>-b</TT><A NAME="409">&#160;</A> switch. The bitrate is specified 
+   in bits/second. The bitrate is the total bitrate for all encoded channels, i.e. 
+   if you select <TT>-br</TT><A NAME="411">&#160;</A><TT> 128000</TT> and encode 
+   in stereo, both channels will be stuffed into one bitstream of 128000 bits/second. 
+ <P> The encoder supports bitrates of 32, 40, 48, 56, 64, 96, 112, 128, 160, 192, 
+   224, 256 and 320&nbsp;kBit/s. 
+ <P>
+ <H2><A NAME="SECTION00413000000000000000"> Stereo mode</A> </H2>
+ If encoding stereo, the bitrate of the encoder is linked to a stereo mode. MPEG 
+ Layer-3 knows four modes for stereo encoding. 
+ <P>
+ <DL> 
+   <DT><STRONG><A NAME="165">&#160;</A>dual channel</STRONG> 
+   <DD>(also known as <A NAME="412">&#160;</A><I>dual mono</I>) In this mode, the 
+     encoder treats the two input channels as separate entities, assuming there 
+     is no similarity between the channels. This would be appropriate if you e.g. 
+     have a bilingual signal where one channel contains a german speaker and one 
+     contains an english speaker. <I>The current version of the encoder does not 
+     support dual channel mode.</I> 
+     <P>
+   <DT><STRONG><A NAME="168">&#160;</A>stereo</STRONG> 
+   <DD>In this mode, like in dual channel above, the encoder makes no use of potentially 
+     existing correlations between the two input channels. It can, however, negotiate 
+     the bit demand between both channel, i.e. give one channel more bits if the 
+     other contains silence. 
+     <P>
+   <DT><STRONG><A NAME="169">&#160;</A><A NAME="337">&#160;</A>MS stereo</STRONG> 
+   <DD>In this mode, the encoder will make use of a correlation between both channels. 
+     The signal will be matrixed into a sum (&#187;mid&#171;) and difference (&#187;side&#171;) 
+     signal. For quasi-mono signals, this will give a significant gain in encoding 
+     quality. 
+     <P> This mode does not destroy phase information like IS stereo (see below) 
+       and thus can be used to encode <i>DOLBY</i> <i>ProLogic<IMG WIDTH="23" HEIGHT="19" ALIGN="BOTTOM" BORDER="0"
+  SRC="img1.gif"
+  ALT="$^{\mbox{tm}}$"></i> <A NAME="173">&#160;</A>surround signals. 
+     <P>
+   <DT><STRONG><A NAME="174">&#160;</A>MS/IS stereo</STRONG> 
+   <DD>In this mode, high-frequency parts of the signal will be downmixed to mono 
+     and transmitted with a direction information (which is basically a pan). This 
+     mode (called &#187;intensity stereo&#171;<A NAME="intensity">&#160;</A> will 
+     loose phase information and should not be used for high-quality encoding. 
+ </DL>
+ <P> <BR>
+ <H2><A NAME="SECTION00414000000000000000"> Encoding speed</A> </H2>
+ <A NAME="encspeed">&#160;</A>Several factors influence the speed of the encoder. 
+ They include: 
+ <P> 
+ <UL>
+   <LI> Number of channels in the output signal. If your output signal has only 
+     one channel, the encoder will run at twice the speed compared to stereo encoding. 
+   <LI> Output sample rate. If the encoder produces a file at 22.050&nbsp;kHz (that 
+     is, a file that contains 22050 samples per second), it runs at twice the speed 
+     compared to one that produces twice the number of samples per second (i.e. 
+     produces a 44.1&nbsp;kHz output). 
+   <LI> Quality of the psychoaccoustic model. You can tell the encoder to use a 
+     dummy psychoaccoustic model, but the quality will be lower. 
+ </UL>
+ <P> Version V3.04 of the encoder reaches realtime speed on a Pentium 166 when 
+   encoding at 64&nbsp;kBit/s, 22,050&nbsp;kHz, stereo. On a SUN Sparc Ultra-1 
+   (143 MHz) the performance is similar. 
+ <P> 
+ <H2><A NAME="SECTION00415000000000000000"> Input file specification</A> </H2>
+ The encoder can read AIFF, AIFF-C, WAV/RIFF, and raw PCM data files. While the 
+ first three only work from a file, plain PCM data can be fed into the encoder 
+ via a pipe. This is useful for live encoding (also known as <A NAME="418">&#160;</A><I>streaming</I>). 
+ <P> 
+ <H3><A NAME="SECTION00415100000000000000"> Input from file: filename</A> </H3>
+ <DL> 
+   <DT><A NAME="switch-if"><STRONG><A NAME="421">&#160;</A><TT> filename</TT></STRONG></A> 
+   <DD>will tell the encoder the filename it reads it input from. If the file is 
+     a RIFF/WAVE, or an AIFF/AIFC file, the encoder will automatically adapt to 
+     the sound file format. For other formats or plain PCM data, see below. 
+ </DL>
+ <H3><A NAME="SECTION00415200000000000000"> Piping data into the encoder</A> </H3>
+ <DL> 
+   <DT><STRONG><TT>-</TT><A NAME="423">&#160;</A></STRONG> 
+   <DD>tells the encoder to get its input from stdin rather than from a file. This 
+     only works when the input is plain pcm data (see below). 
+ </DL>
+ <H3><A NAME="SECTION00415300000000000000"> plain PCM data input</A> </H3>
+ <A NAME="chap-pcm">&#160;</A>If the encoder gets its input as plain pcm data (or 
+ if it does not recognize the sound format by itself), you need to tell it all 
+ about the structure of the PCM stream, i.e. the samplerate. 
+ <DL> 
+   <DT><STRONG><TT>-s</TT><A NAME="425">&#160;</A><TT> samplerate</TT></STRONG> 
+   <DD>The sample rate in the input file. The default is 44.1&nbsp;kHz. 
+   <DT><STRONG><TT>-x</TT><A NAME="431">&#160;</A></STRONG> 
+   <DD>The input file is endian inversed compared to your platform. 
+ </DL>
+ For stereo files, the encoder assumes that the PCM data is interleaved and that 
+ the sample for the right channel follows that for the left channel. 
+ <P> As an example,<TT> -s 22050</TT> would be used to read a 22.05&nbsp;kHz. 
+ <P> Remember that this feature is only needed for input from files other than 
+   RIFF/WAV, AIFF and AIFC. 
+ <P> 
+ <H2><A NAME="SECTION00416000000000000000"> Output file specification</A> </H2>
+ The output is a plain Layer-3 stream wich can be piped into other applications. 
+ This is useful for live streaming. 
+ <P> 
+ <DL> 
+   <DT><A NAME="switch-of"><STRONG><A NAME="435">&#160;</A><TT> filename</TT></STRONG></A> 
+   <DD>tells the encoder the filename of the file that the encoder will write the 
+     bitstream to. If the file does not exist, it is created; if it does exist, 
+     it will be overwritten. 
+ </DL>
+ <H3><A NAME="SECTION00416100000000000000">Streaming data out of the encoder</A> 
+   <A NAME="231">&#160;</A> </H3>
+ <DL> 
+   <DT><STRONG><TT>-</TT><A NAME="439">&#160;</A></STRONG> 
+   <DD>tells the encoder to write its output into stdout rather than in a file. 
+ </DL>
+ </font> 
+ <p>&nbsp;</p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node12.html lame3.13/doc/html/node12.html
*** encoder/doc/html/node12.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node12.html	Fri May 21 14:31:58 1999
***************
*** 0 ****
--- 1,67 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Advanced features</TITLE>
+ <META NAME="description" CONTENT="Advanced features">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="previous" HREF="node11.html">
+ <LINK REL="up" HREF="node10.html">
+ <LINK REL="next" HREF="node13.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html240"
+  HREF="node13.html">Troubleshooting</A> |<B> Up:</B> <A NAME="tex2html236"
+  HREF="node10.html">LAME Features</A> |<B> Previous:</B> <A NAME="tex2html232"
+  HREF="node11.html">Basics</A> |<A HREF=node1.html><B> Table of Contents </B></A>| 
+   <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> <!--Table of Child-Links--> <A NAME="CHILD_LINKS"><strong>Subsections</strong></A> 
+ <UL>
+   <LI><A NAME="tex2html241"
+  HREF="node12.html#SECTION00421000000000000000"> Overriding default settings</A> 
+   <LI><A NAME="tex2html242"
+  HREF="node12.html#SECTION00422000000000000000"> Tids &amp; bits</A> 
+ </UL>
+ <!--End of Table of Child-Links--> 
+ <HR>
+ <H1><A NAME="SECTION00420000000000000000"> Advanced features</A> </H1>
+ <H2><A NAME="SECTION00421000000000000000"> Overriding default settings</A> </H2>
+ <A NAME="override">&#160;</A>Many of the following features override the encoder's 
+ idea of best-quality settings. You should be aware that overriding the encoder 
+ default settings is something for experts. You might wreck the encoding quality 
+ in a number of ways without first noticing it. Also, the encoder is not guaranteed 
+ to run at all parameter combinations. <B>Proceed at your own risk!</B> 
+ <P> 
+ <DL> 
+   <DT><A NAME="switch-bw"><STRONG><TT>-k</TT><A NAME="445">&#160;</A></STRONG></A> 
+   <DD>Tell the encoder to use full <A NAME="249">&#160;</A>bandwidth. By default, 
+     the encoder uses a 16kHz bandwidth up to 64kbps per channel, and full bandwidth 
+     at higher bitrates Increasing the bandwidth from the default setting might 
+     produces ringing artefacts at low bitrates. Use with care! 
+ </DL>
+ <H2><A NAME="SECTION00422000000000000000"> Tids &amp; bits</A> </H2>
+ <DL> 
+   <DT><A NAME="switch-crc"><STRONG><TT>-e</TT><A NAME="449">&#160;</A></STRONG></A> 
+   <DD>For transmission over serial lines with bit errors, parts of the bitstream 
+     can be protected by calculating a CRC checksum. If you are just producing 
+     for harddisk storage, there is no need to set this switch. This feature is 
+     not yet working. 
+   <DT><A NAME="switch-dm"><STRONG><TT>-a</TT><A NAME="451">&#160;</A></STRONG></A> 
+   <DD>This switch tells the encoder to autoconvert a stereo input signal into 
+     one channel, producing mono output. The downmix is calculated as the sum of 
+     the left and right channel, attenuated by 6 dB. 
+   <DT><A NAME="switch-hq"><STRONG><TT>-f</TT><A NAME="453">&#160;</A></STRONG></A> 
+   <DD><A NAME="switch-qual">&#160;</A> This switch forces the encoder to use the 
+     &quot;extra fast&quot; encoding mode<TT></TT>. It will reduce the quality 
+     of the output. This might be useful for real-time processing on slowest computers. 
+ </DL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node13.html lame3.13/doc/html/node13.html
*** encoder/doc/html/node13.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node13.html	Fri May 21 14:41:16 1999
***************
*** 0 ****
--- 1,45 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Troubleshooting</TITLE>
+ <META NAME="description" CONTENT="Troubleshooting">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node17.html">
+ <LINK REL="previous" HREF="node10.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node14.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html254"
+  HREF="node14.html">Is it really a</A> |<B> Up:</B> <A NAME="tex2html250"
+  HREF="index.html">LAME V3 Next Generation High-End</A> |<B> Previous:</B> <A NAME="tex2html244"
+  HREF="node12.html">Advanced features</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00500000000000000000"> Troubleshooting</A> </H1>
+ <P><A NAME="support">&#160;</A>No software is free of errors. If you believe you 
+   have found an error in the operation of <i>LAME</i>, and you have checked the 
+   list below, please report the error to our bugtracking address. 
+ <P> <BR>
+ <HR>
+ <!--Table of Child-Links--> <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A NAME="tex2html255"
+  HREF="node14.html#SECTION00510000000000000000"> Is it really a bug?</A> 
+   <LI><A NAME="tex2html256"
+  HREF="node15.html#SECTION00520000000000000000"> Reporting the bug</A> 
+   <LI><A NAME="tex2html257"
+  HREF="node16.html#SECTION00530000000000000000"> Sample bug report</A> 
+ </UL>
+ <!--End of Table of Child-Links--> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node14.html lame3.13/doc/html/node14.html
*** encoder/doc/html/node14.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node14.html	Fri May 21 14:32:18 1999
***************
*** 0 ****
--- 1,87 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Is it really a bug?</TITLE>
+ <META NAME="description" CONTENT="Is it really a bug?">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node15.html">
+ <LINK REL="previous" HREF="node13.html">
+ <LINK REL="up" HREF="node13.html">
+ <LINK REL="next" HREF="node15.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html269"
+  HREF="node15.html">Reporting the bug</A> |<B> Up:</B> <A NAME="tex2html265"
+  HREF="node13.html">Troubleshooting</A> |<B> Previous:</B> <A NAME="tex2html259"
+  HREF="node13.html">Troubleshooting</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00510000000000000000"> Is it really a bug?</A> </H1>
+ <P> Before you report a bug to our programers, please verify that the bug is really 
+   in the software and not in your configuration. Table <A HREF="node14.html#table-bugs">3.1</A> 
+   helps you track down the bug yourself and see if it can be fixed. 
+ <P> <BR>
+ <DIV ALIGN="CENTER"><A NAME="table-bugs">&#160;</A> <A NAME="302">&#160;</A> 
+   <TABLE CELLPADDING=3 BORDER="1">
+     <CAPTION><STRONG>Table 3.1:</STRONG> Bug symptoms and possible causes</CAPTION>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT">Symptom</TD>
+       <TD ALIGN="LEFT">Check this:</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT">When I open the encoder application from the desktop, a 
+         window opens, error messages flash by, and the window closes before I 
+         can read anything.</TD>
+       <TD ALIGN="LEFT">lame is a commandline application. You need to start it 
+         from a shell.</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT"><TT>could not open input file</TT></TD>
+       <TD ALIGN="LEFT"> 
+         <DIV ALIGN="LEFT"> Have you given an input file to the encoder (see section 
+           <A HREF="#switch-if">2.1.5</A>)? Does the input file exist? Is it readable? 
+         </DIV>
+       </TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT"><TT>could not open output file</TT></TD>
+       <TD ALIGN="LEFT"> 
+         <DIV ALIGN="LEFT"> Have you given an output file to the encoder (see section 
+           <A HREF="#switch-of">2.1.6</A>)? Does the output directory exist and 
+           is it writeable? Does a file of the same name exist and is it deleteable?</DIV>
+       </TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT"><TT>No parameters for this bitrate/samplerate</TT></TD>
+       <TD ALIGN="LEFT">Did you override any of the encoders parameters (stereo 
+         mode, samplerate)? If so, try another samplerate.</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT"><TT><TT>bitrate too low/high</TT></TT></TD>
+       <TD ALIGN="LEFT">LAME only allows bitrates ranging from 32&nbsp;kBit/s to 
+         320&nbsp;kBit/s.</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT">The Layer-3 file sounds muffled</TD>
+       <TD ALIGN="LEFT">Try using a higher bitrate. Try using a higher bandwidth 
+         (see section <A HREF="#switch-bw">2.2.1</A>). Try changing the stereo 
+         mode.</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="LEFT">The stereo image is destroyed.</TD>
+       <TD ALIGN="LEFT">Try using the <TT>-m s</TT><A NAME="464">&#160;</A> switch</TD>
+     </TR>
+   </TABLE>
+ </DIV>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node15.html lame3.13/doc/html/node15.html
*** encoder/doc/html/node15.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node15.html	Fri May 21 14:32:28 1999
***************
*** 0 ****
--- 1,46 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Reporting the bug</TITLE>
+ <META NAME="description" CONTENT="Reporting the bug">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node16.html">
+ <LINK REL="previous" HREF="node14.html">
+ <LINK REL="up" HREF="node13.html">
+ <LINK REL="next" HREF="node16.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html281"
+  HREF="node16.html">Sample bug report</A> |<B> Up:</B> <A NAME="tex2html277"
+  HREF="node13.html">Troubleshooting</A> |<B> Previous:</B> <A NAME="tex2html271"
+  HREF="node14.html">Is it really a</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00520000000000000000"> Reporting the bug</A> </H1>
+ To assist our programmers in the processing of your bug report, we ask you to 
+ include in your mail 
+ <UL>
+   <LI> The version of the encoder you are using. 
+   <LI> The operating system (name and version) you are running the software with. 
+     If you are using a sort of UNIX, please cite the output of <TT>uname -a</TT>. 
+     If you are using Windows, please right-click on the &#187;My Computer&#171; 
+     icon that usually resides in the top left-hand corner of your screen and report 
+     the lines following &#187;System&#171; and &#187;Computer&#171;. 
+   <LI> The exact command line that you entered before you encountered the error. 
+   <LI> The output of the encoder when appending the <TT>-S</TT><A NAME="466">&#160;</A> 
+     switch to the command line. 
+ </UL>
+ <P> If you have gathered this information, please write an email to <A NAME="tex2html1"
+  HREF="mailto:mp3encoder@geek.rcc.se">mp3encoder@geek.rcc.se</A> . 
+ <P>&nbsp; 
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node16.html lame3.13/doc/html/node16.html
*** encoder/doc/html/node16.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node16.html	Fri May 21 14:32:38 1999
***************
*** 0 ****
--- 1,61 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Sample bug report</TITLE>
+ <META NAME="description" CONTENT="Sample bug report">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="previous" HREF="node15.html">
+ <LINK REL="up" HREF="node13.html">
+ <LINK REL="next" HREF="node17.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html291"
+  HREF="node17.html">References</A> |<B> Up:</B> <A NAME="tex2html287"
+  HREF="node13.html">Troubleshooting</A> |<B> Previous:</B> <A NAME="tex2html283"
+  HREF="node15.html">Reporting the bug</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00530000000000000000"> Sample bug report</A> </H1>
+ This is a sample bug report that you may use as a template for your own. 
+ <P> 
+ <PRE>
+ To: mp3encoder@geek.rcc.se 
+ Subject: LAME bug
+ 
+ Hello,
+ 
+ I am using LAME Version V3.x on a PC (according to
+ the System Properties dialog, it is running Microsoft Windows NT
+ 4.00.1381; the computer contains a x86 Family 5 Model 2 Stepping 12
+ AT/AT compatible and 64,951 KB RAM).
+ 
+ When I run the program as
+ 
+ lame -b 127957 -S myfile.wav foobar.mp3
+ 
+ I get the following error message:
+ 
+ LAME 3.03  (www.sulaco.org/mp3)
+ WAVE : Found WAV header. Assuming 44.1khz 16bit stereo samples
+ Encoding track.wav to track.mp3
+ Encoding as 44.1 kHz 128 kbps stereo MPEG-1 LayerIII file
+ using GPSYCHO: GPL'd psycho-acoustic model
+ Frame: [ 336/ 996]   Encoding Time 00:07/00:20  (1.30x)   ETA 00:13
+ 
+ ** lame error: Illegal codebook encountered.
+ 
+ Regards,
+   Hantan
+ </PRE>
+ <P> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node17.html lame3.13/doc/html/node17.html
*** encoder/doc/html/node17.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node17.html	Fri May 21 14:42:00 1999
***************
*** 0 ****
--- 1,103 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>References</TITLE>
+ <META NAME="description" CONTENT="References">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node18.html">
+ <LINK REL="previous" HREF="node13.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node18.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html303"
+  HREF="node18.html">Index</A> |<B> Up:</B> <A NAME="tex2html299"
+  HREF="index.html">LAME V3 Next Generation High-End</A> |<B> Previous:</B> <A NAME="tex2html293"
+  HREF="node16.html">Sample bug report</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H2><A NAME="SECTIONREF">References</A> </H2>
+ <DL compact> 
+   <P></P>
+   <DT><A NAME="bosi96"><STRONG>1</STRONG></A> 
+   <DD> M. Bosi, K. Brandenburg, et al. <BR>
+     ISO/IEC MPEG-2 advanced audio coding. <BR>
+     In <EM>101st AES conference</EM>, Los Angeles, November 1996. <BR>
+     preprint 4382. 
+     <P> 
+     <P></P>
+   <DT><A NAME="bdg95"><STRONG>2</STRONG></A> 
+   <DD> K. Brandenburg and M. Bosi. <BR>
+     Overview of MPEG-audio: Current and future standards for low bit-rate audio 
+     coding. <BR>
+     In <EM>99th AES conference</EM>, New York, October 1995. <BR>
+     preprint 4130. 
+     <P> 
+     <P></P>
+   <DT><A NAME="gil"><STRONG>3</STRONG></A> 
+   <DD> K. Brandenburg, G. Stoll, et al. <BR>
+     The ISO/MPEG-audio codec: A generic standard for coding of high quality digital 
+     audio. <BR>
+     In Neil Gilchrist and Christer Grewin, editors, <EM>Collected Papers On Digital 
+     Audio Bit-Rate Reduction</EM>, pages 31-42. AES, 1996. 
+     <P> 
+     <P></P>
+   <DT><A NAME="bch96"><STRONG>4</STRONG></A> 
+   <DD> R. Buchta, S. Meltzer, et al. <BR>
+     The Worldstar sound format. <BR>
+     In <EM>101st AES conference</EM>, Los Angeles, November 1996. <BR>
+     preprint 4385. 
+     <P> 
+     <P></P>
+   <DT><A NAME="church93"><STRONG>5</STRONG></A> 
+   <DD> S. Church, B. Grill, H. Popp, et al. <BR>
+     ISDN and ISO/MPEG layer-3 audio coding: Powerful new tools for broadcast and 
+     audio production. <BR>
+     In <EM>95th AES conference</EM>, Amsterdam, October 1993. <BR>
+     preprint 3743. 
+     <P> 
+     <P></P>
+   <DT><A NAME="dietz95"><STRONG>6</STRONG></A> 
+   <DD> M. Dietz, H. Popp, et al. <BR>
+     Audio compression for network transmission. <BR>
+     In <EM>99th AES conference</EM>, New York, October 1995. <BR>
+     preprint 4129. 
+     <P> 
+     <P></P>
+   <DT><A NAME="eberl93"><STRONG>7</STRONG></A> 
+   <DD> E. Eberlein, H. Popp, et al. <BR>
+     Layer-3, a flexible coding standard. <BR>
+     In <EM>94th AES conference</EM>, Berlin, March 1993. <BR>
+     preprint 3493. 
+     <P> 
+     <P></P>
+   <DT><A NAME="grill94"><STRONG>8</STRONG></A> 
+   <DD> B. Grill, J. Herre, et al. <BR>
+     Improved MPEG-2 audio multi-channel encoding. <BR>
+     In <EM>96th AES conference</EM>, Amsterdam, February 1994. <BR>
+     preprint 3865. 
+     <P> 
+     <P></P>
+   <DT><A NAME="herre95"><STRONG>9</STRONG></A> 
+   <DD> J. Herre, K. Brandenburg, et al. <BR>
+     Second generation ISO/MPEG audio layer-3 coding. <BR>
+     In <EM>98th AES conference</EM>, Paris, February 1995. 
+     <P> 
+     <P></P>
+   <DT><A NAME="witte94"><STRONG>10</STRONG></A> 
+   <DD> Witte, M. Dietz, et al. <BR>
+     Single chip implementation of an ISO/MPEG layer-3 decoder. <BR>
+     In <EM>96th AES conference</EM>, Amsterdam, February 1994. <BR>
+     preprint 3805. 
+ </DL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node18.html lame3.13/doc/html/node18.html
*** encoder/doc/html/node18.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node18.html	Fri May 21 14:42:18 1999
***************
*** 0 ****
--- 1,111 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Index</TITLE>
+ <META NAME="description" CONTENT="Index">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="previous" HREF="node17.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Up:</B> <A NAME="tex2html309"
+  HREF="index.html">LAME V3 Next Generation High-End</A> |<B> Previous:</B> <A NAME="tex2html305"
+  HREF="node17.html">References</A> |<A HREF=node1.html><B> Table of Contents </B></A>| 
+   <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> <BR>
+ <H2><A NAME="SECTION00700000000000000000"> Index</A> </H2>
+ <DL compact> 
+   <DT><STRONG>audio compression</STRONG> 
+   <DD><A HREF="node6.html#352">Introduction</A> 
+   <DT><STRONG>audio decoding</STRONG> 
+   <DD><A HREF="node6.html#356">Introduction</A> 
+   <DT><STRONG>audio encoding</STRONG> 
+   <DD><A HREF="node6.html#354">Introduction</A> 
+   <DT><STRONG>bandwidth</STRONG> 
+   <DD><A HREF="node11.html#153">Samplerate</A> | <A HREF="node11.html#189">Encoding 
+     speed</A> | <A HREF="node12.html#249">Overriding default settings</A> 
+   <DT><STRONG>bitrate</STRONG> 
+   <DD><A HREF="node6.html#365">Compression ratios, bitrate and</A> | <A HREF="node11.html#404">Bitrate</A> 
+   <DT><STRONG>bitstream</STRONG> 
+   <DD><A HREF="node6.html#360">The two parts of</A> 
+   <DT><STRONG>command-line switch</STRONG> 
+   <DD> 
+     <DL compact> 
+       <DT><STRONG>-b</STRONG> 
+       <DD><A HREF="node8.html#368">Command line switch reference</A> | bb | <A HREF="node11.html#409">Bitrate</A> 
+       <DT><STRONG>-k</STRONG> 
+       <DD><A HREF="node12.html#445">Overriding default settings</A> 
+       <DT><STRONG>-e</STRONG> 
+       <DD><A HREF="node8.html#394">Command line switch reference</A> | <A HREF="node12.html#449">Tids 
+         &amp; bits</A> | <A HREF="node14.html#460">Is it really a</A> 
+       <DT><STRONG>-a</STRONG> 
+       <DD><A HREF="node8.html#396">Command line switch reference</A> | <A HREF="node12.html#451">Tids 
+         &amp; bits</A> 
+       <DT><STRONG>-f</STRONG> 
+       <DD><A HREF="node8.html#390">Command line switch reference</A> | <A HREF="node12.html#457">Tids 
+         &amp; bits</A> | <A HREF="node12.html#457">Tids &amp; bits</A> | <A HREF="node12.html#453">Tids 
+         &amp; bits</A> | <A HREF="node12.html#455">Tids &amp; bits</A> 
+       <DT><STRONG>-s</STRONG> 
+       <DD><A HREF="node8.html#378">Command line switch reference</A> | <A HREF="node11.html#425">plain 
+         PCM data input</A> 
+       <DT><STRONG>-</STRONG> 
+       <DD><A HREF="node8.html#386">Command line switch reference</A> | <A HREF="node11.html#423">Piping 
+         data into the</A> 
+       <DT><STRONG>-</STRONG> 
+       <DD><A HREF="node8.html#388">Command line switch reference</A> | <A HREF="node11.html#439">Streaming 
+         data out of</A> 
+       <DT><STRONG>-S</STRONG> 
+       <DD><A HREF="node8.html#398">Command line switch reference</A> | <A HREF="node15.html#466">Reporting 
+         the bug</A> 
+     </DL>
+   <DT><STRONG>decoding</STRONG> 
+   <DD><A HREF="node6.html#362">The two parts of</A> 
+   <DT><STRONG>downsampling</STRONG> 
+   <DD><A HREF="node11.html#402">Samplerate</A> 
+   <DT><STRONG>dual channel</STRONG> 
+   <DD><A HREF="node11.html#165">Stereo mode</A> 
+   <DT><STRONG>dual mono</STRONG> 
+   <DD><A HREF="node11.html#412">Stereo mode</A> 
+   <DT><STRONG>encoding</STRONG> 
+   <DD><A HREF="node6.html#358">The two parts of</A> 
+   <DT><STRONG>license</STRONG> 
+   <DD><A HREF="node3.html#49">Why should you buy</A> 
+   <DT><STRONG>low-pass</STRONG> 
+   <DD><i>see </i> bandwidth 
+   <DT><STRONG>sample rate</STRONG> 
+   <DD><A HREF="node11.html#152">Samplerate</A> | <A HREF="node12.html#245">Overriding 
+     default settings</A> 
+     <DL compact> 
+       <DT><STRONG>effective</STRONG> 
+       <DD><A HREF="node12.html#244">Overriding default settings</A> 
+     </DL>
+   <DT><STRONG>stereo</STRONG> 
+   <DD><A HREF="node11.html#168">Stereo mode</A> 
+     <DL compact> 
+       <DT><STRONG>intensity</STRONG> 
+       <DD><A HREF="node8.html#141">Command line switch reference</A> | <A HREF="node11.html#174">Stereo 
+         mode</A> | <A HREF="node12.html#251">Overriding default settings</A> 
+       <DT><STRONG>mid-side</STRONG> 
+       <DD><A HREF="node11.html#169">Stereo mode</A> 
+       <DT><STRONG>MS</STRONG> 
+       <DD><i>see </i> stereo, mid-side 
+     </DL>
+   <DT><STRONG>streaming</STRONG> 
+   <DD><A HREF="node11.html#418">Input file specification</A> | <A HREF="node11.html#231">no 
+     title</A> 
+   <DT><STRONG>surround sound</STRONG> 
+   <DD><A HREF="node11.html#173">Stereo mode</A> 
+     <P> 
+ </DL>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node5.html lame3.13/doc/html/node5.html
*** encoder/doc/html/node5.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node5.html	Mon May 24 18:15:00 1999
***************
*** 0 ****
--- 1,54 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>For the impatient</TITLE>
+ <META NAME="description" CONTENT="For the impatient">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node10.html">
+ <LINK REL="previous" HREF="node2.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node6.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1><A NAME="SECTION00300000000000000000"> For the impatient</A> </H1>
+ If you are new to audio compression, you should read section <A HREF="node6.html#chap-intro">1.1</A> 
+ for an introduction about audio compression and MPEG Layer-3. 
+ <P> If, however, you want to jump right into the business of sound compression, 
+   then Section <A HREF="node7.html#cmdl-examples">1.2</A> will show you some prefabricated 
+   command lines that will give you compressed audio streams right away. 
+ <P> If you are an expert in audio coding already, the command line switch reference 
+   page might come in handy. 
+ <P> <BR>
+ <HR>
+ <!--Table of Child-Links--> <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A NAME="tex2html127"
+  HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+     <UL>
+       <LI><A NAME="tex2html128"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+       <LI><A NAME="tex2html129"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+       <LI><A NAME="tex2html130"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+         quality</A> 
+     </UL>
+   <LI><A NAME="tex2html131"
+  HREF="node7.html#SECTION00320000000000000000"> Some examples</A> 
+   <LI><A NAME="tex2html132"
+  HREF="node8.html#SECTION00330000000000000000"> Command line switch reference</A> 
+   <LI><A NAME="tex2html133"
+  HREF="node9.html#SECTION00340000000000000000"> Bugfixes and changes between V3.0 
+     and V3.1</A> 
+ </UL>
+ <!--End of Table of Child-Links--> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node6.html lame3.13/doc/html/node6.html
*** encoder/doc/html/node6.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node6.html	Wed May 26 12:06:16 1999
***************
*** 0 ****
--- 1,133 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Introduction</TITLE>
+ <META NAME="description" CONTENT="Introduction">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node7.html">
+ <LINK REL="previous" HREF="node5.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node7.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Table of Child-Links--> <A NAME="CHILD_LINKS"><strong>Subsections</strong></A> 
+ <UL>
+   <LI><A NAME="tex2html146"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+   <LI><A NAME="tex2html147"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+   <LI><A NAME="tex2html148"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+     quality</A> 
+ </UL>
+ <!--End of Table of Child-Links--> 
+ <HR>
+ <H1><A NAME="SECTION00310000000000000000"> Introduction</A> </H1>
+ <A NAME="chap-intro">&#160;</A> There is a lot of confusion surrounding the terms 
+ <A NAME="352">&#160;</A><I>audio compression</I>, <A NAME="354">&#160;</A><I>audio 
+ encoding</I>, and <A NAME="356">&#160;</A><I>audio decoding</I>. This section 
+ will give you an overview what audio coding (another one of these terms...) is 
+ all about. 
+ <P> 
+ <H2><A NAME="SECTION00311000000000000000"> The purpose of audio compression</A> 
+ </H2>
+ <P> Up to the advent of audio compression, high-quality digital audio data took 
+   a lot of hard disk space to store. Let us go through a short example. 
+ <P> You want to, say, sample your favorite 1-minute song and store it on your 
+   harddisk. Because you want CD quality, you sample at 44.1&nbsp;kHz, stereo, 
+   with 16 bits per sample. 
+ <P> 44100 Hz means that you have 44100 values per second coming in from your sound 
+   card (or input file). Multiply that by two because you have two channels. Multiply 
+   by another factor of two because you have two bytes per value (that's what 16 
+   bit means). The song will take up <NOBR>44100 samples/s &middot; 2 channels 
+   &middot; 2 bytes/sample &middot; 60 s/min ~ 10 MBytes</NOBR> of storage space 
+   on your harddisk. 
+ <P> If you wanted to download that over the internet, given an average 28.8&nbsp;modem, 
+   it would take you (at least) <NOBR>10000000 bytes &middot; 8 bits/byte / (28800 
+   bits/s) &middot; / (60 s/min) ~ 45 minutes</NOBR> 
+ <DIV ALIGN="CENTER"> <B>Just to download one minute of music!</B> </DIV>
+ <P> Digital audio coding, which - in this context - is synonymously called digital 
+   audio compression as well, is the art of minimizing storage space (or channel 
+   bandwidth) requirements for audio data. Modern perceptual audio coding techniques 
+   (like MPEG Layer-3) exploit the properties of the human ear (the perception 
+   of sound) to achieve a size reduction by a factor of 12 with little or no perceptible 
+   loss of quality. 
+ <P> Therefore, such schemes are the key technology for high quality low bit-rate 
+   applications, like soundtracks for CD-ROM games, solid-state sound memories, 
+   Internet audio, digital audio broadcasting systems, and the like. 
+ <P> 
+ <H2><A NAME="SECTION00312000000000000000"> The two parts of audio compression</A> 
+ </H2>
+ <P> Audio compression really consists of two parts. The first part, called <A NAME="358">&#160;</A><I>encoding</I>, 
+   transforms the digital audio data that resides, say, in a WAVE file, into a 
+   highly compressed form called <A NAME="360">&#160;</A><I>bitstream</I>. To play 
+   the bitstream on your soundcard, you need the second part, called <A NAME="362">&#160;</A><I>decoding</I>. 
+   Decoding takes the bitstream and re-expands it to a WAVE file. 
+ <P> The program that effects the first part is called an audio <I>encoder</I>. 
+   <i>LAME</i> is such an encoder . The program that does the second part is called 
+   an audio <I>decoder</I>. One well-known MPEG&nbsp;Layer-3 decoder is <tt>X11Amp</tt>, 
+   another <TT>mpg123</TT>. Both can be found on <A NAME="tex2html1"
+  HREF="http://www.mp3tech.org">http://www.mp3tech.org</A> . 
+ <H2><A NAME="SECTION00313000000000000000"> Compression ratios, bitrate and quality</A> 
+ </H2>
+ <P> It has not been explicitly mentioned up to now: What you end up with after 
+   encoding and decoding is not the same sound file anymore: All superflous information 
+   has been squeezed out, so to say. It is not the same <I>file</I>, but it will 
+   <I>sound</I> the same - more or less, depending on how much compression had 
+   been performed on it. 
+ <P> Generally speaking, the lower the compression ratio achieved, the better the 
+   sound quality will be in the end - and <I>vice versa</I>. Table <A HREF="node6.html#table-soundq">1.1</A> 
+   gives you an overview about quality achievable. 
+ <P> Because compression ratio is a somewhat unwieldy measure, experts use the 
+   term <A NAME="365">&#160;</A><I>bitrate</I> when speaking of the strength of 
+   compression. Bitrate denotes the average number of bits that one second of audio 
+   data will take up in your compressed bitstream. Usually the units used will 
+   be kbps, which is <SUP>kBits</SUP>/<SUB>s</SUB>, or 1000&nbsp;<SUP>bits</SUP>/<SUB>s</SUB>. 
+   To calculate the number of bytes per second of audio data, simply divide the 
+   number of bits per second by eight. 
+ <P> <BR>
+ <DIV ALIGN="CENTER"><A NAME="table-soundq">&#160;</A> <A NAME="95">&#160;</A> 
+   <TABLE CELLPADDING=3 BORDER="1">
+     <CAPTION><STRONG>Table 1.1:</STRONG> Bitrate versus sound quality</CAPTION>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>Bitrate</TD>
+       <TD ALIGN="RIGHT" nowrap>Bandwidth</TD>
+       <TD ALIGN="LEFT" nowrap>Quality comparable to or better than</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>8 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>2.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>POTS (telephone sound)</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>16 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>4.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>shortwave radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>32 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>7.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>AM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>64 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>11 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>FM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>128 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>16 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>CD</TD>
+     </TR>
+   </TABLE>
+ </DIV>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node7.html lame3.13/doc/html/node7.html
*** encoder/doc/html/node7.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node7.html	Mon May 24 18:15:22 1999
***************
*** 0 ****
--- 1,32 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Some examples</TITLE>
+ <META NAME="description" CONTENT="Some examples">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node8.html">
+ <LINK REL="previous" HREF="node6.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node8.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1><A NAME="SECTION00320000000000000000"> Some examples</A> </H1>
+ <A NAME="cmdl-examples">&#160;</A> 
+ <UL>
+   <LI> Encode a WAVE-file <TT>myfile.wav</TT> to a bitrate of 128000 bits/s, writing 
+     to a plain bitstream <TT>myfile.mp3</TT> <BR>
+     <TT>lame -b 128000 myfile.wav myfile.mp3</TT> 
+   <LI> Encode a plain PCM stream (2-channel, 44.1&nbsp;kHz) to a plain 56&nbsp;kBit/s 
+     Layer-3 stream, using the encoder as filter <BR>
+     <TT> lame -s 44100 -b 56000 -f - -</TT> 
+ </UL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node8.html lame3.13/doc/html/node8.html
*** encoder/doc/html/node8.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node8.html	Fri May 21 14:33:56 1999
***************
*** 0 ****
--- 1,100 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Command line switch reference</TITLE>
+ <META NAME="description" CONTENT="Command line switch reference">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node9.html">
+ <LINK REL="previous" HREF="node7.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node9.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html172"
+  HREF="node9.html">Bugfixes and changes between</A> |<B> Up:</B> <A NAME="tex2html168"
+  HREF="node5.html">For the impatient</A> |<B> Previous:</B> <A NAME="tex2html162"
+  HREF="node7.html">Some examples</A> |<A HREF=node1.html><B> Table of Contents 
+   </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00330000000000000000"> Command line switch reference</A> </H1>
+ <P><A NAME="cmdl-ref">&#160;</A> 
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap>switch</TD>
+     <TD ALIGN="LEFT" nowrap>parameter</TD>
+     <TD ALIGN="LEFT" nowrap>see section</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-b</TT><A NAME="368">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>bitrate</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="node11.html#switch-br">2.1.2</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>infile</TT><A NAME="370">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>input file name</TD>
+     <TD ALIGN="LEFT" nowrap>&nbsp;</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>outfile</TT><A NAME="372">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>output file name</TD>
+     <TD ALIGN="LEFT" nowrap>&nbsp;</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-s</TT><A NAME="378">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>sample rate in input file (only needed for raw file 
+       input, 44.1&nbsp;kHz is default)</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="node11.html#chap-pcm">2.1.5</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-x</TT><A NAME="382">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>force byte-swapping of input</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="node11.html#chap-pcm">2.1.5</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-</TT><A NAME="386">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>take input from stdin</TD>
+     <TD ALIGN="LEFT" nowrap>&nbsp;</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-</TT><A NAME="388">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>write output into stdout</TD>
+     <TD ALIGN="LEFT" nowrap>&nbsp;</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-f</TT><A NAME="390">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>extra fast</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="node12.html#switch-qual">2.2.2</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-e</TT><A NAME="394">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>CRC checksum error protection (not working)</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="#switch-crc">2.2.2</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-a</TT><A NAME="396">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>downmix stereo file to mono</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="#switch-dm">2.2.2</A></TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-S</TT><A NAME="398">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>be verbose</TD>
+     <TD ALIGN="LEFT" nowrap>&nbsp;</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT>-no-is</TT><A NAME="400">&#160;</A></TD>
+     <TD ALIGN="LEFT" nowrap>do not use <A NAME="141">&#160;</A>intensity stereo</TD>
+     <TD ALIGN="LEFT" nowrap><A HREF="node11.html#intensity">2.1.3</A></TD>
+   </TR>
+ </TABLE>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node9.html lame3.13/doc/html/node9.html
*** encoder/doc/html/node9.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/node9.html	Fri May 21 14:34:08 1999
***************
*** 0 ****
--- 1,68 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Bugfixes and changes between V3.0 and V3.1</TITLE>
+ <META NAME="description" CONTENT="Bugfixes and changes between V3.0 and V3.1">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="previous" HREF="node8.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node10.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Navigation Panel--> <BR>
+ <P> |<B> Next:</B> <A NAME="tex2html182"
+  HREF="node10.html">LAME Features</A> |<B> Up:</B> <A NAME="tex2html178"
+  HREF="node5.html">For the impatient</A> |<B> Previous:</B> <A NAME="tex2html174"
+  HREF="node8.html">Command line switch reference</A> |<A HREF=node1.html><B> Table 
+   of Contents </B></A>| <BR>
+   <BR>
+ <P> <!--End of Navigation Panel--> 
+ <H1><A NAME="SECTION00340000000000000000"> Bugfixes and changes between V3.0 and 
+   V3.04</A> </H1>
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">Bug description</TD>
+     <TD ALIGN="CENTER" nowrap>Status</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 could not read little-endian raw PCM files.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 did not use a consistent syntax for raw PCM file processing.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 did not accept input/output file paths of more than 
+       100 characters.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 did not produce more than 13..16 kHz of bandwidth.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 documentation erroneously mentioned a <TT>-dual</TT> 
+       switch. The switch did not, and does not, exist.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">V3.0 sometimes deleted part of non-mono compatible signals 
+       were left and right channel had a 180<SUP>o</SUP> phase shift.</TD>
+     <TD ALIGN="CENTER" nowrap>Fixed</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT">Support for the IRIX mips-2 ABI has been dicontinued.</TD>
+     <TD ALIGN="CENTER" nowrap>Permanent</TD>
+   </TR>
+ </TABLE>
+ <BR>
+ </font>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/switchs.html lame3.13/doc/html/switchs.html
*** encoder/doc/html/switchs.html	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/html/switchs.html	Wed May 26 18:43:02 1999
***************
*** 0 ****
--- 1,90 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Command line switch reference</TITLE>
+ <META NAME="description" CONTENT="Command line switch reference">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node9.html">
+ <LINK REL="previous" HREF="node7.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node9.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1>Command line switch reference</H1>
+ <P> 
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap>switch</TD>
+     <TD ALIGN="LEFT" nowrap>parameter</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="advanced.html#autoconvert">-a</a></tt></td>
+     <td align="LEFT" nowrap>downmix stereo file to mono</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitrate">-b</a></tt></td>
+     <td align="LEFT" nowrap>bitrate (32, 40, 48, 56, 64, 96, 112, <b>128</b>, 
+       160, 192, 224, 256, 320)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitrate">-c</a></tt></td>
+     <td align="LEFT" nowrap>mark track as copyrighted</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitrate">-e</a></tt></td>
+     <td align="LEFT" nowrap>de-emphasis (<b>n</b>, 5, c)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="advanced.html#extrafast">-f</a></tt></td>
+     <td align="LEFT" nowrap>extra fast</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt>-g</tt></td>
+     <td align="LEFT" nowrap>turn on MP3x graphical frame analyser (may not be 
+       available on your platform)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitrate">-h</a></tt></td>
+     <td align="LEFT" nowrap>use experimental improvements (for internal testing)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="advanced.html#fullbandwidth">-k</a></tt></td>
+     <td align="LEFT" nowrap>use full bandwidth</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#stereomode">-m</a></tt></td>
+     <td align="LEFT" nowrap>stereo mode (s, <b>j</b>, f, m)</td>
+   </tr>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><tt><a href="basics.html#bitrate">-o</a></tt></TD>
+     <TD ALIGN="LEFT" nowrap>mark track as non-original</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><tt><a href="advanced.html#isomodel">-O</a></tt></TD>
+     <TD ALIGN="LEFT" nowrap>use original low-quality ISO psycho-acoustic model</TD>
+   </TR>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT><a href="basics.html#samplerate">-s</a></TT></TD>
+     <TD ALIGN="LEFT" nowrap>sample rate in input file (only needed for raw file 
+       input, 44.1&nbsp;kHz is default)</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitrate">-S</a></tt></td>
+     <td align="LEFT" nowrap>don't print progress report</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="basics.html#bitswap">-x</a></tt></td>
+     <td align="LEFT" nowrap>force byte-swapping of input</td>
+   </tr>
+ </TABLE>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/man/lame.1 lame3.13/doc/man/lame.1
*** encoder/doc/man/lame.1	Wed Dec 31 17:00:00 1969
--- lame3.13/doc/man/lame.1	Sat Jun  5 12:13:31 1999
***************
*** 0 ****
--- 1,115 ----
+ .TH lame 1 "June 4, 1999" " " "LAME audio compressorMP3 "
+ .SH NAME
+ lame \- create mp3 audio files
+ .SH SYNOPSIS
+ .nf
+ lame
+ .fi
+ .SH DESCRIPTION
+ .PP
+ Lame is a program which can be used to create compressed audio files.
+ (Lame aint MP3 encoder).   These audio files can be played back by popular 
+ mp3 players such as mpg123
+ 
+ .SH OPTIONS
+ .TP
+ .BI -m  " mode"
+  (s)tereo, (j)oint, (f)orce or (m)ono  (default j)
+ force = force ms_stereo on all frames.  Faster and
+ uses special Mid & Side masking thresholds
+ .TP
+ .BI -s " sample" " freq"
+  frequency of input file (khz) - default 44.1
+ .TP
+ .BI -b  " bitrate"
+  set the bitrate, default 128kbps
+ .TP
+ .BI -x
+ force byte-swapping of input
+ 
+ .TP
+ .BI -a
+ autoconvert from stereo to mono file for mono encoding
+ 
+ .TP
+ .BI -e " emp    "
+  de-emphasis n/5/c  (default    n)
+ .TP
+ .BI -c
+ mark as copyright
+ .TP
+ .BI -o
+ mark as non-original (i.e. do not set the original bit)
+ .TP
+ .BI -f
+ fast mode (low quality)
+ .TP
+ .BI -k
+ disable sfb=21 cutoff
+ .TP
+ .BI -d
+ allow channels to have different blocktypes
+ .TP
+ .BI -v
+ use variable bitrate
+ .TP
+ .BI -V
+ quality setting for VBR. Default n=4, 0=high quality,bigger files.
+ 9=smaller files
+ .TP
+ .BI -h
+ slower, but (maybe) higher quality
+ .TP
+ .BI -g
+ run graphical analysis on <infile>.  <infile> can also be a .mp3 file.
+ .TP
+ .BI -S
+ don't print progress report
+ .TP
+ .BI -O
+ use original (buggy) ISO psycho-acoustic model
+ 
+ .SH EXAMPLES
+ .LP
+  Create an mp3 file from a wav file using the defaults.
+ .IP
+ .B lame
+ .I foo.wav foo.mp3
+ .LP
+ Copy track 7 from a regular audio CD, using cdparanoia
+ 
+ .IP
+ .B cdparanoia 7 foo.wav  ;
+ .B  lame foo.wav foo.mp3
+ 
+ .LP
+ Copy track 7 from a regular audio CD with cdda2wav, where the cdrom device is
+ device /dev/cdrom to an mp3 file foo.mp3
+ 
+ .IP
+ .B cdda2wav \-O
+ .I wav
+ .B \-t 7 \-D
+ .I /dev/cdrom
+ .I \-
+ .B  | lame
+ .I \- foo.mp3
+ 
+ .IP
+ 
+ 
+ 
+ .SH BUGS
+ .PP
+ Quality is very good, much better than the iso mp3 compressor, but still can improve.
+ .SH SEE ALSO
+ mpg123(1)
+ .SH AUTHORS
+ .nf
+ LAME originally developed by Mike Cheng
+ (www.uq.net.au/~zzmcheng)
+ GPSYCHO psycho-acoustic model by Mark Taylor 
+ (www.sulaco.org/mp3).
+ mpglib by Michael Hipp
+ Manual page by William Schelter
+ .f
diff -r -c -N encoder/encode.c lame3.13/encode.c
*** encoder/encode.c	Wed Jan 22 02:43:14 1997
--- lame3.13/encode.c	Thu Jun 17 02:00:59 1999
***************
*** 2,113 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: encode.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
   *
   * $Log: encode.c,v $
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
!  *          Davis Pan                                                 *
!  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
!  *                                      efilter to enfilter           *
!  *                                      ewindow to enwindow           *
!  *                              integrated "quantizer", "scalefactor",*
!  *                              and "transmission" files              *
!  *                              update routine "window_subband"       *
!  * 3/31/91  Bill Aspromonte     replaced read_filter by               *
!  *                              create_an_filter                      *
!  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
!  *                              Incorporated Jean-Georges Fritsch's   *
!  *                              "bitstream.c" package.                *
!  *                              Incorporated Bill Aspromonte's        *
!  *                              filterbank coefficient matrix         *
!  *                              calculation routines and added        *
!  *                              roundoff to coincide with specs.      *
!  *                              Modified to strictly adhere to        *
!  *                              encoded bitstream specs, including    *
!  *                              "Berlin changes".                     *
!  *                              Modified PCM sound file handling to   *
!  *                              process all incoming samples and fill *
!  *                              out last encoded frame with zeros     *
!  *                              (silence) if needed.                  *
!  *                              Located and fixed numerous software   *
!  *                              bugs and table data errors.           *
!  * 19jun91  dpwe (Aware)        moved "alloc_*" reader to common.c    *
!  *                              Globals sblimit, alloc replaced by new*
!  *                              struct 'frame_params' passed as arg.  *
!  *                              Added JOINT STEREO coding, layers I,II*
!  *                              Affects: *_bit_allocation,            *
!  *                              subband_quantization, encode_bit_alloc*
!  *                              sample_encoding                       *
!  * 6/10/91  Earle Jennings      modified II_subband_quantization to   *
!  *                              resolve type cast problem for MS_DOS  *
!  * 6/11/91  Earle Jennings      modified to avoid overflow on MS_DOS  *
!  *                              in routine filter_subband             *
!  * 7/10/91  Earle Jennings      port to MsDos from MacIntosh version  *
!  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
!  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
!  *          Don H. Lee,                                               *
!  *          Peter W. Farrett                                          *
!  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
!  *                              newly introduced function encode_CRC  *
!  *11/ 8/91  Kathy Wang          Documentation of code                 *
!  *                              All variablenames are referred to     *
!  *                              with surrounding pound (#) signs      *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  * 6/16/92  Shaun Astarabadi    Changed I_scale_factor_calc() and     *
!  *                              II_scale_factor_calc() to use scale   *
!  *                              factor 0 thru 62 only and not to      *
!  *                              encode index 63 into the bit stream.  *
!  * 7/27/92  Mike Li             (re-)Port to MS-DOS                   *
!  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() defs       *
!  * 3/31/93  Giogio Dimino       changed II_a_bit_allocation() from:   *
!  *                              if( ad > ...) to if(ad >= ...)        *
!  * 8/05/93  TEST                changed I_a_bit_allocation() from:    *
!  *                              if( ad > ...) to if(ad >= ...)        *
!  * 8/02/95  mc@fivebats.com     Changed audio file reading code to    *
!  *                              read samples big-endian               *
!  *10/15/95  mc@fivebats.com     Modified get_audio() for layer3-LSF   *
!  **********************************************************************/
   
  #include "common.h"
  #include "encoder.h"
  
! #ifdef MS_DOS
! extern unsigned _stklen = 16384;
! #endif
! 
! 
! /*=======================================================================\
! |                                                                       |
! | This segment contains all the core routines of the encoder,           |
! | except for the psychoacoustic models.                                 |
! |                                                                       |
! | The user can select either one of the two psychoacoustic              |
! | models. Model I is a simple tonal and noise masking threshold         |
! | generator, and Model II is a more sophisticated cochlear masking      |
! | threshold generator. Model I is recommended for lower complexity      |
! | applications whereas Model II gives better subjective quality at low  |
! | bit rates.                                                            |
! |                                                                       |
! | Layers I and II of mono, stereo, and joint stereo modes are supported.|
! | Routines associated with a given layer are prefixed by "I_" for layer |
! | 1 and "II_" for layer 2.                                              |
! \=======================================================================*/
!  
  /************************************************************************
  *
  * read_samples()
--- 2,26 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: encode.c,v 1.2 1998/10/05 17:06:47 larsi Exp $
   *
   * $Log: encode.c,v $
+  * Revision 1.2  1998/10/05 17:06:47  larsi
+  * *** empty log message ***
+  *
+  * Revision 1.1.1.1  1998/10/05 14:47:17  larsi
+  *
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
   * Received from Mike Coleman
   **********************************************************************/
! 
   
  #include "common.h"
  #include "encoder.h"
  
! #ifndef LIBSNDFILE
  /************************************************************************
  *
  * read_samples()
***************
*** 128,133 ****
--- 41,47 ----
      unsigned long samples_read;
      static unsigned long samples_to_read;
      static char init = TRUE;
+     extern int swapbytes; /* if TRUE then force swapping of byte order */
  
      if (init) {
          samples_to_read = num_samples;
***************
*** 139,145 ****
          samples_read = samples_to_read;
      if ((samples_read =
           fread(sample_buffer, sizeof(short), (int)samples_read, musicin)) == 0)
!         printf("Hit end of audio data\n");
      /*
         Samples are big-endian. If this is a little-endian machine
         we must swap
--- 53,59 ----
          samples_read = samples_to_read;
      if ((samples_read =
           fread(sample_buffer, sizeof(short), (int)samples_read, musicin)) == 0)
!       { /* printf("Hit end of audio data\n"); */ }
      /*
         Samples are big-endian. If this is a little-endian machine
         we must swap
***************
*** 153,164 ****
  	    exit( 1 );
  	  }
        }
!     if ( NativeByteOrder == order_littleEndian )
        SwapBytesInWords( sample_buffer, samples_read );
  
      samples_to_read -= samples_read;
      if (samples_read < frame_size && samples_read > 0) {
!         printf("Insufficient PCM input for one frame - fillout with zeros\n");
          for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
          samples_to_read = 0;
      }
--- 67,84 ----
  	    exit( 1 );
  	  }
        }
!     if (!iswav && ( NativeByteOrder == order_littleEndian ))
!       SwapBytesInWords( sample_buffer, samples_read );
! 
!     if (iswav && ( NativeByteOrder == order_bigEndian ))
!       SwapBytesInWords( sample_buffer, samples_read );
! 
!     if (swapbytes==TRUE)
        SwapBytesInWords( sample_buffer, samples_read );
  
      samples_to_read -= samples_read;
      if (samples_read < frame_size && samples_read > 0) {
!       /* printf("Insufficient PCM input for one frame - fillout with zeros\n"); */
          for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
          samples_to_read = 0;
      }
***************
*** 176,195 ****
  *
  ************************************************************************/
   
! unsigned long get_audio( musicin, buffer, num_samples, stereo, info )
  FILE *musicin;
  short FAR buffer[2][1152];
  unsigned long num_samples;
  int stereo;
  layer *info;
  {
      int j;
!     short insamp[2304];
      unsigned long samples_read;
      int lay;
      lay = info->lay;
  
!     if ( (lay == 3) && (info->version == 0) )
      {
  	if ( stereo == 2 )
  	{
--- 96,123 ----
  *
  ************************************************************************/
   
! unsigned long get_audio( musicin, bufferL,bufferR, num_samples, stereo, info )
  FILE *musicin;
+ /*
  short FAR buffer[2][1152];
+ */
+ short FAR bufferL[1152],bufferR[1152];
  unsigned long num_samples;
  int stereo;
  layer *info;
  {
      int j;
!     short insamp[3176];
      unsigned long samples_read;
      int lay;
+     extern int autoconvert;
+ 
      lay = info->lay;
  
!     /* pad with zeros in case we hit EOF */
!     memset((char *) insamp, 0, sizeof(insamp));
! 
!     if ( (lay == 3) && (info->version == 0) )  /* ie MPEG-2 LSF */
      {
  	if ( stereo == 2 )
  	{
***************
*** 197,204 ****
  					 (unsigned long) 1152 );
  	    for ( j = 0; j < 576; j++ )
  	    {
! 		buffer[0][j] = insamp[2 * j];
! 		buffer[1][j] = insamp[2 * j + 1];
  	    }
  	}
  	else
--- 125,132 ----
  					 (unsigned long) 1152 );
  	    for ( j = 0; j < 576; j++ )
  	    {
! 		bufferL[j] = insamp[2 * j];
! 		bufferR[j] = insamp[2 * j + 1];
  	    }
  	}
  	else
***************
*** 207,310 ****
  					 (unsigned long) 576 );
  	    for ( j = 0; j < 576; j++ )
  	    {
! 		buffer[0][j] = insamp[j];
! 		buffer[1][j] = 0;
  	    }
  	}
      }
      else
!     {
! 	if (lay == 1){
! 	    if(stereo == 2){ /* layer 1, stereo */
! 		samples_read = read_samples(musicin, insamp, num_samples,
! 					    (unsigned long) 768);
! 		for(j=0;j<448;j++) {
! 		    if(j<64) {
! 			buffer[0][j] = buffer[0][j+384];
! 			buffer[1][j] = buffer[1][j+384];
! 		    }
! 		    else {
! 			buffer[0][j] = insamp[2*j-128];
! 			buffer[1][j] = insamp[2*j-127];
! 		    }
! 		}
! 	    }
! 	    else { /* layer 1, mono */
! 		samples_read = read_samples(musicin, insamp, num_samples,
! 					    (unsigned long) 384);
! 		for(j=0;j<448;j++){
! 		    if(j<64) {
! 			buffer[0][j] = buffer[0][j+384];
! 			buffer[1][j] = 0;
! 		    }
! 		    else {
! 			buffer[0][j] = insamp[j-64];
! 			buffer[1][j] = 0;
! 		    }
! 		}
! 	    }
! 	}
! 	else {
  	    if(stereo == 2){ /* layer 2 (or 3), stereo */
! 		samples_read = read_samples(musicin, insamp, num_samples,
! 					    (unsigned long) 2304);
! 		for(j=0;j<1152;j++) {
! 		    buffer[0][j] = insamp[2*j];
! 		    buffer[1][j] = insamp[2*j+1];
! 		}
  	    }
  	    else { /* layer 2 (or 3), mono */
  		samples_read = read_samples(musicin, insamp, num_samples,
  					    (unsigned long) 1152);
  		for(j=0;j<1152;j++){
! 		    buffer[0][j] = insamp[j];
! 		    buffer[1][j] = 0;
  		}
  	    }
  	}
-     }
      return(samples_read);
  }
-  
- /************************************************************************
- *
- * read_ana_window()
- *
- * PURPOSE:  Reads encoder window file "enwindow" into array #ana_win#
- *
- ************************************************************************/
-  
- void read_ana_window(ana_win)
- double FAR ana_win[HAN_SIZE];
- {
-     int i,j[4];
-     FILE *fp;
-     double f[4];
-     char t[150];
-  
-     if (!(fp = OpenTableFile("enwindow") ) ) {
-        printf("Please check analysis window table 'enwindow'\n");
-        exit(1);
-     }
-     for (i=0;i<512;i+=4) {
-        fgets(t, 150, fp);
-        sscanf(t,"C[%d] = %lf C[%d] = %lf C[%d] = %lf C[%d] = %lf\n",
-               j, f,j+1,f+1,j+2,f+2,j+3,f+3);
-        if (i==j[0]) {
-           ana_win[i] = f[0];
-           ana_win[i+1] = f[1];
-           ana_win[i+2] = f[2];
-           ana_win[i+3] = f[3];
-        }
-        else {
-           printf("Check index in analysis window table\n");
-           exit(1);
-        }
-        fgets(t,150,fp);
-     }
-     fclose(fp);
- }
  
  /************************************************************************
  *
  * window_subband()
--- 135,181 ----
  					 (unsigned long) 576 );
  	    for ( j = 0; j < 576; j++ )
  	    {
! 		bufferL[j] = insamp[j];
! 		bufferR[j] = 0;
  	    }
  	}
      }
      else
!     /* MPEG 1 */
!       {
  	    if(stereo == 2){ /* layer 2 (or 3), stereo */
! 	      samples_read = read_samples(musicin, insamp, num_samples,
! 					  (unsigned long) 2304);
! 	      for(j=0;j<1152;j++) {
! 		bufferL[j] = insamp[2*j];
! 		bufferR[j] = insamp[2*j+1];
! 		
! 	      }
  	    }
  	    else { /* layer 2 (or 3), mono */
+ 	      if (autoconvert==TRUE) {  /* downconvert from a stereo file into a mono buffer */
+ 		samples_read = read_samples(musicin, insamp, num_samples,
+ 					    (unsigned long) 2304);
+ 		for(j=0;j<1152;j++){
+ 		  bufferL[j] = insamp[2*j];
+ 		  bufferR[j] = 0;
+ 		}	
+ 	      }
+ 	      else {
  		samples_read = read_samples(musicin, insamp, num_samples,
  					    (unsigned long) 1152);
  		for(j=0;j<1152;j++){
! 		    bufferL[j] = insamp[j];
! 		    bufferR[j] = 0;
  		}
+ 	      }
  	    }
  	}
      return(samples_read);
  }
  
+ #endif 
+  
  /************************************************************************
  *
  * window_subband()
***************
*** 318,349 ****
  * windowed sample #z#
  *
  ************************************************************************/
!  
  void window_subband(buffer, z, k)
! short FAR **buffer;
! double FAR z[HAN_SIZE];
  int k;
  {
      typedef double FAR XX[2][HAN_SIZE];
      static XX FAR *x;
!     int i, j;
!     static off[2] = {0,0};
      static char init = 0;
-     static double FAR *c;
      if (!init) {
-         c = (double FAR *) mem_alloc(sizeof(double) * HAN_SIZE, "window");
-         read_ana_window(c);
          x = (XX FAR *) mem_alloc(sizeof(XX),"x");
!         for (i=0;i<2;i++)
!             for (j=0;j<HAN_SIZE;j++)
!                 (*x)[i][j] = 0;
          init = 1;
      }
  
      /* replace 32 oldest samples with 32 new samples */
!     for (i=0;i<32;i++) (*x)[k][31-i+off[k]] = (double) *(*buffer)++/SCALE;
      /* shift samples into proper window positions */
!     for (i=0;i<HAN_SIZE;i++) z[i] = (*x)[k][(i+off[k])&HAN_SIZE-1] * c[i];
      off[k] += 480;              /*offset is modulo (HAN_SIZE-1)*/
      off[k] &= HAN_SIZE-1;
  
--- 189,219 ----
  * windowed sample #z#
  *
  ************************************************************************/
! 
! extern double enwindow[];
! 
  void window_subband(buffer, z, k)
! short **buffer;
! double z[HAN_SIZE];
  int k;
  {
      typedef double FAR XX[2][HAN_SIZE];
      static XX FAR *x;
!     double *xk;
!     int i;
!     static int off[2] = {0,0};
      static char init = 0;
      if (!init) {
          x = (XX FAR *) mem_alloc(sizeof(XX),"x");
!         memset(x, 0, 2*HAN_SIZE);
          init = 1;
      }
+     xk=(*x)[k];
  
      /* replace 32 oldest samples with 32 new samples */
!     for (i=0;i<32;i++) /*(*x)[k]*/xk[31-i+off[k]] = (double) *(*buffer)++/SCALE;
      /* shift samples into proper window positions */
!     for (i=0;i<HAN_SIZE;i++) z[i] = xk[(i+off[k])&(HAN_SIZE-1)] * enwindow[i];
      off[k] += 480;              /*offset is modulo (HAN_SIZE-1)*/
      off[k] &= HAN_SIZE-1;
  
***************
*** 351,384 ****
   
  /************************************************************************
  *
- * create_ana_filter()
- *
- * PURPOSE:  Calculates the analysis filter bank coefficients
- *
- * SEMANTICS:
- * Calculates the analysis filterbank coefficients and rounds to the
- * 9th decimal place accuracy of the filterbank tables in the ISO
- * document.  The coefficients are stored in #filter#
- 
- ************************************************************************/
-  
- void create_ana_filter(filter)
- double FAR filter[SBLIMIT][64];
- {
-    register int i,k;
-  
-    for (i=0; i<32; i++)
-       for (k=0; k<64; k++) {
-           if ((filter[i][k] = 1e9*cos((double)((2*i+1)*(16-k)*PI64))) >= 0)
-              modf(filter[i][k]+0.5, &filter[i][k]);
-           else
-              modf(filter[i][k]-0.5, &filter[i][k]);
-           filter[i][k] *= 1e-9;
-    }
- }
- 
- /************************************************************************
- *
  * filter_subband()
  *
  * PURPOSE:  Calculates the analysis filter bank coefficients
--- 221,226 ----
***************
*** 390,425 ****
  * them by the filter matrix, producing 32 subband samples.
  *
  ************************************************************************/
!  
  void filter_subband(z,s)
  double FAR z[HAN_SIZE], s[SBLIMIT];
  {
!    double y[64];
!    int i,j;
! static char init = 0;
!    typedef double MM[SBLIMIT][64];
! static MM FAR *m;
! #ifdef MS_DOS
!    long    SIZE_OF_MM;
!    SIZE_OF_MM      = SBLIMIT*64;
!    SIZE_OF_MM      *= 8;
!    if (!init) {
!        m = (MM FAR *) mem_alloc(SIZE_OF_MM, "filter");
!        create_ana_filter(*m);
!        init = 1;
!    }
! #else
!    if (!init) {
!        m = (MM FAR *) mem_alloc(sizeof(MM), "filter");
!        create_ana_filter(*m);
!        init = 1;
     }
- #endif
-    for (i=0;i<64;i++) for (j=0, y[i] = 0;j<8;j++) y[i] += z[i+64*j];
-    for (i=0;i<SBLIMIT;i++)
-        for (j=0, s[i]= 0;j<64;j++) s[i] += (*m)[i][j] * y[j];
  }
  
  /************************************************************************
  * encode_info()
  *
--- 232,297 ----
  * them by the filter matrix, producing 32 subband samples.
  *
  ************************************************************************/
! 
! 
! void
! create_dct_matrix( filter )
! double filter[16][32];
! {
!   register int i,k;
!  
!   for (i=0; i<16; i++)
!     for (k=0; k<32; k++) {
!        filter[i][k] = cos((double)((2*i+1)*k*PI64));
!     }
! }
! 
! void
! IDCT32( xin, xout )
! double *xin, *xout;
! {
!   int i,j;
!   double s0, s1;
!   typedef double MM[16][32];
!   static MM FAR * m = 0;
!   if( m==0 ) {
!     m = (MM FAR *)mem_alloc(sizeof(MM),"filter");
!     create_dct_matrix( *m );
!   }
!   for( i=0; i<16; i++ ) {
!     s0 = s1 = 0.0;
!     for( j=0; j<32; j+=2 ) {
!       s0 += (*m)[i][j]*xin[j+0];
!       s1 += (*m)[i][j+1]*xin[j+1];
!     }
!     xout[i] = s0+s1;
!     xout[31-i] = s0-s1;
!   }
! }
! 
  void filter_subband(z,s)
  double FAR z[HAN_SIZE], s[SBLIMIT];
  {
!    double y[64],yprime[32];
!    int i;
!    double *zi;
! 
!    zi = z;
!    for( i=0; i<64; i++ ) {
!       y[ i ] = *zi + zi[ 64 ] + zi[ 128 ] + zi[ 192 ] +
!                zi[ 256 ] + zi[ 320 ] + zi[ 384 ] + zi[ 448 ];
!       zi++;
!    }
! 
!    {
!      yprime[0] = y[16];
!      for( i=1; i<=16; i++ ) yprime[i] = y[i+16]+y[16-i];
!      for( i=17; i<=31; i++ ) yprime[i] = y[i+16]-y[80-i];
!      IDCT32( yprime, s );
     }
  }
  
+ 
  /************************************************************************
  * encode_info()
  *
***************
*** 463,1446 ****
      return (a > 0) ? a : -a;
  }
   
- /************************************************************************
- *
- * I_combine_LR    (Layer I)
- * II_combine_LR   (Layer II)
- *
- * PURPOSE:Combines left and right channels into a mono channel
- *
- * SEMANTICS:  The average of left and right subband samples is put into
- * #joint_sample#
- *
- * Layer I and II differ in frame length and # subbands used
- *
- ************************************************************************/
-  
- void I_combine_LR(sb_sample, joint_sample)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- {   /* make a filtered mono for joint stereo */
-     int sb, smp;
-  
-    for(sb = 0; sb<SBLIMIT; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-         joint_sample[0][smp][sb] = .5 *
-                     (sb_sample[0][0][smp][sb] + sb_sample[1][0][smp][sb]);
- }
-  
- void II_combine_LR(sb_sample, joint_sample, sblimit)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- int sblimit;
- {  /* make a filtered mono for joint stereo */
-    int sb, smp, sufr;
-  
-    for(sb = 0; sb<sblimit; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-          for(sufr = 0; sufr<3; ++sufr)
-             joint_sample[sufr][smp][sb] = .5 * (sb_sample[0][sufr][smp][sb]
-                                            + sb_sample[1][sufr][smp][sb]);
- }
-  
- /************************************************************************
- *
- * I_scale_factor_calc     (Layer I)
- * II_scale_factor_calc    (Layer II)
- *
- * PURPOSE:For each subband, calculate the scale factor for each set
- * of the 12 subband samples
- *
- * SEMANTICS:  Pick the scalefactor #multiple[]# just larger than the
- * absolute value of the peak subband sample of 12 samples,
- * and store the corresponding scalefactor index in #scalar#.
- *
- * Layer II has three sets of 12-subband samples for a given
- * subband.
- *
- ************************************************************************/
-  
- void I_scale_factor_calc(sb_sample,scalar,stereo)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo;
- {
-    int i,j, k;
-    double s[SBLIMIT];
-  
-    for (k=0;k<stereo;k++) {
-      for (i=0;i<SBLIMIT;i++)
-        for (j=1, s[i] = mod(sb_sample[k][0][0][i]);j<SCALE_BLOCK;j++)
-          if (mod(sb_sample[k][0][j][i]) > s[i])
-             s[i] = mod(sb_sample[k][0][j][i]);
-  
-      for (i=0;i<SBLIMIT;i++)
-        for (j=SCALE_RANGE-2,scalar[k][0][i]=0;j>=0;j--) /* $A 6/16/92 */
-          if (s[i] <= multiple[j]) {
-             scalar[k][0][i] = j;
-             break;
-          }
-    }
- }
- 
- /******************************** Layer II ******************************/
-  
- void II_scale_factor_calc(sb_sample,scalar,stereo,sblimit)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo,sblimit;
- {
-   int i,j, k,t;
-   double s[SBLIMIT];
-  
-   for (k=0;k<stereo;k++) for (t=0;t<3;t++) {
-     for (i=0;i<sblimit;i++)
-       for (j=1, s[i] = mod(sb_sample[k][t][0][i]);j<SCALE_BLOCK;j++)
-         if (mod(sb_sample[k][t][j][i]) > s[i])
-              s[i] = mod(sb_sample[k][t][j][i]);
-  
-   for (i=0;i<sblimit;i++)
-     for (j=SCALE_RANGE-2,scalar[k][t][i]=0;j>=0;j--)    /* $A 6/16/92 */
-       if (s[i] <= multiple[j]) {
-          scalar[k][t][i] = j;
-          break;
-       }
-       for (i=sblimit;i<SBLIMIT;i++) scalar[k][t][i] = SCALE_RANGE-1;
-     }
- }
- 
- /************************************************************************
- *
- * pick_scale  (Layer II)
- *
- * PURPOSE:For each subband, puts the smallest scalefactor of the 3
- * associated with a frame into #max_sc#.  This is used
- * used by Psychoacoustic Model I.
- * (I would recommend changin max_sc to min_sc)
- *
- ************************************************************************/
-  
- void pick_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-   int i,j,k,max;
-   int stereo  = fr_ps->stereo;
-   int sblimit = fr_ps->sblimit;
-  
-   for (k=0;k<stereo;k++)
-     for (i=0;i<sblimit;max_sc[k][i] = multiple[max],i++)
-       for (j=1, max = scalar[k][0][i];j<3;j++)
-          if (max > scalar[k][j][i]) max = scalar[k][j][i];
-   for (i=sblimit;i<SBLIMIT;i++) max_sc[0][i] = max_sc[1][i] = 1E-20;
- }
  
- /************************************************************************
- *
- * put_scale   (Layer I)
- *
- * PURPOSE:Sets #max_sc# to the scalefactor index in #scalar.
- * This is used by Psychoacoustic Model I
- *
- ************************************************************************/
-  
- void put_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-    int i,j,k, max;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-  
-    for (k=0;k<stereo;k++) for (i=0;i<SBLIMIT;i++)
-         max_sc[k][i] = multiple[scalar[k][0][i]];
- }
-  
- /************************************************************************
- *
- * II_transmission_pattern (Layer II only)
- *
- * PURPOSE:For a given subband, determines whether to send 1, 2, or
- * all 3 of the scalefactors, and fills in the scalefactor
- * select information accordingly
- *
- * SEMANTICS:  The subbands and channels are classified based on how much
- * the scalefactors changes over its three values (corresponding
- * to the 3 sets of 12 samples per subband).  The classification
- * will send 1 or 2 scalefactors instead of three if the scalefactors
- * do not change much.  The scalefactor select information,
- * #scfsi#, is filled in accordingly.
- *
- ************************************************************************/
-  
- void II_transmission_pattern(scalar, scfsi, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int dscf[2];
-    int class[2],i,j,k;
- static int pattern[5][5] = {0x123, 0x122, 0x122, 0x133, 0x123,
-                             0x113, 0x111, 0x111, 0x444, 0x113,
-                             0x111, 0x111, 0x111, 0x333, 0x113,
-                             0x222, 0x222, 0x222, 0x333, 0x123,
-                             0x123, 0x122, 0x122, 0x133, 0x123};
-  
-    for (k=0;k<stereo;k++)
-      for (i=0;i<sblimit;i++) {
-        dscf[0] =  (scalar[k][0][i]-scalar[k][1][i]);
-        dscf[1] =  (scalar[k][1][i]-scalar[k][2][i]);
-        for (j=0;j<2;j++) {
-          if (dscf[j]<=-3) class[j] = 0;
-          else if (dscf[j] > -3 && dscf[j] <0) class[j] = 1;
-               else if (dscf[j] == 0) class[j] = 2;
-                    else if (dscf[j] > 0 && dscf[j] < 3) class[j] = 3;
-                         else class[j] = 4;
-        }
-        switch (pattern[class[0]][class[1]]) {
-          case 0x123 :    scfsi[k][i] = 0;
-                          break;
-          case 0x122 :    scfsi[k][i] = 3;
-                          scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x133 :    scfsi[k][i] = 3;
-                          scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x113 :    scfsi[k][i] = 1;
-                          scalar[k][1][i] = scalar[k][0][i];
-                          break;
-          case 0x111 :    scfsi[k][i] = 2;
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-                          break;
-          case 0x222 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x333 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x444 :    scfsi[k][i] = 2;
-                          if (scalar[k][0][i] > scalar[k][2][i])
-                               scalar[k][0][i] = scalar[k][2][i];
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-       }
-    }
- }
-  
- /************************************************************************
- *
- * I_encode_scale  (Layer I)
- * II_encode_scale (Layer II)
- *
- * PURPOSE:The encoded scalar factor information is arranged and
- * queued into the output fifo to be transmitted.
- *
- * For Layer II, the three scale factors associated with
- * a given subband and channel are transmitted in accordance
- * with the scfsi, which is transmitted first.
- *
- ************************************************************************/
-  
- void I_encode_scale(scalar, bit_alloc, fr_ps, bs)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int i,j;
-  
-    for (i=0;i<SBLIMIT;i++) for (j=0;j<stereo;j++)
-       if (bit_alloc[j][i]) putbits(bs,scalar[j][0][i],6);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_scale(bit_alloc, scfsi, scalar, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int i,j,k;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  putbits(bs,scfsi[k][i],2);
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  /* above jsbound, bit_alloc[0][i] == ba[1][i] */
-         switch (scfsi[k][i]) {
-            case 0: for (j=0;j<3;j++)
-                      putbits(bs,scalar[k][j][i],6);
-                    break;
-            case 1:
-            case 3: putbits(bs,scalar[k][0][i],6);
-                    putbits(bs,scalar[k][2][i],6);
-                    break;
-            case 2: putbits(bs,scalar[k][0][i],6);
-         }
- }
-  
- /*=======================================================================\
- |                                                                        |
- |      The following routines are done after the masking threshold       |
- | has been calculated by the fft analysis routines in the Psychoacoustic |
- | model. Using the MNR calculated, the actual number of bits allocated   |
- | to each subband is found iteratively.                                  |
- |                                                                        |
- \=======================================================================*/
-  
- /************************************************************************
- *
- * I_bits_for_nonoise  (Layer I)
- * II_bits_for_nonoise (Layer II)
- *
- * PURPOSE:Returns the number of bits required to produce a
- * mask-to-noise ratio better or equal to the noise/no_noise threshold.
- *
- * SEMANTICS:
- * bbal = # bits needed for encoding bit allocation
- * bsel = # bits needed for encoding scalefactor select information
- * banc = # bits needed for ancillary data (header info included)
- *
- * For each subband and channel, will add bits until one of the
- * following occurs:
- * - Hit maximum number of bits we can allocate for that subband
- * - MNR is better than or equal to the minimum masking level
- *   (NOISY_MIN_MNR)
- * Then the bits required for scalefactors, scfsi, bit allocation,
- * and the subband samples are tallied (#req_bits#) and returned.
- *
- * (NOISY_MIN_MNR) is the smallest MNR a subband can have before it is
- * counted as 'noisy' by the logic which chooses the number of JS
- * subbands.
- *
- * Joint stereo is supported.
- *
- ************************************************************************/
- 
- static double snr[18] = {0.00, 7.00, 11.00, 16.00, 20.84,
-                          25.28, 31.59, 37.75, 43.84,
-                          49.89, 55.93, 61.96, 67.98, 74.01,
-                          80.03, 86.05, 92.01, 98.01};
- 
- int I_bits_for_nonoise(perm_smr, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int req_bits = 0;
-  
-    /* initial b_anc (header) allocation bits */
-    req_bits = 32 + 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-  
-    for(i=0; i<SBLIMIT; ++i)
-      for(j=0; j<((i<jsbound)?stereo:1); ++j) {
-        for(k=0;k<14; ++k)
-          if( (-perm_smr[j][i] + snr[k]) >= NOISY_MIN_MNR)
-            break; /* we found enough bits */
-          if(stereo == 2 && i >= jsbound)     /* check other JS channel */
-            for(;k<14; ++k)
-              if( (-perm_smr[1-j][i] + snr[k]) >= NOISY_MIN_MNR) break;
-          if(k>0) req_bits += (k+1)*SCALE_BLOCK + 6*((i>=jsbound)?stereo:1);
-    }
-    return req_bits;
- }
-  
- /***************************** Layer II  ********************************/
-  
- int II_bits_for_nonoise(perm_smr, scfsi, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int sb,ch,ba;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-    int req_bits = 0, bbal = 0, berr = 0, banc = 32;
-    int maxAlloc, sel_bits, sc_bits, smp_bits;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
- 
-    /* added 92-08-11 shn */
-    if (fr_ps->header->error_protection) berr=16; else berr=0; 
-  
-    for (sb=0; sb<jsbound; ++sb)
-      bbal += stereo * (*alloc)[sb][0].bits;
-    for (sb=jsbound; sb<sblimit; ++sb)
-      bbal += (*alloc)[sb][0].bits;
-    req_bits = banc + bbal + berr;
-  
-    for(sb=0; sb<sblimit; ++sb)
-      for(ch=0; ch<((sb<jsbound)?stereo:1); ++ch) {
-        maxAlloc = (1<<(*alloc)[sb][0].bits)-1;
-        sel_bits = sc_bits = smp_bits = 0;
-        for(ba=0;ba<maxAlloc-1; ++ba)
-          if( (-perm_smr[ch][sb] + snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-              >= NOISY_MIN_MNR)
-             break;      /* we found enough bits */
-        if(stereo == 2 && sb >= jsbound) /* check other JS channel */
-          for(;ba<maxAlloc-1; ++ba)
-            if( (-perm_smr[1-ch][sb]+ snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-                >= NOISY_MIN_MNR)
-              break;
-        if(ba>0) {
-          smp_bits = SCALE_BLOCK * ((*alloc)[sb][ba].group * (*alloc)[sb][ba].bits);
-          /* scale factor bits required for subband */
-          sel_bits = 2;
-          sc_bits  = 6 * sfsPerScfsi[scfsi[ch][sb]];
-          if(stereo == 2 && sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            sel_bits += 2;
-            sc_bits  += 6 * sfsPerScfsi[scfsi[1-ch][sb]];
-          }
-          req_bits += smp_bits+sel_bits+sc_bits;
-        }
-    }
-    return req_bits;
- }
-  
- /************************************************************************
- *
- * I_main_bit_allocation   (Layer I)
- * II_main_bit_allocation  (Layer II)
- *
- * PURPOSE:For joint stereo mode, determines which of the 4 joint
- * stereo modes is needed.  Then calls *_a_bit_allocation(), which
- * allocates bits for each of the subbands until there are no more bits
- * left, or the MNR is at the noise/no_noise threshold.
- *
- * SEMANTICS:
- *
- * For joint stereo mode, joint stereo is changed to stereo if
- * there are enough bits to encode stereo at or better than the
- * no-noise threshold (NOISY_MIN_MNR).  Otherwise, the system
- * iteratively allocates less bits by using joint stereo until one
- * of the following occurs:
- * - there are no more noisy subbands (MNR >= NOISY_MIN_MNR)
- * - mode_ext has been reduced to 0, which means that all but the
- *   lowest 4 subbands have been converted from stereo to joint
- *   stereo, and no more subbands may be converted
- *
- *     This function calls *_bits_for_nonoise() and *_a_bit_allocation().
- *
- ************************************************************************/
-  
- void I_main_bit_allocation(perm_smr, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs;
-    int  mode, mode_ext, lay, i;
-    int  rq_db, av_db = *adb;
- static  int init = 0;
-  
-    if(init == 0) {
-      /* rearrange snr for layer I */
-      snr[2] = snr[3];
-      for (i=3;i<16;i++) snr[i] = snr[i+2];
-      init = 1;
-    }
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if(rq_db = I_bits_for_nonoise(perm_smr, fr_ps) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-           --mode_ext;
-           fr_ps->jsbound = js_bound(lay, mode_ext);
-           rq_db = I_bits_for_nonoise(perm_smr, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_main_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs, nn;
-    int  mode, mode_ext, lay;
-    int  rq_db, av_db = *adb;
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if((rq_db=II_bits_for_nonoise(perm_smr, scfsi, fr_ps)) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-          --mode_ext;
-          fr_ps->jsbound = js_bound(lay, mode_ext);
-          rq_db = II_bits_for_nonoise(perm_smr, scfsi, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps);
- }
-  
- /************************************************************************
- *
- * I_a_bit_allocation  (Layer I)
- * II_a_bit_allocation (Layer II)
- *
- * PURPOSE:Adds bits to the subbands with the lowest mask-to-noise
- * ratios, until the maximum number of bits for the subband has
- * been allocated.
- *
- * SEMANTICS:
- * 1. Find the subband and channel with the smallest MNR (#min_sb#,
- *    and #min_ch#)
- * 2. Calculate the increase in bits needed if we increase the bit
- *    allocation to the next higher level
- * 3. If there are enough bits available for increasing the resolution
- *    in #min_sb#, #min_ch#, and the subband has not yet reached its
- *    maximum allocation, update the bit allocation, MNR, and bits
-     available accordingly
- * 4. Repeat until there are no more bits left, or no more available
- *    subbands. (A subband is still available until the maximum
- *    number of bits for the subband has been allocated, or there
- *    aren't enough bits to go to the next higher resolution in the
-     subband.)
- *
- ************************************************************************/
-  
- int I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps) /* return noisy sbs */
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, k, smpl_bits, scale_bits, min_sb, min_ch, oth_ch;
-    int bspl, bscf, ad, noisy_sbs, done = 0, bbal ;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
-  
-    if (!init) {
-       init = 1;
-       if (fr_ps->header->error_protection) berr = 16;  /* added 92-08-11 shn */
-    }
-    bbal = 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-    *adb -= bbal + berr + banc;
-    ad= *adb;
-  
-    for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = mnr[0][0]+1;    min_sb = -1; min_ch = -1;
-      for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++)
-        /* go on only if there are bits left */
-        if (used[k][i] != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-        }
-      if(min_sb > -1) {   /* there was something to find */
-        /* first step of bit allocation is biggest */
-        if (used[min_ch][min_sb])  { smpl_bits = SCALE_BLOCK; scale_bits = 0; }
-        else                       { smpl_bits = 24; scale_bits = 6; }
-        if(min_sb >= jsbound)        scale_bits *= stereo;
-  
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-  
-        if (ad >= bspl + bscf + scale_bits + smpl_bits) {
-          bspl += smpl_bits; /* bit for subband sample */
-          bscf += scale_bits; /* bit for scale factor */
-          bit_alloc[min_ch][min_sb]++;
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb]
-                                + snr[bit_alloc[min_ch][min_sb]];
-          /* Check if subband has been fully allocated max bits */
-          if (bit_alloc[min_ch][min_sb] ==  14 ) used[min_ch][min_sb] = 2;
-        }
-        else            /* no room to improve this band */
-          used[min_ch][min_sb] = 2; /*   for allocation anymore */
-        if(stereo == 2 && min_sb >= jsbound) {
-          oth_ch = 1-min_ch;  /* joint-st : fix other ch */
-          bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb]
-                                + snr[bit_alloc[oth_ch][min_sb]];
-        }
-      }
-    } while(min_sb>-1);     /* i.e. still some sub-bands to find */
- 
-    /* Calculate the number of bits left, add on to pointed var */
-    ad -= bspl+bscf;
-    *adb = ad;
- 
-    /* see how many channels are noisy */
-    noisy_sbs = 0; small = mnr[0][0];
-    for(k=0; k<stereo; ++k) {
-      for(i = 0; i< SBLIMIT; ++i) {
-        if(mnr[k][i] < NOISY_MIN_MNR)   ++noisy_sbs;
-        if(small > mnr[k][i])           small = mnr[k][i];
-      }
-    }
-    return noisy_sbs;
- }
- 
- /***************************** Layer II  ********************************/
-  
- int II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, min_ch, min_sb, oth_ch, k, increment, scale, seli, ba;
-    int bspl, bscf, bsel, ad, noisy_sbs, bbal=0;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
-  
-    if (!init) { 
-        init = 1;  
-        if (fr_ps->header->error_protection) berr=16; /* added 92-08-11 shn */
-    }
-    for (i=0; i<jsbound; ++i)
-      bbal += stereo * (*alloc)[i][0].bits;
-    for (i=jsbound; i<sblimit; ++i)
-      bbal += (*alloc)[i][0].bits;
-    *adb -= bbal + berr + banc;
-    ad = *adb;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = bsel = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = 999999.0; min_sb = -1; min_ch = -1;
-      for (i=0;i<sblimit;i++) for(k=0;k<stereo;++k)
-        if (used[k][i]  != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-      }
-      if(min_sb > -1) {   /* there was something to find */
-        /* find increase in bit allocation in subband [min] */
-        increment = SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].group *
-                         (*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].bits);
-        if (used[min_ch][min_sb])
-          increment -= SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]].group*
-                            (*alloc)[min_sb][bit_alloc[min_ch][min_sb]].bits);
-  
-        /* scale factor bits required for subband [min] */
-        oth_ch = 1 - min_ch;    /* above js bound, need both chans */
-        if (used[min_ch][min_sb]) scale = seli = 0;
-        else {          /* this channel had no bits or scfs before */
-          seli = 2;
-          scale = 6 * sfsPerScfsi[scfsi[min_ch][min_sb]];
-          if(stereo == 2 && min_sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            seli += 2;
-            scale += 6 * sfsPerScfsi[scfsi[oth_ch][min_sb]];
-          }
-        }
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-        if (ad >= bspl + bscf + bsel + seli + scale + increment) {
-          ba = ++bit_alloc[min_ch][min_sb]; /* next up alloc */
-          bspl += increment;  /* bits for subband sample */
-          bscf += scale;      /* bits for scale factor */
-          bsel += seli;       /* bits for scfsi code */
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-          /* Check if subband has been fully allocated max bits */
-          if (ba >= (1<<(*alloc)[min_sb][0].bits)-1) used[min_ch][min_sb] = 2;
-        }
-        else used[min_ch][min_sb] = 2; /* can't increase this alloc */
-        if(min_sb >= jsbound && stereo == 2) {
-          /* above jsbound, alloc applies L+R */
-          ba = bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-        }
-      }
-    } while(min_sb > -1);   /* until could find no channel */
-    /* Calculate the number of bits left */
-    ad -= bspl+bscf+bsel;   *adb = ad;
-    for (i=sblimit;i<SBLIMIT;i++) for (k=0;k<stereo;k++) bit_alloc[k][i]=0;
-  
-    noisy_sbs = 0;  small = mnr[0][0];      /* calc worst noise in case */
-    for(k=0;k<stereo;++k) {
-      for (i=0;i<sblimit;i++) {
-        if (small > mnr[k][i]) small = mnr[k][i];
-        if(mnr[k][i] < NOISY_MIN_MNR) ++noisy_sbs; /* noise is not masked */
- 
-      }
-    }
-    return noisy_sbs;
- }
-  
- /************************************************************************
- *
- * I_subband_quantization  (Layer I)
- * II_subband_quantization (Layer II)
- *
- * PURPOSE:Quantizes subband samples to appropriate number of bits
- *
- * SEMANTICS:  Subband samples are divided by their scalefactors, which
-  makes the quantization more efficient. The scaled samples are
- * quantized by the function a*x+b, where a and b are functions of
- * the number of quantization levels. The result is then truncated
- * to the appropriate number of bits and the MSB is inverted.
- *
- * Note that for fractional 2's complement, inverting the MSB for a
-  negative number x is equivalent to adding 1 to it.
- *
- ************************************************************************/
-  
- static double a[17] = {
-   0.750000000, 0.625000000, 0.875000000, 0.562500000, 0.937500000,
-   0.968750000, 0.984375000, 0.992187500, 0.996093750, 0.998046875,
-   0.999023438, 0.999511719, 0.999755859, 0.999877930, 0.999938965,
-   0.999969482, 0.999984741 };
-  
- static double b[17] = {
-   -0.250000000, -0.375000000, -0.125000000, -0.437500000, -0.062500000,
-   -0.031250000, -0.015625000, -0.007812500, -0.003906250, -0.001953125,
-   -0.000976563, -0.000488281, -0.000244141, -0.000122070, -0.000061035,
-   -0.000030518, -0.000015259 };
-  
- void I_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                             bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT]; /* L+R for j-stereo if necess */
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, n, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    double d;
- static char init = 0;
- 
-    if (!init) {
-      init = 1;
-      /* rearrange quantization coef to correspond to layer I table */
-      a[1] = a[2]; b[1] = b[2];
-      for (i=2;i<15;i++) { a[i] = a[i+2]; b[i] = b[i+2]; }
-    }
-    for (j=0;j<SCALE_BLOCK;j++) for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        if (bit_alloc[k][i]) {
-          /* for joint stereo mode, have to construct a single subband stream
-             for the js channels.  At present, we calculate a set of mono
-             subband samples and pass them through the scaling system to
-             generate an alternate normalised sample stream.
-  
-             Could normalise both streams (divide by their scfs), then average
-             them.  In bad conditions, this could give rise to spurious
-             cancellations.  Instead, we could just select the sb stream from
-             the larger channel (higher scf), in which case _that_ channel
-             would be 'properly' reconstructed, and the mate would just be a
-             scaled version.  Spec recommends averaging the two (unnormalised)
-             subband channels, then normalising this new signal without
-             actually sending this scale factor... This means looking ahead.
-          */
-          if(stereo == 2 && i>=jsbound)
-            /* use the joint data passed in */
-            d = j_samps[0][j][i] / multiple[j_scale[0][i]];
-          else
-            d = sb_samples[k][0][j][i] / multiple[scalar[k][0][i]];
-          /* scale and quantize floating point sample */
-          n = bit_alloc[k][i];
-          d = d * a[n-1] + b[n-1];
-          /* extract MSB N-1 bits from the floating point sample */
-          if (d >= 0) sig = 1;
-          else { sig = 0; d += 1.0; }
-          sbband[k][0][j][i] = (unsigned int) (d * (double) (1L<<n));
-          /* tag the inverted sign bit to sbband at position N */
-          if (sig) sbband[k][0][j][i] |= 1<<n;
-        }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                              bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, s, n, qnt, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    unsigned int stps;
-    double d;
-    al_table *alloc = fr_ps->alloc;
- 
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j++)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              /* scale and quantize floating point sample */
-              if(stereo == 2 && i>=jsbound)       /* use j-stereo samples */
-                d = j_samps[s][j][i] / multiple[j_scale[s][i]];
-              else
-                d = sb_samples[k][s][j][i] / multiple[scalar[k][s][i]];
-              if (mod(d) > 1.0)
-                printf("Not scaled properly %d %d %d %d\n",k,s,j,i);
-              qnt = (*alloc)[i][bit_alloc[k][i]].quant;
-              d = d * a[qnt] + b[qnt];
-              /* extract MSB N-1 bits from the floating point sample */
-              if (d >= 0) sig = 1;
-              else { sig = 0; d += 1.0; }
-              n = 0;
- #ifndef MS_DOS
-              stps = (*alloc)[i][bit_alloc[k][i]].steps;
-              while ((1L<<n) < stps) n++;
- #else
-              while  ( ( (unsigned long)(1L<<(long)n) <
-                        ((unsigned long) ((*alloc)[i][bit_alloc[k][i]].steps)
-                         & 0xffff
-                         )
-                        ) && ( n <16)
-                      ) n++;
- #endif
-              n--;
-              sbband[k][s][j][i] = (unsigned int) (d * (double) (1L<<n));
-              /* tag the inverted sign bit to sbband at position N */
-              /* The bit inversion is a must for grouping with 3,5,9 steps
-                 so it is done for all subbands */
-              if (sig) sbband[k][s][j][i] |= 1<<n;
-            }
-            for (s=0;s<3;s++)
-              for (j=sblimit;j<SBLIMIT;j++)
-                for (i=0;i<SCALE_BLOCK;i++) for (k=0;k<stereo;k++) sbband[k][s][i][j] = 0;
- }
-  
- /*************************************************************************
- * I_encode_bit_alloc  (Layer I)
- * II_encode_bit_alloc (Layer II)
- *
- * PURPOSE:Writes bit allocation information onto bitstream
- *
- * Layer I uses 4 bits/subband for bit allocation information,
- * and Layer II uses 4,3,2, or 0 bits depending on the
- * quantization table used.
- *
- ************************************************************************/
-  
- void I_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++) putbits(bs,bit_alloc[k][i],4);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (i=0;i<sblimit;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        putbits(bs,bit_alloc[k][i],(*alloc)[i][0].bits);
- }
-  
- /************************************************************************
- *
- * I_sample_encoding   (Layer I)
- * II_sample_encoding  (Layer II)
- *
- * PURPOSE:Put one frame of subband samples on to the bitstream
- *
- * SEMANTICS:  The number of bits allocated per sample is read from
- * the bit allocation information #bit_alloc#.  Layer 2
- * supports writing grouped samples for quantization steps
- * that are not a power of 2.
- *
- ************************************************************************/
-  
- void I_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for(j=0;j<SCALE_BLOCK;j++) {
-      for(i=0;i<SBLIMIT;i++)
-        for(k=0;k<((i<jsbound)?stereo:1);k++)
-          if(bit_alloc[k][i]) putbits(bs,sbband[k][0][j][i],bit_alloc[k][i]+1);
-    }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    unsigned int temp;
-    unsigned int i,j,k,s,x,y;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j+=3)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              if ((*alloc)[i][bit_alloc[k][i]].group == 3) {
-                for (x=0;x<3;x++) putbits(bs,sbband[k][s][j+x][i],
-                                          (*alloc)[i][bit_alloc[k][i]].bits);
-              }
-              else {
-                y =(*alloc)[i][bit_alloc[k][i]].steps;
-                temp = sbband[k][s][j][i] +
-                       sbband[k][s][j+1][i] * y +
-                       sbband[k][s][j+2][i] * y * y;
-                putbits(bs,temp,(*alloc)[i][bit_alloc[k][i]].bits);
-              }
-            }
- }
   
  /************************************************************************
  *
--- 335,341 ----
diff -r -c -N encoder/encoder.h lame3.13/encoder.h
*** encoder/encoder.h	Wed Jan 22 02:43:14 1997
--- lame3.13/encoder.h	Tue Jun 15 18:34:51 1999
***************
*** 10,47 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
!  *          Davis Pan                                                 *
!  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
!  *                              into "common.h" and "encoder.h".      *
!  *                              Ported to Macintosh and Unix.         *
!  *                              Added function prototypes for more    *
!  *                              rigorous type checking.               *
!  * 27jun91  dpwe (Aware)        moved "alloc_*" types, pros to common *
!  *                              Use ifdef PROTO_ARGS for prototypes   *
!  *                              prototypes reflect frame_params struct*
!  * 7/10/91  Earle Jennings      Conversion of all floats to FLOAT     *
!  * 10/3/91  Don H. Lee          implemented CRC-16 error protection   *
!  *                              Additions and revisions are marked    *
!  *                              with "dhl" for clarity                *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  *                              Modified some function prototypes.    *
!  * 7/27/92  Masahiro Iwadare    FFT modifications for Layer 3         *
!  * 8/3/92   Mike Li             removed declaration _stklen for DOS.  *
!  * 9/22/92  jddevine@aware.com  Fix protos for _scale_factor_calc()   *
!  * 11/04/94 Jon Rowlands        Fix protos for usage()                *
!  * 07/11/95 Soeren H. Nielsen   Changed defs. and protos for LSF      *
!  **********************************************************************/
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
--- 10,16 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
! 
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
***************
*** 60,71 ****
  
  /* Default Input Arguments (for command line control) */
  
! #define DFLT_LAY        2      /* default encoding layer is II */
! #define DFLT_MOD        's'    /* default mode is stereo */
! #define DFLT_PSY        1      /* default psych model is 1 */
  #define DFLT_SFQ        44.1   /* default input sampling rate is 44.1 kHz */
  #define DFLT_EMP        'n'    /* default de-emphasis is none */
! #define DFLT_EXT        ".mpg" /* default output file extension */
  
  #define FILETYPE_ENCODE 'TEXT'
  #define CREATOR_ENCODE  'MpgD'
--- 29,40 ----
  
  /* Default Input Arguments (for command line control) */
  
! #define DFLT_LAY        3      /* default encoding layer is III */
! #define DFLT_MOD        'j'    /* default mode is stereo */
! #define DFLT_PSY        2      /* default psych model is 2 */
  #define DFLT_SFQ        44.1   /* default input sampling rate is 44.1 kHz */
  #define DFLT_EMP        'n'    /* default de-emphasis is none */
! #define DFLT_EXT        ".mp3" /* default output file extension */
  
  #define FILETYPE_ENCODE 'TEXT'
  #define CREATOR_ENCODE  'MpgD'
***************
*** 75,92 ****
  
  #define NOISY_MIN_MNR   0.0
  
- /* Psychacoustic Model 1 Definitions */
- 
- #define CB_FRACTION     0.33
- #define MAX_SNR         1000
- #define NOISE           10
- #define TONE            20
- #define DBMIN           -200.0
- #define LAST            -1
- #define STOP            -100
- #define POWERNORM       90.3090 /* = 20 * log10(32768) to normalize */
-                                 /* max output power to 96 dB per spec */
- 
  /* Psychoacoustic Model 2 Definitions */
  
  #define LOGBLKSIZE      10
--- 44,49 ----
***************
*** 101,128 ****
  *
  ***********************************************************************/
  
- /* Psychoacoustic Model 1 Type Definitions */
- 
- typedef int        IFFT2[FFT_SIZE/2];
- typedef int        IFFT[FFT_SIZE];
- typedef double     D9[9];
- typedef double     D10[10];
- typedef double     D640[640];
- typedef double     D1408[1408];
- typedef double     DFFT2[FFT_SIZE/2];
- typedef double     DFFT[FFT_SIZE];
- typedef double     DSBL[SBLIMIT];
- typedef double     D2SBL[2][SBLIMIT];
- 
- typedef struct {
-         int        line;
-         double     bark, hear, x;
- } g_thres, *g_ptr;
- 
- typedef struct {
-         double     x;
-         int        type, next, map;
- } mask, *mask_ptr;
  
  /* Psychoacoustic Model 2 Type Definitions */
  
--- 58,63 ----
***************
*** 136,143 ****
  typedef FLOAT      FHBLK[HBLKSIZE];
  typedef FLOAT      F2HBLK[2][HBLKSIZE];
  typedef FLOAT      F22HBLK[2][2][HBLKSIZE];
! typedef double     DCB[CBANDS];
  
  /***********************************************************************
  *
  *  Encoder Function Prototype Declarations
--- 71,79 ----
  typedef FLOAT      FHBLK[HBLKSIZE];
  typedef FLOAT      F2HBLK[2][HBLKSIZE];
  typedef FLOAT      F22HBLK[2][2][HBLKSIZE];
! typedef double     DCBA[CBANDS];
  
+ extern int iswav;
  /***********************************************************************
  *
  *  Encoder Function Prototype Declarations
***************
*** 153,238 ****
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   print_config(frame_params*, int*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
- void   usage(void);
  extern void   aiff_check(char*, IFF_AIFF*, int*);
  #else
  extern void   obtain_parameters();
  extern void   parse_args();
  extern void   print_config();
- static void   usage();
  extern void   aiff_check();
  #endif
  
  /* The following functions are in the file "encode.c" */
  
  #ifdef        PROTO_ARGS
  extern unsigned long    read_samples(FILE*, short[2304], unsigned long,
                             unsigned long);
- #if 0
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, int);
- #else
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, layer* info);
  #endif
  extern void   read_ana_window(double[HAN_SIZE]);
  extern void   window_subband(short**, double[HAN_SIZE], int);
  extern void   create_ana_filter(double[SBLIMIT][64]);
  extern void   filter_subband(double[HAN_SIZE], double[SBLIMIT]);
  extern void   encode_info(frame_params*, Bit_stream_struc*);
  extern double mod(double);
- extern void   I_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT]);
- extern void   II_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], int);
- extern void   I_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int);
- extern void   II_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int, int);
  extern void   pick_scale(unsigned int[2][3][SBLIMIT], frame_params*,
                             double[2][SBLIMIT]);
  extern void   put_scale(unsigned int[2][3][SBLIMIT], frame_params*,
                             double[2][SBLIMIT]);
- extern void   II_transmission_pattern(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*);
- extern void   II_encode_scale(unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_scale(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern int    II_bits_for_nonoise(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            frame_params*);
- extern void   II_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern int    II_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_bits_for_nonoise(double[2][SBLIMIT], frame_params*);
- extern void   I_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern void   I_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   II_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   encode_CRC(unsigned int, Bit_stream_struc*);
  #else
  extern unsigned long  read_samples();
  extern unsigned long  get_audio();
--- 89,124 ----
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   print_config(frame_params*, int*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   aiff_check(char*, IFF_AIFF*, int*);
  #else
  extern void   obtain_parameters();
  extern void   parse_args();
  extern void   print_config();
  extern void   aiff_check();
  #endif
  
  /* The following functions are in the file "encode.c" */
  
  #ifdef        PROTO_ARGS
+ 
+ extern unsigned long    get_audio(FILE*, short [1152],short [1152], unsigned long,
+                            int, int);
+ #ifndef LIBSNDFILE
  extern unsigned long    read_samples(FILE*, short[2304], unsigned long,
                             unsigned long);
  #endif
+ 
+ 
  extern void   read_ana_window(double[HAN_SIZE]);
  extern void   window_subband(short**, double[HAN_SIZE], int);
  extern void   create_ana_filter(double[SBLIMIT][64]);
  extern void   filter_subband(double[HAN_SIZE], double[SBLIMIT]);
  extern void   encode_info(frame_params*, Bit_stream_struc*);
  extern double mod(double);
  extern void   pick_scale(unsigned int[2][3][SBLIMIT], frame_params*,
                             double[2][SBLIMIT]);
  extern void   put_scale(unsigned int[2][3][SBLIMIT], frame_params*,
                             double[2][SBLIMIT]);
  #else
  extern unsigned long  read_samples();
  extern unsigned long  get_audio();
***************
*** 242,320 ****
  extern void        filter_subband();
  extern void        encode_info();
  extern double      mod();
- extern void        I_combine_LR();
- extern void        II_combine_LR();
- extern void        I_scale_factor_calc();
- extern void        II_scale_factor_calc();
  extern void        pick_scale();
  extern void        put_scale();
- extern void        II_transmission_pattern();
- extern void        II_encode_scale();
- extern void        I_encode_scale();
- extern int         II_bits_for_nonoise();
- extern void        II_main_bit_allocation();
- extern int         II_a_bit_allocation();
- extern int         I_bits_for_nonoise();
- extern void        I_main_bit_allocation();
- extern int         I_a_bit_allocation();
- extern void        I_subband_quantization();
- extern void        II_subband_quantization();
- extern void        II_encode_bit_alloc();
- extern void        I_encode_bit_alloc();
- extern void        I_sample_encoding();
- extern void        II_sample_encoding();
- extern void        encode_CRC();
  #endif
  
  /* The following functions are in the file "tonal.c" */
  
  #ifdef     PROTO_ARGS
- extern void        read_cbound(int, int);
- extern void        read_freq_band(g_ptr*, int, int);
  extern void        make_map(mask[HAN_SIZE], g_thres*);
  extern double      add_db(double, double);
- extern void        II_f_f_t(double[FFT_SIZE], mask[HAN_SIZE]);
- extern void        II_hann_win(double[FFT_SIZE]);
- extern void        II_pick_max(mask[HAN_SIZE], double[SBLIMIT]);
- extern void        II_tonal_label(mask[HAN_SIZE], int*);
  extern void        noise_label(mask*, int*, g_thres*);
  extern void        subsampling(mask[HAN_SIZE], g_thres*, int*, int*);
  extern void        threshold(mask[HAN_SIZE], g_thres*, int*, int*, int);
- extern void        II_minimum_mask(g_thres*, double[SBLIMIT], int);
- extern void        II_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT],
-                            int);
- extern void        II_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
- extern void        I_f_f_t(double[FFT_SIZE/2], mask[HAN_SIZE/2]);
- extern void        I_hann_win(double[FFT_SIZE/2]);
- extern void        I_pick_max(mask[HAN_SIZE/2], double[SBLIMIT]);
- extern void        I_tonal_label(mask[HAN_SIZE/2], int*);
- extern void        I_minimum_mask(g_thres*, double[SBLIMIT]);
- extern void        I_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT]);
- extern void        I_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
  #else
- extern void        read_cbound();
- extern void        read_freq_band();
  extern void        make_map();
  extern double      add_db();
- extern void        II_f_f_t();
- extern void        II_hann_win();
- extern void        II_pick_max();
- extern void        II_tonal_label();
  extern void        noise_label();
  extern void        subsampling();
  extern void        threshold();
- extern void        II_minimum_mask();
- extern void        II_smr();
- extern void        II_Psycho_One();
- extern void        I_f_f_t();
- extern void        I_hann_win();
- extern void        I_pick_max();
- extern void        I_tonal_label();
- extern void        I_minimum_mask();
- extern void        I_smr();
- extern void        I_Psycho_One();
  #endif
  
  /* The following functions are in the file "psy.c" */
--- 128,151 ----
***************
*** 329,337 ****
  /* The following functions are in the file "subs.c" */
  
  #ifdef     PROTO_ARGS
! extern void        fft(FLOAT[BLKSIZE], FLOAT[BLKSIZE], FLOAT[BLKSIZE],
                             FLOAT[BLKSIZE], int );
  #else
  extern void        fft();
  #endif
  #endif
--- 160,170 ----
  /* The following functions are in the file "subs.c" */
  
  #ifdef     PROTO_ARGS
! extern void        fft(FLOAT[BLKSIZE], FLOAT[BLKSIZE],
                             FLOAT[BLKSIZE], int );
+ extern double fft_side( FLOAT in[2][1024], int s);
  #else
  extern void        fft();
+ extern double fft_side();
  #endif
  #endif
diff -r -c -N encoder/formatBitstream.c lame3.13/formatBitstream.c
*** encoder/formatBitstream.c	Wed Jan 22 02:43:14 1997
--- lame3.13/formatBitstream.c	Fri Jun 18 01:55:08 1999
***************
*** 27,32 ****
--- 27,40 ----
  static int BitsRemaining  = 0;
  static BitsFcnPtr PutBits = NULL;
  
+ void InitFormatBitStream(void)
+ {
+ 	BitCount		= 0;
+ 	ThisFrameSize	= 0;
+ 	BitsRemaining	= 0;
+ 	PutBits			= NULL;
+ }
+ 
  /* forward declarations */
  static int store_side_info( BF_FrameData *frameInfo );
  static int main_data( BF_FrameData *frameInfo, BF_FrameResults *results );
***************
*** 49,58 ****
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
--- 57,67 ----
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
+ static int elements, forwardFrameLength, forwardSILength; 
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
***************
*** 87,108 ****
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
  
      /* get ptr to bit writing function */
      PutBits = frameInfo->putbits;
      assert( PutBits );
  
-     elements = side_queue_elements( &forwardFrameLength, &forwardSILength );
- 
      if ( elements )
      {
! 	int bitsRemaining = forwardFrameLength - forwardSILength;
! 	int wordsRemaining = bitsRemaining / 32;
! 	while ( wordsRemaining-- )
! 	    WriteMainDataBits( 0, 32, results );
! 	WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
--- 96,117 ----
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      /* get ptr to bit writing function */
      PutBits = frameInfo->putbits;
      assert( PutBits );
  
      if ( elements )
      {
!       int bitsRemaining = forwardFrameLength - forwardSILength;
!       int wordsRemaining = bitsRemaining / 32;
!       while ( wordsRemaining-- ) {
! 	WriteMainDataBits( 0, 32, results );
!       }
!       WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
+     
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
diff -r -c -N encoder/get_audio.c lame3.13/get_audio.c
*** encoder/get_audio.c	Wed Dec 31 17:00:00 1969
--- lame3.13/get_audio.c	Sat Jun  5 13:29:42 1999
***************
*** 0 ****
--- 1,260 ----
+ #ifdef LIBSNDFILE 
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ ** 
+ ** This program is distributed in the hope that it will be useful,
+ ** but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ** GNU General Public License for more details.
+ ** 
+ ** You should have received a copy of the GNU General Public License
+ ** along with this program; if not, write to the Free Software 
+ ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+ #include "common.h"
+ #include "get_audio.h"
+ #include "globalflags.h"
+ #include <stdio.h>
+ 
+ /* External references */
+ 
+ static SNDFILE*	gs_pSndFileIn=NULL;
+ static SF_INFO	gs_wfInfo;
+ 
+ 
+ #if 0
+ static int		iswav=0;			/* IS BYTE SWAPPING STILL NEEDED WITH LIBSNDFILE ? */
+ #endif
+ 
+ int GetSndSampleRate()
+ {
+ 	return gs_wfInfo.samplerate;
+ }
+ 
+ int GetSndChannels()
+ {
+ 	return gs_wfInfo.channels;
+ }
+ 
+ void CloseSndFile()
+ {
+ 	if (gs_pSndFileIn)
+ 	{
+ 		if (sf_close(gs_pSndFileIn) !=0)
+ 		{
+ 			fprintf(stderr, "Could not close sound file \n");
+ 			exit(2);
+ 		}
+ 	}
+ }
+ 
+ void OpenSndFile(const char* lpszFileName)
+ {
+ 	// Try to open the sound file
+ 	gs_pSndFileIn=sf_open_read(lpszFileName,&gs_wfInfo);
+ 
+ 	// Check result
+ 	if (gs_pSndFileIn==NULL)
+ 	{
+ 		fprintf(stderr, "Could not open sound file \"%s\".\n", lpszFileName);
+ 		exit(1);
+ 	}
+ #ifdef _DEBUG_SND_FILE
+ 	printf("\n\nSF_INFO structure\n");
+ 	printf("samplerate        :%d\n",gs_wfInfo.samplerate);
+ 	printf("samples           :%d\n",gs_wfInfo.samples);
+ 	printf("channels          :%d\n",gs_wfInfo.channels);
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("format            :");
+ 
+ 	if (gs_wfInfo.format&SF_FORMAT_WAV) printf("Microsoft WAV format (big endian)");
+ 	if (gs_wfInfo.format&SF_FORMAT_AIFF) printf("Apple/SGI AIFF format (little endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_AU) printf("Sun/NeXT AU format (big endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_AULE) printf("DEC AU format (little endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_PCM) printf("PCM data in 8, 16, 24 or 32 bits.");
+ 	if (gs_wfInfo.format&SF_FORMAT_FLOAT) printf("32 bit Intel x86 floats.");
+ 	if (gs_wfInfo.format&SF_FORMAT_ULAW) printf("U-Law encoded.");
+ 	if (gs_wfInfo.format&SF_FORMAT_ALAW) printf("A-Law encoded.");
+ 	if (gs_wfInfo.format&SF_FORMAT_MS_ADPCM) printf("Microsoft ADPCM.");
+ 	if (gs_wfInfo.format&SF_FORMAT_IMA_ADPCM) printf("IMA ADPCM.");
+ 
+ 	printf("\n");
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("sections          :%d\n",gs_wfInfo.sections);
+ 	printf("seekable          :\n",gs_wfInfo.seekable);
+ #endif
+ }
+ 
+ 
+ /************************************************************************
+ *
+ * read_samples()
+ *
+ * PURPOSE:  reads the PCM samples from a file to the buffer
+ *
+ *  SEMANTICS:
+ * Reads #samples_read# number of shorts from #musicin# filepointer
+ * into #sample_buffer[]#.  Returns the number of samples read.
+ *
+ ************************************************************************/
+ 
+ DWORD read_samples( 
+ 					short		sample_buffer[2304],
+ 					DWORD		num_samples,
+ 					DWORD		frame_size
+ 					)
+ {
+     DWORD			samples_read;
+     static DWORD	samples_to_read;
+     static char		init = TRUE;
+ 
+     if (init)
+ 	{
+ 		samples_to_read = num_samples;
+ 		init = FALSE;
+     }
+ 
+     if (samples_to_read >= frame_size)
+ 	{
+         samples_read = frame_size;
+ 	}
+     else
+ 	{
+         samples_read = samples_to_read;
+ 	}
+ 	if (gs_pSndFileIn)
+ 		samples_read=sf_read_short(gs_pSndFileIn,sample_buffer,samples_read);
+ 	else
+ 		samples_read=fread(sample_buffer, sizeof(short),samples_read, stdin);
+ 
+ 
+ 	if (samples_read!=0)
+ 	{
+ #if 0
+ 		/* Samples are big-endian. If this is a little-endian machine we must swap */
+ 		if ( NativeByteOrder == order_unknown )
+ 		{
+ 			NativeByteOrder = DetermineByteOrder();
+ 			if ( NativeByteOrder == order_unknown )
+ 			{
+ 				fprintf( stderr, "byte order not determined\n" );
+ 				exit( 1 );
+ 			}
+ 		}
+ 		if (!iswav && ( NativeByteOrder == order_littleEndian ))
+ 			SwapBytesInWords( sample_buffer, samples_read );
+ 
+ 		if (swapbytes==TRUE)
+ 			SwapBytesInWords( sample_buffer, samples_read );
+ #endif
+ 
+ 	    samples_to_read -= samples_read;
+ 		if (samples_read < frame_size && samples_read > 0)
+ 		{
+ 			/* printf("Insufficient PCM input for one frame - fillout with zeros\n"); */
+ 			for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
+ 				samples_to_read = 0;
+ 		}
+ 	}
+ 	return(samples_read);
+ }
+ 
+ 
+ /************************************************************************
+ *
+ * get_audio()
+ *
+ * PURPOSE:  reads a frame of audio data from a file to the buffer,
+ *   aligns the data for future processing, and separates the
+ *   left and right channels
+ *
+ *
+ ************************************************************************/
+  
+ DWORD get_audio(	                FILE            *musicin,  /* ignored */
+ 					short		bufferL[1152],
+ 					short		bufferR[1152],
+ 					DWORD		num_samples,
+ 					int			stereo,
+ 					layer*		info
+ 				)
+ {
+ 	int		j;
+ 	short	insamp[2304];
+ 	DWORD	samples_read;
+ 	int		lay;
+ 
+ 	lay = info->lay;
+ 
+ 	/* pad with zeros in case we hit EOF */
+ 	/* THIS IS ALREADY DONE IN THE SND LIB */
+ 	/* memset((char *) insamp, 0, sizeof(insamp)); */
+ 
+ 	if ( (lay == 3) && (info->version == 0) )  /* ie MPEG-2 LSF */
+ 	{
+ 		if ( stereo == 2 )
+ 		{
+ 			samples_read = read_samples(insamp, num_samples,1152 );
+ 			for ( j = 0; j < 576; j++ )
+ 			{
+ 				bufferL[j] = insamp[2 * j];
+ 				bufferR[j] = insamp[2 * j + 1];
+ 			}
+ 		}
+ 		else
+ 		{
+ 			samples_read = read_samples(insamp, num_samples,576 );
+ 			for ( j = 0; j < 576; j++ )
+ 			{
+ 				bufferL[j] = insamp[j];
+ 				bufferR[j] = 0;
+ 			}
+ 		}
+ 	}
+ 	else
+ 	{
+ 		/* MPEG 1 */
+ 		if(stereo == 2)
+ 		{
+ 			/* layer 2 (or 3), stereo */
+ 			samples_read = read_samples(insamp, num_samples,2304);
+ 			for(j=0;j<1152;j++)
+ 			{
+ 				bufferL[j] = insamp[2*j];
+ 				bufferR[j] = insamp[2*j+1];
+ 			}
+ 		}
+ 		else
+ 		{
+ 			/* layer 2 (or 3), mono */
+ 			if (autoconvert==TRUE)
+ 			{
+ 				/* downconvert from a stereo file into a mono buffer */
+ 				samples_read = read_samples(insamp, num_samples,2304);
+ 				for(j=0;j<1152;j++)
+ 				{
+ 					bufferL[j] = insamp[2*j];
+ 					bufferR[j] = 0;
+ 				}	
+ 			}
+ 			else
+ 			{
+ 				samples_read = read_samples(insamp, num_samples,1152);
+ 				for(j=0;j<1152;j++)
+ 				{
+ 					bufferL[j] = insamp[j];
+ 					bufferR[j] = 0;
+ 				}
+ 			}
+ 		}
+ 	}
+ 
+ 	return(samples_read);
+ }
+ #endif
diff -r -c -N encoder/get_audio.h lame3.13/get_audio.h
*** encoder/get_audio.h	Wed Dec 31 17:00:00 1969
--- lame3.13/get_audio.h	Wed Jun  9 20:52:47 1999
***************
*** 0 ****
--- 1,46 ----
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ ** 
+ ** This program is distributed in the hope that it will be useful,
+ ** but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ** GNU General Public License for more details.
+ ** 
+ ** You should have received a copy of the GNU General Public License
+ ** along with this program; if not, write to the Free Software 
+ ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+ #ifndef GET_AUDIO_H_INCLUDED
+ #define GET_AUDIO_H_INCLUDED
+ 
+ /* INCLUDE the sound library header file */
+ #ifdef _WIN32
+ 	/* one byte alignment for WIN32 platforms */
+ 	#pragma pack(push,1)
+ 	#include "./libsndfile/src/sndfile.h"
+ 	#pragma pack(pop,1)
+ #else
+ 	#include "sndfile.h"
+ #endif
+ 
+ #ifndef DWORD
+ typedef unsigned long DWORD;
+ #endif
+ 
+ int		GetSndSampleRate();
+ int		GetSndChannels();
+ void	CloseSndFile();
+ void	OpenSndFile(const char* lpszFileName);
+ 
+ DWORD read_samples( short sample_buffer[2304],
+ 				    DWORD num_samples,DWORD frame_size);
+ DWORD get_audio(FILE *musicin, short bufferL[1152],short bufferR[1152],
+ 				DWORD	num_samples,int stereo,layer* info);
+ 
+ #endif
diff -r -c -N encoder/globalflags.h lame3.13/globalflags.h
*** encoder/globalflags.h	Wed Dec 31 17:00:00 1969
--- lame3.13/globalflags.h	Thu Jun 24 18:16:16 1999
***************
*** 0 ****
--- 1,23 ----
+ 
+ /***********************************************************************
+ *
+ *  Global Variable External Declarations
+ *
+ ***********************************************************************/
+ extern int force_ms;
+ extern int VBR;
+ extern int VBR_q;
+ extern int VBR_min_bitrate;
+ extern int VBR_max_bitrate;
+ extern int gpsycho;
+ extern int sfb21;
+ extern int silent;
+ extern int highq;
+ extern int fast_mode;
+ extern int allow_diff_short;
+ extern int autoconvert;
+ extern int swapbytes;
+ extern int experimentalX;
+ extern int experimentalY;
+ extern int experimentalZ;
+ 
diff -r -c -N encoder/gpkplotting.c lame3.13/gpkplotting.c
*** encoder/gpkplotting.c	Wed Dec 31 17:00:00 1969
--- lame3.13/gpkplotting.c	Thu Jun  3 13:13:16 1999
***************
*** 0 ****
--- 1,276 ----
+ #ifdef HAVEGTK
+ #include "gpkplotting.h"
+ #include "string.h"
+ 
+ static gint num_plotwindows = 0;
+ static gint max_plotwindows = 10;
+ static GdkPixmap *pixmaps[10];
+ static GtkWidget *pixmapboxes[10];
+ 
+ 
+ 
+ 
+ /* compute a gdkcolor */
+ void setcolor(GtkWidget *widget, GdkColor *color, gint red,gint green,gint blue)
+ {
+ 
+   /* colors in GdkColor are taken from 0 to 65535, not 0 to 255.    */
+   color->red = red * (65535/255);
+   color->green = green * (65535/255);
+   color->blue = blue * (65535/255);
+   color->pixel = (gulong)(color->red*65536 + color->green*256 + color->blue);
+   /* find closest in colormap, if needed */
+   gdk_color_alloc(gtk_widget_get_colormap(widget),color);
+ }
+ 
+ 
+ 
+ 
+ void gpk_redraw(pixmap,pixmapbox)
+      GtkWidget *pixmapbox;
+      GdkPixmap *pixmap;
+ {
+   /* redraw the entire pixmap */
+   gdk_draw_pixmap(pixmapbox->window,
+ 		  pixmapbox->style->fg_gc[GTK_WIDGET_STATE (pixmapbox)],
+ 		  pixmap,0,0,0,0,
+ 		  pixmapbox->allocation.width,
+ 		  pixmapbox->allocation.height);
+ }
+ 
+ 
+ static GdkPixmap **findpixmap(GtkWidget *widget)
+ {
+   int i;
+   for (i=0; i<num_plotwindows  && widget != pixmapboxes[i] ; i++);
+   if (i>=num_plotwindows) {
+     g_print("findpixmap(): bad argument widget \n");
+     return NULL;
+   }
+   return &pixmaps[i];
+ }
+ 
+ void gpk_graph_draw(GtkWidget *widget,               /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint *points;
+   int i;
+   gint16 width,height;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     points = g_malloc(n*sizeof(GdkPoint));
+     for (i=0; i<n ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     gdk_draw_lines(*ppixmap,gc,points,n);
+     g_free(points);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_rectangle_draw(GtkWidget *widget,              /* plot on this widged */
+ 			gdouble *xcord, gdouble *ycord, /* corners */
+ 			gdouble xmn,gdouble ymn,        /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color)
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     for (i=0; i<2 ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     width=points[1].x-points[0].x + 1;
+     height=points[1].y-points[0].y + 1;
+     gdk_draw_rectangle(*ppixmap,gc,TRUE,
+ 		       points[0].x,points[0].y,width,height);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_bargraph_draw(GtkWidget *widget,           /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    int barwidth,                    /* bar width. 0=compute based on window size */    
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height,x,y,barheight;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     for (i=0; i<n ; i++) {
+       points[1].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[1].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       points[0].x = points[1].x;
+       points[0].y = height-1;
+ 
+       x = .5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       y = .5+((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       if (!barwidth) barwidth  = (width/(n+1))-1;
+       barwidth = barwidth > 5 ? 5 : barwidth;
+       barwidth = barwidth < 1 ? 1 : barwidth;
+       barheight = height-1 - y;
+       /* gdk_draw_lines(*ppixmap,gc,points,2); */
+       gdk_draw_rectangle(*ppixmap,gc,TRUE,x,y,barwidth,barheight);
+ 
+     }
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ 
+ 
+ /* Create a new backing pixmap of the appropriate size */
+ static gint
+ configure_event (GtkWidget *widget, GdkEventConfigure *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     if (*ppixmap) gdk_pixmap_unref(*ppixmap);
+     *ppixmap = gdk_pixmap_new(widget->window,
+ 			    widget->allocation.width,
+ 			    widget->allocation.height,
+ 			    -1);
+     gdk_draw_rectangle (*ppixmap,
+ 			widget->style->white_gc,
+ 			TRUE,
+ 			0, 0,
+ 			widget->allocation.width,
+ 			widget->allocation.height);
+   }
+   return TRUE;
+ }
+ 
+ 
+ 
+ /* Redraw the screen from the backing pixmap */
+ static gint
+ expose_event (GtkWidget *widget, GdkEventExpose *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     gdk_draw_pixmap(widget->window,
+ 		    widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		    *ppixmap,
+ 		    event->area.x, event->area.y,
+ 		    event->area.x, event->area.y,
+ 		    event->area.width, event->area.height);
+   }
+ 
+   return FALSE;
+ }
+ 
+ 
+ 
+ 
+ 
+ GtkWidget *gpk_plot_new(int width, int height)
+ {
+   GtkWidget *pixmapbox;
+    
+   pixmapbox = gtk_drawing_area_new();
+   gtk_drawing_area_size(GTK_DRAWING_AREA(pixmapbox),width,height);
+   gtk_signal_connect (GTK_OBJECT (pixmapbox), "expose_event",
+ 		      (GtkSignalFunc) expose_event, NULL);
+   gtk_signal_connect (GTK_OBJECT(pixmapbox),"configure_event",
+ 		      (GtkSignalFunc) configure_event, NULL);
+   gtk_widget_set_events (pixmapbox, GDK_EXPOSURE_MASK);
+ 
+   if (num_plotwindows < max_plotwindows) {
+     pixmapboxes[num_plotwindows] = pixmapbox;
+     pixmaps[num_plotwindows] = NULL;
+     num_plotwindows ++;
+   } else {
+     g_print("gtk_plotarea_new(): exceeded maximum of 10 plotarea windows\n");
+   }
+ 
+   return pixmapbox;
+ }
+ 
+ 
+ #endif
diff -r -c -N encoder/gpkplotting.h lame3.13/gpkplotting.h
*** encoder/gpkplotting.h	Wed Dec 31 17:00:00 1969
--- lame3.13/gpkplotting.h	Wed Apr 28 20:04:35 1999
***************
*** 0 ****
--- 1,27 ----
+ #include <gtk/gtk.h>
+ 
+ /* allocate a graphing widget */
+ GtkWidget *gpk_plot_new(int width,int height);
+ 
+ /* graph a function in the graphing widged */
+ void gpk_graph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title,GdkColor *color);
+ 
+ /* draw a rectangle in the graphing widget */
+ void gpk_rectangle_draw(GtkWidget *widget,                  /* plot on this widged */
+ 			gdouble xcord[2], gdouble ycord[2], /* corners */
+ 			gdouble xmn,gdouble ymn,            /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color);                         /* color to use */
+ 
+ /* make a bar graph in the graphing widged */
+ void gpk_bargraph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title, int bwidth,GdkColor *color);
+ 
+ /* set forground color  */
+ void setcolor(GtkWidget *widget, GdkColor *color,int red,int green,int blue);
+ 
diff -r -c -N encoder/gtkanal.c lame3.13/gtkanal.c
*** encoder/gtkanal.c	Wed Dec 31 17:00:00 1969
--- lame3.13/gtkanal.c	Tue Jun 22 00:01:44 1999
***************
*** 0 ****
--- 1,1190 ----
+ #ifdef HAVEGTK
+ #include <math.h>
+ #include <gtk/gtk.h>
+ #include "gpkplotting.h"
+ #include "common.h"
+ #include "encoder.h"
+ #include "l3psy.h"
+ #include "gtkanal.h"
+ #include "version.h"
+ 
+ /* global variables for the state of the system */
+ static gint idle_keepgoing;        /* processing of frames is ON */
+ static gint idle_count_max;   /* number of frames to process before plotting */
+ static gint idle_count;       /* pause & plot when idle_count=idel_count_max */
+ static gint idle_finish=0;      /* process all frames, finish mp3 file and exit */
+ static gint idle_back = 0;     /* set when we are displaying the old data */
+ static int mp3done = 0;         /* last frame has been read */
+ static GtkWidget *frameprogress; /* progress bar */ 
+ static GtkWidget *framecounter;  /* progress counter */ 
+ 
+ /* main window */
+ GtkWidget *window;
+ /* Backing pixmap for drawing areas */
+ GtkWidget *pcmbox;       /* PCM data plotted here */
+ GtkWidget *winbox;       /* mpg123 synthesis data plotted here */
+ GtkWidget *enerbox[2];   /* spectrum, gr=0,1 plotted here */
+ GtkWidget *mdctbox[2];   /* mdct coefficients gr=0,1 plotted here */
+ GtkWidget *headerbox;    /* mpg123 header info shown here */
+ 
+ plotting_data *pinfo;
+ plotting_data Pinfo[NUMPINFO];
+ 
+ struct gtkinfostruct {
+   int totalframes;        /* total number of frames in mp3 file */
+   int filetype;           /* input file type 0=WAV, 1=MP3 */
+   int msflag;             /* toggle between L&R vs M&S PCM data display */
+   int chflag;             /* toggle between L & R channels */
+   int kbflag;             /* toggle between wave # and barks */
+   int flag123;            /* show mpg123 frame info, OR ISO encoder frame info */
+   int gpsycho;            /* TRUE if using gpsycho model */
+   double avebits;         /* running average bits per frame */
+   int approxbits;         /* (approx) bits per frame */
+   int maxbits;            /* max bits per frame used so far*/
+   int totemph;            /* total of frames with de-emphasis */
+   int totms;              /* total frames with ms_stereo */
+   int totis;              /* total frames with i_stereo */
+   int totshort;           /* total granules with short blocks */
+   int totmix;             /* total granules with mixed blocks */
+   int pupdate;            /* plot while processing, or only when needed */
+ } gtkinfo;
+ 
+ 
+ 
+ 
+ 
+ void plot_frame()
+ {
+   int i,j,n,ch,gr,grtemp;
+   gdouble *xcord,*ycord;
+   gdouble xmx,xmn,ymx,ymn;
+   double *data,*data2,*data3;
+   char title2[80];
+   char *title;
+   plotting_data *pplot;
+   plotting_data *pplot1;
+   plotting_data *pplot2;
+   plotting_data *ptemp;
+ 
+   double en,samp;
+   static int firstcall=1;
+   static GdkColor *barcolor,*color,*grcolor[2];
+   static GdkColor yellow,gray,cyan,magenta,orange,pink,red,green,blue,black,oncolor,offcolor;
+   int blocktype[2][2];
+   int headbits;
+   int mode_gr = 2;
+ 
+   /* find the delay between the frame we are plotting and the frame for
+    * which MPG123 finally produced some output.  */
+   /*
+   { int mpglag=0;
+   for (i=0; i<=(pinfo->mpglag); i++ ) {
+     if ((pinfo-i)->mpglag > mpglag ) mpglag = (pinfo-i)->mpglag;
+   }
+   pplot2 = pinfo-mpglag;
+   }
+   */
+   { int mpglag=0;
+   for (i=0; i<(READ_AHEAD); i++ ) {
+     if ((pinfo-i)->mpglag == (pinfo-i-1)->mpglag) {
+       mpglag = (pinfo-i)->mpglag;
+       break;
+     }
+   }
+   pplot2 = pinfo-mpglag;
+   }
+ 
+ 
+ 
+ 
+ 
+   /* however, the PCM data is delayed by 528 samples in the encoder filterbanks.
+    * We added another 1152-528 delay to this so the PCM data is *exactly* one 
+    * frame behind the header & MDCT information */
+   pplot1 =pplot2 +1;                   /* back one frame for header info, MDCT */
+   pplot = pinfo;                       /* reference frame pcm input, FFT's */
+ 
+   /* allocate these GC's only once */
+   if (firstcall) {
+     firstcall=0;
+     /*    grcolor[0]=&magenta; */
+     grcolor[0]=&blue;
+     grcolor[1]=&green;
+     barcolor = &gray;
+ 
+     setcolor(headerbox,&oncolor,255,0,0);
+     setcolor(headerbox,&offcolor,175,175,175);
+     setcolor(pcmbox,&red,255,0,0);
+     setcolor(pcmbox,&pink,255,0,255);
+     setcolor(pcmbox,&magenta,255,0,100);
+     setcolor(pcmbox,&orange,255,127,0);
+     setcolor(pcmbox,&cyan,0,255,255);
+     setcolor(pcmbox,&green,0,255,0);
+     setcolor(pcmbox,&blue,0,0,255);
+     setcolor(pcmbox,&black,0,0,0);
+     setcolor(pcmbox,&gray,100,100,100);
+     setcolor(pcmbox,&yellow,255,255,0);
+ 
+   }
+ 
+   /*******************************************************************
+    * frame header info
+    *******************************************************************/
+   if (pplot1->sampfreq)
+     samp=pplot1->sampfreq;
+   else samp=1;
+   
+   headbits = 32 + ((pplot1->stereo==2) ? 256 : 136);
+   gtkinfo.approxbits = (pplot1->bitrate*1000*1152.0/samp) - headbits;
+   /*font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");*/
+   sprintf(title2,"%3.1fkHz %ikbs ",samp/1000,pplot1->bitrate);
+   gtk_text_freeze (GTK_TEXT(headerbox));
+   gtk_text_backward_delete(GTK_TEXT(headerbox),
+ 			    gtk_text_get_length(GTK_TEXT(headerbox)));
+   gtk_text_set_point(GTK_TEXT(headerbox),0);
+   gtk_text_insert(GTK_TEXT(headerbox),NULL,&oncolor,NULL,title2, -1);
+   title = " mono ";
+   if (2==pplot1->stereo) title = pplot1->js ? " jstereo " : " stereo ";
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title, -1);
+   color = pplot1->ms_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"ms_stereo ", -1);
+   color = pplot1->i_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"i_stereo ", -1);
+   color = pplot1->emph ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"emph ", -1);
+   color = pplot1->scfsi ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"scfsi ", -1);
+   if (gtkinfo.filetype) 
+     sprintf(title2," mdb=%i %i/NA",pplot1->maindata,pplot1->totbits);
+   else
+     sprintf(title2," mdb=%i   %i/%i",
+ 	  pplot1->maindata,pplot1->totbits,pplot->resvsize);
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title2, -1);
+   gtk_text_thaw (GTK_TEXT(headerbox));
+ 
+ 
+   ch = gtkinfo.chflag;
+   /*******************************************************************
+    * block type
+    *******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) 
+     if (gtkinfo.flag123) 
+       blocktype[gr][ch]=pplot1->mpg123blocktype[gr][ch];
+     else blocktype[gr][ch]=pplot->blocktype[gr][ch]; 
+ 
+   
+   /*******************************************************************
+    * draw the PCM data *
+    *******************************************************************/
+   n = 1600;  /* PCM frame + FFT window:   224 + 1152 + 224  */
+   xcord = g_malloc(n*sizeof(gdouble));
+   ycord = g_malloc(n*sizeof(gdouble));
+ 
+ 
+   if (gtkinfo.msflag) 
+     title=ch ? "Side Channel" :  "Mid Channel";
+   else 
+     title=ch ? "Right Channel" : "Left Channel";
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1;
+ 
+   /*  0  ... 224      draw in black, connecting to 224 pixel
+    * 1375 .. 1599     draw in black  connecting to 1375 pixel
+    * 224 ... 1375     MP3 frame.  draw in blue
+    */
+ 
+   /* draw the title */
+   gpk_graph_draw(pcmbox,0,xcord,ycord,xmn,ymn,xmx,ymx,1,title,
+ 		 &black);
+ 
+ 
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < mode_gr ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+   /* bars representing FFT windows */
+   xcord[0] = 0;       ycord[0] = ymn+3000;
+   xcord[1] = 1024-1;  ycord[1] = ymn+1000;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[0]);
+   xcord[0] = 576;          ycord[0] = ymn+2000;
+   xcord[1] = 576+1024-1;   ycord[1] = ymn;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[1]);
+ 
+ 
+   /* plot PCM data */
+   for (i=0; i<n; i++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot->pcmdata[0][i]-pplot->pcmdata[1][i]) : 
+       .5*(pplot->pcmdata[0][i]+pplot->pcmdata[1][i]);
+     else 
+       ycord[i]=pplot->pcmdata[ch][i];
+   }
+ 
+   /* skip plot if we are doing an mp3 file */
+   if (!gtkinfo.filetype) {
+   n = 224;    /* number of points on end of blue part */
+   /* data left of frame */
+   gpk_graph_draw(pcmbox,n+1,xcord,ycord,xmn,ymn,xmx,ymx,0,title,&black);
+   /* data right of frame */
+   gpk_graph_draw(pcmbox,n+1,&xcord[1152+n-1],&ycord[1152+n-1],
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+   /* the actual frame */
+   gpk_graph_draw(pcmbox,1152,&xcord[n],&ycord[n],xmn,ymn,xmx,ymx,0,title,&black);
+   }
+ 
+ 
+   /*******************************************************************/
+   /* draw the PCM re-synthesis data */
+   /*******************************************************************/
+   n = 1152;
+ 
+   sprintf(title2,"Re-synthesis  ms_ratio=%3.2f  %3.2f",
+ 	  pplot->ms_ratio[0],pplot->ms_ratio[1]);
+   title=title2;
+ 
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1; 
+   gpk_graph_draw(winbox,0,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,1,title,&black);
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < 2 ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+ 
+ 
+ 
+   n = 224;
+   for (j=1152-n,i=0; i<=n; i++,j++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot1->pcmdata2[0][j]-
+                           pplot1->pcmdata2[1][j]) : 
+       .5*(pplot1->pcmdata2[0][j]+pplot1->pcmdata2[1][j]);
+     else 
+       ycord[i]=pplot1->pcmdata2[ch][j];
+   }
+   gpk_graph_draw(winbox,n+1,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+   n = 1152;
+   for (i=0; i<n; i++) {
+     xcord[i] = i+224;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot2->pcmdata2[0][i]-pplot2->pcmdata2[1][i]) : 
+       .5*(pplot2->pcmdata2[0][i]+pplot2->pcmdata2[1][i]);
+     else 
+       ycord[i]=pplot2->pcmdata2[ch][i];
+   }
+   gpk_graph_draw(winbox,n,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+ 
+ 
+ 
+ 
+   /*******************************************************************/
+   /* draw the MDCT energy spectrum */
+   /*******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) {
+     int bits;
+     char *blockname;
+     char label[80],label2[80];
+     switch (blocktype[gr][ch]) {
+     case 0: blockname = "normal"; 	break;
+     case 1:  	blockname = "start";	break;
+     case 2: 	blockname = "short"; 	break;
+     case 3: 	blockname = "end"; 	break;
+     }
+     strcpy(label,blockname);
+     if (pplot1->mixed[gr][ch]) strcat(label,"(mixed)");
+     if (blocktype[gr][ch]==2) {
+       sprintf(label2,
+ 	      "%i %i%i%i",
+ 	      pplot1->scalefac_scale[gr][ch],
+               pplot1->sub_gain[gr][ch][0],
+ 	      pplot1->sub_gain[gr][ch][1],
+ 	      pplot1->sub_gain[gr][ch][2]);
+       strcat(label,label2);
+     }else{
+       sprintf(label2,"%i",pplot1->scalefac_scale[gr][ch]);
+       strcat(label,label2);
+     }
+ 
+     
+     
+     
+     n = 576;
+     if (gtkinfo.flag123) {
+       data = pplot1->mpg123xr[gr][0];
+       data2 = pplot1->mpg123xr[gr][1];
+     }else{
+       data = pplot->xr[gr][0];
+       data2 = pplot->xr[gr][1];
+     }
+     
+ 
+ 
+     ymn=9e20;
+     ymx=-9e20;
+     for (i=0; i<n; i++) {
+       double coeff;
+       xcord[i] = i+1;
+       if (gtkinfo.msflag){
+ 	coeff = ch ?  .5*(data[i]-data2[i]) : .5*(data[i]+data2[i]) ;
+       }else{
+ 	coeff = ch ? data2[i] : data[i];
+       }
+       ycord[i]=coeff*coeff*1e10;
+       ycord[i] = log10( MAX( ycord[i],(double) 1)); 
+       ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+       ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+     }
+     /*  print the min/max
+ 	sprintf(title2,"MDCT%1i %5.2f %5.2f  bits=%i",gr,ymn,ymx,
+ 	pplot1->mainbits[gr][ch]);
+     */
+     if (gtkinfo.flag123) bits=pplot1->mainbits[gr][ch];
+     else bits=pplot->LAMEmainbits[gr][ch];
+     
+     
+     sprintf(title2,"MDCT%1i(%s) bits=%i q=%i n=%3.1f",gr,label,bits,
+ 	      pplot1->qss[gr][ch]-210,pplot->noise[gr][ch]*1e6);
+     
+     xmn = 1;
+     xmx = n;
+     ymn=0;
+     ymx=11;
+     gpk_bargraph_draw(mdctbox[gr],n,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+   }
+   
+ 
+ 
+   
+   /*******************************************************************
+    * draw the psy model energy spectrum (k space) 
+    * l3psy.c computes pe, en, thm for THIS granule.  
+    * To encode, ISO uses (bug): en,thm from last granule.  
+    *                            pe from this granule
+    * gpsycho model corrects this
+    *******************************************************************/
+   if (gtkinfo.msflag || gtkinfo.filetype) {
+     /* erase everything */
+     gpk_bargraph_draw(enerbox[0],0,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1," ",0,barcolor);
+     gpk_bargraph_draw(enerbox[1],0,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1," ",0,barcolor);
+   }
+   else if (gtkinfo.kbflag){
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+       n = HBLKSIZE; /* only show half the spectrum */
+       if (gtkinfo.gpsycho)
+ 	{ptemp=pplot;  grtemp=gr;}
+       else {
+ 	/* display info from one granule behind */
+ 	if (gr==0) {ptemp=(pplot+1); grtemp=1;}
+ 	if (gr==1) {ptemp=pplot;  grtemp=0;}
+       }
+       data = &ptemp->energy[grtemp][ch][0];
+       
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       for (en=0 , j=0; j<BLKSIZE ; j++) 
+ 	en += ptemp->energy[grtemp][ch][j];
+ 
+       sprintf(title2,"FFT%1i  pe=%4.1fK  en=%5.2e ",gr,
+ 	      ptemp->pe[grtemp][ch]/1000,en);
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n;
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+       
+     }
+   }else{
+     /*******************************************************************
+      * draw the psy model energy spectrum (scalefactor bands)
+      * ISO model (because of bugs) uses:  
+      *        pe,en,thm,energy delayed 1 granule
+      *******************************************************************/
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+       if (gtkinfo.gpsycho)
+ 	{ ptemp=pplot;  grtemp=gr;}
+       else {
+ 	if (gr==0) {ptemp=(pplot+1); grtemp=1;}
+ 	if (gr==1) {ptemp=pplot;  grtemp=0;}
+       }
+       
+       if (blocktype[gr][ch]==2) {
+ 	n = 3*SBMAX_s; 
+ 	data = &ptemp->en_s[grtemp][ch][0];
+ 	data2 = &ptemp->thr_s[grtemp][ch][0];
+ 	data3 = &pplot->xfsf_s[grtemp][ch][0];
+       } else {
+ 	n = SBMAX_l; 
+ 	data = &ptemp->en[grtemp][ch][0];
+ 	data2 = &ptemp->thr[grtemp][ch][0];
+ 	data3 = &pplot->xfsf[grtemp][ch][0];
+       }
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+ 
+ 
+ 
+ 
+       /* en = max energy difference amoung the 3 short FFTs for this granule */
+       en = pplot->ers[gr][ch];
+       sprintf(title2,"FFT%1i pe=%4.1fK del_en=%3.1f over=%i",gr,
+ 	      ptemp->pe[grtemp][ch]/1000,en,pplot->over[gr][ch]);
+ 
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n+1; /* a little extra because of the bar thickness */
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+ 
+ 
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data3[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,&red);  
+ 
+       
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1 + (.25*n)/SBMAX_l;
+ 	ycord[i] = log10( MAX( data2[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,grcolor[gr]);
+     }
+   }
+ }
+ 
+ 
+ 
+ static void update_progress()
+ {    
+   char label[80];
+   sprintf(label,"Frame:%4i/%4i  %6.2fs",
+ 	 pinfo->frameNum,gtkinfo.totalframes, pinfo->frametime);
+   gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) pinfo->frameNum);
+   gtk_label_set_text(GTK_LABEL(framecounter),label);
+ }
+ 
+ 
+ 
+ static void analyze()
+ {
+     if ( idle_keepgoing) {
+       idle_count = 0;
+       idle_count_max=0;
+       idle_keepgoing=0;
+       idle_finish=0;
+     }
+     plot_frame();   
+     update_progress(); 
+ }
+ 
+ static void plotclick( GtkWidget *widget, gpointer   data )
+ {   analyze(); }
+ 
+ 
+ 
+ 
+ static int frameadv1( GtkWidget *widget, gpointer   data )
+ {
+   int i;
+   if (idle_keepgoing ){
+     if (idle_back) {
+       /* frame displayed is the old frame.  to advance, just swap in new frame */
+       idle_back--;
+       pinfo = &Pinfo[READ_AHEAD+idle_back];
+     }else{
+       /* advance the frame by reading in a new frame */
+       if (mp3done) { 
+ 	/* dont try to read any more frames, and quit if "finish MP3" was selected */
+ 	if (idle_finish) gtk_main_quit();
+ 	idle_count_max=0; 
+       } else {
+ 	/* read in the next frame */
+ 	for (i=NUMPINFO-1 ; i>0 ; i--)
+ 	  memcpy(&Pinfo[i],&Pinfo[i-1],sizeof(plotting_data));
+ 	pinfo = &Pinfo[0];
+ 	if (gtkinfo.filetype) {
+           /* analyzing a .mp3 file */
+ 	  pinfo->num_samples = readframe() ;
+ 	}else{
+ 	  pinfo->num_samples = makeframe();
+ 	}
+ 
+ 
+ 	if (pinfo->sampfreq) 
+ 	  pinfo->frametime = (pinfo->frameNum-1)*1152.0/pinfo->sampfreq;
+ 	else pinfo->frametime=0;
+ 	if (!pinfo->num_samples) {
+ 	  mp3done = 1; 
+ 	  if (idle_finish) gtk_main_quit();
+ 	}
+ 
+ 	pinfo->totbits = 0;
+ 	{ int gr,ch;
+ 	for (gr = 0 ; gr < 2 ; gr ++) 
+ 	  for (ch = 0 ; ch < 2 ; ch ++) {
+ 	    gtkinfo.totshort += (pinfo->mpg123blocktype[gr][ch]==2);
+ 	    gtkinfo.totmix  += !(pinfo->mixed[gr][ch]==0);
+ 	    pinfo->totbits += pinfo->mainbits[gr][ch];
+ 	  }
+ 	}
+ 	if (pinfo->frameNum > 1) /* start averaging at frame = 2*/
+ 	  gtkinfo.avebits = (gtkinfo.avebits*((pinfo->frameNum)-2)
+ 	  + pinfo->totbits ) /(pinfo->frameNum-1);
+ 
+ 	gtkinfo.maxbits=MAX(gtkinfo.maxbits,pinfo->totbits);
+ 	gtkinfo.totemph += !(pinfo->emph==0);
+ 	gtkinfo.totms   += !(pinfo->ms_stereo==0);
+ 	gtkinfo.totis   += !(pinfo->i_stereo==0);
+ 
+ 	pinfo = &Pinfo[READ_AHEAD];
+       }
+     }
+ 
+     idle_count++;
+     if (gtkinfo.pupdate) plot_frame();
+     update_progress();
+     if ((idle_count>=idle_count_max) && (! idle_finish)) analyze();
+   }
+   return 1;
+ }
+ 
+ 
+ static void frameadv( GtkWidget *widget, gpointer   data )
+ {
+     int adv;
+ 
+     if (!strcmp((char *) data,"-1")) {
+       /* ignore if we've already gone back as far as possible */
+       if (pinfo->frameNum==1 || (idle_back==NUMBACK)) return;  
+       idle_back++;
+       pinfo = &Pinfo[READ_AHEAD+idle_back];
+       analyze();
+       return;
+     }
+ 
+ 
+     adv = 1;
+     if (!strcmp((char *) data,"1")) adv = 1;
+     if (!strcmp((char *) data,"10")) adv = 10;
+     if (!strcmp((char *) data,"100")) adv = 100;
+     if (!strcmp((char *) data,"finish")) idle_finish = 1;
+ 
+ 
+     if (idle_keepgoing) {
+       /* already running - que up additional frame advance requests */
+       idle_count_max += adv; 
+     }
+     else {
+       /* turn on idleing */
+       idle_count_max = adv;
+       idle_count = 0;
+       idle_keepgoing = 1;
+     }
+ }
+ 
+ 
+ 
+ 
+ /* another callback */
+ static void delete_event( GtkWidget *widget,
+                    GdkEvent  *event,
+ 		   gpointer   data )
+ {
+     gtk_main_quit ();
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ static void channel_option (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   option = (int) data;
+   switch (option) {
+   case 1:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0; 
+     break;
+   case 2:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=1; 
+     break;
+   case 3:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=0; 
+     break;
+   case 4:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=1; 
+   }
+   analyze();
+ }
+ static void spec_option (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   option = (int) data;
+   switch (option) {
+   case 1:
+     gtkinfo.kbflag=0;
+     break;
+   case 2:
+     gtkinfo.kbflag=1;
+     break;
+   case 3:
+     gtkinfo.flag123=0;
+     break;
+   case 4:
+     gtkinfo.flag123=1;
+     break;
+   case 5:
+     gtkinfo.pupdate=1;
+     break;
+   case 6:
+     gtkinfo.pupdate=0;
+     break;
+   }
+   analyze();
+ }
+ 
+ 
+ 
+ static void text_window (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   GtkWidget *hbox,*vbox,*button,*box;
+   GtkWidget *textwindow,*vscrollbar;
+   char text[80];
+ 
+   option = (int) data;
+   
+   textwindow = gtk_window_new(GTK_WINDOW_DIALOG);
+   gtk_signal_connect_object (GTK_OBJECT (window), "delete_event",
+ 		      GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 		      GTK_OBJECT (textwindow));
+ 
+   gtk_container_set_border_width (GTK_CONTAINER (textwindow), 0);
+   vbox = gtk_vbox_new(FALSE,0);
+   hbox = gtk_hbox_new(FALSE,0);
+ 
+   button = gtk_button_new_with_label ("close");
+   gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+ 			     GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 			     GTK_OBJECT (textwindow));
+ 
+   box = gtk_text_new (NULL, NULL);
+   gtk_text_set_editable (GTK_TEXT (box), FALSE);
+   vscrollbar = gtk_vscrollbar_new (GTK_TEXT(box)->vadj);
+ 
+ 
+   switch (option) {
+   case 0: 
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Documentation");
+     gtk_widget_set_usize(box,450,500); 
+     gtk_text_set_word_wrap(GTK_TEXT(box),TRUE);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"Frame header information: "\
+ 		"First the bitrate, sampling frequency and mono, stereo or jstereo "\
+ 		"indicators are displayed .  If the bitstream is jstereo, then mid/side "\
+ 		"stereo or intensity stereo may be on (indicated in red).  If "\
+ 		"de-emphasis is used, this is also indicated in red.  The mdb value is "\
+ 		"main_data_begin.  The encoded data starts this many bytes *before* the "\
+ 		"frame header.  A large value of mdb means the bitstream has saved some "\
+ 		"bits into the reservoir, which it may allocate for some future frame. "\
+ 		"The two numbers after mdb are the size (in bits) used to encode the "\
+ 		"MDCT coefficients for this frame, followed byt the size of the bit "\
+ 		"resevoir before encoding this frame.  The maximum frame size and a "\
+ 		"running average are given in the Stats pull down menu.  A large "\
+ 		"maximum frame size indicates the bitstream has made use of the bit "\
+ 		"reservoir. \n\n",-1);
+ 
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM data (top graph): "\
+ 		"The PCM data is plotted in black.  The layer3 frame is divided into 2 "\
+ 		"granules of 576 samples (marked with yellow vertical lines).  In the "\
+ 		"case of normal, start and stop blocks, the MDCT coefficients for each "\
+ 		"granule are computed using a 1152 sample window centered over the "\
+ 		"granule.  In the case of short blocks, the granule is further divided "\
+ 		"into 3 blocks of 192 samples (also marked with yellow vertical lines)."\
+ 		"The MDCT coefficients for these blocks are computed using 384 sample "\
+ 		"windows centered over the 192 sample window.  (This info not available "\
+ 		"when analyzing .mp3 files.)  For the psycho-acoustic model, a windowed "\
+ 		"FFT is computed for each granule.  The range of these windows "\
+ 		"is denoted by the blue and green bars.\n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM re-synthesis data (second graph): "\
+ 		"Same as the PCM window described above.  The data displayed is the "\
+ 		"result of encoding and then decoding the original sample. \n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"MDCT windows: "\
+ 		"Shows the energy in the MDCT spectrum for granule 0 (left window) "\
+ 		"and granule 1 (right window).  The text also shows the blocktype "\
+ 		"used, the number of bits used to encode the coefficients and the "\
+ 		"number of extra bits allocated from the reservoir.  The MDCT pull down "\
+ 		"window will toggle between the original unquantized MDCT coefficients "\
+ 		"and the compressed (quantized) coefficients.\n\n",-1); 
+  
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"FFT window: "\
+ 		"The gray bars show the energy in the FFT spectrum used by the "\
+ 		"psycho-acoustic model.  Granule 0 is in the left window, granule 1 in "\
+ 		"the right window.  The green and blue bars show how much distortion is "\
+ 		"allowable, as computed by the psycho-acoustic model. The red bars show "\
+ 		"the actual distortion after encoding.  There is one FFT for each "\
+ 		"granule, computed with a 1024 Hann window centered over the "\
+ 		"appropriate granule.  (the range of this 1024 sample window is shown "\
+ 		"by the blue and green bars in the PCM data window).  The Spectrum pull "\
+ 		"down window will toggle between showing the energy in equally spaced "\
+ 		"frequency domain and the scale factor bands used by layer3.  Finally, "\
+ 		"the perceptual entropy, total energy and number of scalefactor bands "\
+ 		"with audible distortion is shown.  (This info not available when "\
+ 		"analyzing .mp3 files.)",-1);
+ 
+     break;
+   case 1:
+ 	/* Set the about box information */
+     gtk_window_set_title (GTK_WINDOW (textwindow), "About");
+     gtk_widget_set_usize(box,350,260);
+ 
+     sprintf(text,"LAME version %s \nwww.sulaco.org/mp3\n\n",get_lame_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+ 
+     sprintf(text,"psycho-acoustic model:  GPSYCHO version %s \nMark Taylor\n\n",get_psy_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     sprintf(text,"frame analyzer: MP3x version %s  \nMark Taylor\n\n",get_mp3x_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		    "decoder:  mpg123/mpglib  .59q  \nMichael Hipp \nwww-ti.informatik.uni-tuebingen.de/~hippm/mpg123.html\n\n",-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+     "Encoder, decoder & psy-models based on ISO\ndemonstration source. ",-1);
+     break;
+ 
+   case 2:
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Statistics");
+     gtk_widget_set_usize(box,350,260);
+     sprintf(text,"frames processed so far: %i \n",Pinfo[0].frameNum);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"granules processed so far: %i \n\n",4*Pinfo[0].frameNum);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (approximate): %i\n",
+ 	    gtkinfo.approxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (from LAME): %i\n",
+ 	    4*Pinfo[0].mean_bits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"bitsize of largest frame: %i \n",gtkinfo.maxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"average bits/frame: %3.1f \n\n",gtkinfo.avebits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"ms_stereo frames: %i \n",gtkinfo.totms);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"i_stereo frames: %i \n",gtkinfo.totis);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"de-emphasis frames: %i \n",gtkinfo.totemph);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"short block granules: %i \n",gtkinfo.totshort);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mixed block granules: %i \n",gtkinfo.totmix);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     break;
+   }
+ 
+ 
+ 
+   gtk_widget_show (vscrollbar);
+   gtk_widget_show (box);
+   gtk_widget_show (vbox);
+   gtk_widget_show (hbox);
+   gtk_widget_show (button);
+ 
+   gtk_box_pack_start (GTK_BOX(hbox), box, FALSE, TRUE, 0);
+   gtk_box_pack_start(GTK_BOX(hbox), vscrollbar, FALSE, FALSE, 0);
+   gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 0);
+   gtk_box_pack_end (GTK_BOX (vbox), button, FALSE, TRUE, 0);
+   gtk_container_add (GTK_CONTAINER (textwindow), vbox); 
+   gtk_widget_show(textwindow);
+ 
+ }
+ 
+ 
+ 
+ 
+ /* #include <strings.h>*/
+ 
+ 
+ /* This is the GtkItemFactoryEntry structure used to generate new menus.
+    Item 1: The menu path. The letter after the underscore indicates an
+            accelerator key once the menu is open.
+    Item 2: The accelerator key for the entry
+    Item 3: The callback function.
+    Item 4: The callback action.  This changes the parameters with
+            which the function is called.  The default is 0.
+    Item 5: The item type, used to define what kind of an item it is.
+            Here are the possible values:
+ 
+            NULL               -> "<Item>"
+            ""                 -> "<Item>"
+            "<Title>"          -> create a title item
+            "<Item>"           -> create a simple item
+            "<CheckItem>"      -> create a check item
+            "<ToggleItem>"     -> create a toggle item
+            "<RadioItem>"      -> create a radio item
+            <path>             -> path of a radio item to link against
+            "<Separator>"      -> create a separator
+            "<Branch>"         -> create an item to hold sub items
+            "<LastBranch>"     -> create a right justified branch 
+ */
+ 
+ static GtkItemFactoryEntry menu_items[] = {
+   {"/_File",         NULL,         NULL, 0, "<Branch>"},
+   /*
+   {"/File/_New",     "<control>N", print_hello, 0, NULL},
+   {"/File/_Open",    "<control>O", print_hello, 0, NULL},
+   {"/File/_Save",    "<control>S", print_hello, 0, NULL},
+   {"/File/Save _As", NULL,         NULL, 0, NULL},
+   {"/File/sep1",     NULL,         NULL, 0, "<Separator>"},
+   {"/File/Quit",     "<control>Q", gtk_main_quit, 0, NULL}, 
+   */
+   {"/File/_Quit",     "<control>Q", delete_event, 0, NULL}, 
+ 
+   {"/_Plotting",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Plotting/_While advancing" ,  NULL,  spec_option, 5, NULL},
+   {"/Plotting/_After advancing",  NULL,  spec_option, 6, NULL},
+ 
+   {"/_Channel",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Channel/show _Left" ,  NULL,  channel_option, 1, NULL},
+   {"/Channel/show _Right",  NULL,  channel_option, 2, NULL},
+   {"/Channel/show _Mid" ,   NULL,  channel_option, 3, NULL},
+   {"/Channel/show _Side",   NULL,  channel_option, 4, NULL},
+ 
+   {"/_Spectrum",                   NULL,  NULL, 0, "<Branch>"},
+   {"/Spectrum/_Scalefactor bands",  NULL,  spec_option, 1, NULL},
+   {"/Spectrum/_Wave number",        NULL,  spec_option, 2, NULL},
+ 
+   {"/_MDCT",                         NULL,  NULL, 0, "<Branch>"},
+   {"/MDCT/_Original",               NULL,  spec_option, 3, NULL},
+   {"/MDCT/_Compressed",             NULL,  spec_option, 4, NULL},
+ 
+   {"/_Stats",                         NULL,  NULL, 0, "<Branch>"},
+   {"/Stats/_Show",               NULL,  text_window, 2, NULL},
+ 
+   {"/_Help",         NULL,         NULL, 0, "<LastBranch>"},
+   {"/_Help/_Documentation",   NULL,   text_window, 0, NULL},
+   {"/_Help/_About",           NULL,   text_window, 1, NULL},
+ };
+ 
+ 
+ static void get_main_menu(GtkWidget *window, GtkWidget ** menubar) {
+   int nmenu_items = sizeof(menu_items) / sizeof(menu_items[0]);
+   GtkItemFactory *item_factory;
+   GtkAccelGroup *accel_group;
+ 
+   accel_group = gtk_accel_group_new();
+ 
+   /* This function initializes the item factory.
+      Param 1: The type of menu - can be GTK_TYPE_MENU_BAR, GTK_TYPE_MENU,
+               or GTK_TYPE_OPTION_MENU.
+      Param 2: The path of the menu.
+      Param 3: A pointer to a gtk_accel_group.  The item factory sets up
+               the accelerator table while generating menus.
+   */
+ 
+   item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<main>", 
+ 				       accel_group);
+ 
+   /* This function generates the menu items. Pass the item factory,
+      the number of items in the array, the array itself, and any
+      callback data for the the menu items. */
+   gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, NULL);
+ 
+   /* Attach the new accelerator group to the window. */
+   gtk_accel_group_attach (accel_group, GTK_OBJECT (window));
+ 
+   if (menubar)
+     /* Finally, return the actual menu bar created by the item factory. */ 
+     *menubar = gtk_item_factory_get_widget(item_factory, "<main>");
+ }
+ 
+ 
+ 
+ 
+ int gtkcontrol(int totalframes,int filetype,char *infile, int gpsycho)
+ {
+     /* GtkWidget is the storage type for widgets */
+     GtkWidget *button;
+     GtkAdjustment *adj;
+     GtkWidget *mbox;        /* main box */
+     GtkWidget *box1;        /* frame control buttons go */
+     GtkWidget *box2;        /* frame counters */
+     GtkWidget *box3;        /* frame header info */
+     GtkWidget *table;       /* table for all the plotting areas */
+     GtkWidget *menubar;
+ 
+     gint tableops,graphx,graphy;
+     char frameinfo[80];
+ 
+     graphx = 500;  /* minimum allowed size of pixmap */
+     graphy = 100;
+ 
+ 
+     /* set some global defaults/variables */
+     gtkinfo.totalframes = totalframes; 
+     gtkinfo.filetype = filetype;
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0;
+     gtkinfo.kbflag=0;
+     gtkinfo.flag123=filetype;
+     gtkinfo.pupdate=0;
+     gtkinfo.avebits = 0;
+     gtkinfo.maxbits = 0;
+     gtkinfo.approxbits = 0;
+     gtkinfo.totemph = 0;
+     gtkinfo.totms = 0;
+     gtkinfo.totis = 0;
+     gtkinfo.totshort = 0;
+     gtkinfo.totmix = 0;
+ 
+     gtkinfo.gpsycho=gpsycho;
+     memset((char *) Pinfo, 0, sizeof(Pinfo));
+     pinfo = &Pinfo[READ_AHEAD];
+ 
+     strcpy(frameinfo,"MP3x: ");
+     strncat(frameinfo,infile,70);
+ 
+     window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+     gtk_window_set_title (GTK_WINDOW (window), frameinfo);
+     gtk_signal_connect (GTK_OBJECT (window), "delete_event",
+ 			GTK_SIGNAL_FUNC (delete_event), NULL);
+     gtk_container_set_border_width (GTK_CONTAINER (window), 0);
+ 
+ 
+     mbox = gtk_vbox_new(FALSE, 0);
+ 
+ 
+     /* layout of mbox */
+     box1 = gtk_hbox_new(FALSE, 0);
+     box2 = gtk_hbox_new(FALSE, 0);
+     box3 = gtk_hbox_new(FALSE, 0);
+     table = gtk_table_new (4, 2, FALSE);
+     tableops = GTK_FILL | GTK_EXPAND | GTK_SHRINK;
+     get_main_menu(window, &menubar);
+ 
+     gtk_box_pack_start(GTK_BOX(mbox), menubar, FALSE, TRUE, 0);
+     gtk_box_pack_end (GTK_BOX (mbox), box1, FALSE, TRUE, 0);
+     gtk_box_pack_end(GTK_BOX (mbox),box2, FALSE, TRUE, 0);
+     gtk_box_pack_start(GTK_BOX (mbox),box3, FALSE, TRUE, 0);
+     gtk_box_pack_start (GTK_BOX (mbox), table, TRUE, TRUE, 0);
+     gtk_container_add (GTK_CONTAINER (window), mbox); 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box3  frame header info */
+     /*********************************************************************/
+     /*
+     headerbox = gtk_label_new(" ");
+     gtk_label_set_justify(GTK_LABEL(headerbox),GTK_JUSTIFY_LEFT); 
+     */
+     headerbox = gtk_text_new (NULL, NULL);
+     gtk_text_set_editable (GTK_TEXT (headerbox), FALSE);
+     gtk_widget_set_usize(headerbox,200,20);
+     gtk_widget_show (headerbox);
+     gtk_box_pack_start(GTK_BOX (box3),headerbox, TRUE, TRUE, 0);
+     
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box2   frame counters  */
+     /*********************************************************************/
+     framecounter = gtk_label_new("");
+     gtk_widget_show(framecounter);
+     gtk_box_pack_start(GTK_BOX (box2),framecounter, FALSE, TRUE, 0);
+ 
+     adj = (GtkAdjustment *) gtk_adjustment_new (0, 1,(gint) totalframes, 0, 0, 0);
+     frameprogress = gtk_progress_bar_new_with_adjustment (adj);
+     /* Set the format of the string that can be displayed in the
+      * trough of the progress bar:
+      * %p - percentage
+      * %v - value
+      * %l - lower range value
+      * %u - upper range value */
+     gtk_progress_set_format_string (GTK_PROGRESS (frameprogress),
+ 	                            "%p%%");
+     gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) 0);
+     gtk_progress_set_show_text (GTK_PROGRESS (frameprogress),TRUE);
+     gtk_widget_show (frameprogress);
+     gtk_box_pack_end (GTK_BOX (box2), frameprogress, FALSE, TRUE, 0);
+ 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box1  buttons along bottom */
+     /*********************************************************************/
+     button = gtk_button_new_with_label ("-1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "-1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+10");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "10");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+100");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "100");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("finish mp3");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "finish");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("stop/plot");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (plotclick), NULL);
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+ 
+     /*********************************************************************/
+     /* stuff in table.  all the plotting windows */
+     /*********************************************************************/
+     pcmbox = gpk_plot_new(graphx,graphy);
+     gtk_table_attach (GTK_TABLE(table),pcmbox,0,2,0,1,tableops,tableops,2,2 );
+     gtk_widget_show (pcmbox);
+ 
+     winbox = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),winbox,0,2,1,2,tableops,tableops,2,2);
+     gtk_widget_show (winbox);
+ 
+ 
+     mdctbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),mdctbox[0],0,1,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[0]);
+ 
+     mdctbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),mdctbox[1],1,2,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[1]);
+ 
+     enerbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),enerbox[0],0,1,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[0]);
+ 
+     enerbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),enerbox[1],1,2,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[1]);
+ 
+ 
+ 
+ 
+     gtk_idle_add((GtkFunction) frameadv1, NULL);
+     gtk_widget_show(menubar); 
+     gtk_widget_show(box2); 
+     gtk_widget_show(box3); 
+     gtk_widget_show(table);
+     gtk_widget_show(box1);
+     gtk_widget_show (mbox);
+     gtk_widget_show (window);     /* show smallest allowed window */
+ 
+     /* make window bigger.   */ 
+     /* now the user will be able to shrink it, if desired */
+     /* gtk_widget_set_usize(mbox,500,500);  */
+     /* gtk_widget_show (window); */     /* show smallest allowed window */
+ 
+ 
+     
+     idle_keepgoing=1;             /* processing of frames is ON */
+     idle_count_max=READ_AHEAD+1;  /* number of frames to process before plotting */
+     idle_count=0;                 /* pause & plot when idle_count=idle_count_max */
+ 
+ 
+     gtk_main ();
+     if (!mp3done) exit(2);
+     return(0);
+ }
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/gtkanal.h lame3.13/gtkanal.h
*** encoder/gtkanal.h	Wed Dec 31 17:00:00 1969
--- lame3.13/gtkanal.h	Mon Jun 21 23:59:02 1999
***************
*** 0 ****
--- 1,104 ----
+ /* 
+ layerIII enc->dec delay:  1056    (observed)
+ layerII  enc->dec dealy:   480    (observed)
+ 
+ 
+ polyphase 256-16             (dec or enc)
+ mdct      256+32  (9*32)     (dec or enc) 
+ total:    512+16
+ 
+ 
+ SYNC_FLUSH calculation:
+ layerIII enc delay:                     528
+ extra bits to display full fft window:  224
+ total:                                  752
+ 
+ layerII sync_flush:  should be 464
+ layerIII sync_flush: should be 752
+ 
+ 
+ Also we would like to remove mpg123 decoder delay with 
+ DECDELAY of -528 (not possible)
+ so delay by a enough to make the total delay 1 whole frame (1152-528)
+ */
+ 
+ 
+ 
+ #define ENCDELAY 528 
+ #define DECDELAY (1152-528)
+ 
+ /* use this delay if you want to also include the data from the FFT window */
+ #define WINDELAY (224 + ENCDELAY)
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ #ifdef HAVEGTK
+ 
+ /* mpg123 ouput is delayed by 1 frame
+  * HOWEVER, sometimes mpg123 doesn't produce a frame until we send the
+  * next frame.  Everytime this happens, bump up MPGLAG.  
+  */
+ #define READ_AHEAD 10              /* number of frames to read ahead */
+ #define MAXMPGLAG READ_AHEAD      /* if the mpg123 lag becomes bigger than this 				     we have to stop */
+ #define NUMBACK 5                 /* number of frames we can back up */
+ #define NUMPINFO (NUMBACK+READ_AHEAD+1)
+ 
+ #define BLKSIZE         1024
+ #define HBLKSIZE        513
+ #define SBMAX_l 21
+ #define SBMAX_s 12
+ 
+ 
+ 
+ typedef struct {
+   int frameNum;           /* current frame number */
+   int num_samples;        /* number of pcm samples read for this frame */
+   double frametime;       /* starting time of frame, in seconds */
+   double pcmdata[2][1152+WINDELAY];
+   double pcmdata2[2][1152+DECDELAY];
+   double energy[2][2][BLKSIZE];
+   double xr[2][2][576];
+   double mpg123xr[2][2][576];
+   double pe[2][2];
+   double ms_ratio[2];
+ 
+   double thr[2][2][SBMAX_l];
+   double en[2][2][SBMAX_l];
+   double thr_s[2][2][3*SBMAX_s];
+   double en_s[2][2][3*SBMAX_s];
+   double ers[2][2];
+ 
+   double xfsf[2][2][SBMAX_l];
+   double xfsf_s[2][2][3*SBMAX_s];
+ 
+   int mpglag;
+   int qss[2][2];
+   int sub_gain[2][2][3];
+   int over[2][2];
+   double noise[2][2];
+   int blocktype[2][2];
+   int scalefac_scale[2][2];
+   int mpg123blocktype[2][2];
+   int mixed[2][2];
+   int mainbits[2][2];
+   int LAMEmainbits[2][2];
+   int stereo,js,ms_stereo,i_stereo,emph,bitrate,sampfreq,maindata;
+   int scfsi,mean_bits,resvsize;
+   int totbits;
+ } plotting_data;
+  
+ 
+ int gtkcontrol(int,int,char *,int);
+ 
+ extern int gtkflag;
+ extern plotting_data *pinfo;
+ 
+ #endif
diff -r -c -N encoder/huffman.c lame3.13/huffman.c
*** encoder/huffman.c	Wed Jan 22 02:43:15 1997
--- lame3.13/huffman.c	Sat Jun 19 19:52:37 1999
***************
*** 1,224 ****
! /**********************************************************************
!  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
!  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
!  *
!  * $Id: huffman.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
!  *
!  * $Log: huffman.c,v $
!  * Revision 1.1  1996/02/14 04:04:23  rowlands
!  * Initial revision
!  *
!  * Received from Mike Coleman
!  **********************************************************************/
! /**********************************************************************
!  *   changes made since last update:                                  *
!  *   date   programmers                comment                        *
!  *27.2.92   F.O.Witte                  (ITT Intermetall)              *
!  *				       email: otto.witte@itt-sc.de    *
!  *				       tel:   ++49 (761)517-125	      *
!  *				       fax:   ++49 (761)517-880	      *
!  *12.6.92   J. Pineda                  Added sign bit to decoder.     *
!  * 08/24/93 M. Iwadare                 Changed for 1 pass decoding.   *
!  *--------------------------------------------------------------------*
!  *  7/14/94 Juergen Koller      Bug fixes in Layer III code           *
!  *********************************************************************/	
  #include <stdlib.h>
  #include "common.h"
  #include "huffman.h"
-      
- HUFFBITS dmask = 1 << (sizeof(HUFFBITS)*8-1);
- unsigned int hs = sizeof(HUFFBITS)*8;
- 
- struct huffcodetab ht[HTN];	/* array of all huffcodtable headers	*/
- 				/* 0..31 Huffman code table 0..31	*/
- 				/* 32,33 count1-tables			*/
- 
- /* read the huffman encode table */
- int read_huffcodetab(fi) 
- FILE *fi;
- {
- 
-   char line[100],command[40],huffdata[40];
-   unsigned int t,i,j,k,nn,x,y,n=0;
-   unsigned int xl, yl, len;
-   HUFFBITS h;
-   int	hsize;
-   
-   hsize = sizeof(HUFFBITS)*8; 
-   do {
-       fgets(line,99,fi);
-   } while ((line[0] == '#') || (line[0] < ' ') );
-   
-   do {    
-     while ((line[0]=='#') || (line[0] < ' ')) {
-       fgets(line,99,fi);
-     } 
- 
-     sscanf(line,"%s %s %u %u %u",command,ht[n].tablename,
- 			         &xl,&yl,&ht[n].linbits);
-     if (strcmp(command,".end")==0)
-       return n;
-     else if (strcmp(command,".table")!=0) {
-       fprintf(stderr,"huffman table %u data corrupted\n",n);
-       return -1;
-     }
-     ht[n].linmax = (1<<ht[n].linbits)-1;
-    
-     sscanf(ht[n].tablename,"%u",&nn);
-     if (nn != n) {
-       fprintf(stderr,"wrong table number %u\n",n);
-       return(-2);
-     } 
  
-     ht[n].xlen = xl;
-     ht[n].ylen = yl;
  
!     do {
!       fgets(line,99,fi);
!     } while ((line[0] == '#') || (line[0] < ' '));
  
!     sscanf(line,"%s %u",command,&t);
!     if (strcmp(command,".reference")==0) {
!       ht[n].ref   = t;
!       ht[n].table = ht[t].table;
!       ht[n].hlen  = ht[t].hlen;
!       if ( (xl != ht[t].xlen) ||
!            (yl != ht[t].ylen)  ) {
!         fprintf(stderr,"wrong table %u reference\n",n);
!         return (-3);
!       };
!       do {
!         fgets(line,99,fi);
!       } while ((line[0] == '#') || (line[0] < ' ') );
!     } 
!     else {
! 	ht[n].ref  = -1;
!       ht[n].table=(HUFFBITS *) calloc(xl*yl,sizeof(HUFFBITS));
!       if (ht[n].table == NULL) {
!          fprintf(stderr,"unsufficient heap error\n");
!          return (-4);
!       }
!       ht[n].hlen=(unsigned char *) calloc(xl*yl,sizeof(unsigned char));
!       if (ht[n].hlen == NULL) {
!          fprintf(stderr,"unsufficient heap error\n");
!          return (-4);
!       }
!       for (i=0; i<xl; i++) {
!         for (j=0;j<yl; j++) {
! 	  if (xl>1) 
!             sscanf(line,"%u %u %u %s",&x, &y, &len,huffdata);
! 	  else 
!             sscanf(line,"%u %u %s",&x,&len,huffdata);
!           h=0;k=0;
! 	  while (huffdata[k]) {
!             h <<= 1;
!             if (huffdata[k] == '1')
!               h++;
!             else if (huffdata[k] != '0'){
!               fprintf(stderr,"huffman-table %u bit error\n",n);
!               return (-5);
!             };
!             k++;
!           };
!           if (k != len) {
!            fprintf(stderr,
!               "warning: wrong codelen in table %u, pos [%2u][%2u]\n",
! 	       n,i,j);
!           };
!           ht[n].table[i*xl+j] = h;
!           ht[n].hlen[i*xl+j] = (unsigned char) len;
! 	  do {
!             fgets(line,99,fi);
!           } while ((line[0] == '#') || (line[0] < ' '));
!         }
!       }
!     }
!     n++;
!   } while (1);
! }
  
! /* read the huffman decoder table */
! int read_decoder_table(fi) 
! FILE *fi;
  {
!   int n,i,nn,t;
!   unsigned int v0,v1;
!   char command[100],line[100];
!   for (n=0;n<HTN;n++) {
!     /* .table number treelen xlen ylen linbits */ 
!     do {
!       fgets(line,99,fi);
!     } while ((line[0] == '#') || (line[0] < ' '));
!      
!     sscanf(line,"%s %s %u %u %u %u",command,ht[n].tablename,
!            &ht[n].treelen, &ht[n].xlen, &ht[n].ylen, &ht[n].linbits);
!     if (strcmp(command,".end")==0)
!       return n;
!     else if (strcmp(command,".table")!=0) {
!       fprintf(stderr,"huffman table %u data corrupted\n",n);
!       return -1;
!     }
!     ht[n].linmax = (1<<ht[n].linbits)-1;
!    
!     sscanf(ht[n].tablename,"%u",&nn);
!     if (nn != n) {
!       fprintf(stderr,"wrong table number %u\n",n);
!       return(-2);
!     } 
!     do {
!       fgets(line,99,fi);
!     } while ((line[0] == '#') || (line[0] < ' '));
! 
!     sscanf(line,"%s %u",command,&t);
!     if (strcmp(command,".reference")==0) {
!       ht[n].ref   = t;
!       ht[n].val   = ht[t].val;
!       ht[n].treelen  = ht[t].treelen;
!       if ( (ht[n].xlen != ht[t].xlen) ||
!            (ht[n].ylen != ht[t].ylen)  ) {
!         fprintf(stderr,"wrong table %u reference\n",n);
!         return (-3);
!       };
!       while ((line[0] == '#') || (line[0] < ' ') ) {
!         fgets(line,99,fi);
!       }
!     }    
!     else if (strcmp(command,".treedata")==0) {
!       ht[n].ref  = -1;
!       if ( ht[n].treelen )
!       {
! 	  ht[n].val = (unsigned char (*)[2]) 
! 	      calloc(2*(ht[n].treelen),sizeof(unsigned char));
! 	  if (ht[n].val == NULL) {
! 	      fprintf(stderr, "heaperror at table %d\n",n);
! 	      exit (-10);
! 	  }
!       }
!       else
! 	  ht[n].val = NULL;
!       for (i=0;i<ht[n].treelen; i++) {
!         fscanf(fi,"%x %x",&v0, &v1);
!         ht[n].val[i][0]=(unsigned char)v0;
!         ht[n].val[i][1]=(unsigned char)v1;
!       }
!       fgets(line,99,fi); /* read the rest of the line */
!     }
!     else {
!       fprintf(stderr,"huffman decodertable error at table %d\n",n);
!     }
!   }
!   return n;
! }
  
  
  /* do the huffman coding,  */
  /* note! for counta,countb - the 4 bit value is passed in y, set x to 0 */
  /* return value: 0-no error, 1 decode error				*/
! void huffman_coder( x, y, h, bs)
! unsigned int x; 	/* x-value */
! unsigned int y; 	/* y-value */
! struct huffcodetab *h; 	/* pointer to huffman code record 	*/
! Bit_stream_struc *bs;  	/* pointer to open write bitstream 	*/
  {
    HUFFBITS huffbits; /* data left aligned */
    HUFFBITS linbitsX; 
--- 1,133 ----
! #include <string.h>
  #include <stdlib.h>
  #include "common.h"
  #include "huffman.h"
  
  
!      
! /* HUFFBITS dmask = 1 << (sizeof(HUFFBITS)*8-1); */
! unsigned int hs = sizeof(HUFFBITS)*8;
  
! static HUFFBITS      t1HB[]   = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
!  1, 0}; 
! static HUFFBITS      t2HB[]   = {1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
!  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0};
! static HUFFBITS      t3HB[]   = {3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0};
! static HUFFBITS      t5HB[]   = {1, 2, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 1, 0};
! static HUFFBITS      t6HB[]   = {7, 3, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 0};
! static HUFFBITS      t7HB[]   = {1, 2, 10, 19, 16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 7, 10, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 13, 17, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 11, 18, 15, 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 9, 14, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 5, 3, 2, 0};
! static HUFFBITS      t8HB[]   = {3, 4, 6, 18, 12, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 2, 16, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3, 5, 14, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 17, 15, 13, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 5, 8, 11, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 4, 4, 1, 1, 0};
! static HUFFBITS      t9HB[]   = {7, 5, 9, 14, 15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 5, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 6, 9, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 7, 9, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 4, 6, 2, 6, 0};
! static HUFFBITS      t10HB[]   = {1, 2, 10, 23, 35, 30, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 8, 12, 18, 21, 12, 7, 0, 0, 0, 0, 0, 0, 0, 0, 11, 9, 15, 21, 32, 40, 19, 6, 0, 0, 0, 0, 0, 0, 0, 0, 14, 13, 22, 34, 46, 23, 18, 7, 0, 0, 0, 0, 0, 0, 0, 0, 20, 19, 33, 47, 27, 22, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 31, 22, 41, 26, 21, 20, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 14, 13, 10, 11, 16, 6, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 7, 8, 4 , 4, 2, 0};
! static HUFFBITS      t11HB[]   = {3, 4, 10, 24, 34, 33, 21, 15, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3, 4, 10, 32, 17, 11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 11, 7, 13, 18, 30, 31, 20, 5, 0, 0, 0, 0, 0, 0, 0, 0, 25, 11, 19, 59, 27, 18, 12, 5, 0, 0, 0, 0, 0, 0, 0, 0, 35, 33, 31, 58, 30, 16, 7, 5, 0, 0, 0, 0, 0, 0, 0, 0, 28, 26, 32, 19, 17, 15, 8, 14, 0, 0, 0, 0, 0, 0, 0, 0, 14, 12, 9, 13, 14, 9, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 6, 6, 6, 3, 2, 0};
! static HUFFBITS      t12HB[]   = {9, 6, 16, 33, 41, 39, 38, 26, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, 6, 9, 23, 16, 26, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 7, 11, 14, 21, 30, 10, 7, 0, 0, 0, 0, 0, 0, 0, 0, 17, 10, 15, 12, 18, 28, 14, 5, 0, 0, 0, 0, 0, 0, 0, 0, 32, 13, 22, 19, 18, 16, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 40, 17, 31, 29, 17, 13, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 27, 12, 11, 15, 10, 7, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 27, 12, 8, 12 , 6, 3, 1, 0}; 
! static HUFFBITS      t13HB[]   = {1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19, 3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14, 15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16, 22,
!                                  20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14, 35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24, 58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17, 47, 
!                                  45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15, 72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42, 43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16, 53, 
!                                  25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11, 35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22, 53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7, 34, 32, 
!                                  28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5, 45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3, 48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2, 16, 15, 17, 27, 25, 
!                                  20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1};
! static HUFFBITS      t15HB[]   = {7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63, 13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36, 19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 
!                                   33, 29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29, 52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27, 77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,
!                                   125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30, 109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25, 90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,
!                                   71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15, 109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9, 86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11, 
!                                   118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7, 91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3, 123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1, 71, 
!                                   37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0};
! static HUFFBITS      t16HB[]   = {1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17, 3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9, 15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 
!                                   110, 209, 206, 16, 45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26, 75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9, 66, 30, 59, 56, 102,
!                                   185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16, 111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10, 98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372,
!                                   380, 889, 884, 8, 85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7, 154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11, 139, 129, 67, 125,
!                                   247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4, 243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6, 202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 
!                                   443, 707, 440, 437, 1728, 4, 747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2, 377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 
!                                   0, 12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3};
! static HUFFBITS      t24HB[]   = {15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88, 14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42, 47, 22, 41, 74, 68, 128, 120, 221,
!                                   207, 194, 182, 340, 315, 295, 541, 18, 81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16, 147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 
!                                   540, 14, 263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12, 249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10, 435, 115, 111,
!                                   109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17, 427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16, 335, 199, 197, 191, 189, 181, 174, 333, 
!                                   321, 305, 289, 275, 521, 379, 371, 11, 668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10, 652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 
!                                   368, 362, 6, 648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4, 620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2, 1033, 280, 278,
!                                   274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0, 43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3};
! static HUFFBITS      t32HB[]   = {1, 5, 4, 5, 6, 5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1};
! static HUFFBITS      t33HB[]   = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
! 
! static unsigned char t1l[]  = {1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3}; 
! static unsigned char t2l[]  = {1, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6}; 
! static unsigned char t3l[]  = {2, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6}; 
! static unsigned char t5l[]  = {1, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 8}; 
! static unsigned char t6l[]  = {3, 3, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 7}; 
! static unsigned char t7l[]  = {1, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 7, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10}; 
! static unsigned char t8l[]  = {2, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 9, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 9, 9, 11, 11}; 
! static unsigned char t9l[]  = {3, 3, 5, 6, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 5, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 8, 9, 9}; 
! static unsigned char t10l[]  = {1, 3, 6, 8, 9, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 6, 7, 8, 9, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7, 8, 9, 10, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 10, 10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 10, 10, 11, 11, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 9, 10, 10, 11, 11, 11}; 
! static unsigned char t11l[]  = {2, 3, 5, 7, 8, 9, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 6, 8, 8, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6, 7, 8, 9, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 9, 8, 10, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 9, 9, 10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 11, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 7, 8, 9, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 9, 10, 10, 10, 10}; 
! static unsigned char t12l[]  = {4, 3, 5, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 5, 7, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 5, 6, 7, 8, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 6, 7, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 7, 8, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 8, 8, 9, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 7, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 8, 9, 9, 9, 9, 10}; 
! static unsigned char t13l[]  = {1, 4, 6, 7, 8, 9, 9, 10, 9, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 12, 6, 6, 7, 8, 9, 9, 10, 10, 9, 10, 10, 11, 11, 12, 13, 13, 7, 7, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 
! 8, 7, 9, 9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14, 9, 8, 9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 10, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16, 9, 8, 9, 10,
! 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 10, 9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15, 10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17, 11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16, 11, 11, 11, 12, 12, 
! 13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16, 12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16, 13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16, 12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}; 
! static unsigned char t15l[]  = {3, 4, 5, 7, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 13, 4, 3, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 5, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 11, 11, 11, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 7, 6, 7,
!  7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 8, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 9, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11,
!  12, 12, 12, 9, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 10, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 11, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 
! 11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13}; 
! static unsigned char t16l[]  = {1, 4, 6, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 9, 3, 4, 6, 7, 8, 9, 9, 9, 10, 10, 10, 11, 12, 11, 12, 8, 6, 6, 7, 8, 9, 9, 10, 10, 11, 10, 11, 11, 11, 12, 12, 9, 8, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,
!  10, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 9, 9, 8, 9, 9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10, 10, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10, 10, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10, 10, 10,
!  10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11, 11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10, 12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11, 12, 12,
!  12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11, 14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11, 13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11, 9, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8}; 
! static unsigned char t24l[]  = {4, 4, 6, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 9, 4, 4, 5, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 6, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 7, 7, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 7, 8, 7, 7, 8,
!  8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 7, 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 7, 9, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 7, 10, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 
! 8, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 8, 11, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10,
!  10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8, 12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4}; 
! static unsigned char t32l[]  = {1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6}; 
! static unsigned char t33l[]  = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}; 
  
! #define NOREF -1
! struct huffcodetab ht[HTN] =
  {
! { 0, 0, 0,   0,NULL,NULL},
! { 2,16, 0,   0,t1HB, t1l},
! { 3,16, 0,   0,t2HB, t2l},
! { 3,16, 0,   0,t3HB, t3l},
! { 0, 0, 0,   0,NULL,NULL},/* Apparently not used */
! { 4,16, 0,   0,t5HB, t5l},
! { 4,16, 0,   0,t6HB, t6l},
! { 6,16, 0,   0,t7HB, t7l},
! { 6,16, 0,   0,t8HB, t8l},
! { 6,16, 0,   0,t9HB, t9l},
! { 8,16, 0,   0,t10HB, t10l},
! { 8,16, 0,   0,t11HB, t11l},
! { 8,16, 0,   0,t12HB, t12l},
! {16,16, 0,   0,t13HB, t13l},
! { 0, 0, 0,   0,NULL,NULL},/* Apparently not used */
! {16,16, 0,   0,t15HB, t15l},
! {16,16, 1,   1,t16HB, t16l},
! {16,16, 2,   3,t16HB, t16l},
! {16,16, 3,   7,t16HB, t16l},
! {16,16, 4,  15,t16HB, t16l},
! {16,16, 6,  63,t16HB, t16l},
! {16,16, 8, 255,t16HB, t16l},
! {16,16,10,1023,t16HB, t16l},
! {16,16,13,8191,t16HB, t16l},
! {16,16, 4,  15,t24HB, t24l},
! {16,16, 5,  31,t24HB, t24l},
! {16,16, 6,  63,t24HB, t24l},
! {16,16, 7, 127,t24HB, t24l},
! {16,16, 8, 255,t24HB, t24l},
! {16,16, 9, 511,t24HB, t24l},
! {16,16,11,2047,t24HB, t24l},
! {16,16,13,8191,t24HB, t24l},
! { 1,16, 0,   0,t32HB, t32l},
! { 1,16, 0,   0,t33HB, t33l},
! };	
  
  
+ #if 0
  /* do the huffman coding,  */
  /* note! for counta,countb - the 4 bit value is passed in y, set x to 0 */
  /* return value: 0-no error, 1 decode error				*/
! void huffman_coder(unsigned int x,
!                    unsigned int y,
!                    struct huffcodetab *h,
!                    Bit_stream_struc *bs)
  {
    HUFFBITS huffbits; /* data left aligned */
    HUFFBITS linbitsX; 
***************
*** 238,244 ****
    else if (x >= xl1) {
      linbitsX = x-xl1;
      if (linbitsX > h->linmax) {
-       fprintf(stderr,"warning: Huffman X table overflow\n");
        linbitsX= h->linmax;
      };
      if (y >= yl1) {
--- 147,152 ----
***************
*** 247,253 ****
        putbits(bs,huffbits,len);
        linbitsY = y-yl1;
        if (linbitsY > h->linmax) {
-         fprintf(stderr,"warning: Huffman Y table overflow\n");
          linbitsY = h->linmax;
        };
        if (h->linbits) {
--- 155,160 ----
***************
*** 270,276 ****
      putbits(bs,huffbits,len);
      linbitsY = y-yl1;
      if (linbitsY > h->linmax) {
-       fprintf(stderr,"warning: Huffman Y table overflow\n");
        linbitsY = h->linmax;
      };
      if (h->linbits) {
--- 177,182 ----
***************
*** 279,380 ****
    }
  }
  
! /* do the huffman-decoding 						*/
! /* note! for counta,countb -the 4 bit value is returned in y, discard x */
! int huffman_decoder(h, x, y, v, w)
! struct huffcodetab *h;	/* pointer to huffman code record	*/
! /* unsigned */ int *x; 	/* returns decoded x value 		*/
! /* unsigned */ int *y;	/* returns decoded y value		*/
! int *v;
! int *w;
! {  
!   HUFFBITS level;
!   int point = 0;
!   int error = 1;
!   level     = dmask;
!   if (h->val == NULL) return 2;
! 
!   /* table 0 needs no bits */
!   if ( h->treelen == 0)
!   {  *x = *y = 0;
!      return 0;
!   }
! 
! 
!   /* Lookup in Huffman table. */
! 
!   do {
!     if (h->val[point][0]==0) {   /*end of tree*/
!       *x = h->val[point][1] >> 4;
!       *y = h->val[point][1] & 0xf;
! 
!       error = 0;
!       break;
!     } 
!     if (hget1bit()) {
!       while (h->val[point][1] >= MXOFF) point += h->val[point][1]; 
!       point += h->val[point][1];
!     }
!     else {
!       while (h->val[point][0] >= MXOFF) point += h->val[point][0]; 
!       point += h->val[point][0];
!     }
!     level >>= 1;
!   } while (level  || (point < ht->treelen) );
!   
!   /* Check for error. */
!   
!   if (error) { /* set x and y to a medium value as a simple concealment */
!     printf("Illegal Huffman code in data.\n");
!     *x = (h->xlen-1 << 1);
!     *y = (h->ylen-1 << 1);
!   }
! 
!   /* Process sign encodings for quadruples tables. */
! 
!   if (h->tablename[0] == '3'
!       && (h->tablename[1] == '2' || h->tablename[1] == '3')) {
!      *v = (*y>>3) & 1;
!      *w = (*y>>2) & 1;
!      *x = (*y>>1) & 1;
!      *y = *y & 1;
! 
!      /* v, w, x and y are reversed in the bitstream. 
!         switch them around to make test bistream work. */
!      
! /*   {int i=*v; *v=*y; *y=i; i=*w; *w=*x; *x=i;}  MI */
! 
!      if (*v)
!         if (hget1bit() == 1) *v = -*v;
!      if (*w)
!         if (hget1bit() == 1) *w = -*w;
!      if (*x)
!         if (hget1bit() == 1) *x = -*x;
!      if (*y)
!         if (hget1bit() == 1) *y = -*y;
!      }
!      
!   /* Process sign and escape encodings for dual tables. */
!   
!   else {
!   
!       /* x and y are reversed in the test bitstream.
!          Reverse x and y here to make test bitstream work. */
! 	 
! /*    removed 11/11/92 -ag  
! 		{int i=*x; *x=*y; *y=i;} 
! */      
!      if (h->linbits)
!        if ((h->xlen-1) == *x) 
!          *x += hgetbits(h->linbits);
!      if (*x)
!         if (hget1bit() == 1) *x = -*x;
!      if (h->linbits)	  
!        if ((h->ylen-1) == *y)
!          *y += hgetbits(h->linbits);
!      if (*y)
!         if (hget1bit() == 1) *y = -*y;
!      }
! 	  
!   return error;  
! }
--- 185,188 ----
    }
  }
  
! #endif
diff -r -c -N encoder/huffman.h lame3.13/huffman.h
*** encoder/huffman.h	Wed Jan 22 02:43:15 1997
--- lame3.13/huffman.h	Wed May  5 10:15:21 1999
***************
*** 1,60 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: huffman.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: huffman.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *  27.2.92 F.O.Witte (ITT Intermetall)				      *
-  *  8/24/93 M. Iwadare          Changed for 1 pass decoding.          *
-  *  7/14/94 J. Koller		useless 'typedef' before huffcodetab  *
-  *				removed				      *
-  *********************************************************************/	
-  
  #define HUFFBITS unsigned long int
  #define HTN	34
  #define MXOFF	250
   
  struct huffcodetab {
-   char tablename[3];	/*string, containing table_description	*/
    unsigned int xlen; 	/*max. x-index+			      	*/ 
    unsigned int ylen;	/*max. y-index+				*/
    unsigned int linbits; /*number of linbits			*/
    unsigned int linmax;	/*max number to be stored in linbits	*/
-   int ref;		/*a positive value indicates a reference*/
    HUFFBITS *table;	/*pointer to array[xlen][ylen]		*/
    unsigned char *hlen;	/*pointer to array[xlen][ylen]		*/
-   unsigned char(*val)[2];/*decoder tree				*/ 
-   unsigned int treelen;	/*length of decoder tree		*/
  };
  
  extern struct huffcodetab ht[HTN];/* global memory block		*/
  				/* array of all huffcodtable headers	*/
  				/* 0..31 Huffman code table 0..31	*/
  				/* 32,33 count1-tables			*/
- #ifdef PROTO_ARGS
  
- extern int read_huffcodetab(FILE *); 
- extern int read_decoder_table(FILE *);
-  
  extern void huffman_coder(unsigned int, unsigned int,
! 			  struct huffcodetab *, Bit_stream_struc *);
! 			  
! extern int huffman_decoder(struct huffcodetab *,
! 			   /* unsigned */ int *, /* unsigned */ int*, int*, int*);
! 
! #else
! 
! extern int read_huffcodetab(); 
! extern int read_decoder_table(); 
! extern void huffman_coder();
! extern int huffman_decoder();
! 
! #endif
--- 1,20 ----
  #define HUFFBITS unsigned long int
  #define HTN	34
  #define MXOFF	250
   
  struct huffcodetab {
    unsigned int xlen; 	/*max. x-index+			      	*/ 
    unsigned int ylen;	/*max. y-index+				*/
    unsigned int linbits; /*number of linbits			*/
    unsigned int linmax;	/*max number to be stored in linbits	*/
    HUFFBITS *table;	/*pointer to array[xlen][ylen]		*/
    unsigned char *hlen;	/*pointer to array[xlen][ylen]		*/
  };
  
  extern struct huffcodetab ht[HTN];/* global memory block		*/
  				/* array of all huffcodtable headers	*/
  				/* 0..31 Huffman code table 0..31	*/
  				/* 32,33 count1-tables			*/
  
  extern void huffman_coder(unsigned int, unsigned int,
!                           struct huffcodetab*, Bit_stream_struc*);
diff -r -c -N encoder/ieeefloat.c lame3.13/ieeefloat.c
*** encoder/ieeefloat.c	Wed Jan 22 02:43:17 1997
--- lame3.13/ieeefloat.c	Sat Jun  5 13:45:49 1999
***************
*** 1,3 ****
--- 1,4 ----
+ #ifndef LIBSNDFILE
  /* Copyright (C) 1988-1991 Apple Computer, Inc.
   * All Rights Reserved.
   *
***************
*** 969,971 ****
--- 970,973 ----
  */
   
  #endif /* TEST_FP */
+ #endif
diff -r -c -N encoder/l3bitstream.c lame3.13/l3bitstream.c
*** encoder/l3bitstream.c	Wed Jan 22 02:43:15 1997
--- lame3.13/l3bitstream.c	Sat Jun 19 17:00:40 1999
***************
*** 75,85 ****
  		      char             *ancillary,
  		      int              ancillary_bits )
  {
!     int gr, ch, i, mode_gr;
      fr_ps = in_fr_ps;
      bs = in_bs;
      stereo = fr_ps->stereo;
      mode_gr = (fr_ps->header->version == 1) ? 2 : 1;
      
      if ( frameData == NULL )
      {
--- 75,88 ----
  		      char             *ancillary,
  		      int              ancillary_bits )
  {
!     int gr, ch,  mode_gr;
      fr_ps = in_fr_ps;
      bs = in_bs;
      stereo = fr_ps->stereo;
      mode_gr = (fr_ps->header->version == 1) ? 2 : 1;
+ 
+ 
+ 
      
      if ( frameData == NULL )
      {
***************
*** 111,130 ****
  	PartHoldersInitialized = 1;
      }
  
! #if 1
      for ( gr = 0; gr < mode_gr; gr++ )
  	for ( ch =  0; ch < stereo; ch++ )
  	{
  	    int *pi = &l3_enc[gr][ch][0];
! 	    double *pr = &xr[gr][ch][0];
! 	    for ( i = 0; i < 576; i++, pr++, pi++ )
! 	    {
! 		if ( (*pr < 0) && (*pi > 0) )
! 		    *pi *= -1;
  	    }
  	}
  #endif
  
      encodeSideInfo( l3_side );
      encodeMainData( l3_enc, l3_side, scalefac );
      write_ancillary_data( ancillary, ancillary_bits );
--- 114,142 ----
  	PartHoldersInitialized = 1;
      }
  
! #if 0
!     /* this makes more sense in loop.c */
      for ( gr = 0; gr < mode_gr; gr++ )
  	for ( ch =  0; ch < stereo; ch++ )
  	{
  	    int *pi = &l3_enc[gr][ch][0];
! 	    int i;
! 	    for ( i = 0; i < 576; i++) 	    {
! 	      double pr = xr[gr][ch][i];
!               /* ms stereo fix.  if ms_stereo, l3_enc will be M/S values */
! 	      if (in_fr_ps->header->mode_ext == 2) {
! 		pr = ch ? (xr[gr][0][i]-xr[gr][1][i]) : (xr[gr][0][i]+xr[gr][1][i]);
! 		/* pr /= sqrt(2.0); */
! 	      }
! 
! 	      if ( (pr < 0) && (pi[i] > 0) )   pi[i] *= -1;
  	    }
  	}
  #endif
  
+ 
+ 
+ 
      encodeSideInfo( l3_side );
      encodeMainData( l3_enc, l3_side, scalefac );
      write_ancillary_data( ancillary, ancillary_bits );
***************
*** 159,164 ****
--- 171,177 ----
  
      /* we set this here -- it will be tested in the next loops iteration */
      l3_side->main_data_begin = frameResults->nextBackPtr;
+ 
  }
  
  void
***************
*** 179,184 ****
--- 192,200 ----
      int i, gr, ch, sfb, window, mode_gr;
      layer *info = fr_ps->header;
  
+ 
+ 
+ 
      if ( info->version == 1 )
  	mode_gr = 2;
      else
***************
*** 206,211 ****
--- 222,228 ----
  
  		if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  		{
+ #ifdef ALLOW_MIXED
  		    if ( gi->mixed_block_flag )
  		    {
  			for ( sfb = 0; sfb < 8; sfb++ )
***************
*** 221,226 ****
--- 238,244 ----
  
  		    }
  		    else
+ #endif
  		    {
  			for ( sfb = 0; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
***************
*** 262,272 ****
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
- 
  	    assert( gi->sfb_partition_table );
  
  	    if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	    {
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
--- 280,290 ----
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
  	    assert( gi->sfb_partition_table );
  
  	    if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	    {
+ #ifdef ALLOW_MIXED
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
***************
*** 283,288 ****
--- 301,307 ----
  		    }
  		}
  		else
+ #endif
  		{
  		    for ( sfb = 0, sfb_partition = 0; sfb_partition < 4; sfb_partition++ )
  		    {
***************
*** 304,315 ****
  			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen );
  		}
  	    }
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0;
  
  static int encodeSideInfo( III_side_info_t  *si )
  {
--- 323,351 ----
  			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen );
  		}
  	    }
+ 
+ 
+ 
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0; /* (jo) current crc */
! 
! /* (jo) this wrapper function for BF_addEntry() updates also the crc */
! static BF_PartHolder *CRC_BF_addEntry( BF_PartHolder *thePH, uint32 value, uint16 length )
! {
!    unsigned int bit = 1 << length;
!    
!    while((bit >>= 1)){
!       crc <<= 1;
!       if (!(crc & 0x10000) ^ !(value & bit))
! 	crc ^= CRC16_POLYNOMIAL;
!    }
!    crc &= 0xffff;   
!    return BF_addEntry(thePH, value, length);
! }
  
  static int encodeSideInfo( III_side_info_t  *si )
  {
***************
*** 317,345 ****
      layer *info = fr_ps->header;
      
      mode_gr =  (info->version == 1) ? 2 : 1;
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
      headerPH = BF_addEntry( headerPH, info->version,            1 );
      headerPH = BF_addEntry( headerPH, 4 - info->lay,            2 );
      headerPH = BF_addEntry( headerPH, !info->error_protection,  1 );
!     headerPH = BF_addEntry( headerPH, info->bitrate_index,      4 );
!     headerPH = BF_addEntry( headerPH, info->sampling_frequency, 2 );
!     headerPH = BF_addEntry( headerPH, info->padding,            1 );
!     headerPH = BF_addEntry( headerPH, info->extension,          1 );
!     headerPH = BF_addEntry( headerPH, info->mode,               2 );
!     headerPH = BF_addEntry( headerPH, info->mode_ext,           2 );
!     headerPH = BF_addEntry( headerPH, info->copyright,          1 );
!     headerPH = BF_addEntry( headerPH, info->original,           1 );
!     headerPH = BF_addEntry( headerPH, info->emphasis,           2 );
      
      bits_sent = 32;
! 
!     if ( fr_ps->header->error_protection )
!     {
! 	headerPH = BF_addEntry( headerPH, crc, 16 );
! 	bits_sent += 16;
!     }
  
      frameSIPH->part->nrEntries = 0;
  
--- 353,380 ----
      layer *info = fr_ps->header;
      
      mode_gr =  (info->version == 1) ? 2 : 1;
+    
+     crc = 0xffff; /* (jo) init crc16 for error_protection */
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
      headerPH = BF_addEntry( headerPH, info->version,            1 );
      headerPH = BF_addEntry( headerPH, 4 - info->lay,            2 );
      headerPH = BF_addEntry( headerPH, !info->error_protection,  1 );
!     /* (jo) from now on call the CRC_BF_addEntry() wrapper to update crc */
!     headerPH = CRC_BF_addEntry( headerPH, info->bitrate_index,      4 );
!     headerPH = CRC_BF_addEntry( headerPH, info->sampling_frequency, 2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->padding,            1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->extension,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->mode,               2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->mode_ext,           2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->copyright,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->original,           1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->emphasis,           2 );
      
      bits_sent = 32;
!    
!     /* (jo) see below for BF_addEntry( headerPH, crc, 16 ); */
  
      frameSIPH->part->nrEntries = 0;
  
***************
*** 352,369 ****
  
      if ( info->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
  	for ( ch = 0; ch < stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
--- 387,404 ----
  
      if ( info->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
  	for ( ch = 0; ch < stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = CRC_BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
***************
*** 371,405 ****
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
  		    assert( gi->block_type == 0 );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
  	if ( stereo == 2 )
--- 406,440 ----
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
  		    assert( gi->block_type == 0 );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = CRC_BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
  	if ( stereo == 2 )
***************
*** 409,459 ****
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
  	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
  	if ( stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
      return bits_sent;
  }
  
--- 444,501 ----
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
  	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
  	if ( stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
+ 
+     if ( fr_ps->header->error_protection )
+     {   /* (jo) error_protection: add crc16 information to header */
+ 	headerPH = BF_addEntry( headerPH, crc, 16 );
+ 	bits_sent += 16;
+     }
+ 
      return bits_sent;
  }
  
***************
*** 527,535 ****
      struct huffcodetab *h;
      int bvbits, c1bits, tablezeros, r0, r1, r2, rt, *pr;
      int bitsWritten = 0;
-     int idx = 0;
      tablezeros = 0;
      r0 = r1 = r2 = 0;
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
--- 569,577 ----
      struct huffcodetab *h;
      int bvbits, c1bits, tablezeros, r0, r1, r2, rt, *pr;
      int bitsWritten = 0;
      tablezeros = 0;
      r0 = r1 = r2 = 0;
+ 
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
***************
*** 569,576 ****
  		    {
  			x = (*ix_s)[line][window];
  			y = (*ix_s)[line + 1][window];
- 			assert( idx < 576 );
- 			assert( idx >= 0 );
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
--- 611,616 ----
***************
*** 580,585 ****
--- 620,626 ----
  	    }
  	}
  	else
+ #ifdef ALLOW_MIXED
  	    if ( gi->mixed_block_flag && gi->block_type == 2 )
  	    {  /* Mixed blocks long, short */
  		int sfb, window, line, start, end;
***************
*** 625,630 ****
--- 666,672 ----
  
  	    }
  	    else
+ #endif
  	    { /* Long blocks */
  		int *scalefac = &sfBandIndex[fr_ps->header->sampling_frequency + (fr_ps->header->version * 3)].l[0];
  		unsigned scalefac_index = 100;
***************
*** 644,649 ****
--- 686,692 ----
  		    region2Start = scalefac[ scalefac_index ];
  		    assert( region1Start == gi->address1 );
  		}
+ 
  		for ( i = 0; i < bigvalues; i += 2 )
  		{
  		    unsigned tableindex = 100;
***************
*** 671,676 ****
--- 714,720 ----
  		    y = ix[i + 1];
  		    if ( tableindex )
  		    {
+ 
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
***************
*** 701,706 ****
--- 745,751 ----
  	bitsWritten += L3_huffman_coder_count1( pph, h, v, w, x, y );
      }
      c1bits = bitsWritten - bvbits;
+ 
      if ( (stuffingBits = gi->part2_3_length - gi->part2_length - bitsWritten) )
      {
  	int stuffingWords = stuffingBits / 32;
***************
*** 719,725 ****
      }
      assert( bitsWritten == gi->part2_3_length - gi->part2_length );
  #ifdef DEBUG
!     printf( "#### %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ####\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
--- 764,770 ----
      }
      assert( bitsWritten == gi->part2_3_length - gi->part2_length );
  #ifdef DEBUG
!     printf( "## %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ##\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
diff -r -c -N encoder/l3psy.c lame3.13/l3psy.c
*** encoder/l3psy.c	Wed Jan 22 02:43:15 1997
--- lame3.13/l3psy.c	Thu Jun 24 18:16:37 1999
***************
*** 2,10 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3psy.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
   *
   * $Log: l3psy.c,v $
   * Revision 1.2  1997/01/19 22:28:29  rowlands
   * Layer 3 bug fixes from Seymour Shlien
   *
--- 2,15 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3psy.c,v 1.2 1998/10/05 17:06:48 larsi Exp $
   *
   * $Log: l3psy.c,v $
+  * Revision 1.2  1998/10/05 17:06:48  larsi
+  * *** empty log message ***
+  *
+  * Revision 1.1.1.1  1998/10/05 14:47:18  larsi
+  *
   * Revision 1.2  1997/01/19 22:28:29  rowlands
   * Layer 3 bug fixes from Seymour Shlien
   *
***************
*** 25,38 ****
--- 30,62 ----
   **********************************************************************/
  
  #include "common.h"
+ #include "globalflags.h"
  #include "encoder.h"
  #include "l3psy.h"
  #include "l3side.h"
  #include <assert.h>
+ #include "gtkanal.h"
+ #define MSFREQ 20
  
  #define maximum(x,y) ( (x>y) ? x : y )
  #define minimum(x,y) ( (x<y) ? x : y )
  
+ /* some different types of adaptive window switching */
+ 
+ 
+ /* This mode will turn on short_blocks if there is a localized surge in energy */
+ #define ENER_AWS  
+ 
+ /* from Gabriel Bouvigne <bouvigne@multimania.com> */
+ #define AWS    
+ 
+ static int switch_pe=1800;
+ 
+ 
+ void sprdngf1(FLOAT *, double *);
+ void sprdngf2(double *, FLOAT *);
+ static double s3_l[CBANDS][CBANDS]; /* needed global static by sprdngfs */
+ 
  void L3para_read( double sfreq, int numlines[CBANDS], int partition_l[HBLKSIZE],
  		  double minval[CBANDS], double qthr_l[CBANDS], double norm_l[CBANDS],
  		  double s3_l[CBANDS][CBANDS], int partition_s[HBLKSIZE_s], double qthr_s[CBANDS_s],
***************
*** 42,71 ****
  		  int cbw_s[SBMAX_s], int bu_s[SBMAX_s], int bo_s[SBMAX_s],
  		  double w1_s[SBMAX_s], double w2_s[SBMAX_s] );
  									
! void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
! 		    double sfreq, double ratio_d[21], double ratio_ds[12][3],
! 		    double *pe, gr_info *cod_info )
  {
!     static double ratio[2][21];
!     static double ratio_s[2][12][3];
!     int blocktype;
!     unsigned int   b, i, j, k;
!     double         r_prime, phi_prime; /* not FLOAT */
!     FLOAT          freq_mult, bval_lo, min_thres, sum_energy;
!     double         tb, temp1,temp2,temp3;
  
!     /*         nint(); Layer III */
!     double   thr[CBANDS];
  
  /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
  /* to be remembered for the unpredictability measure.  For "r" and        */
  /* "phi_sav", the first index from the left is the channel select and     */
  /* the second index is the "age" of the data.                             */
- 
- 
-    static FLOAT window_s[BLKSIZE_s] ;
   static int     new = 0, old = 1, oldest = 0;
!  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
   static double 	cw[HBLKSIZE], eb[CBANDS];
   static double 	ctb[CBANDS];
   static double	SNR_l[CBANDS], SNR_s[CBANDS_s];
--- 66,259 ----
  		  int cbw_s[SBMAX_s], int bu_s[SBMAX_s], int bo_s[SBMAX_s],
  		  double w1_s[SBMAX_s], double w2_s[SBMAX_s] );
  									
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! 
! void L3psycho_energy( short int *buffer, 
!     FLOAT energy[HBLKSIZE],
!     FLOAT ax[HBLKSIZE], FLOAT bx[HBLKSIZE],
!     FLOAT energy_s[3][HBLKSIZE_s],
!     FLOAT ax_s[3][HBLKSIZE_s], FLOAT bx_s[3][HBLKSIZE_s],
!      int chn,int gr_out , layer * info,
!      int check_ms_stereo, double *ms_ener_ratio)
! {
!   static short int savebuffer[2][1344];
!   static double ms_ener[2];
!   static int sync_flush,flush,syncsize;
!   static int init=0;
!   static FLOAT scalefac;
!   static FLOAT window_s[BLKSIZE_s];
!   static FLOAT window[BLKSIZE];
! 
! #ifdef HAVEGTK
!   static FLOAT energy_save[2][HBLKSIZE];
! #endif
! 
!   short int *savebuf;
!   int i,j,k,sblock;
!   
!   static FLOAT wsamp_r_int[2][BLKSIZE];
!   FLOAT wsamp_rs[256],*wsamp_r; 
! 
! 
!   wsamp_r=wsamp_r_int[chn]; 
!   savebuf = &savebuffer[chn][0];
!   
!   if(init==0){
!     init=1;
!     memset((char *) savebuffer, 0, sizeof(savebuffer));    
!     if (gpsycho) {sync_flush=WINDELAY; flush=576; syncsize=WINDELAY+576;}
!     else        {sync_flush=768; flush=576; syncsize=1344;} 
!     
!     scalefac=1.0;
!     if (force_ms) scalefac=SQRT2;
!     
!     /* calculate HANN window coefficients */
!     /*   for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0)));*/
!     for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
!     for(i=0;i<BLKSIZE_s;i++)window_s[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE_s));
!   }
!   
!   /**********************************************************************
!    *  Delay signal by sync_flush samples                             *
!    **********************************************************************/
!   for ( j = 0; j < sync_flush; j++ ) /* for long window samples */
!     savebuf[j] = savebuf[j+flush];
!   
!   for ( j = sync_flush; j < syncsize; j++ )
!     savebuf[j] = buffer[j-sync_flush];
!   
!   
!   
!   /**********************************************************************
!    *  compute FFTs
!    **********************************************************************/
!   for ( j = 0; j < BLKSIZE; j++ ) 
!     wsamp_r[j] = window[j] * savebuf[j] * scalefac;
!   fft( wsamp_r, energy, ax, bx, 1024 );		/**long FFT**/
!   
! #ifdef HAVEGTK
!   if(gtkflag) {
!     for (j=0; j<HBLKSIZE ; j++) {
!       pinfo->energy[gr_out][chn][j]=energy_save[chn][j];
!       energy_save[chn][j]=energy[j];
!     }
!   }
! #endif
!   for ( sblock = 0; sblock < 3; sblock++ ) {
!     int shlen = 128;
!     int shoff = 2;
!     if (gpsycho) {
!       shlen = 192;
!       shoff = 1;
!     }
!     for ( j = 0, k = shlen * (shoff + sblock); j < 256; j++, k++ )
!       wsamp_rs[j] = window_s[j]* savebuf[k]*scalefac;
!     fft( wsamp_rs, &energy_s[sblock][0], &ax_s[sblock][0], &bx_s[sblock][0], 256 );
!   }
! 
!   /**********************************************************************/
!   /* compute side_energy / total_energy ratio */
!   /**********************************************************************/
!   *ms_ener_ratio=0;
!   if (check_ms_stereo) {
!     double ms_ener_side;
!     
!     /* compute energy in frequencies above MSFREQ */
!     for (ms_ener[chn]=0, j=MSFREQ; j<HBLKSIZE ; j++) {
!       ms_ener[chn] += energy[j];
!     }
!     if (chn == 1) {
!       /* compute energy in side channel */
!       ms_ener_side = fft_side( wsamp_r_int, MSFREQ);
!       
!       /* ener_side / total_energy */
!       if (ms_ener_side <= .01*(ms_ener[0]+ms_ener[1]))
! 	*ms_ener_ratio = .01;
!       else
! 	*ms_ener_ratio = ms_ener_side/(ms_ener[0]+ms_ener[1]);
!     }
!   }
! 
!   if (force_ms) {
!     for (ms_ener[chn]=0, j=MSFREQ; j<HBLKSIZE ; j++)
!       ms_ener[chn] += energy[j];
!     if (chn == 1) {
!       if (ms_ener[1] <= .01*(ms_ener[0]+ms_ener[1]))
! 	*ms_ener_ratio = .01;
!       else
! 	*ms_ener_ratio = ms_ener[1]/(ms_ener[0]+ms_ener[1]);
!     }
!   }
!       
! 
! }
! 
! 
! 
!  
! 
! 
! 
!  
! 
! void L3psycho_anal( short int *buffer[2], int stereo,
! 		    int gr_out , layer * info,
! 		    double sfreq, 
! 		    int check_ms_stereo, double *ms_ener_ratio,
! 		    double ratio_d[2][21], double ratio_ds[2][12][3],
! 		    double percep_energy[2], int blocktype_d[2])
  {
!   static double pe[2]={0,0};
!   static double ms_ratio_s_old=0,ms_ratio_l_old=0;
! 
!   static double ratio[2][SBMAX_l];
!   static double ratio_s[2][SBMAX_s][3];
! #ifdef HAVEGTK
!   static double pe_save[2];
!   static double ers_save[2];
! #endif
!   static double thm_save[2][SBMAX_l];
!   static double en_save[2][SBMAX_l];
!   static double thm_s_save[2][SBMAX_s][3];
!   static double en_s_save[2][SBMAX_s][3];
! 
! 
!   int blocktype[2],uselongblock[2],chn;
!   unsigned int   b, i, j, k;
!   FLOAT          freq_mult, bval_lo;
!   double         temp1,temp2,temp3;
!   double ms_ratio_l=0,ms_ratio_s=0;
!   double estot[2][3];
! 
!   
!   /*         nint(); Layer III */
!   double   thr[CBANDS];
!   FLOAT ax[HBLKSIZE], bx[HBLKSIZE];
!   FLOAT energy[HBLKSIZE];
!   FLOAT energy_s[3][HBLKSIZE_s];
!   FLOAT ax_s[3][HBLKSIZE_s], bx_s[3][HBLKSIZE_s]; /* 256 samples not 129. */
  
!   static float mld_l[SBMAX_l],mld_s[SBMAX_s];
!   
! 
!   
  
  /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
  /* to be remembered for the unpredictability measure.  For "r" and        */
  /* "phi_sav", the first index from the left is the channel select and     */
  /* the second index is the "age" of the data.                             */
   static int     new = 0, old = 1, oldest = 0;
!  static int     init = 0,  sfreq_idx;
   static double 	cw[HBLKSIZE], eb[CBANDS];
   static double 	ctb[CBANDS];
   static double	SNR_l[CBANDS], SNR_s[CBANDS_s];
***************
*** 73,79 ****
   static double	minval[CBANDS],qthr_l[CBANDS],norm_l[CBANDS];
   static double	qthr_s[CBANDS_s],norm_s[CBANDS_s];
   static double	nb_1[2][CBANDS], nb_2[2][CBANDS];
-  static double	s3_l[CBANDS][CBANDS]; /* s3_s[CBANDS_s][CBANDS_s]; */
  
  /* Scale Factor Bands */
   static int	cbw_l[SBMAX_l],bu_l[SBMAX_l],bo_l[SBMAX_l] ;
--- 261,266 ----
***************
*** 88,192 ****
  
  /* The following static variables are constants.                           */
  
-  static double  nmt = 5.5;
- 
   static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
                                 920, 1080, 1270,1480,1720,2000,2320, 2700,
                                3150, 3700, 4400,5300,6400,7700,9500,12000,
                               15500,25000,30000};
  
!  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
!                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
!                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
!                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
! 
! /* The following pointer variables point to large areas of memory         */
! /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
! /* allocation is used in order to avoid stack frame or data area          */
! /* overflow errors that otherwise would have occurred at compile time     */
! /* on the Macintosh computer.                                             */
! 
!  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
!  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
!  static FLOAT	energy_s[3][256];
!  static FLOAT phi_s[3][256] ; /* 256 samples not 129 */
!  FLOAT          *c, *fthr;
!  F32            *snrtmp;
  
   static	int	*numlines ;
   static int     *partition;
   static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
   static double  *tmn;
   static FCB     *s;
   static FHBLK   *lthr;
!  static F2HBLK  *r, *phi_sav;
  
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
  
!  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
!  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
   nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
   cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
   ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
   bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
!  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
!  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
!  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
!  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
   c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
   fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
   snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
  
-     assert( lay == 3 );
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
       numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
       partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
       cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
       rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
!      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
!      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr"); 
!      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
       s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
       lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
!      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
!      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
  
- /*#if 0 */
       i = sfreq + 0.5;
       switch(i){
          case 32000: sfreq_idx = 0; break;
          case 44100: sfreq_idx = 1; break;
          case 48000: sfreq_idx = 2; break;
          default:    printf("error, invalid sampling frequency: %d Hz\n",i);
          exit(-1);
       }
!      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
!      read_absthr(absthr, sfreq_idx);
!      switch(lay){
! 	case 1: sync_flush=576; flush=384; syncsize=1024; break;
! 	case 2: sync_flush=480; flush=576; syncsize=1056; break;
! 	case 3: sync_flush=768; flush=576; syncsize=1344; break;
!        default: printf("Bad lay value:(%d)",lay); exit(-1); break;
!      }
! /* #endif */
! 
! /* calculate HANN window coefficients */
! /*   for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0)));*/
!      for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
!      for(i=0;i<BLKSIZE_s;i++)window_s[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE_s));
  /* reset states used in unpredictability measure */
       for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
          lthr[0][i] = 60802371420160.0;
          lthr[1][i] = 60802371420160.0;
       }
--- 275,359 ----
  
  /* The following static variables are constants.                           */
  
   static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
                                 920, 1080, 1270,1480,1720,2000,2320, 2700,
                                3150, 3700, 4400,5300,6400,7700,9500,12000,
                               15500,25000,30000};
  
!  static FLOAT          *nb, *cb, *ecb, *bc;
  
+  static FLOAT          *c, *fthr;
+  static F32            *snrtmp;
   static	int	*numlines ;
+  static	int	*numlines2 ;
   static int     *partition;
   static FLOAT   *cbval, *rnorm;
   static double  *tmn;
   static FCB     *s;
   static FHBLK   *lthr;
!  static F2HBLK  *ax_sav, *bx_sav, *rx_sav;
!  static double   decibel_lower;
!  
! 
!  assert( info->lay == 3 );
  
  
!  if(init==0){
!    /* multiply an energy by decibel_lower to reduce its volume by 
!     * vdb Decibels. */
!    double vdb = 5;
!    decibel_lower = pow(10.0,-vdb/10.0);
! 
! 
! 
! /* These dynamic memory allocations simulate "static" variables placed    */
! /* in the data space.  Each mem_alloc() call here occurs only once at     */
! /* initialization time.  The mem_free() function must not be called.      */
   nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
   cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
   ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
   bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
! 
   c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
   fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
   snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
  
       numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
+      if (gpsycho) 
+        numlines2 = (int *) mem_alloc(sizeof(ICB), "numlines");
+      else  /* ISO model overwrites numlines with garbage */
+        numlines2 = numlines;
+ 
       partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
       cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
       rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
!      tmn = (double *) mem_alloc(sizeof(DCBA), "tmn");
       s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
       lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
!      rx_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "rx_sav");
!      ax_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "ax_sav");
!      bx_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "bx_sav");
! 
  
       i = sfreq + 0.5;
       switch(i){
          case 32000: sfreq_idx = 0; break;
          case 44100: sfreq_idx = 1; break;
          case 48000: sfreq_idx = 2; break;
+         case 16000: sfreq_idx = 3; break;
+         case 22050: sfreq_idx = 4; break;
+         case 24000: sfreq_idx = 5; break;
          default:    printf("error, invalid sampling frequency: %d Hz\n",i);
          exit(-1);
       }
! 
! 
! 
  /* reset states used in unpredictability measure */
+ 	memset (rx_sav,0, 4* HBLKSIZE);
+ 	memset (ax_sav,0, 4* HBLKSIZE);
+ 	memset (bx_sav,0, 4* HBLKSIZE);
       for(i=0;i<HBLKSIZE;i++){
          lthr[0][i] = 60802371420160.0;
          lthr[1][i] = 60802371420160.0;
       }
***************
*** 241,247 ****
             temp1 = (cbval[i] - cbval[j])*1.05;
             if(temp1>=0.5 && temp1<=2.5){
                temp2 = temp1 - 0.5;
!               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
             }
             else temp2 = 0;
             temp1 += 0.474;
--- 408,414 ----
             temp1 = (cbval[i] - cbval[j])*1.05;
             if(temp1>=0.5 && temp1<=2.5){
                temp2 = temp1 - 0.5;
!               temp2 = 8.0 * (temp2*(temp2 - 2.0));
             }
             else temp2 = 0;
             temp1 += 0.474;
***************
*** 264,1033 ****
             rnorm[j] += s[j][i];
          }
       }
       init++;
   }
!  
  /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
- 	for ( i=0; i<lay; i++)
-   {
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-   for (j=0; j<syncsize; j++)
-   {
-     if (j < (sync_flush) )
-       savebuf[j] = savebuf[j+flush];
-     else
-       savebuf[j] = *buffer++;
  
- /**window data with HANN window***********************************************/
-     if (j<BLKSIZE)
-     {
-       wsamp_r[j] = window[j]*((FLOAT) savebuf[j]); 
-       wsamp_i[j] = 0;
-     }
-   }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- 	   temp1 = r[chn][new][j] * cos((double) phi[j])
- 		   - r_prime * cos(phi_prime);
- 	   temp2=r[chn][new][j] * sin((double) phi[j])
- 		   - r_prime * sin(phi_prime);
-            temp3=r[chn][new][j] + fabs(r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*only update data "age" pointers after you are done with the second channel */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-         if(lay==2 || chn==1){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
- /*         tb = -0.434294482*log((double) cb[j])-0.301029996; */
-            tb = -0.43 *log((double) cb[j]) - 0.29 ;
-            if(tb<0.0) tb=0.0; else if(tb>1.0) tb=1.0;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
-            temp1=nb[partition[j]];		 /* preliminary threshold */
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            min_thres = fthr[j];
-            sum_energy = energy[j];
-            for(k=1;k<17;k++){
-               if(min_thres>fthr[j+k]) min_thres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(min_thres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            min_thres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               min_thres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/min_thres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)		/* if(lay==2 && chn==2) MI */
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
- 
- /*************************************************************************/
- /**       LAYER 3                                                        */
- /*************************************************************************/
  
-    case 3:
- 	if ( init_L3 == 0 )
- 	{
- 	    L3para_read( sfreq,numlines,partition_l,minval,qthr_l,norm_l,s3_l,
- 			 partition_s,qthr_s,norm_s,SNR_s,
- 			 cbw_l,bu_l,bo_l,w1_l,w2_l, cbw_s,bu_s,bo_s,w1_s,w2_s );
- 	    init_L3 ++ ;
- 	}
- 	
- 	for ( j = 0; j < 21; j++ )
- 	    ratio_d[j] = ratio[chn][j];
- 	for ( j = 0; j < 12; j++ )
- 	    for ( i = 0; i < 3; i++ )
- 		ratio_ds[j][i] = ratio_s[chn][j][i];
- 	
- 	if ( chn == 0 )
- 	    if ( new == 0 )
- 	    {
- 		new = 1;
- 		old = 0;
- 		oldest = 1;
- 	    }
- 	    else
- 	    {
- 		new = 0;
- 		old = 1;
- 		oldest = 0;
- 	    }
  
  
  /**********************************************************************
! *  Delay signal by sync_flush=768 samples                             *
  **********************************************************************/
! 	
! 	for ( j = 0; j < sync_flush; j++ ) /* for long window samples */
! 	    savebuf[j] = savebuf[j+flush];
! 	
! 	for ( j = sync_flush; j < syncsize; j++ )
! 	    savebuf[j] = *buffer++;
! 	
! 	for ( j = 0; j < BLKSIZE; j++ )
! 	{ /**window data with HANN window**/
! 	    wsamp_r[j] = window[j] * savebuf[j];  
! 	    wsamp_i[j] = 0.0;
! 	}
! 
  
  /**********************************************************************
  *    compute unpredicatability of first six spectral lines            * 
  **********************************************************************/
  
! 	fft( wsamp_r, wsamp_i, energy, phi, 1024 );		/**long FFT**/
! 	for ( j = 0; j < 6; j++ )
! 	{	 /* calculate unpredictability measure cw */
! 	    r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
! 	    phi_prime = 2.0 * phi_sav[chn][old][j]-phi_sav[chn][oldest][j];
! 	    r[chn][new][j] = sqrt((double) energy[j]);
! 	    phi_sav[chn][new][j] = phi[j];
! 	    temp1 = r[chn][new][j] * cos((double) phi[j])
! 		- r_prime * cos(phi_prime);
! 	    temp2 = r[chn][new][j] * sin((double) phi[j])
! 		- r_prime * sin(phi_prime);
! 	    temp3=r[chn][new][j] + fabs(r_prime);
! 	    
! 	    if ( temp3 != 0.0 )
! 		cw[j] = sqrt( temp1*temp1+temp2*temp2 ) / temp3;
! 	    else
! 		cw[j] = 0;
! 	}
  
  
  /**********************************************************************
  *     compute unpredicatibility of next 200 spectral lines            *
  **********************************************************************/ 
! 	for ( sblock = 0; sblock < 3; sblock++ )
! 	{ /**window data with HANN window**/
! 	    for ( j = 0, k = 128 * (2 + sblock); j < 256; j++, k++ )
! 	    {
! 		wsamp_r[j] = window_s[j]* savebuf[k]; 
! 		wsamp_i[j] = 0.0;
! 	    }							/* short FFT*/
! 	    
! 	    fft( wsamp_r, wsamp_i, &energy_s[sblock][0], &phi_s[sblock][0], 256 );
!         }
!  
!         sblock = 1;
  
! 	for ( j = 6; j < 206; j += 4 )
! 	{/* calculate unpredictability measure cw */
! 	    double r2, phi2, temp1, temp2, temp3;
! 	    
! 	    k = (j+2) / 4; 
! 	    r_prime = 2.0 * sqrt((double) energy_s[0][k])
! 		- sqrt((double) energy_s[2][k]);
! 	    phi_prime = 2.0 * phi_s[0][k] - phi_s[2][k];
! 	    r2 = sqrt((double) energy_s[1][k]);
! 	    phi2 = phi_s[1][k];
! 	    temp1 = r2 * cos( phi2 ) - r_prime * cos( phi_prime );
! 	    temp2 = r2 * sin( phi2 ) - r_prime * sin( phi_prime );
! 	    temp3 = r2 + fabs( r_prime );
! 	    if ( temp3 != 0.0 )
! 		cw[j] = sqrt( temp1 * temp1 + temp2 * temp2 ) / temp3;
! 	    else
! 		cw[j] = 0.0;
! 	    cw[j+1] = cw[j+2] = cw[j+3] = cw[j];
! 	}
  
  
  /**********************************************************************
! *    Set unpredicatiblility of remaining spectral lines to 0.4        *
  **********************************************************************/
! 	for ( j = 206; j < HBLKSIZE; j++ )
! 	    cw[j] = 0.4;
  	
  
  
  /**********************************************************************
  *    Calculate the energy and the unpredictability in the threshold   *
  *    calculation partitions                                           *
  **********************************************************************/
! 
! 	for ( b = 0; b < CBANDS; b++ )
! 	{
! 	    eb[b] = 0.0;
! 	    cb[b] = 0.0;
! 	}
! 	for ( j = 0; j < HBLKSIZE; j++ )
! 	{
! 	    int tp = partition_l[j];
! 	    if ( tp >= 0 )
! 	    {
! 		eb[tp] += energy[j];
! 		cb[tp] += cw[j] * energy[j];
! 	    }
! 	}
! 
  
  /**********************************************************************
  *      convolve the partitioned energy and unpredictability           *
  *      with the spreading function, s3_l[b][k]                        *
  ******************************************************************** */
! 	
! 	for ( b = 0; b < CBANDS; b++ )
! 	{
! 	    ecb[b] = 0.0;
! 	    ctb[b] = 0.0;
! 	}
! 	for ( b = 0;b < CBANDS; b++ )
! 	{
! 	    for ( k = 0; k < CBANDS; k++ )
! 	    {
! 		ecb[b] += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
! 		ctb[b] += s3_l[b][k] * cb[k];
! 	    }
! 	}
  
! 	/* calculate the tonality of each threshold calculation partition */
! 	/* calculate the SNR in each threshhold calculation partition */
  
! 	for ( b = 0; b < CBANDS; b++ )
! 	{
! 	    double cbb,tbb;
! 	    if (ecb[b] != 0.0 )
!                 {
! 		cbb = ctb[b]/ecb[b];
!                 if (cbb <0.01) cbb = 0.01;
! 		cbb = log( cbb);
!                 }
! 	    else
! 		cbb = 0.0 ;
! 	    tbb = -0.299 - 0.43*cbb;  /* conv1=-0.299, conv2=-0.43 */
! 	    tbb = minimum( 1.0, maximum( 0.0, tbb) ) ;  /* 0<tbb<1 */
! 	    SNR_l[b] = maximum( minval[b], 29.0*tbb+6.0*(1.0-tbb) );
! 	}	/* TMN=29.0,NMT=6.0 for all calculation partitions */
! 	
! 	for ( b = 0; b < CBANDS; b++ ) /* calculate the threshold for each partition */
! 	    nb[b] = ecb[b] * norm_l[b] * exp( -SNR_l[b] * LN_TO_LOG10 );
  
! 	for ( b = 0; b < CBANDS; b++ )
! 	{ /* pre-echo control */
! 	    double temp_1; /* BUG of IS */
! 	    temp_1 = minimum( nb[b], minimum(2.0*nb_1[chn][b],16.0*nb_2[chn][b]) );
! 	    thr[b] = maximum( qthr_l[b], temp_1 );/* rpelev=2.0, rpelev2=16.0 */
! 	    nb_2[chn][b] = nb_1[chn][b];
! 	    nb_1[chn][b] = nb[b];
! 	}
  
  
- 	*pe = 0.0;		/*  calculate percetual entropy */
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    double tp ;
- 	    tp = minimum( 0.0, log((thr[b]+1.0) / (eb[b]+1.0) ) ) ; /*not log*/
- 	    *pe -= numlines[b] * tp ;
- 	}	/* thr[b] -> thr[b]+1.0 : for non sound portition */
- 	
- #define switch_pe  1800
-         blocktype = NORM_TYPE;
- 	
  
- 	if ( *pe < switch_pe )
- 	{				/* no attack : use long blocks */
- 	    switch( blocktype_old[chn] ) 
- 	    {
- 	      case NORM_TYPE:
- 	      case STOP_TYPE:
- 		blocktype = NORM_TYPE;
- 		break;
-     
- 	      case SHORT_TYPE:
- 		blocktype = STOP_TYPE;
- 		break;
-     
- 	      case START_TYPE:
- 		fprintf( stderr, "Error in block selecting\n" );
- 		abort();
- 		break; /* problem */
- 	    }
  
- 	    /* threshold calculation (part 2) */
- 	    for ( sb = 0; sb < SBMAX_l; sb++ )
- 	    {
- 		en[sb] = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
- 		thm[sb] = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
- 		for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
- 		{
- 		    en[sb]  += eb[b];
- 		    thm[sb] += thr[b];
- 		}
- 		if ( en[sb] != 0.0 )
- 		    ratio[chn][sb] = thm[sb]/en[sb];
- 		else
- 		    ratio[chn][sb] = 0.0;
- 	    }
- 	}
- 	else 
- 	{
- 	    /* attack : use short blocks */
- 	    blocktype = SHORT_TYPE;
- 	    
- 	    if ( blocktype_old[chn] == NORM_TYPE ) 
- 		blocktype_old[chn] = START_TYPE;
- 	    if ( blocktype_old[chn] == STOP_TYPE )
- 		blocktype_old[chn] = SHORT_TYPE ;
- 	    
- 	    /* threshold calculation for short blocks */
- 	    
- 	    for ( sblock = 0; sblock < 3; sblock++ )
- 	    {
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    eb[b] = 0.0;
- 		    ecb[b] = 0.0;
- 		}
- 		for ( j = 0; j < HBLKSIZE_s; j++ )
- 		    eb[partition_s[j]] += energy_s[sblock][j];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		    for ( k = 0; k < CBANDS_s; k++ )
- 			ecb[b] += s3_l[b][k] * eb[k];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    nb[b] = ecb[b] * norm_l[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
- 		    thr[b] = maximum (qthr_s[b],nb[b]);
- 		}
- 		for ( sb = 0; sb < SBMAX_s; sb++ )
- 		{
- 		    en[sb] = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
- 		    thm[sb] = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
- 		    for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
- 		    {
- 			en[sb] += eb[b];
- 			thm[sb] += thr[b];
- 		    }
- 		    if ( en[sb] != 0.0 )
- 			ratio_s[chn][sb][sblock] = thm[sb]/en[sb];
- 		    else
- 			ratio_s[chn][sb][sblock] = 0.0;
- 		}
- 	    }
- 	} 
- 	
- 	cod_info->block_type = blocktype_old[chn];
- 	blocktype_old[chn] = blocktype;
  
! 	if ( cod_info->block_type == NORM_TYPE )
! 	    cod_info->window_switching_flag = 0;
! 	else
! 	    cod_info->window_switching_flag = 1;
! 	cod_info->mixed_block_flag = 0;
! 	break;
  
  
!   default:
!      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
   }
  
! /* These mem_free() calls must correspond with the mem_alloc() calls     */
! /* used at the beginning of this function to simulate "automatic"        */
! /* variables placed on the stack.                                        */
! 
!  mem_free((void **) &grouped_c);
!  mem_free((void **) &grouped_e);
!  mem_free((void **) &nb);
!  mem_free((void **) &cb);
!  mem_free((void **) &ecb);
!  mem_free((void **) &bc);
!  mem_free((void **) &wsamp_r);
!  mem_free((void **) &wsamp_i);
!  mem_free((void **) &phi);
!  mem_free((void **) &energy);
!  mem_free((void **) &c);
!  mem_free((void **) &fthr);
!  mem_free((void **) &snrtmp);
! }
! #ifdef DEBUG
! #undef DEBUG
  #endif
  
  
  void L3para_read(double sfreq, int *numlines, int *partition_l, double *minval, double *qthr_l, double *norm_l, double (*s3_l)[63], int *partition_s, double *qthr_s, double *norm_s, double *SNR, int *cbw_l, int *bu_l, int *bo_l, double *w1_l, double *w2_l, int *cbw_s, int *bu_s, int *bo_s, double *w1_s, double *w2_s)
  {
!    double freq_tp;
!    static double bval_l[CBANDS], bval_s[CBANDS];
!    int   cbmax, cbmax_tp;
!    static double s3_s[CBANDS][CBANDS];
! 
!    FILE *fin;
!    char tp[256];
!    int  sbmax ;
!    int  i,j,k,k2,loop, part_max ;
! 
!    fin = OpenTableFile( "psy_data" );
!    if (fin == NULL)
!        exit( 1 );
! 
! /* Read long block data */
! 
!       for(loop=0;loop<6;loop++)
!       {
! 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
! 	cbmax_tp++;
! #ifdef DEBUG
! 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
! #endif
  
! 	if (sfreq == freq_tp )
! 	  {
! 	     cbmax = cbmax_tp;
! 	     for(i=0,k2=0;i<cbmax_tp;i++)
! 	       {
! 		fscanf(fin,
! 		  "No=%d #lines=%d minval=%lf qthr=%lf norm=%lf bval=%lf\n",
! 		  &j,&numlines[i],&minval[i],&qthr_l[i],&norm_l[i],&bval_l[i]);
! 	        if (j!=i)
! 	         { printf("please check \"psy_data\"");
! 		   exit(-1);
! 	         }
! 		for(k=0;k<numlines[i];k++)
! 		  partition_l[k2++] = i ;
! #ifdef DEBUG
!      printf("No=%2d #lines=%2d minval=%4.1f qthr=%8.3f norm=%5.3f bval=%8.3f\n",
! 		     i,numlines[i],minval[i],qthr_l[i],norm_l[i],bval_l[i] );
! #endif
  		}
! 	   }
! 	   else
! 	   {
! 	     for(j=0;j<cbmax_tp;j++)
! 	       {
! 		fgets(tp,255,fin);
! 	        sscanf(tp,"No=%d %s\n",&i,tp);
! 	        if (j!=i)
! 	         { printf("please check \"psy_data.\"\n");
! 		   exit(-1);
! 	         }
! 	       }
! 	   }
!        }
  
! /************************************************************************
!  * Now compute the spreading function, s[j][i], the value of the spread-*
!  * ing function, centered at band j, for band i, store for later use    *
!  ************************************************************************/
! #ifdef DEBUG
! 	printf("freq = %f\n",sfreq);
! #endif
! 	  part_max = cbmax ;
!           for(i=0;i<part_max;i++)
! 	  {
! 	  double tempx,x,tempy,temp;
!             for(j=0;j<part_max;j++)
  	    {
!              tempx = (bval_l[i] - bval_l[j])*1.05;
!              if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
!                else    tempx = (bval_l[i] - bval_l[j])*1.5;
! /*             if (j>=i) tempx = (bval_l[j] - bval_l[i])*3.0;
!                else    tempx = (bval_l[j] - bval_l[i])*1.5; */
!              if(tempx>=0.5 && tempx<=2.5)
! 	     {
!                temp = tempx - 0.5;
!                x = 8.0 * (temp*temp - 2.0 * temp);
!              }
!              else x = 0.0;
!              tempx += 0.474;
!              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
!              if (tempy <= -60.0) s3_l[i][j] = 0.0;
!              else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
! #ifdef DEBUG_S3
! 	     printf("s[%d][%d]=%f\n",i,j,s3_l[i][j]);
! #endif
  
! #ifdef DEBUGP
! 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
! 	   minval[i] = bmax[j-1];
! 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
! #endif
!             }
!           }
  
  
! /* Read short block data */
  
!       for(loop=0;loop<6;loop++)
!       {
! 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
! 	cbmax_tp++;
! #ifdef DEBUG
! 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
! #endif
  
! 	if (sfreq == freq_tp )
! 	  {
! 	     cbmax = cbmax_tp;
! 	     for(i=0,k2=0;i<cbmax_tp;i++)
! 	       {
! 		fscanf(fin,
! 		  "No=%d #lines=%d qthr=%lf norm=%lf SNR=%lf bval=%lf\n",
! 		   &j,&numlines[i],&qthr_s[i],&norm_s[i],&SNR[i],&bval_s[i]);
! 	        if (j!=i)
! 	         { printf("please check \"psy_data\"");
! 		   exit(-1);
! 	         }
! 		for(k=0;k<numlines[i];k++)
! 		  partition_s[k2++] = i ;
! #ifdef DEBUG
!       printf("No=%2d #lines=%2d qthr=%8.3f norm=%5.3f SNR=%6.3f bval=%8.3f\n",
! 		      i,numlines[i],qthr_s[i],norm_s[i],SNR[i],bval_s[i] );
! #endif
  		}
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<cbmax_tp;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"No=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
  
! /************************************************************************
!  * Now compute the spreading function, s[j][i], the value of the spread-*
!  * ing function, centered at band j, for band i, store for later use    *
!  ************************************************************************/
! #ifdef DEBUG_S3
! fpp=fopen("s3_s","w");
! #endif
! 	  part_max = cbmax ;
!           for(i=0;i<part_max;i++)
! 	  {
! 	  double tempx,x,tempy,temp;
!             for(j=0;j<part_max;j++)
  	    {
!              tempx = (bval_s[i] - bval_s[j])*1.05;
!              if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
!                else    tempx = (bval_s[i] - bval_s[j])*1.5;
!              if(tempx>=0.5 && tempx<=2.5)
! 	     {
!                temp = tempx - 0.5;
!                x = 8.0 * (temp*temp - 2.0 * temp);
!              }
!              else x = 0.0;
!              tempx += 0.474;
!              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
!              if (tempy <= -60.0) s3_s[i][j] = 0.0;
!              else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
! #ifdef DEBUG_S3
! 	     fprintf(fpp,"s3_s[%d][%d]=%f\n",i,j,s3_s[i][j]);
! #endif
! #ifdef DEBUGP
! 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
! 	   minval[i] = bmax[j-1];
! 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
! #endif
!             }
!           }
! #ifdef DEBUG_S3
! 	fclose(fpp);
! #endif
! /* Read long block data for converting threshold calculation 
!    partitions to scale factor bands */
  
!       for(loop=0;loop<6;loop++)
!       {
! 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
! 	sbmax++;
! #ifdef DEBUG
! 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
! #endif
  
! 	if (sfreq == freq_tp)
! 	  {
! 	     for(i=0;i<sbmax;i++)
! 	      {
! 		fscanf(fin,
! 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
! 		  &j,&cbw_l[i],&bu_l[i],&bo_l[i],&w1_l[i],&w2_l[i]);
! 	        if (j!=i)
! 	         { printf("30:please check \"psy_data\"\n");
! 		   exit(-1);
! 	         }
! #ifdef DEBUG
! 		printf(
! 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
! 		  j,cbw_l[i],bu_l[i],bo_l[i],w1_l[i],w2_l[i]);
! #endif
! 	        if (i!=0)
! 		 if ( (bo_l[i] != (bu_l[i]+cbw_l[i])) ||
! 				 (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
! 	         { printf("31:please check \"psy_data.\"\n");
! 		   exit(-1);
! 	         }
! 	      }
! 	   }
! 	   else
! 	   {
! 	     for(j=0;j<sbmax;j++)
! 	       {
! 		fgets(tp,255,fin);
! 	        sscanf(tp,"sb=%d %s\n",&i,tp);
! 	        if (j!=i)
! 	         { printf("please check \"psy_data.\"\n");
! 		   exit(-1);
! 	         }
! 	       }
! 	   }
!        }
  
- /* Read short block data for converting threshold calculation 
-    partitions to scale factor bands */
  
!       for(loop=0;loop<6;loop++)
!       {
! 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
! 	sbmax++;
! #ifdef DEBUG
! 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
! #endif
  
- 	if (sfreq == freq_tp)
- 	  {
- 	     for(i=0;i<sbmax;i++)
- 	      {
- 		fscanf(fin,
- 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
- 		  &j,&cbw_s[i],&bu_s[i],&bo_s[i],&w1_s[i],&w2_s[i]);
- 	        if (j!=i)
- 	         { printf("30:please check \"psy_data\"\n");
- 		   exit(-1);
- 	         }
- #ifdef DEBUG
- 		printf(
- 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
- 		  j,cbw_s[i],bu_s[i],bo_s[i],w1_s[i],w2_s[i]);
- #endif
- 	        if (i!=0)
- 		 if ( (bo_s[i] != (bu_s[i]+cbw_s[i])) ||
- 				 (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
- 	         { printf("31:please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	      }
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<sbmax;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"sb=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
  
  }
--- 431,1417 ----
             rnorm[j] += s[j][i];
          }
       }
+ 
+ 
+     /* setup stereo demasking thresholds */
+     /* formula reverse enginerred from plot in paper */
+     for ( sb = 0; sb < SBMAX_s; sb++ ) {
+       double mld = 1.25*(1-cos(3.14159*sb/SBMAX_s))-2.5;
+       mld_s[sb] = pow(10.0,mld);
+     }
+     for ( sb = 0; sb < SBMAX_l; sb++ ) {
+       double mld = 1.25*(1-cos(3.14159*sb/SBMAX_l))-2.5;
+       mld_l[sb] = pow(10.0,mld);
+     }
+   
+ 
+ 
+ 
       init++;
   }
! 
!  if ( init_L3 == 0 )
!    {
!      L3para_read( sfreq,numlines2,partition_l,minval,qthr_l,norm_l,s3_l,
! 		  partition_s,qthr_s,norm_s,SNR_s,
! 		  cbw_l,bu_l,bo_l,w1_l,w2_l, cbw_s,bu_s,bo_s,w1_s,w2_s );
!      init_L3 ++ ;
!    }
  /************************* End of Initialization *****************************/
  
  
  
  
+ 
+ #ifdef AWS
+  /* reduce switch_pe if there where preecho events in previous granules */
+  {
+    int prev_granule_used_shortblock=0;
+    
+    for (chn=0; chn<stereo; chn++)
+      if (blocktype_old[chn]==SHORT_TYPE) 
+        prev_granule_used_shortblock=1;
+    
+    if (prev_granule_used_shortblock)
+      switch_pe=maximum(switch_pe-700,900);
+    else  switch_pe = minimum(switch_pe+200,1800);
+  }
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+   
+  for (chn=0; chn<stereo; chn++) {
+ 
+  
+  for ( j = 0; j < 21; j++ )
+    ratio_d[chn][j] = ratio[chn][j];
+  for ( j = 0; j < 12; j++ )
+    for ( i = 0; i < 3; i++ )
+      ratio_ds[chn][j][i] = ratio_s[chn][j][i];
+  percep_energy[chn] = pe[chn]; 
+  
+  
+  /*if ( chn == 0 )*/
+    if ( new == 0 )
+      {
+        new = 1;
+        old = 0;
+        oldest = 1;
+      }
+    else
+      {
+        new = 0;
+        old = 1;
+        oldest = 0;
+      }
+  
+ 
  /**********************************************************************
! *  compute FFTs
  **********************************************************************/
!  L3psycho_energy( buffer[chn], energy, ax, bx, energy_s, ax_s, bx_s,
! 		  chn,gr_out,info,check_ms_stereo,&ms_ratio_l);
!  ms_ratio_s=ms_ratio_l;
  
  /**********************************************************************
  *    compute unpredicatability of first six spectral lines            * 
  **********************************************************************/
+  for ( j = 0; j < 6; j++ )
+    {	 /* calculate unpredictability measure cw */
+      double an, a1, a2;
+      double bn, b1, b2;
+      double rn, r1, r2;
+      double numre, numim, den;
+ 
+      a2 = ax_sav[chn][oldest][j];
+      b2 = bx_sav[chn][oldest][j];
+      r2 = rx_sav[chn][oldest][j];
+      a1 = ax_sav[chn][oldest][j] = ax_sav[chn][old][j];
+      b1 = bx_sav[chn][oldest][j] = bx_sav[chn][old][j];
+      r1 = rx_sav[chn][oldest][j] = rx_sav[chn][old][j];
+      an = ax_sav[chn][old][j] = ax[j];
+      bn = bx_sav[chn][old][j] = bx[j];
+      rn = rx_sav[chn][old][j] = sqrt(energy[j]);
+ 
+      { /* square (x1,y1) */
+        if( r1 != 0.0 ) {
+ 	 numre = (a1*b1);
+ 	 numim = (a1*a1-b1*b1)*0.5;
+ 	 den = r1*r1;
+        } else {
+ 	 numre = 1.0;
+ 	 numim = 0.0;
+ 	 den = 1.0;
+        }
+      }
  
!      { /* multiply by (x2,-y2) */
!        if( r2 != 0.0 ) {
! 	 double tmp2 = (numim+numre)*(a2+b2)*0.5;
! 	 double tmp1 = -a2*numre+tmp2;
! 	 numre =       -b2*numim+tmp2;
! 	 numim = tmp1;
! 	 den *= r2;
!        } else {
! 	 /* do nothing */
!        }
!      }
  
+      { /* r-prime factor */
+        double tmp = (2.0*r1-r2)/den;
+        numre *= tmp;
+        numim *= tmp;
+      }
+ 
+      if( (den=rn+fabs(2.0*r1-r2)) != 0.0 ) {
+        numre = (an+bn)/2.0-numre;
+        numim = (an-bn)/2.0-numim;
+        cw[j] = sqrt(numre*numre+numim*numim)/den;
+      } else {
+        cw[j] = 0.0;
+      }
  
+    }
+                                                                                   
  /**********************************************************************
  *     compute unpredicatibility of next 200 spectral lines            *
  **********************************************************************/ 
!  sblock = 1;
! 	
!  for ( j = 6; j < 206; j += 4 )
!    {/* calculate unpredictability measure cw */
!      double rn, r1, r2;
!      double numre, numim, den;
! 
!      k = (j+2) / 4; 
! 
!      { /* square (x1,y1) */
!        r1 = sqrt((double)energy_s[0][k]);
!        if( r1 != 0.0 ) {
! 	 double a1 = ax_s[0][k];
! 	 double b1 = bx_s[0][k];
! 	 numre = (a1*b1);
! 	 numim = (a1*a1-b1*b1)*0.5;
! 	 den = r1*r1;
!        } else {
! 	 numre = 1.0;
! 	 numim = 0.0;
! 	 den = 1.0;
!        }
!      }
  
!      { /* multiply by (x2,-y2) */
!        r2 = sqrt((double)energy_s[2][k]);
!        if( r2 != 0.0 ) {
! 	 double a2 = ax_s[2][k];
! 	 double b2 = bx_s[2][k];
! 
! 	 double tmp2 = (numim+numre)*(a2+b2)*0.5;
! 	 double tmp1 = -a2*numre+tmp2;
! 	 numre =       -b2*numim+tmp2;
! 	 numim = tmp1;
! 
! 	 den *= r2;
!        } else {
! 	 /* do nothing */
!        }
!      }
! 
!      { /* r-prime factor */
!        double tmp = (2.0*r1-r2)/den;
!        numre *= tmp;
!        numim *= tmp;
!      }
! 
!      rn = sqrt((double)energy_s[1][k]);
!      if( (den=rn+fabs(2.0*r1-r2)) != 0.0 ) {
!        double an = ax_s[1][k];
!        double bn = bx_s[1][k];
!        numre = (an+bn)/2.0-numre;
!        numim = (an-bn)/2.0-numim;
!        cw[j] = sqrt(numre*numre+numim*numim)/den;
!      } else {
!        cw[j] = 0.0;
!      }
! 
!      cw[j+1] = cw[j+2] = cw[j+3] = cw[j];
!    }
  
  
  /**********************************************************************
! *    Set unpredicatiblility of remaining spectral lines to 0.4  206..513 *
  **********************************************************************/
!  for ( j = 206; j < HBLKSIZE; j++ )
!    cw[j] = 0.4;
  	
  
  
+ #if 0
+  for ( j = 14; j < HBLKSIZE-4; j += 4 )
+    {/* calculate energy from short ffts */
+      double tot,ave;
+      k = (j+2) / 4; 
+      for (tot=0, sblock=0; sblock < 3; sblock++)
+        tot+=energy_s[sblock][k];
+      ave = energy[j+1]+ energy[j+2]+ energy[j+3]+ energy[j];
+      ave /= 4.;
+      /*
+        printf("energy / tot %i %5.2f   %e  %e\n",j,ave/(tot*16./3.),
+        ave,tot*16./3.);
+      */
+      energy[j+1] = energy[j+2] = energy[j+3] =  energy[j]=tot;
+    }
+ #endif
+  
+ 
+ 
+ 
+ 
+ 
+ 
+ 
  /**********************************************************************
  *    Calculate the energy and the unpredictability in the threshold   *
  *    calculation partitions                                           *
  **********************************************************************/
!  for ( b = 0; b < CBANDS; b++ )
!    {
!      eb[b] = 0.0;
!      cb[b] = 0.0;
!    }
!  for ( j = 0; j < HBLKSIZE; j++ )
!    {
!      int tp = partition_l[j];
!      if ( tp >= 0 )
!        {
! 	 eb[tp] += energy[j];
! 	 cb[tp] += cw[j] * energy[j];
!        }
!    }
!  
  
  /**********************************************************************
  *      convolve the partitioned energy and unpredictability           *
  *      with the spreading function, s3_l[b][k]                        *
  ******************************************************************** */
!  for ( b = 0; b < CBANDS; b++ )
!    {
!      ecb[b] = 0.0;
!      ctb[b] = 0.0;
!    }
!  /* s3_l is a sparse matrix for 44.1khz */
!  if (sfreq_idx==1) {
!    sprdngf1(ecb,eb);
!    sprdngf2(ctb,cb);
!  }
!  else {
!    for ( b = 0;b < CBANDS; b++ )
!      {
!        for ( k = 0; k < CBANDS; k++ )
! 	 {
! 	   ecb[b] += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
! 	   ctb[b] += s3_l[b][k] * cb[k];
! 	 }
!      }
!  }
!  /* calculate the tonality of each threshold calculation partition */
!  /* calculate the SNR in each threshhold calculation partition */
  
!  for ( b = 0; b < CBANDS; b++ )
!    {
!      double cbb,tbb;
!      if (ecb[b] != 0.0 )
!        {
! 	 cbb = ctb[b]/ecb[b];
! 	 if (cbb <0.01) cbb = 0.01;
! 	 cbb = log( cbb);
!        }
!      else
!        cbb = 0.0 ;
!      tbb = -0.299 - 0.43*cbb;  /* conv1=-0.299, conv2=-0.43 */
!      tbb = minimum( 1.0, maximum( 0.0, tbb) ) ;  /* 0<tbb<1 */
!      SNR_l[b] = maximum( minval[b], 29.0*tbb+6.0*(1.0-tbb) );
!    }	/* TMN=29.0,NMT=6.0 for all calculation partitions */
!  
!  for ( b = 0; b < CBANDS; b++ ) /* calculate the threshold for each partition */
!    nb[b] = ecb[b] * norm_l[b] * exp( -SNR_l[b] * LN_TO_LOG10 );
!  
!  for ( b = 0; b < CBANDS; b++ )
!    { /* pre-echo control */
!      double temp_1; /* BUG of IS */
!      int rpelev=2; int rpelev2=16; 
!      temp_1 = minimum( nb[b], minimum(rpelev*nb_1[chn][b],rpelev2*nb_2[chn][b]) );
!      if (experimentalX) temp_1 = temp_1*decibel_lower; 
!      thr[b] = maximum( qthr_l[b], temp_1 );/* rpelev=2.0, rpelev2=16.0 */
!      nb_2[chn][b] = nb_1[chn][b];
!      nb_1[chn][b] = nb[b];
!    }
!  /* note: all surges in PE are because of the above pre-echo formula
!   * for temp_1.  it this is not used, PE is always around 600
!   */
! 
!  pe[chn] = 0.0;		/*  calculate percetual entropy */
!  for ( b = 0; b < CBANDS; b++ )
!    {
!      double tp ;
!      tp = minimum( 0.0, log((thr[b]+1.0) / (eb[b]+1.0) ) ) ;  /*not log*/
!      pe[chn] -= numlines[b] * tp ;
! 
!    }	/* thr[b] -> thr[b]+1.0 : for non sound portition */
! 
! 
!  /*************************************************************** 
!   * Check to see if we also need to compute long block thresholds
!   ***************************************************************/
!  uselongblock[chn] = (pe[chn] < switch_pe);
! 
!  {
!    double mn,mx;
!    for (sblock=0; sblock < 3; sblock++)
!        estot[chn][sblock]=0;
!    for ( j = HBLKSIZE_s/2; j < HBLKSIZE_s; j ++)
!      for (sblock=0; sblock < 3; sblock++)
!        estot[chn][sblock]+=energy_s[sblock][j];
!    mn = minimum(estot[chn][0],estot[chn][1]);
!    mn = minimum(mn,estot[chn][2]);
!    mx = maximum(estot[chn][0],estot[chn][1]);
!    mx = maximum(mx,estot[chn][2]);
! #ifdef HAVEGTK
!    if (gtkflag) {
!      pinfo->ers[gr_out][chn]=ers_save[chn];
!      ers_save[chn]=mx/(1e-12+mn);
!      pinfo->pe[gr_out][chn]=pe_save[chn];
!      pe_save[chn]=pe[chn];
!    }
! #endif
! #ifdef ENER_AWS
!    uselongblock[chn] = 1;
  
!    /* old ISO formula.  For t3.wav, add this and lower 25 to a 20.  */
!    if (pe[chn] > 1800) uselongblock[chn]=0; 
  
!    /* big surge of energy - always use short blocks */
!    if (  mx > 25*mn) uselongblock[chn] = 0;
  
+    /* switch based on pe, but only if there is some energy surge */
+    if (( mx > 2.5*mn ) && (pe[chn] > switch_pe)) uselongblock[chn]=0;
+ #endif
+  }
+  
  
  
  
  
!  if ((chn == 1) && (force_ms)) {
!    /* Forced ms_stereo mode.  */
!    /* ch=0 (mid) blocktype determines ch=1 (side) blocktype */
!    uselongblock[1] = uselongblock[0];
!  }
! 
! 
!  /*************************************************************** 
!   * compute masking thresholds
!   * we need to always compute short block masking thresholds because
!   * we dont know if this granule will be changed to a short block later.
!   ***************************************************************/
!  if ( uselongblock[chn]) 
!    {				/* no attack : use long blocks */
!      /* threshold calculation (part 2) */
!      for ( sb = 0; sb < SBMAX_l; sb++ )
!        {
! 	 en[sb] = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
! 	 thm[sb] = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
! 	 for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
! 	   {
! 	     en[sb]  += eb[b];
! 	     thm[sb] += thr[b];
! 	   }
  
+ 	 if ( en[sb] != 0.0 )
+ 	   ratio[chn][sb] = thm[sb]/en[sb];
+ 	 else
+ 	   ratio[chn][sb] = 0.0;
+        }
+ #ifdef HAVEGTK
+      if (gtkflag) {
+        for (sb=0; sb< SBMAX_l; sb ++ ) {
+ 	 pinfo->thr[gr_out][chn][sb]=thm_save[chn][sb];
+ 	 pinfo->en[gr_out][chn][sb]=en_save[chn][sb];
+ 	 thm_save[chn][sb]=thm[sb];
+ 	 en_save[chn][sb]=en[sb];
+        }
+      }
+ #endif
+      for (sb=0; sb< SBMAX_l; sb ++ ) {
+        thm_save[chn][sb]=thm[sb];
+        en_save[chn][sb]=en[sb];
+      }
  
!    }
!  
!  /* in some cases, when computing the next granule, we may switch this
!   * granule to a short block.  compute short block thresholds just in case */
! 
!  /* threshold calculation for short blocks */
!  for ( sblock = 0; sblock < 3; sblock++ )    {
!    for ( b = 0; b < CBANDS_s; b++ )
!      {
!        eb[b] = 0.0;
!        ecb[b] = 0.0;
!      }
!    for ( j = 0; j < HBLKSIZE_s; j++ )
!      eb[partition_s[j]] += energy_s[sblock][j];
!    for ( b = 0; b < CBANDS_s; b++ )
!      for ( k = 0; k < CBANDS_s; k++ )
!        ecb[b] += s3_l[b][k] * eb[k];
!    for ( b = 0; b < CBANDS_s; b++ )
!      {
!        if (gpsycho)
! 	 nb[b] = ecb[b] * norm_s[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
!        else
! 	 nb[b] = ecb[b] * norm_l[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
!        if (experimentalX) nb[b] = nb[b]*decibel_lower;  
!        thr[b] = maximum (qthr_s[b],nb[b]);
!      }
!    for ( sb = 0; sb < SBMAX_s; sb++ )
!      {
!        en[sb] = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
!        thm[sb] = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
!        for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
! 	 {
! 	   en[sb] += eb[b];
! 	   thm[sb] += thr[b];
! 	 }
! 
!        if ( en[sb] != 0.0 ) 
! 	 ratio_s[chn][sb][sblock] = thm[sb]/en[sb];
!        else
! 	 ratio_s[chn][sb][sblock] = 0.0;
! #ifdef HAVEGTK
!        if (gtkflag) {
! 	 pinfo->thr_s[gr_out][chn][3*sb+sblock]=thm_s_save[chn][sb][sblock];
! 	 pinfo->en_s[gr_out][chn][3*sb+sblock]=en_s_save[chn][sb][sblock];
!        }
! #endif
!        thm_s_save[chn][sb][sblock]=thm[sb];
!        en_s_save[chn][sb][sblock]=en[sb];
!      }
!    
!  } 
!  
!  
!  /* compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper */
! #define JOHNSTON
! #ifdef JOHNSTON
!  if (force_ms) {
!    if (chn == 1) {
!      double rside,rmid,mld; 
!      if ( uselongblock[chn]) {
!        for ( sb = 0; sb < SBMAX_l; sb++ ) {
! 	 mld = mld_l[sb];
! 	 /*
! 	 x1 = minimum(thm_save[0][sb],thm_save[1][sb]);
! 	 x2 = maximum(thm_save[0][sb],thm_save[1][sb]);
! 	 */
!          /* if db = 10*log10(x2/x1) < 2 */
!          /* if (x2 < 1.58*x1) { */
! 	   rmid = Max(ratio[0][sb],Min(ratio[1][sb],mld));
! 	   rside = Max(ratio[1][sb],Min(ratio[0][sb],mld));
! 	   ratio[0][sb]=rmid;
! 	   ratio[1][sb]=rside;
!        }
!      } 
!      /* alwasy compute these - we may need them later */
!      for ( sblock = 0; sblock < 3; sblock++ ){
!        for ( sb = 0; sb < SBMAX_s; sb++ ) {
! 	 mld = mld_s[sb];
! 	 rmid = Max(ratio_s[0][sb][sblock],Min(ratio_s[1][sb][sblock],mld));
! 	 rside = Max(ratio_s[1][sb][sblock],Min(ratio_s[0][sb][sblock],mld));
! 	 ratio_s[0][sb][sblock]=rmid;
! 	 ratio_s[1][sb][sblock]=rside;
!        }
!      }
!    }
   }
+ #endif
  
! 
! 
!  } /* end loop over chn */
! 
! 
! #if 1
!  if (check_ms_stereo)  {
!  /* determin ms_ratio from masking thresholds*/
!  /* use ms_stereo (ms_ratio < .35) if average thresh. diff < 5 db */
!  { double db,x1,x2,sidetot=0,tot=0;
!  for (sb= SBMAX_l/4 ; sb< SBMAX_l; sb ++ ) {
!    x1 = minimum(thm_save[0][sb],thm_save[1][sb]);
!    x2 = maximum(thm_save[0][sb],thm_save[1][sb]);
!    /* thresholds difference in db */
!    if (x2 >= 1000*x1)  db=30;
!    else db = 10*log10(x2/x1);  
!    sidetot += db;
!    tot++;
!  }
!  ms_ratio_l= .35*(sidetot/tot)/5.0;
!  
!  sidetot=0; tot=0;
!  for ( sblock = 0; sblock < 3; sblock++ )
!    for ( sb = SBMAX_s/4; sb < SBMAX_s; sb++ ) {
!      x1 = minimum(thm_s_save[0][sb][sblock],thm_s_save[1][sb][sblock]);
!      x2 = maximum(thm_s_save[0][sb][sblock],thm_s_save[1][sb][sblock]);
!      /* thresholds difference in db */
!      if (x2 >= 1000*x1)  db=30;
!      else db = 10*log10(x2/x1);  
!      sidetot += db;
!      tot++;
!    }
!  ms_ratio_s = .35*(sidetot/tot)/5.0;
!  }
!  }
  #endif
  
  
+  /*************************************************************** 
+   * determin final block type
+   ***************************************************************/
+  for (chn=0; chn<stereo; chn++) {
+    blocktype[chn] = NORM_TYPE;
+  }
+ 
+  if (!allow_diff_short)
+  if (info->mode==MPG_MD_JOINT_STEREO) {
+    /* force both channels to use the same block type */
+    /* this is necessary if the frame is to be encoded in ms_stereo.  */
+    /* But even without ms_stereo, FhG  does this */
+    int bothlong= (uselongblock[0] && uselongblock[1]);
+    if (!bothlong) {
+      uselongblock[0]=0;
+      uselongblock[1]=0;
+    }
+  }
+ 
+ 
+ 
+ 
+  /* update the blocktype of the previous granule, since it depends on what
+   * happend in this granule */
+  for (chn=0; chn<stereo; chn++) {
+  if ( uselongblock[chn])
+    {				/* no attack : use long blocks */
+      switch( blocktype_old[chn] ) 
+        {
+        case NORM_TYPE:
+        case STOP_TYPE:
+ 	 blocktype[chn] = NORM_TYPE;
+ 	 break;
+        case SHORT_TYPE:
+ 	 blocktype[chn] = STOP_TYPE; 
+ 	 break;
+        case START_TYPE:
+ 	 fprintf( stderr, "Error in block selecting\n" );
+ 	 abort();
+ 	 break; /* problem */
+        }
+    } else   {
+      /* attack : use short blocks */
+      blocktype[chn] = SHORT_TYPE;
+      if ( blocktype_old[chn] == NORM_TYPE ) {
+        blocktype_old[chn] = START_TYPE;
+      }
+      if ( blocktype_old[chn] == STOP_TYPE ) {
+        blocktype_old[chn] = SHORT_TYPE ;
+      }
+    }
+ 
+  
+  blocktype_d[chn] = blocktype_old[chn];  /* value returned to calling program */
+  blocktype_old[chn] = blocktype[chn];    /* save for next call to l3psy_anal */
+  }
+ 
+  if (blocktype_d[0]==2)
+    *ms_ener_ratio = ms_ratio_s_old;
+  else
+    *ms_ener_ratio = ms_ratio_l_old;
+  ms_ratio_s_old = ms_ratio_s;
+  ms_ratio_l_old = ms_ratio_l;
+ 
+ 
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ extern double psy_data[];
+ 
  void L3para_read(double sfreq, int *numlines, int *partition_l, double *minval, double *qthr_l, double *norm_l, double (*s3_l)[63], int *partition_s, double *qthr_s, double *norm_s, double *SNR, int *cbw_l, int *bu_l, int *bo_l, double *w1_l, double *w2_l, int *cbw_s, int *bu_s, int *bo_s, double *w1_s, double *w2_s)
  {
!   double freq_tp;
!   static double bval_l[CBANDS], bval_s[CBANDS];
!   int   cbmax=0, cbmax_tp;
!   static double s3_s[CBANDS][CBANDS];
!   double *p = psy_data;
  
!   int  sbmax ;
!   int  i,j,k,k2,loop, part_max ;
! 
!   /* Read long block data */
! 
!   for(loop=0;loop<6;loop++)
!     {
!       freq_tp = *p++;
!       cbmax_tp = (int) *p++;
!       cbmax_tp++;
! 
!       if (sfreq == freq_tp )
! 	{
! 	  cbmax = cbmax_tp;
! 	  for(i=0,k2=0;i<cbmax_tp;i++)
! 	    {
! 	      j = (int) *p++;
! 	      numlines[i] = (int) *p++;
! 	      minval[i] = *p++;
! 	      qthr_l[i] = *p++;
! 	      norm_l[i] = *p++;
! 	      bval_l[i] = *p++;
! 	      if (j!=i)
! 		{
! 		  printf("1. please check \"psy_data\"");
! 		  exit(-1);
  		}
! 	      for(k=0;k<numlines[i];k++)
! 		partition_l[k2++] = i ;
! 	    }
! 	}
!       else
! 	p += cbmax_tp * 6;
!     }
  
!   /************************************************************************
!    * Now compute the spreading function, s[j][i], the value of the spread-*
!    * ing function, centered at band j, for band i, store for later use    *
!    ************************************************************************/
!   part_max = cbmax ;
!   for(i=0;i<part_max;i++)
!     {
!       double tempx,x,tempy,temp;
!       for(j=0;j<part_max;j++)
! 	{
! 	  tempx = (bval_l[i] - bval_l[j])*1.05;
! 	  if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
! 	  else    tempx = (bval_l[i] - bval_l[j])*1.5;
! 	  /*             if (j>=i) tempx = (bval_l[j] - bval_l[i])*3.0;
! 			 else    tempx = (bval_l[j] - bval_l[i])*1.5; */
! 	  if(tempx>=0.5 && tempx<=2.5)
  	    {
! 	      temp = tempx - 0.5;
! 	      x = 8.0 * (temp*temp - 2.0 * temp);
! 	    }
! 	  else x = 0.0;
! 	  tempx += 0.474;
! 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
! 	  if (tempy <= -60.0) s3_l[i][j] = 0.0;
! 	  else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
! 	}
!     }
  
!   /* Read short block data */
  
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       cbmax_tp = (int) *p++;
+       cbmax_tp++;
  
!       if (sfreq == freq_tp )
! 	{
! 	  cbmax = cbmax_tp;
! 	  for(i=0,k2=0;i<cbmax_tp;i++)
! 	    {
! 	      j = (int) *p++;
! 	      numlines[i] = (int) *p++;
! 	      qthr_s[i] = *p++;
! 	      norm_s[i] = *p++;
! 	      SNR[i] = *p++;
! 	      bval_s[i] = *p++;
! 	      if (j!=i)
! 		{
! 		  printf("3. please check \"psy_data\"");
! 		  exit(-1);
! 		}
! 	      for(k=0;k<numlines[i];k++)
! 		partition_s[k2++] = i ;
! 	    }
! 	}
!       else
! 	p += cbmax_tp * 6;
!     }
  
!   /************************************************************************
!    * Now compute the spreading function, s[j][i], the value of the spread-*
!    * ing function, centered at band j, for band i, store for later use    *
!    ************************************************************************/
!   part_max = cbmax ;
!   for(i=0;i<part_max;i++)
!     {
!       double tempx,x,tempy,temp;
!       for(j=0;j<part_max;j++)
! 	{
! 	  tempx = (bval_s[i] - bval_s[j])*1.05;
! 	  if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
! 	  else    tempx = (bval_s[i] - bval_s[j])*1.5;
! 	  if(tempx>=0.5 && tempx<=2.5)
! 	    {
! 	      temp = tempx - 0.5;
! 	      x = 8.0 * (temp*temp - 2.0 * temp);
! 	    }
! 	  else x = 0.0;
! 	  tempx += 0.474;
! 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
! 	  if (tempy <= -60.0) s3_s[i][j] = 0.0;
! 	  else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
! 	}
!     }
!   /* Read long block data for converting threshold calculation 
!      partitions to scale factor bands */
  
!   for(loop=0;loop<6;loop++)
!     {
!       freq_tp = *p++;
!       sbmax =  (int) *p++;
!       sbmax++;
! 
!       if (sfreq == freq_tp)
! 	{
! 	  for(i=0;i<sbmax;i++)
! 	    {
! 	      j = (int) *p++;
! 	      cbw_l[i] = (int) *p++;
! 	      bu_l[i] = (int) *p++;
! 	      bo_l[i] = (int) *p++;
! 	      w1_l[i] = (double) *p++;
! 	      w2_l[i] = (double) *p++;
! 	      if (j!=i)
! 		{ printf("30:please check \"psy_data\"\n");
! 		exit(-1);
  		}
  
! 	      if (i!=0)
! 		if ( (bo_l[i] != (bu_l[i]+cbw_l[i])) ||
! 		     (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
! 		  {
! 		    printf("31l: please check \"psy_data.\"\n");
! 		    exit(-1);
! 		  }
! 	    }
! 	}
!       else
! 	p += sbmax * 6;
!     }
! 
!   /* Read short block data for converting threshold calculation 
!      partitions to scale factor bands */
! 
!   for(loop=0;loop<6;loop++)
!     {
!       freq_tp = *p++;
!       sbmax = (int) *p++;
!       sbmax++;
! 
!       if (sfreq == freq_tp)
! 	{
! 	  for(i=0;i<sbmax;i++)
  	    {
! 	      j = (int) *p++;
! 	      cbw_s[i] = (int) *p++;
! 	      bu_s[i] = (int) *p++;
! 	      bo_s[i] = (int) *p++;
! 	      w1_s[i] = *p++;
! 	      w2_s[i] = *p++;
! 	      if (j!=i)
! 		{ printf("30:please check \"psy_data\"\n");
! 		exit(-1);
! 		}
  
! 	      if (i!=0)
! 		if ( (bo_s[i] != (bu_s[i]+cbw_s[i])) ||
! 		     (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
! 		  { printf("31s: please check \"psy_data.\"\n");
! 		  exit(-1);
! 		  }
! 	    }
! 	}
!       else
! 	p += sbmax * 6;
!     }
  
! }
! void sprdngf1(dest,source)
! FLOAT *dest;
! double *source;
! {
! int b,k;
! extern double s3_l[CBANDS][CBANDS];  /* s3_l is a sparse matrix. fudge with it for 44.1 khz */
!  static int s3ind[CBANDS][2] = {
!    {0,2},
!    {0,3},
!    {0,4},
!    {0,5},
!    {0,6},
!    {0,7},
!    {0,8},
!    {0,9},
!    {0,10},
!    {0,11},
!    {0,12},
!    {1,14},
!    {1,14},
!    {2,15},
!    {3,15},
!    {5,16},
!    {6,17},
!    {7,19},
!    {9,20},
!    {10,21},
!    {11,22},
!    {12,23},
!    {14,24},
!    {15,25},
!    {15,27},
!    {16,28},
!    {16,28},
!    {17,29},
!    {18,30},
!    {19,31},
!    {19,32},
!    {20,34},
!    {21,35},
!    {22,36},
!    {22,36},
!    {23,37},
!    {24,38},
!    {25,39},
!    {26,41},
!    {27,42},
!    {28,43},
!    {29,44},
!    {30,45},
!    {31,46},
!    {32,47},
!    {33,48},
!    {34,49},
!    {35,50},
!    {36,51},
!    {37,52},
!    {37,53},
!    {38,54},
!    {39,55},
!    {40,56},
!    {41,57},
!    {42,58},
!    {43,59},
!    {44,60},
!    {45,61},
!    {46,62},
!    {47,62},
!    {48,62},
!    {48,62},
!  };
  
  
! 	for ( b = 0;b < CBANDS; b++ )
! 	    for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ )
! 		dest[b] += s3_l[b][k] * source[k];	
! }
! 
! 
! void sprdngf2(dest,source)
! double *dest;
! FLOAT *source;
! {
! int b,k;
! extern double s3_l[CBANDS][CBANDS];  /* s3_l is a sparse matrix. fudge with it for 44.1 khz */
!  static int s3ind[CBANDS][2] = {
!    {0,2},
!    {0,3},
!    {0,4},
!    {0,5},
!    {0,6},
!    {0,7},
!    {0,8},
!    {0,9},
!    {0,10},
!    {0,11},
!    {0,12},
!    {1,14},
!    {1,14},
!    {2,15},
!    {3,15},
!    {5,16},
!    {6,17},
!    {7,19},
!    {9,20},
!    {10,21},
!    {11,22},
!    {12,23},
!    {14,24},
!    {15,25},
!    {15,27},
!    {16,28},
!    {16,28},
!    {17,29},
!    {18,30},
!    {19,31},
!    {19,32},
!    {20,34},
!    {21,35},
!    {22,36},
!    {22,36},
!    {23,37},
!    {24,38},
!    {25,39},
!    {26,41},
!    {27,42},
!    {28,43},
!    {29,44},
!    {30,45},
!    {31,46},
!    {32,47},
!    {33,48},
!    {34,49},
!    {35,50},
!    {36,51},
!    {37,52},
!    {37,53},
!    {38,54},
!    {39,55},
!    {40,56},
!    {41,57},
!    {42,58},
!    {43,59},
!    {44,60},
!    {45,61},
!    {46,62},
!    {47,62},
!    {48,62},
!    {48,62},
!  };
  
  
+ 	for ( b = 0;b < CBANDS; b++ )
+ 	    for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ )
+ 		dest[b] += s3_l[b][k] * source[k];	
  }
diff -r -c -N encoder/l3psy.h lame3.13/l3psy.h
*** encoder/l3psy.h	Wed Jan 22 02:43:16 1997
--- lame3.13/l3psy.h	Wed Jun 16 17:28:32 1999
***************
*** 30,37 ****
  
  /* l3psy.c */
  #include "l3side.h"
! void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
! 					double sfreq, double ratio_d[21], double ratio_ds[12][3],
! 					double *pe, gr_info *cod_info );
  /* void read_absthr(float *absthr, int table); */
  #endif
--- 30,41 ----
  
  /* l3psy.c */
  #include "l3side.h"
! void L3psycho_anal( short int *buffer[2], int chn, 
! 		    int gr , layer *info,
! 		    double sfreq, 
! 		    int check_ms, double *ms_ener_ratio, 
! 		    double ratio_d[2][21], double ratio_ds[2][12][3],
! 		    double pe[2], 
!                     int blocktype_d[2]); 
  /* void read_absthr(float *absthr, int table); */
  #endif
diff -r -c -N encoder/l3side.h lame3.13/l3side.h
*** encoder/l3side.h	Wed Jan 22 02:43:16 1997
--- lame3.13/l3side.h	Sat Jun  5 16:44:56 1999
***************
*** 49,63 ****
  } III_psy_xmin;
  
  typedef struct {
- 	double	xr[576];
- 	double	xr_s[3][192];
- 	double	xmin[21];
- 	double	xmin_s[3][192];
- 	int	ix[576];
- 	int	ix_s[3][192];
- 	} III_input3; /* ch */
- 
- typedef struct {
  	unsigned part2_3_length;
  	unsigned big_values;
  	unsigned count1;
--- 49,54 ----
diff -r -c -N encoder/lame.dsp lame3.13/lame.dsp
*** encoder/lame.dsp	Wed Dec 31 17:00:00 1969
--- lame3.13/lame.dsp	Sat Jun 12 23:01:40 1999
***************
*** 0 ****
--- 1,304 ----
+ # Microsoft Developer Studio Project File - Name="lame" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Console Application" 0x0103
+ 
+ CFG=lame - Win32 Debug GTK
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak" CFG="lame - Win32 Debug GTK"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "lame - Win32 Release" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug GTK" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Release GTK" (based on\
+  "Win32 (x86) Console Application")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "lame - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "lame___W"
+ # PROP BASE Intermediate_Dir "lame___W"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "DebugGTK"
+ # PROP Intermediate_Dir "DebugGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Release GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "lame___0"
+ # PROP BASE Intermediate_Dir "lame___0"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "ReleaseGTK"
+ # PROP Intermediate_Dir "ReleaseGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /profile /map /machine:I386 /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "lame - Win32 Release"
+ # Name "lame - Win32 Debug"
+ # Name "lame - Win32 Debug GTK"
+ # Name "lame - Win32 Release GTK"
+ # Begin Source File
+ 
+ SOURCE=.\common.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\common.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\encode.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3psy.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3psy.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\loop-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\loop.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\loop.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\musicin.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\profile.txt
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\psy.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\sqrttab.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\subs.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\subs.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\WinGTK.txt
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/lame.dsw lame3.13/lame.dsw
*** encoder/lame.dsw	Wed Dec 31 17:00:00 1969
--- lame3.13/lame.dsw	Sun Jun  6 16:19:25 1999
***************
*** 0 ****
--- 1,44 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "lame"=.\lame.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+     Begin Project Dependency
+     Project_Dep_Name mpglib
+     End Project Dependency
+ }}}
+ 
+ ###############################################################################
+ 
+ Project: "mpglib"=.\mpglib\mpglib.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/loop-pvt.h lame3.13/loop-pvt.h
*** encoder/loop-pvt.h	Wed Jan 22 02:43:16 1997
--- lame3.13/loop-pvt.h	Sat Jun 19 16:26:39 1999
***************
*** 25,39 ****
  
  */
  
! int outer_loop( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
!                 int max_bits,
                  III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
                  int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
  		frame_params *fr_ps,
                  III_scalefac_t *scalefac, /* scalefactors */
                  int gr,
                  int ch,
! 		III_side_info_t *l3_side );
  
  int part2_length( III_scalefac_t *scalefac,
  		  frame_params *fr_ps,
--- 25,59 ----
  
  */
  
! void outer_loop( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
! 		 double xr_org[2][2][576],
!                 int mean_bits,
!                 int VBRbits[2][2],
!                 int bit_rate,
! 		int best_over[2],
!                 III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
!                 int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
! 		frame_params *fr_ps,
!                 III_scalefac_t *scalefac, /* scalefactors */
!                 int gr,
!                 int ch,
! 		III_side_info_t *l3_side,
! 		III_psy_ratio *ratio, 
! 		double pe[2][2],
! 		double ms_ratio[2]);
! 
! void outer_loop_old( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
! 		 double xr_org[2][2][576],
!                 int mean_bits,
                  III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
                  int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
  		frame_params *fr_ps,
                  III_scalefac_t *scalefac, /* scalefactors */
                  int gr,
                  int ch,
! 		III_side_info_t *l3_side,
! 		III_psy_ratio *ratio, double pe[2][2]);
! 
  
  int part2_length( III_scalefac_t *scalefac,
  		  frame_params *fr_ps,
***************
*** 43,49 ****
  
  int quantanf_init( double xr[576] );
  
! int inner_loop( double xr[2][2][576],
                  int l3_enc[2][2][576],
                  int max_bits,
                  gr_info *cod_info,
--- 63,69 ----
  
  int quantanf_init( double xr[576] );
  
! int inner_loop( double xr[2][2][576], double xrpow[2][2][576],
                  int l3_enc[2][2][576],
                  int max_bits,
                  gr_info *cod_info,
***************
*** 80,89 ****
                      gr_info *cod_info,
                      int gr,
                      int ch );
  void calc_noise( double xr[576],
                   int ix[576],
                   gr_info *cod_info,
!                  double xfsf[4][CBLIMIT] );
  
  
  int loop_break( III_scalefac_t *scalefac,
--- 100,126 ----
                      gr_info *cod_info,
                      int gr,
                      int ch );
+ int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info,
+                     int gr, int ch );
  void calc_noise( double xr[576],
                   int ix[576],
                   gr_info *cod_info,
!                  double xfsf[4][CBLIMIT]);
! int calc_noise1( double xr[576],
!                  int ix[576],
!                  gr_info *cod_info,
!                  double xfsf[4][CBLIMIT], 
! 		 int distort[4][CBLIMIT],
!                  III_psy_xmin  *l3_xmin,
! 		 int gr, int ch, double noise);
! 
! void calc_noise2( double xr[2][576],
!                  int ix[2][576],
!                  gr_info *cod_info[2],
!                  double xfsf[2][4][CBLIMIT], 
! 		 int distort[2][4][CBLIMIT],
!                  III_psy_xmin  *l3_xmin,
! 		 int gr, int ch, int over[2], double noise[2]);
  
  
  int loop_break( III_scalefac_t *scalefac,
***************
*** 96,101 ****
--- 133,144 ----
                    int gr,
                    int ch,
  		  III_side_info_t *l3_side );
+ int preemphasis2( double xr[576], double xrpow[576],
+                   III_psy_xmin  *l3_xmin,
+                   int gr,
+                   int ch,
+ 		  III_side_info_t *l3_side,
+                   int distort[4][CBLIMIT] );
  int amp_scalefac_bands( double xr[576],
                          double xfsf[4][CBLIMIT],
                          III_psy_xmin  *l3_xmin,
***************
*** 103,110 ****
                          III_scalefac_t *scalefac,
                          int gr,
                          int ch,
! 			int iteration );
! void quantize( double xr[576],
                 int  ix[576],
                 gr_info *cod_info );
  int ix_max( int ix[576],
--- 146,164 ----
                          III_scalefac_t *scalefac,
                          int gr,
                          int ch,
! 			int iteration);
! int amp_scalefac_bands2( double xr[576], double xrpow[576],
!                         III_psy_xmin  *l3_xmin,
! 			III_side_info_t *l3_side,
!                         III_scalefac_t *scalefac,
!                         int gr,
!                         int ch,
! 			int iteration,
!                         int distort[4][CBLIMIT]);
! int quantize( double xr[576],
!                int  ix[576],
!                gr_info *cod_info );
! void quantize_xrpow( double xr[576],
                 int  ix[576],
                 gr_info *cod_info );
  int ix_max( int ix[576],
***************
*** 115,119 ****
  int
  new_choose_table( int ix[576],
  		  unsigned int begin,
! 		  unsigned int end );
  #endif
--- 169,182 ----
  int
  new_choose_table( int ix[576],
  		  unsigned int begin,
! 		  unsigned int end, int * s );
! 
! /* New SS 20-12-96 */
! int bin_search_StepSize(int desired_rate, double start, int bot, int ix[576],
!            double xrs[576], double xrspow[576], gr_info * cod_info);
! int bin_search_StepSize2(int desired_rate, double start, int bot, int ix[576],
!            double xrs[576], double xrspow[576], gr_info * cod_info);
! int count_bits();
! 
! 
  #endif
diff -r -c -N encoder/loop.c lame3.13/loop.c
*** encoder/loop.c	Wed Jan 22 02:43:16 1997
--- lame3.13/loop.c	Thu Jun 24 18:28:31 1999
***************
*** 2,8 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: loop.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
   *
   * $Log: loop.c,v $
   * Revision 1.2  1997/01/19 22:28:29  rowlands
--- 2,8 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: loop.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $ 
   *
   * $Log: loop.c,v $
   * Revision 1.2  1997/01/19 22:28:29  rowlands
***************
*** 13,65 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *25. 6.92  Toshiyuki Ishino           Ver 1.0                        *
-  *29.10.92  Masahiro Iwadare           Ver 2.0                        *
-  *17. 4.93  Masahiro Iwadare           Updated for IS Modification    *
-  *04.11.93  Seymour Shlien             Speed up inner loop            *
-  *09.09.95  mc@fivebats.com            Several changes for updated IS,*
-  *                                     and some MPEG2-LSF support     *
-  *20.12.96  seymour.shlien@crc.doc.ca  Fixed some bugs and improved   *
-  *                                     the appearance                 *
-  *********************************************************************/ 
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <math.h>
  #include <assert.h>
  #include "l3side.h"
  #include "loop.h"
  #include "huffman.h"
  #include "l3bitstream.h"
  #include "reservoir.h"
  #include "loop-pvt.h"
  
  /* #define DEBUG */
  /* #define DEBUGSC */
! /* #define PERFORM 3 */
! /* If PERFORM is defined to some number, then a file encode.log
!    is preduced showing the intermediate results produced by the
!    outer_loop code for the frame number = PERFORM.
  */
- #define BIN_SEARCH 
- /* for speeding up the iteration_loop algorithm */
  
- #ifdef PERFORM
- FILE *log_output;
- extern int frameNum;
- float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
-                              ,int block_type,int gr,int ch);
- #endif
  
- /* New SS 20-12-96 */
- #ifdef BIN_SEARCH 
- int bin_search_StepSize(int desired_rate, double start, int ix[576],
-            double xrs[576], gr_info * cod_info);
- int count_bits();
- float worst_xfsf_to_xmin_ratio();
- #endif
  
  
  /*
--- 13,66 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <math.h>
  #include <assert.h>
+ #include "globalflags.h"
+ #include "common.h"
  #include "l3side.h"
  #include "loop.h"
  #include "huffman.h"
  #include "l3bitstream.h"
  #include "reservoir.h"
  #include "loop-pvt.h"
+ #include "gtkanal.h"
+ 
  
  /* #define DEBUG */
  /* #define DEBUGSC */
! 
! 
! static int convert_mdct, convert_psy, reduce_sidechannel;
! /*
! mt 5/99.  These global flags denote 4 possibilities:
! 
! 1   MDCT input L/R, quantize L/R,   psy-model thresholds: L/R    -m s
! 2   MDCT input L/R, quantize M/S,   psy-model thresholds: L/R    -m j
! 3   MDCT input M/S, quantize M/S,   psy-model thresholds: M/S    -m f 
! 4   MDCT input L/R, quantize M/S,   psy-model thresholds: M/S     coming soon
! 
! 1:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=0
! 2:  convert_mdct = 1, convert_psy=1,  reduce_sidechannel=1
! 3:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=1
! 4:  convert_mdct = 1, convert_psy=0,  reduce_sidechannel=1
! 
! if (convert_mdct), then iteration_loop will quantize M/S data from
! the L/R input MDCT coefficients.
! 
! if (convert_psy), then calc_noise will compute the noise for the L/R
! channels from M/S MDCT data and L/R psy-model threshold information.
! Distortion in ether L or R channel will be marked as distortion in
! both Mid and Side channels.  
! 
! if (reduce_sidechannel) then outer_loop will allocate less bits
! to the side channel and more bits to the mid channel based on relative 
! energies.
  */
  
  
  
  
  /*
***************
*** 82,88 ****
      {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
    },
    { /* Table B.2.a: 16 kHz */
!     {0,6,12,18,24,30,36,44,45,66,80,96,116,140,168,200,238,248,336,396,464,522,576},
      {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
    },
    { /* Table B.8.b: 44.1 kHz */
--- 83,89 ----
      {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
    },
    { /* Table B.2.a: 16 kHz */
!     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,248,336,396,464,522,576},
      {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
    },
    { /* Table B.8.b: 44.1 kHz */
***************
*** 169,665 ****
  
  
  
  /************************************************************************/
  /*  iteration_loop()                                                    */
  /************************************************************************/
  void
! iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
  		III_side_info_t *l3_side, int l3_enc[2][2][576],
! 		int mean_bits, int stereo, double xr_dec[2][2][576],
! 		III_scalefac_t *scalefac, frame_params *fr_ps,
! 		int ancillary_pad, int bitsPerFrame ) 
! {
!     static int firstcall = 1;
!     III_psy_xmin l3_xmin;
!     gr_info *cod_info;
!     layer *info;
!     int *main_data_begin;
! 
!     int max_bits;
!     int ch, gr, sfb, i, mode_gr;
!     static int huffman_read_flag = 0; 
! 
!     double xr[2][2][576];
!     I576  *ix;
! 
!     main_data_begin = &l3_side->main_data_begin;
!     l3_side->resvDrain = 0;
! 
!     if ( firstcall )
!     {
! 	*main_data_begin = 0;
! 	firstcall = 0;
! #ifdef PERFORM
! 	log_output = fopen("encode.log","w");
! #endif
!     }
  
!     info = fr_ps->header;
!     mode_gr = (info->version == 1) ? 2 : 1;
  
!     scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
!     scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
  
!     /* reading huffman code table */
!     if (huffman_read_flag == 0) {
!         FILE *fi = OpenTableFile( "huffcode" );
!         if ( fi == NULL )
!             exit( EXIT_FAILURE );
!         read_huffcodetab( fi );
!         huffman_read_flag++;
!         fclose( fi );
      }
  
  
!     for ( gr = 0; gr < mode_gr; gr++ )
!     {
!         for ( ch = 0; ch < stereo; ch++ )
! 	{
!             for ( i = 0; i < 576; i++ ) 
!                 xr[gr][ch][i] = xr_org[gr][ch][i];
! 	}
!     }
  
      ResvFrameBegin( fr_ps, l3_side, mean_bits, bitsPerFrame );
  
-     for ( gr = 0; gr < mode_gr; gr++ )
-     {
-         for ( ch = 0; ch < stereo; ch++ )
-         {
-             ix = (I576 *) l3_enc[gr][ch];
-             cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
-             gr_deco(cod_info);
-             calc_xmin( xr, ratio, cod_info, &l3_xmin, gr, ch );
- 	    
- #ifdef DEBUG
-             printf( "----- start gr[%d] ch[%1d] : block_type=%1d, window_switching_flag=%1d (loop)\n",
-                     gr,ch, cod_info->block_type, cod_info->window_switching_flag ); 
- #endif
- 	    
-             if ( info->version == 1 )
-                 calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr );
- 	    
-             /* calculation of number of available bit( per granule ) */
- 	    max_bits = ResvMaxBits( fr_ps, l3_side, &pe[gr][ch], mean_bits );
- #ifdef DEBUG
-             printf( " max_bits = %d, mean_bits = %d (iteration_loop)\n", max_bits, mean_bits ); 
- #endif
- 	    
-             /* reset of iteration variables */
- 	    
-             for ( sfb = 0; sfb < 21; sfb++ )
-                 scalefac->l[gr][ch][sfb] = 0;
-             for ( sfb = 0; sfb < 13; sfb++ )
-                 for ( i = 0; i < 3; i++ )
-                     scalefac->s[gr][ch][sfb][i] = 0;
- 
- 	    for ( i = 0; i < 4; i++ )
- 		cod_info->slen[i] = 0;
- 	    cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
- 
-             cod_info->part2_3_length    = 0;
-             cod_info->big_values        = 0;
-             cod_info->count1            = 0;
-             cod_info->scalefac_compress = 0;
-             cod_info->table_select[0]   = 0;
-             cod_info->table_select[1]   = 0;
-             cod_info->table_select[2]   = 0;
-             cod_info->subblock_gain[0]  = 0;
-             cod_info->subblock_gain[1]  = 0;
-             cod_info->subblock_gain[2]  = 0;
-             cod_info->region0_count     = 0;
-             cod_info->region1_count     = 0;
-             cod_info->part2_length      = 0;
-             cod_info->preflag           = 0;
-             cod_info->scalefac_scale    = 0;
-             cod_info->quantizerStepSize = 0.0;
-             cod_info->count1table_select= 0;
-             
-             /* all spectral values zero ? */
-             if ( fabs(xr_max(xr[gr][ch], 0, 576)) != 0.0 )
-             {
-                 cod_info->quantizerStepSize =
- 			 (double) quantanf_init( xr[gr][ch] );
-                 cod_info->part2_3_length = outer_loop( xr, max_bits, &l3_xmin,
-                                                        l3_enc, fr_ps, scalefac,
-                                                        gr, ch, l3_side );
-             }
- 	    ResvAdjust( fr_ps, cod_info, l3_side, mean_bits );
  
! 	    cod_info->global_gain = nint( cod_info->quantizerStepSize + 210.0 );
! 	    assert( cod_info->global_gain < 256 );
!         } /* for ch */
!     } /* for gr */
!     ResvFrameEnd( fr_ps, l3_side, mean_bits );
  }
  
  
  
  /************************************************************************/
! /*  quantanf_init                                                       */
  /************************************************************************/
! int quantanf_init( double xr[576] )
! /* Function: Calculate the first quantization step quantanf.       */
  {
!     int i, tp = 0;
!     double system_const, minlimit;
!     double sfm = 0.0, sum1 = 0.0, sum2 = 0.0;
      
!     system_const = 8.0;
!     minlimit = -100.0;
  
!     for ( i = 0; i < 576; i++ )
!     {
!         if ( xr[i] != 0 )
! 	{
!             double tpd = xr[i] * xr[i];
!             sum1 += log( tpd );
!             sum2 += tpd;
!         }
      }
!     if ( sum2 != 0.0 )
!     {
!         sfm = exp( sum1 / 576.0 ) / (sum2 / 576.0);
!         tp = nint( system_const * log(sfm) );
! 	if ( tp < minlimit )
! 	    tp = minlimit;
! #ifdef DEBUG
!         printf(" quantanf = %d (quantanf_init)\n",tp );
  #endif
-     }
-       return(tp-70.0); /* SS 19-12-96. Starting value of
-                           global_gain or quantizerStepSize 
-                           has to be reduced for iteration_loop
-                        */
  }
  
  
  
  
! 
  /************************************************************************/
! /*  outer_loop                                                          */
  /************************************************************************/
  /*  Function: The outer iteration loop controls the masking conditions  */
  /*  of all scalefactorbands. It computes the best scalefac and          */
! /*  global gain. This module calls the inner iteration loop             */
! /************************************************************************/
! int outer_loop(
!     double xr[2][2][576],     /*  magnitudes of the spectral values */
!     int max_bits,
      III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
      int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
      frame_params *fr_ps,
      III_scalefac_t *scalefac, /* scalefactors */
!     int gr, int ch, III_side_info_t *l3_side )
  {
!     int status ;
!     int scalesave_l[CBLIMIT], scalesave_s[CBLIMIT][3];
!     int sfb, bits, huff_bits, save_preflag, save_compress;
!     double xfsf[4][CBLIMIT];
!     int i, over, iteration;
!     float max_ratio;
  
  
- /* D576 *xrs; */ /* to eliminate warning messages from gcc compiler */
- /* I576 *ix; */  /* replace this code with below. S. Shlien 15-1-97 */
  
!   double *xrs; 
!   int *ix;  
!   gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
  
! /* xrs = (D576 *) &xr[gr][ch][0]; */ 
! /* ix  = (I576 *) l3_enc[gr][ch]; */
!  
  
! xrs = (double *) &(xr[gr][ch][0]); 
! ix  = (int *) &(l3_enc[gr][ch][0]);
  
  
-     iteration = 0;
- #ifdef PERFORM
-     if(frameNum == PERFORM)
-     fprintf(log_output,"\n\nframe = %d ch = %d gr= %d\n",frameNum,ch,gr);
- #endif
-     do 
-     {
- 	iteration += 1;
- 	cod_info->part2_length = part2_length( scalefac, fr_ps, gr, ch, l3_side );
-         huff_bits = max_bits - cod_info->part2_length;
  
! #ifdef BIN_SEARCH
! 	if(iteration == 1)
!         {
!        bin_search_StepSize(max_bits,cod_info->quantizerStepSize,
!           ix,xrs,cod_info); /* speeds things up a bit */
!         }
! #endif
! #ifdef PERFORM
! 	if(frameNum==PERFORM)
!           fprintf(log_output,"\n    Interim Results %d\n\n",iteration);
!         bits = test_inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch,
!          xfsf,l3_xmin);
! #else
!         bits = inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch );
! #endif
  
!         calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf ); /* distortion calculation */
  
!         for ( sfb = 0; sfb < CBLIMIT; sfb++ ) /* save scaling factors */
!             scalesave_l[sfb] = scalefac->l[gr][ch][sfb];
  
-         for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
-             for ( i = 0; i < 3; i++ )
-                 scalesave_s[sfb][i] = scalefac->s[gr][ch][sfb][i];
-         
-         save_preflag  = cod_info->preflag;
-         save_compress = cod_info->scalefac_compress;
  
!         preemphasis( &xr[gr][ch][0], xfsf, l3_xmin, gr, ch, l3_side );
  
  
  
! #ifdef PERFORM 
!     if(frameNum == PERFORM)  
!     {
!     fprintf(log_output,"\nbits = %d  huff_bits= %d ", bits,huff_bits);
!     fprintf(log_output," max_bits = %d\n",max_bits);
!     fprintf(log_output,"Stepsize = %f ",cod_info->quantizerStepSize);
!     fprintf(log_output," scale_bits    = %d \n", cod_info->part2_length );  
!     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
!     /*if (gr==0 && ch==0)
!       print_quantized_values(log_output,l3_enc[gr][ch] ,cod_info);*/
!     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
!     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
!     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
!     fprintf(log_output,"\n\n");
!     fflush(log_output);
      }
  #endif
!         over = amp_scalefac_bands( &xr[gr][ch][0], xfsf, l3_xmin,
!                                    l3_side, scalefac, gr, ch, iteration );
  
- #if 1
-         if ( (status = loop_break(scalefac, cod_info, gr, ch)) == 0 )
- 	{
- 	    if ( fr_ps->header->version == 1 )
- 		status = scale_bitcount( scalefac, cod_info, gr, ch );
- 	    else
- 		status = scale_bitcount_lsf( scalefac, cod_info, gr, ch );
  	}
! #else
!         status = loop_break( scalefac, cod_info, gr, ch );
! 	if ( fr_ps->header->version == 1 )
! 	    status += scale_bitcount( scalefac, cod_info, gr, ch );
! 	else
! 	    status += scale_bitcount_lsf( scalefac, cod_info, gr, ch );
! #endif
! 
      }
-     while ( (status == 0) && (over > 0) );
  
!     cod_info->preflag = save_preflag;
!     cod_info->scalefac_compress = save_compress;
  
-     for ( sfb = 0; sfb < 21; sfb++ )
-         scalefac->l[gr][ch][sfb] = scalesave_l[sfb];    
  
-     for ( i = 0; i < 3; i++ )
-         for ( sfb = 0; sfb < 12; sfb++ )
-             scalefac->s[gr][ch][sfb][i] = scalesave_s[sfb][i];    
  
!     cod_info->part2_length   = part2_length( scalefac, fr_ps, gr, ch, l3_side );
!     cod_info->part2_3_length = cod_info->part2_length + bits;
  
! #ifdef PERFORM 
!     if(frameNum == PERFORM)
!     {
!     fprintf(log_output,"\n  Final Results\n");
!     fprintf(log_output,"bits = %d  huff_bits= %d", bits,huff_bits);
!     fprintf(log_output," max_bits = %d\n",max_bits);
!     fprintf(log_output," Stepsize = %f ",cod_info->quantizerStepSize);
!     fprintf(log_output, " scale_bits    = %d \n", cod_info->part2_length );  
!     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
!     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
!     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
!     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
!     fflush(log_output);
      }
! #endif    
!     return cod_info->part2_3_length;
! }
  
  
  
  
- /***************************************************************************/ 
- /*         inner_loop                                                      */ 
- /***************************************************************************/ 
- /* The code selects the best quantizerStepSize for a particular set
- /* of scalefacs                                                            */
-  
- int
- inner_loop( double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
- 	    gr_info *cod_info, int gr, int ch )
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
  
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
  
-         calc_runlen( ix, cod_info );  /*rzero,count1,big_values*/
-         bits = c1bits = count1_bitcount( ix, cod_info );  /*count1_table selection*/
-         subdivide( cod_info );  /* bigvalues sfb division */
-         bigv_tab_select( ix, cod_info );  /* codebook selection*/
-         bits += bvbits = bigv_bitcount( ix, cod_info );  /* bit count */
- 
- #ifdef PERFORM
-         if(frameNum == PERFORM)
- 	fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-            cod_info->quantizerStepSize,bits,max_bits);
- #endif
  
-     }
-     while ( bits > max_bits );
  
-     return bits;
  }
  
  
  
- /***************************************************************************/ 
- /*        calc_scfsi                                                       */ 
- /***************************************************************************/ 
- /* calculation of the scalefactor select information ( scfsi )        */
  
- void calc_scfsi( double  xr[576], III_side_info_t *l3_side,
- 	    III_psy_xmin *l3_xmin, int ch, int gr )
- {
-     static int en_tot[2][2]; /* ch,gr */
-     static int en[2][2][21];
-     static int xm[2][2][21];
-     static int xrmax[2][2];
- 
-     int en_tot_krit        = 10;
-     int en_dif_krit        = 100;
-     int en_scfsi_band_krit = 10;
-     int xm_scfsi_band_krit = 10;
- 
-     int scfsi_band;
-     unsigned scfsi_set;
- 
-     int sfb, start, end, i;
-     int condition = 0;
-     double temp, log2 = log( 2.0 );
-     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
  
!     xrmax[gr][ch] = xr_max( xr, 0, 576 );
!     scfsi_set = 0;
  
-     /* the total energy of the granule */    
-     for ( temp = 0.0, i = 0; i < 576; i++ )
-         temp += xr[i] * xr[i];
-     if ( temp == 0.0 )
-         en_tot[gr][ch] = 0.0;
-     else
-         en_tot[gr][ch] = log( temp ) / log2 ;
  
-     /* the energy of each scalefactor band, en */
-     /* the allowed distortion of each scalefactor band, xm */
  
-     if ( cod_info->window_switching_flag == 0 ||
-          cod_info->block_type != 2 )
-         for ( sfb = 0; sfb < 21; sfb++ )
-         {
-             start = scalefac_band_long[ sfb ];
-             end   = scalefac_band_long[ sfb+1 ];
  
-             for ( temp = 0.0, i = start; i < end; i++ )
-                 temp += xr[i] * xr[i];
-             if ( temp == 0.0 )
-                 en[gr][ch][sfb] = 0.0;
-             else
-                 en[gr][ch][sfb] = log( temp )/ log2;
  
!             if ( l3_xmin->l[gr][ch][sfb] == 0.0 )
!                 xm[gr][ch][sfb] = 0.0;
!             else
!                 xm[gr][ch][sfb] = log( l3_xmin->l[gr][ch][sfb] ) / log2;
!         }
!     if ( gr == 1 )
      {
!         int gr2, tp;
  
-         for ( gr2 = 0; gr2 < 2; gr2++ )
-         {
-             /* The spectral values are not all zero */
-             if ( xrmax[ch][gr2] != 0.0 )
-                 condition++;
-             /* None of the granules contains short blocks */
-             if ( (cod_info->window_switching_flag == 0) ||
-                  (cod_info->block_type != 2) )
-                 condition++;
-         }
-         if ( abs(en_tot[0] - en_tot[1]) < en_tot_krit )
-             condition++;
-         for ( tp = 0, sfb = 0; sfb < 21; sfb++ ) 
-             tp += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-         if ( tp < en_dif_krit ) 
-             condition++;
  
-         if ( condition == 6 )
-         {
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-             {
-                 int sum0 = 0, sum1 = 0;
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-                 start = scfsi_band_long[scfsi_band];
-                 end   = scfsi_band_long[scfsi_band+1];
-                 for ( sfb = start; sfb < end; sfb++ )
-                 { 
-                     sum0 += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-                     sum1 += abs( xm[ch][0][sfb] - xm[ch][1][sfb] );
-                 }
  
-                 if ( sum0 < en_scfsi_band_krit && sum1 < xm_scfsi_band_krit )
- 		{
-                     l3_side->scfsi[ch][scfsi_band] = 1;
- 		    scfsi_set |= (1 << scfsi_band);
- 		}
-                 else
-                     l3_side->scfsi[ch][scfsi_band] = 0;
-             } /* for scfsi_band */
- #ifdef DEBUG
- 	    fprintf( stderr, "calc_scfsi: scfsi_set = 0x%02x\n", scfsi_set );
- #endif
-         } /* if condition == 6 */
-         else
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-     } /* if gr == 1 */
- }
  
  
  
--- 170,1028 ----
  
  
  
+ /* convert from L/R <-> Mid/Side */
+ void ms_convert(double xr[2][576],double xr_org[2][576])
+ {
+   int i;
+   for ( i = 0; i < 576; i++ ) {
+     xr[0][i] = (xr_org[0][i]+xr_org[1][i])/SQRT2;
+     xr[1][i] = (xr_org[0][i]-xr_org[1][i])/SQRT2;
+   }
+ }
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+  * allocate bits among the 4 granules based on PE
+  * mt 6/99
+  ************************************************************************/
+ int VBR_on_pe(frame_params *fr_ps, layer *info, III_side_info_t *l3_side, 
+ 	       int VBRbits[2][2],
+ 	       double pe[][2], int *mean_bits)
+ 
+ { 
+   int nshort=0;
+   int index,gr,ch;
+   int bitsPerFrame;
+   int stereo = fr_ps->stereo;  
+   int fullframebits;
+   int mode_gr = (info->version == 1) ? 2 : 1;
+ 
+   getframebits(info,stereo,&bitsPerFrame,mean_bits);
+   fullframebits= ResvFrameBegin( fr_ps, l3_side, *mean_bits, bitsPerFrame );
+   
+   
+   for (gr=0;gr<mode_gr;gr++)
+     for (ch=0;ch<2;ch++) {
+       int shortblock = (l3_side->gr[gr].ch[ch].tt.block_type==2);
+       if (shortblock) nshort ++;
+     }
+   index = nshort;
+   if (index>3) index=3; 
+ 
+   /* impose a minimum bit rate based on number of short blocks */  
+   if (index>0) {
+     /* nshort=1: min 160kbs.  (1 shortblock granule)
+      * nshort=2: min 190kbs.  (2 shortblock granules)
+      * nshort=3: min 220kbs   (3 shortblock granules)
+      * nshort=4: min 256kbs   (4 shortblock granules) */
+     if (info->bitrate_index < 9 + index) info->bitrate_index = 9+index;  
+     if (info->bitrate_index > 14) info->bitrate_index=14;
+ 
+     
+     getframebits(info,stereo,&bitsPerFrame,mean_bits);
+     fullframebits= ResvFrameBegin( fr_ps, l3_side, *mean_bits, bitsPerFrame );
+   }
+ 
+   /* allocate a minimum 125 bits per channel (approx 32kbs) */
+   for (gr=0;gr<mode_gr;gr++) {
+     for (ch=0;ch<2;ch++) {
+       VBRbits[gr][ch] = 125;
+     }
+   }
+   fullframebits -= 500;
+ 
+   /* divide bits based on PE */  
+   if (fullframebits > 0 )
+   {
+     double pe2[2][2],pe_tot=.01;
+     for (gr=0;gr<mode_gr;gr++) {
+       for (ch=0;ch<2;ch++) {
+ 	int shortblock = (l3_side->gr[gr].ch[ch].tt.block_type==2);
+ 	pe2[gr][ch] = Min(pe[gr][ch],2800.);
+ 	if (shortblock)  pe2[gr][ch] = Max(pe2[gr][ch],1800.0);
+ 	pe_tot += pe2[gr][ch];
+       }
+     }
+     for (gr=0;gr<mode_gr;gr++) {
+       for (ch=0;ch<2;ch++) {
+ 	VBRbits[gr][ch] = (fullframebits*pe2[gr][ch])/pe_tot;
+       }
+     }
+   }
+   /* return value = 1 => do not decrease bit rate further */
+   if (index) 
+     return (info->bitrate_index <= 9 + index);
+   else return 0;
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************
+  * increase or decrease frame bitrate based on max_over = number of scale
+  * factor bands with audible distortion.  If bitrate in increased, allocate
+  * the additional bits among the granules based on "over"
+  * mt 6/99
+  ************************************************************************/
+ void VBR_on_over(frame_params *fr_ps, layer *info, III_side_info_t *l3_side, 
+ 	       int VBRbits[2][2], double pe[2][2], int max_over, 
+ 	       int over[2][2], int *mean_bits, int *VBR_no_decrease)
+ 
+ { 
+   int extrabits=0;
+   int gr,ch;
+   int bitsPerFrame;
+   int stereo = fr_ps->stereo;  
+   int fullframebits;
+   int mode_gr = (info->version == 1) ? 2 : 1;
+ 
+   if (max_over <= VBR_q) {
+     info->bitrate_index --;
+     if (info->bitrate_index < VBR_min_bitrate) 
+       info->bitrate_index=VBR_min_bitrate;
+     *VBR_no_decrease = VBR_on_pe(fr_ps,info,l3_side,VBRbits,pe,mean_bits);
+     return;
+   }
+ 
+   getframebits(info,stereo,&bitsPerFrame,mean_bits);
+   fullframebits= ResvFrameBegin( fr_ps, l3_side, *mean_bits, bitsPerFrame );
+ 
+   info->bitrate_index ++;
+   if (info->bitrate_index > VBR_max_bitrate) 
+     info->bitrate_index=VBR_max_bitrate;
+   
+   getframebits(info,stereo,&bitsPerFrame,mean_bits);
+   extrabits= ResvFrameBegin( fr_ps, l3_side, *mean_bits, bitsPerFrame );
+   extrabits -= fullframebits;
+ 
+   /* divide extra bits based on OVER */
+   if (extrabits > 0) {
+     double over2[2][2],over_tot=0;
+     for (gr=0;gr<mode_gr;gr++) {
+       for (ch=0;ch<2;ch++) {
+ 	over2[gr][ch] = over[gr][ch] + 1;
+ 	over_tot += over2[gr][ch];
+       }
+     }
+     for (gr=0;gr<mode_gr;gr++) {
+       for (ch=0;ch<2;ch++) {
+ 	VBRbits[gr][ch] += (extrabits*over2[gr][ch])/over_tot;
+       }
+     }
+   }
+   for (gr=0;gr<mode_gr;gr++) {
+     for (ch=0;ch<2;ch++) {
+       if (VBRbits[gr][ch]>4095) VBRbits[gr][ch]=4095;
+     }
+   }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
  /************************************************************************/
  /*  iteration_loop()                                                    */
  /************************************************************************/
  void
! iteration_loop( double pe[][2], double ms_ener_ratio[2],
! 		double xr_org[2][2][576], III_psy_ratio *ratio,
  		III_side_info_t *l3_side, int l3_enc[2][2][576],
! 		III_scalefac_t *scalefac, frame_params *fr_ps)
! {
!   static int firstcall = 1;
!   III_psy_xmin l3_xmin;
!   gr_info *cod_info;
!   layer *info;
!   int VBRbits[2][2];
!   int best_over[2][2];
!   int bitsPerFrame;
!   int mean_bits;
!   int stereo = fr_ps->stereo;
!   int ch, gr, i, mode_gr, bit_rate;
!   int VBR_no_decrease;
!   int samp_freq;
!   double xr[2][2][576];
!   
!   if ( firstcall ) {
!     l3_side->main_data_begin = 0;
!     memset((char *) &l3_xmin, 0, sizeof(l3_xmin));
!     firstcall = 0;
!   }
!   l3_side->resvDrain = 0;
!   info = fr_ps->header;
!   mode_gr = (info->version == 1) ? 2 : 1;
!   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
!   samp_freq = s_freq[info->version][info->sampling_frequency]*1000 +.5;
  
!   scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
!   scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
!   
  
!   convert_mdct=0;
!   convert_psy=0;
!   reduce_sidechannel=0;
!   if (info->mode_ext==2) {
!     convert_mdct = 1;
!     convert_psy = 1;
!     reduce_sidechannel=1;
!   }
!   if (force_ms) {
!     convert_mdct = 0;
!     convert_psy = 0;
!     reduce_sidechannel=1;
!   }
!   
  
!   /* remove coefficients in scalefactor band 21 (12 for short blocks)
!    * FhG does this for bps <= 128kbs, so we will too.  
!    * This amounds to a 16kHz low-pass filter.  If that offends you, you
!    * probably should not be encoding at 128kbs!
!    * There is no ratio[21] or xfsf[21], so when these coefficients are
!    * included they are just quantized as is.  mt 5/99
!    */
!   if (sfb21 && (samp_freq>33000)) {
!     if (bit_rate <= 64*stereo) {
!       for (ch =0 ; ch < 2 ; ch++)
! 	for ( gr = 0; gr < mode_gr; gr++ ) {
! 	  int shortblock = (l3_side->gr[gr].ch[0].tt.block_type==2);
! 	  if (shortblock) {
! 	    int j;
! 	    for (j=0; j<3; j++) {
! 	      int start = scalefac_band_short[ SFB_SMAX-1 ];
! 	      for ( i = start; i < 192; i++ ) {
! 		int i0 = 3*i+j; 
! 		xr_org[gr][ch][i0]=0;
! 	      }
! 	    }
! 	  }else{
! 	    int start = scalefac_band_long[ SFB_LMAX-1 ];
! 	    for ( i = start; i < 576; i++ ) xr_org[gr][ch][i]=0;
! 	  }
! 	}
!     }
!   }
!   
!   
!   
!   /* some intializations. */
!   for ( gr = 0; gr < mode_gr; gr++ ){
!     for ( ch = 0; ch < stereo; ch++ ){
!       cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
!       gr_deco(cod_info);
      }
+   }
  
  
!   /* dont bother with scfsi. */
!   for ( ch = 0; ch < stereo; ch++ )
!     for ( i = 0; i < 4; i++ )
!       l3_side->scfsi[ch][i] = 0;
!   
! 
  
+   VBR_no_decrease=0;
+   if (VBR) {
+     VBR_no_decrease=VBR_on_pe(fr_ps,info,l3_side,VBRbits,pe,&mean_bits);
+   }else{
+     getframebits(info,stereo,&bitsPerFrame,&mean_bits);
      ResvFrameBegin( fr_ps, l3_side, mean_bits, bitsPerFrame );
+   }
+ 
  
  
! 
!   /* quantize! */
!   do {
!     int max_over;
! 
!     for ( gr = 0; gr < mode_gr; gr++ )    
!       outer_loop( xr, xr_org, mean_bits, VBRbits, bit_rate, best_over[gr],
! 		  &l3_xmin,l3_enc, fr_ps, 
! 		  scalefac,gr,stereo, l3_side, ratio, pe, ms_ener_ratio);
!     
!     if (!VBR) break;
!     
!     /* see if we should try a higher bitrate quantization */
!     max_over=0;
!     for ( gr = 0; gr < mode_gr; gr++ ) 
!       for (ch=0 ; ch < stereo ; ch ++ ) {
! 	if (best_over[gr][ch]>max_over) max_over=best_over[gr][ch];
!       }
!     
!     if ((max_over <= VBR_q) && (info->bitrate_index <= VBR_min_bitrate)) break;
!     if ((max_over > VBR_q) && (info->bitrate_index >= VBR_max_bitrate)) break;
!     /* do not decrease bit rate if we have ever increased bit rate 
!      * otherwise infinite loop */
!     if ((max_over <= VBR_q) && (VBR_no_decrease)) break;
!     
!     /* compute a new bitrate, and allocate bits between granules */
!     if (max_over > VBR_q) VBR_no_decrease=1;
!     VBR_on_over(fr_ps,info,l3_side,VBRbits,pe,max_over,best_over,&mean_bits,&VBR_no_decrease);
!   } while (1);
!   
!   if (VBR) {
!     /* update reservoir status after FINAL quantization/bitrate */
!     for ( gr = 0; gr < mode_gr; gr++ ) {
!       for (ch=0 ; ch < stereo ; ch ++ ) {
! 	gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
! 	ResvAdjust( fr_ps, cod_info, l3_side, mean_bits );
!       }
!     }
!   }
!   
!   /* set the sign of l3_enc */
!   for ( gr = 0; gr < mode_gr; gr++ )
!     for ( ch =  0; ch < stereo; ch++ )
!       {
! 	int *pi = &l3_enc[gr][ch][0];
! 	
! 	for ( i = 0; i < 576; i++) 	    {
! 	  double pr = xr[gr][ch][i];
! 	  if ( (pr < 0) && (pi[i] > 0) )   pi[i] *= -1;
! 	}
!       }
! 
! 
!   ResvFrameEnd( fr_ps, l3_side, mean_bits );
  }
  
  
  
  /************************************************************************/
! /*  init_outer_loop  mt 6/99                                            */
  /************************************************************************/
! void init_outer_loop(
!     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
!     double xr_org[2][2][576],
!     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
!     III_scalefac_t *scalefac, /* scalefactors */
!     int gr, int stereo, III_side_info_t *l3_side,
!     III_psy_ratio *ratio)
  {
!   int ch,sfb,i;
!   gr_info *cod_info[2];  
!   cod_info[0] = &l3_side->gr[gr].ch[0].tt;
!   cod_info[1] = &l3_side->gr[gr].ch[1].tt;
! 
!   /* copy data to be quantized into xr */
!   if (convert_mdct) ms_convert(xr[gr],xr_org[gr]);
!   else memcpy(xr[gr],xr_org[gr],sizeof(double)*2*576);   
! 
! 
!   /* compute max allowed distortion */
!   for ( ch = 0; ch < stereo; ch++ ){
!     calc_xmin( xr_org, ratio, cod_info[ch], l3_xmin, gr, ch );
!   }
! 
      
!   for (ch=0 ; ch < stereo ; ch ++ ){
  
!     /* if ( info->version == 1 )
!       calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr ); 
!     */
! 	    
!     
!     /* reset of iteration variables */
!     
!     for ( sfb = 0; sfb < SFB_LMAX; sfb++ )
!       scalefac->l[gr][ch][sfb] = 0;
!     for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
!       for ( i = 0; i < 3; i++ )
! 	scalefac->s[gr][ch][sfb][i] = 0;
!     
!     for ( i = 0; i < 4; i++ )
!       cod_info[ch]->slen[i] = 0;
!     cod_info[ch]->sfb_partition_table = &nr_of_sfb_block[0][0][0];
!     
!     cod_info[ch]->part2_3_length    = 0;
!     cod_info[ch]->big_values        = 0;
!     cod_info[ch]->count1            = 0;
!     cod_info[ch]->scalefac_compress = 0;
!     cod_info[ch]->table_select[0]   = 0;
!     cod_info[ch]->table_select[1]   = 0;
!     cod_info[ch]->table_select[2]   = 0;
!     cod_info[ch]->subblock_gain[0]  = 0;
!     cod_info[ch]->subblock_gain[1]  = 0;
!     cod_info[ch]->subblock_gain[2]  = 0;
!     cod_info[ch]->region0_count     = 0;
!     cod_info[ch]->region1_count     = 0;
!     cod_info[ch]->part2_length      = 0;
!     cod_info[ch]->preflag           = 0;
!     cod_info[ch]->scalefac_scale    = 0;
!     cod_info[ch]->quantizerStepSize = 0.0;
!     cod_info[ch]->count1table_select= 0;
!     cod_info[ch]->address1          = 0;
!     cod_info[ch]->address2          = 0;
!     cod_info[ch]->address3          = 0;
!   }
! 
! 
! #define SBGAINXXX
! #ifdef  SBGAIN
!   /* compute subblock gains */
!   for (ch=0 ; ch < stereo ; ch ++) {
!     int j,b;  double en[3],mx;
!     if ((cod_info[ch]->block_type ==2) && count[ch]) {
!       /* estimate energy within each subblock */
!       for (b=0; b<3; b++) en[b]=0;
!       for ( i=0,j = 0; j < 192; j++ ) {
! 	for (b=0; b<3; b++) {
! 	  en[b]+=xr[gr][ch][i]*xr[gr][ch][i];
! 	  i++;
! 	}
!       }
!       mx = 1e-12;
!       for (b=0; b<3; b++) mx=Max(mx,en[b]);
!       for (b=0; b<3; b++) en[b] = Max(en[b],1e-12)/mx;
!       printf("ener = %4.2f  %4.2f  %4.2f  \n",en[0],en[1],en[2]);
!       /* pick gain so that 2^(2gain)*en[0] = 1  */
!       /* gain = .5* log( 1/en[0] )/log(2) = -.5*log(en[])/log(2) */
!       for (b=0; b<3; b++) {
! 	cod_info[ch]->subblock_gain[b]=nint(-.5*log(en[b])/log(2.0));
! 	if (cod_info[ch]->subblock_gain[b] > 2) 
! 	  cod_info[ch]->subblock_gain[b]=2;
! 	if (cod_info[ch]->subblock_gain[b] < 0) 
! 	  cod_info[ch]->subblock_gain[b]=0;
!       }
      }
!   }
  #endif
  }
  
  
  
  
!   
  /************************************************************************/
! /*  outer_loop                                                         */
  /************************************************************************/
  /*  Function: The outer iteration loop controls the masking conditions  */
  /*  of all scalefactorbands. It computes the best scalefac and          */
! /*  global gain. This module calls the inner iteration loop             
!  * 
!  *  mt 5/99 completely rewritten to allow for bit reservoir control,   
!  *  mid/side channels with L/R or mid/side masking thresholds, 
!  *  and chooses best quantization instead of last quantization when 
!  *  no distortion free quantization can be found.  
!  *  
!  *  added VBR support mt 5/99
!  ************************************************************************/
! void outer_loop(
!     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
!     double xr_org[2][2][576],
!     int mean_bits,
!     int VBRbits[2][2],
!     int bit_rate,
!     int best_over[2],
      III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
      int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
      frame_params *fr_ps,
      III_scalefac_t *scalefac, /* scalefactors */
!     int gr, int stereo, III_side_info_t *l3_side,
!     III_psy_ratio *ratio, double pe[2][2], double ms_ener_ratio[2])
  {
!   int status[2],notdone[2]={0,0},count[2]={0,0},bits_found[2];
!   int targ_bits[2],real_bits[2],tbits,extra_bits; 
!   int scalesave_l[2][CBLIMIT], scalesave_s[2][CBLIMIT][3];
!   int sfb, bits, huff_bits, save_preflag[2], save_compress[2];
!   double xfsf[2][4][CBLIMIT];
!   double xrpow[2][2][576],temp;
!   int distort[2][4][CBLIMIT];
!   int save_l3_enc[2][576];  
!   int save_real_bits[2];
!   int i,over[2], iteration, ch, try_scale;
!   int better[2];
!   double tot_noise[2];
!   double best_noise[2];
!   gr_info save_cod_info[2];
!   gr_info *cod_info[2];  
! 
!   cod_info[0] = &l3_side->gr[gr].ch[0].tt;
!   cod_info[1] = &l3_side->gr[gr].ch[1].tt;
!   for (ch=0 ; ch < stereo ; ch ++) 
!     best_over[ch] = 100;
  
+   init_outer_loop(xr,xr_org,l3_xmin,scalefac,gr,stereo,l3_side,ratio);  
+   
+   for (ch=0 ; ch < stereo ; ch ++) {
+     count[ch]=0;
+     for (i=0; i<576; i++) {
+       if ( fabs(xr[gr][ch][i]) > 0 ) count[ch]++; 
+     }
+     notdone[ch]=count[ch];
+     if (count[ch]==0) best_over[ch]=0;
+   }
  
  
!   /******************************************************************
!    * allocate bits for each channel 
!    ******************************************************************/
!   if (VBR) {
!     for (ch=0 ; ch < stereo ; ch ++ )
!       targ_bits[ch]=VBRbits[gr][ch];
! 
!   }else { 
!     int add_bits[2]; 
!     double bits_needed;
  
!     /* allocate targ_bits for granule */
!     ResvMaxBits2( mean_bits, &tbits, &extra_bits, gr);
  
!     for (ch=0 ; ch < stereo ; ch ++ )
!       targ_bits[ch]=tbits/stereo;
!     
!     // allocate extra bits from reservoir based on PE 
!     bits=0;
!     for (ch=0; ch<stereo; ch++) {
!       /* extra bits based on PE > 700 */
!       add_bits[ch]=(pe[gr][ch]-700)/2.0;  /* 3.0; */
!       if (convert_psy) bits_needed = (pe[gr][0]+pe[gr][1]-1400)/2.0;
!       
!       /* short blocks need extra, no matter what the pe */
!       if (cod_info[ch]->block_type==2) 
! 	if (add_bits[ch]<500) add_bits[ch]=500;
!       
!       if (add_bits[ch] < 0) add_bits[ch]=0;
!       bits += add_bits[ch];
!     }
!     for (ch=0; ch<stereo; ch++) {
!       if (bits > extra_bits) add_bits[ch] = (extra_bits*add_bits[ch])/bits;
!       targ_bits[ch] = targ_bits[ch] + add_bits[ch];
!     }
!     for (ch=0; ch<stereo; ch++) 
!       extra_bits -= add_bits[ch];
!   }
  
  
  
!   if (reduce_sidechannel) {
!     /*  ms_ener_ratio = 0:  allocate 66/33  mid/side  fac=.33  
!      *  ms_ener_ratio =.5:  allocate 50/50 mid/side   fac= 0 */
!     /* 75/25 split is fac=.5 */
!     /* float fac = .50*(.5-ms_ener_ratio[gr])/.5;*/
!     float fac = .33*(.5-ms_ener_ratio[gr])/.5;
!     if (fac<0) fac=0;
! 
!     /* dont reduce side channel below 125 bits */
!     if (targ_bits[1]-targ_bits[1]*fac > 125) {
!       targ_bits[0] += targ_bits[1]*fac;
!       targ_bits[1] -= targ_bits[1]*fac;
!     }
!   }
!   
!   /* dont allow to many bits per channel */  
!   for (ch=0; ch<stereo; ch++) {
!     int max_bits = mean_bits/2 + 1200;
!     if (targ_bits[ch] > max_bits) {
!       extra_bits += (targ_bits[ch] - max_bits);
!       targ_bits[ch] = max_bits;
!     }
!   }
!   
!   
  
!   
!   
!   /* BEGIN MAIN LOOP */
!   iteration = 0;
  
!   while ( (notdone[0] || notdone[1])  ) {
!     int pre_just_turned_on[2];
!     iteration ++;
! 
!     if (iteration==1) {
!       /* compute initial quantization step */
!       for (ch=0 ; ch < stereo ; ch ++ )
! 	if (count[ch]) {
! 	  for(i=0;i<576;i++) 	    {
! 	    temp=fabs(xr[gr][ch][i]);
! 	    xrpow[gr][ch][i]=sqrt(sqrt(temp)*temp);
! 	  }
! 	  bits_found[ch]=bin_search_StepSize2(targ_bits[ch],-211.0,46,
! 	      l3_enc[gr][ch],xr[gr][ch],xrpow[gr][ch],cod_info[ch]); 
! 	}
!     }
  
  
!     for (ch=0 ; ch < stereo ; ch ++ ) {
!     /* inner_loop starts with the initial quantization step computed above
!      * and slowly increases until the bits < huff_bits.
!      * Thus is it important not to start with too large of an inital
!      * quantization step.  Too small is ok, but inner_loop will take longer 
!      */
!       for (ch=0 ; ch < stereo ; ch ++ ) {
! 	if (notdone[ch]) {
! 	  cod_info[ch]->part2_length = part2_length( scalefac, fr_ps, gr, ch, l3_side );
! 	  huff_bits = targ_bits[ch] - cod_info[ch]->part2_length;
! 	  if (huff_bits < 0) {
! 	    if (iteration==1) {
! 	      fprintf(stderr,"ERROR: outer_loop(): huff_bits < 0. \n");
! 	      exit(-5);
! 	    }else{
! 	      /* scale factors too large, not enough bits. use previous quantizaton */
! 	      notdone[ch]=0;
! 	      over[ch]=999;
! 	    }
! 	  }else{
! 	    /* if this is the first iteration, see if we can reuse the quantization
! 	     * computed in bin_search_StepSize above */
! 	    if (iteration==1) {
! 	      if(bits_found[ch]>huff_bits) {
! 		cod_info[ch]->quantizerStepSize+=1.0;
! 		real_bits[ch] = inner_loop( xr, xrpow, l3_enc, huff_bits, cod_info[ch], gr, ch );
! 	      } else real_bits[ch]=bits_found[ch];
! 	    }
! 	    else 
! 	      real_bits[ch]=inner_loop( xr, xrpow, l3_enc, huff_bits, cod_info[ch], gr, ch );
! 	  }
! 	}
!       }
!     }
  
+     if (fast_mode) {
+       for (ch=0; ch<stereo; ch++)
+ 	over[ch]=0;
+     }else{
+       if (convert_psy) {
+ 	/* mid/side coefficiets, l/r thresholds */
+ 	calc_noise2( xr[gr], l3_enc[gr], cod_info, xfsf,
+ 		     distort, l3_xmin,gr,stereo,over,tot_noise);
+       }	else {
+ 	  /* coefficients and thresholds both l/r (or both mid/side) */
+ 	  for (ch=0; ch<stereo; ch++)
+ 	    if (notdone[ch])
+ 	      over[ch]=calc_noise1( xr[gr][ch], l3_enc[gr][ch], cod_info[ch], 
+ 				    xfsf[ch],distort[ch], l3_xmin,gr,ch, tot_noise[ch]);
+       }
+     }
  
  
!     /* check if this quantization is better the our saved quantization */
!     for (ch=0 ; ch < stereo ; ch ++ ) {
!       better[ch]=0;
!       if (notdone[ch]) {
! 	if (convert_psy) {
! 	  if (experimentalZ) {
! 	    better[ch] = (over[0]+over[1]) < (best_over[0]+best_over[1]);
!             if ((over[0]+over[1])==(best_over[0]+best_over[1])) {
! 	      better[ch] = (tot_noise[0]+tot_noise[1]) < (best_noise[0]+best_noise[1]);
! 	    }
! 	  } else {
! 	    better[ch] = (over[0]+over[1]) <= (best_over[0]+best_over[1]);
! 	  }
! 	}else{
! 	  if (experimentalZ) {
! 	    better[ch] = ((over[ch] < best_over[ch]) ||
! 			  ((over[ch]==best_over[ch]) && (tot_noise[ch]<=best_noise[ch])) ) ;
! 	  }else{
! 	    better[ch] = (over[ch] <= best_over[ch]);
! 	  }
! 	}
!       }
      }
+     /* save data so we can restore this quantization later */    
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       if (better[ch]) {
+ 	best_over[ch]=over[ch];
+ 	best_noise[ch]=tot_noise[ch];
+ 	if (notdone[ch]) {
+ 	  for ( sfb = 0; sfb < CBLIMIT; sfb++ ) /* save scaling factors */
+ 	    scalesave_l[ch][sfb] = scalefac->l[gr][ch][sfb];
+ 	  
+ 	  for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
+ 	    for ( i = 0; i < 3; i++ )
+ 	      scalesave_s[ch][sfb][i] = scalefac->s[gr][ch][sfb][i];
+ 	  
+ 	  save_preflag[ch]  = cod_info[ch]->preflag;
+ 	  save_compress[ch] = cod_info[ch]->scalefac_compress;
+ 	  
+ 	  memcpy(save_l3_enc[ch],l3_enc[gr][ch],sizeof(l3_enc[gr][ch]));   
+ 	  memcpy(&save_cod_info[ch],cod_info[ch],sizeof(save_cod_info[ch]));
+ 	  save_real_bits[ch]=real_bits[ch];
+ 
+ #ifdef HAVEGTK
+ 	  if (gtkflag) {
+ 	    for ( i = 0; i < 3; i++ ) {
+ 	      for ( sfb = cod_info[ch]->sfb_smax; sfb < 12; sfb++ )  {
+ 		pinfo->xfsf_s[gr][ch][3*sfb+i] =  
+ 		  pinfo->thr_s[gr][ch][3*sfb+i]*xfsf[ch][i+1][sfb]/
+ 		  (1e-20+l3_xmin->s[gr][ch][sfb][i]);
+ 	      }
+ 	    }
+ 	    for ( sfb = 0; sfb < cod_info[ch]->sfb_lmax; sfb++ )   {
+ 	      pinfo->xfsf[gr][ch][sfb] =  
+ 		pinfo->thr[gr][ch][sfb]*xfsf[ch][0][sfb]/
+ 		(1e-20 + l3_xmin->l[gr][ch][sfb]);
+ 	    }
+ 	    pinfo->over[gr][ch]=over[ch];
+ 	    pinfo->noise[gr][ch]=tot_noise[ch];
+ 	  }
  #endif
! 	  
  
  	}
!       }
      }
  
!     /* if no bands with distortion, we are done */
!     for (ch=0 ; ch < stereo ; ch ++ ) 
!       if (notdone[ch]) {
! 	if (convert_psy) 
! 	  notdone[ch] = (over[0] || over[1]);
! 	else
! 	  notdone[ch] = over[ch];
!       }
! 
  
  
  
!     /* see if we should apply preemphasis */
!     for (ch=0 ; ch < stereo ; ch ++ ) {
!       pre_just_turned_on[ch]=0;
!       if (notdone[ch]) pre_just_turned_on[ch]=
! 	 preemphasis2( xr[gr][ch], xrpow[gr][ch], l3_xmin, 
! 	       gr, ch, l3_side,	distort[ch]);
!     }
!     
!     
!     /* if we didn't just apply pre-emph, let us see if we should 
!      * amplify some scale factor bands */
!     for (ch=0 ; ch < stereo ; ch ++ ) 
!       if (notdone[ch] && (!pre_just_turned_on[ch]) ) {
! 	  amp_scalefac_bands2( xr[gr][ch], xrpow[gr][ch], l3_xmin,
! 		l3_side, scalefac, gr, ch, iteration,distort[ch]);
!       }
!     
  
!     /* check to make sure we have not amplified too much */
!     try_scale=0;
!     for (ch=0 ; ch < stereo ; ch ++ ) {
!       if (notdone[ch]) {
! 	if ( (status[ch] = loop_break(scalefac, cod_info[ch], gr, ch)) == 0 ) {
! 	  if ( fr_ps->header->version == 1 ) {
! 	    status[ch] = scale_bitcount( scalefac, cod_info[ch], gr, ch );
! 	    if (status[ch] && (cod_info[ch]->scalefac_scale==0)) try_scale=1; 
! 	  }else{
! 	    status[ch] = scale_bitcount_lsf( scalefac, cod_info[ch], gr, ch );
! 	    if (status[ch] && (cod_info[ch]->scalefac_scale==0)) try_scale=1; 
! 	  }
!         }
! 	notdone[ch] = !status[ch];
!       }
      }
!     if (try_scale && experimentalY) {
!       init_outer_loop(xr,xr_org,l3_xmin,scalefac,gr,stereo,l3_side,ratio);  
!       for (ch=0 ; ch < stereo ; ch ++ ) {
! 	iteration=0;
! 	notdone[ch]=1;
! 	cod_info[ch]->scalefac_scale=1;
!       }
!     }
!   }    /* done with main iteration */
!   
  
+   
+   /* restore some data */
+   for (ch=0 ; ch < stereo ; ch ++ ) {
+     if (count[ch] ) {
+       cod_info[ch]->preflag = save_preflag[ch];
+       cod_info[ch]->scalefac_compress = save_compress[ch];
+       
+       for ( sfb = 0; sfb < CBLIMIT; sfb++ ) {
+ 	scalefac->l[gr][ch][sfb] = scalesave_l[ch][sfb];    
+       }
+       
+       for ( i = 0; i < 3; i++ )
+ 	for ( sfb = 0; sfb < SFB_SMAX; sfb++ ) {
+ 	  scalefac->s[gr][ch][sfb][i] = scalesave_s[ch][sfb][i];    
+ 	}
  
+       { 
+ 	real_bits[ch]=save_real_bits[ch];  
+ 	memcpy(l3_enc[gr][ch],save_l3_enc[ch],sizeof(l3_enc[gr][ch]));   
+ 	memcpy(cod_info[ch],&save_cod_info[ch],sizeof(save_cod_info[ch]));
+ 	
+ 	if ( fr_ps->header->version == 1 )
+ 	  status[ch] = scale_bitcount( scalefac, cod_info[ch], gr, ch );
+ 	else
+ 	  status[ch] = scale_bitcount_lsf( scalefac, cod_info[ch], gr, ch );
+ 	if (status[ch]) {
+ 	  fprintf(stderr,"Error recomputing scalefac_compress...this should not happen");
+ 	  exit(-10);
+ 	}
+       }
+       cod_info[ch]->part2_length   = part2_length( scalefac, fr_ps, gr, ch, l3_side );
+       cod_info[ch]->part2_3_length = cod_info[ch]->part2_length + real_bits[ch];
  
+ #ifdef HAVEGTK
+       if (gtkflag)
+ 	pinfo->LAMEmainbits[gr][ch]=cod_info[ch]->part2_3_length;
+ #endif
+     }      
+   }
+   
+   /* finish up */
+   for (ch=0 ; ch < stereo ; ch ++ ) {
+     if (!VBR) ResvAdjust( fr_ps, cod_info[ch], l3_side, mean_bits );
+     cod_info[ch]->global_gain = nint( cod_info[ch]->quantizerStepSize + 210.0 );
+     assert( cod_info[ch]->global_gain < 256 );
+   }
  
  
  
  
  
  }
  
  
  
  
  
!   
  
  
  
  
  
! /*************************************************************************** 
!  *         inner_loop                                                      * 
!  *************************************************************************** 
!  * The code selects the best quantizerStepSize for a particular set
!  * of scalefacs                                                            */
!  
! int
! inner_loop( double xr[2][2][576], double xrpow[2][2][576],
! 	    int l3_enc[2][2][576], int max_bits,
! 	    gr_info *cod_info, int gr, int ch )
! {
!     int bits;
! 
!     assert( max_bits >= 0 );
!     cod_info->quantizerStepSize -= 1.0;;
!     do
      {
!       cod_info->quantizerStepSize += 1.0;
!       quantize_xrpow( xrpow[gr][ch], l3_enc[gr][ch], cod_info );
!       bits = count_bits(l3_enc[gr][ch],cod_info);  
!     }
!     while ( bits > max_bits );
!     return bits;
! }
  
  
  
  
  
  
***************
*** 673,679 ****
  int part2_length( III_scalefac_t *scalefac, frame_params *fr_ps,
  	      int gr, int ch, III_side_info_t *si )
  {
!     int slen1, slen2, slen3, slen4, bits, sfb, window, partition;
      gr_info *gi = &si->gr[gr].ch[ch].tt;
  
      bits = 0;
--- 1036,1042 ----
  int part2_length( III_scalefac_t *scalefac, frame_params *fr_ps,
  	      int gr, int ch, III_side_info_t *si )
  {
!     int slen1, slen2,  bits, partition;
      gr_info *gi = &si->gr[gr].ch[ch].tt;
  
      bits = 0;
***************
*** 687,700 ****
  
  	if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	{
- 	    if ( gi->mixed_block_flag )
- 	    {
- 		bits += (8 * slen1) + (9 * slen1) + (18 * slen2);
- 	    }
- 	    else
- 	    {
  		bits += (18 * slen1) + (18 * slen2);
- 	    }
  	}
  	else
  	{
--- 1050,1056 ----
***************
*** 738,749 ****
  
      static int slen1[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
      static int slen2[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
-     static int pow2[5]   = { 1, 2, 4, 8, 16 };
  
      if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
      {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
              /* a = 18; b = 18;  */
              for ( i = 0; i < 3; i++ )
              {
--- 1094,1102 ----
***************
*** 754,776 ****
                      if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
                          max_slen2 = scalefac->s[gr][ch][sfb][i];
              }
-         }
-         else
-         {/* mixed_block_flag = 1 */
-             /* a = 17; b = 18;  */
-             for ( sfb = 0; sfb < 8; sfb++ )
-                 if ( scalefac->l[gr][ch][sfb] > max_slen1 )
-                     max_slen1 = scalefac->l[gr][ch][sfb];
-             for ( i = 0; i < 3; i++ )
-             {
-                 for ( sfb = 3; sfb < 6; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
-                         max_slen1 = scalefac->s[gr][ch][sfb][i];
-                 for ( sfb = 6; sfb < 12; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
-                         max_slen2 = scalefac->s[gr][ch][sfb][i];
-             }
-         }
      }
      else
      { /* block_type == 1,2,or 3 */
--- 1107,1112 ----
***************
*** 785,791 ****
  
      for ( k = 0; k < 16; k++ )
      {
!         if ( (max_slen1 < pow2[slen1[k]]) && (max_slen2 < pow2[slen2[k]]) )
          { 
              ep = 0;
              break;
--- 1121,1127 ----
  
      for ( k = 0; k < 16; k++ )
      {
!         if ( (max_slen1 < (1<<slen1[k])) && (max_slen2 < (1<<slen2[k])) )
          { 
              ep = 0;
              break;
***************
*** 794,803 ****
  
      if ( ep == 0 )
          cod_info->scalefac_compress = k;
- #ifdef DEBUG
-     if ( ep != 0 ) 
-         printf( "---WARNING !! Amplification of some bands over limits\n" );
- #endif
      return ep;
  }
  
--- 1130,1135 ----
***************
*** 818,824 ****
  		    int gr, int ch )
  {
      int table_number, row_in_table, partition, nr_sfb, window, over;
!     int i, k, sfb, max_sfac[ 4 ];
      unsigned *partition_table;
  
      /*
--- 1150,1156 ----
  		    int gr, int ch )
  {
      int table_number, row_in_table, partition, nr_sfb, window, over;
!     int i, sfb, max_sfac[ 4 ];
      unsigned *partition_table;
  
      /*
***************
*** 835,842 ****
  
      if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
      {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
  	    row_in_table = 1;
  	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
  	    for ( sfb = 0, partition = 0; partition < 4; partition++ )
--- 1167,1172 ----
***************
*** 847,872 ****
  			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
  			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
  	    }
-         }
-         else
-         {/* mixed_block_flag = 1 */
- 	    row_in_table = 2;
- 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	    partition = 0;
- 	    nr_sfb = partition_table[ partition ];
- 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
- 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
- 	    
- 	    for ( sfb = 0, partition = 1; partition < 4; partition++ )
- 	    {
- 		nr_sfb = partition_table[ partition ] / 3;
- 		for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		    for ( window = 0; window < 3; window++ )
- 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
- 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
- 	    }
-         }
      }
      else
      {
--- 1177,1182 ----
***************
*** 939,960 ****
  }
  
  
  /*************************************************************************/
  /*            calc_noise                                                 */
  /*************************************************************************/
  
- /*   Function: Calculate the distortion introduced by the quantization   */
- /*   in each scale factor band.                                          */
- 
- void calc_noise( double xr[576], int ix[576], gr_info *cod_info,
- 	    double xfsf[4][CBLIMIT] )
  {
!     int start, end, sfb, l, i;
      double sum,step,bw;
  
      D192_3 *xr_s;
      I192_3 *ix_s;
  
      xr_s = (D192_3 *) xr;
      ix_s = (I192_3 *) ix;
  
--- 1249,1282 ----
  }
  
  
+ 
+ 
  /*************************************************************************/
  /*            calc_noise                                                 */
  /*************************************************************************/
+ /*  mt 5/99:  Function: Improved calc_noise for a single channel   */
+ int calc_noise1( double xr[576], int ix[576], gr_info *cod_info,
+ 	    double xfsf[4][CBLIMIT], int distort[4][CBLIMIT],
+             III_psy_xmin *l3_xmin,int gr, int ch, double noise)
  
  {
!     int start, end, sfb, l, i, over=0;
      double sum,step,bw;
  
      D192_3 *xr_s;
      I192_3 *ix_s;
  
+     #define PRECALC_SIZE 1024 /* WAS 256 !!! */
+     static double pow43[PRECALC_SIZE];
+     static int init=0;
+     noise=0;
+ 
+     if (init==0) {
+       init++;
+       for(i=0;i<PRECALC_SIZE;i++)
+         pow43[i] = pow((double)i, 4.0/3.0);
+     }
+       
      xr_s = (D192_3 *) xr;
      ix_s = (I192_3 *) ix;
  
***************
*** 968,982 ****
          for ( sum = 0.0, l = start; l < end; l++ )
          {
              double temp;
!             temp = fabs( xr[l] ) - pow( (double) ix[l], 4.0 / 3.0 ) * step;
!             sum += temp * temp; 
          }
          xfsf[0][sfb] = sum / bw;
      }
  
      for ( i = 0; i < 3; i++ )
      {
          step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 ); /* subblock_gain ? */
          for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
          {
              start = scalefac_band_short[ sfb ];
--- 1290,1317 ----
          for ( sum = 0.0, l = start; l < end; l++ )
          {
              double temp;
! 	    if (ix[l]<PRECALC_SIZE)
! 	      temp = fabs(xr[l]) - pow43[ix[l]] * step;
! 	    else
!             {   
!                temp = fabs(xr[l]) - pow((double)ix[l],4.0/3.0)*step;
! 	       /*   printf("EHHHHHHH !?!?! ---> %d\n",ix[l]); .. table is not big enough */
!             }
! 	      sum += temp * temp; 
          }
          xfsf[0][sfb] = sum / bw;
+ 	distort[0][sfb] = ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] );
+ 	if (distort[0][sfb]) over++;
+ 	if (distort[0][sfb]) noise += xfsf[0][sfb] - l3_xmin->l[gr][ch][sfb];
      }
  
+ 
      for ( i = 0; i < 3; i++ )
      {
          step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 ); /* subblock_gain ? */
+ 	if (cod_info->subblock_gain[i] )
+ 	  step *= pow(2.0,-2.0*cod_info->subblock_gain[i]);
+ 
          for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
          {
              start = scalefac_band_short[ sfb ];
***************
*** 986,1001 ****
              for ( sum = 0.0, l = start; l < end; l++ )
              {
                  double temp;
!                 temp = fabs( (*xr_s)[l][i] ) - pow( (double) (*ix_s)[l][i], 4.0 / 3.0 ) * step;
                  sum += temp * temp;
              }       
              xfsf[i+1][sfb] = sum / bw;
          }
      }
  }
  
  
  
  
  /*************************************************************************/
  /*            calc_xmin                                                  */
--- 1321,1469 ----
              for ( sum = 0.0, l = start; l < end; l++ )
              {
                  double temp;
! 		if((*ix_s)[l][i]<PRECALC_SIZE)
!                     temp = fabs((*xr_s)[l][i]) - pow43[(*ix_s)[l][i]] * step;
!                 else
!                 {
!                     temp = fabs((*xr_s)[l][i]) - pow((double)(*ix_s)[l][i],4.0/3.0)*step;
! 		    /*    printf("EHHHHHHH !?!?! ---> %d\n",(*ix_s)[l][i]); */
!                 }
                  sum += temp * temp;
              }       
              xfsf[i+1][sfb] = sum / bw;
+ 	    distort[i+1][sfb] = 
+ 	    ( xfsf[i+1][sfb] > l3_xmin->s[gr][ch][sfb][i] );
+ 	    if (distort[i+1][sfb]) over++;
+ 	    if (distort[i+1][sfb]) noise += xfsf[i+1][sfb]-l3_xmin->s[gr][ch][sfb][i];
          }
      }
+ return over;
  }
  
  
  
+ /*************************************************************************/
+ /*            calc_noise2                                                */
+ /*************************************************************************/
+ /*   Improved version of calc_noise for dual channel.  This routine is */
+ /*   used when you are quantizaing mid and side channels using masking */
+ /*   thresholds from L and R channels.  mt 5/99 */
+ 
+ void calc_noise2( double xr[2][576], int ix[2][576], gr_info *cod_info[2],
+ 	    double xfsf[2][4][CBLIMIT], int distort[2][4][CBLIMIT],
+             III_psy_xmin *l3_xmin,int gr,int stereo, int over[2], 
+             double noise[2])
+ {
+     int start, end, sfb, l, i;
+     double sum[2],step_s[3][2],step[2],bw;
+ 
+     D192_3 *xr_s[2];
+     I192_3 *ix_s[2];
+ 
+     #define PRECALC_SIZE 1024 /* WAS 256 !!! */
+     static double pow43[PRECALC_SIZE];
+     int ch;
+     static int init=0;
+     double diff[2], qcoeff;
+ 
+     if (init==0) {
+       init++;
+       for(i=0;i<PRECALC_SIZE;i++)
+         pow43[i] = pow((double)i, 4.0/3.0);
+     }
+     
+     
+ 
+     /* calc_noise2: we can assume block types of both channels must be the same */
+     if (cod_info[0]->block_type != 2) {
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       over[ch]=0;
+       noise[ch]=0;
+       step[ch] = pow( 2.0, (cod_info[ch]->quantizerStepSize) * 0.25 );
+     }
+     for ( sfb = 0; sfb < SFB_LMAX-1; sfb++ ) {
+       start = scalefac_band_long[ sfb ];
+       end   = scalefac_band_long[ sfb+1 ];
+       bw = end - start;
+       
+       for (ch=0 ; ch < stereo ; ch ++ ) sum[ch]=0;
+       for ( l = start; l < end; l++ ) {
+ 	for (ch=0 ; ch < stereo ; ch ++ ) {
+ 	  qcoeff= (ix[ch][l] < PRECALC_SIZE) ?
+ 	    pow43[ix[ch][l]] * step[ch]: 
+ 	    pow((double)ix[ch][l],4.0/3.0)*step[ch];  
+ 	  if (xr[ch][l]<0) qcoeff=-qcoeff;
+ 	  diff[ch]=xr[ch][l]-qcoeff;
+ 	}
+ 	sum[0] += (diff[0]+diff[1])*(diff[0]+diff[1])/(2.0);
+ 	sum[1] += (diff[0]-diff[1])*(diff[0]-diff[1])/(2.0);
+       }
+       for (ch=0 ; ch < stereo ; ch ++ ) {
+ 	xfsf[ch][0][sfb] = sum[ch] / bw;
+ 	distort[ch][0][sfb] = ( xfsf[ch][0][sfb] > l3_xmin->l[gr][ch][sfb] );
+ 	if (distort[ch][0][sfb]) over[ch]++;
+ 	if (distort[ch][0][sfb]) noise[ch] += xfsf[ch][0][sfb] - l3_xmin->l[gr][ch][sfb];
+       }
+ 
+       /* if there is audible distortion in left or right channel, set flags
+        * to denote distortion in both mid and side channels */
+       for (ch=0 ; ch < stereo ; ch ++ ) {
+ 	distort[ch][0][sfb] = (distort[0][0][sfb] || distort[1][0][sfb]);
+       }
+     }
+     }
+ 
+     /* calc_noise2: we can assume block types of both channels must be the same */
+     if (cod_info[0]->block_type == 2) {
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+ 
+       for (i=0;i<3;i++){
+ 	step_s[i][ch] = pow( 2.0, (cod_info[ch]->quantizerStepSize) * 0.25 ); /* subblock_gain ? */
+ 	if (cod_info[ch]->subblock_gain[i] )
+ 	  step_s[i][ch] *= pow(2.0,-2.0*cod_info[ch]->subblock_gain[i]);
+       }
+ 
+       over[ch] = 0;
+       xr_s[ch] = (D192_3 *) xr[ch];
+       ix_s[ch] = (I192_3 *) ix[ch];
+     }
+ 
+     for ( sfb = 0 ; sfb < SFB_SMAX-1; sfb++ ) {
+       start = scalefac_band_short[ sfb ];
+       end   = scalefac_band_short[ sfb+1 ];
+       bw = end - start;
+       for ( i = 0; i < 3; i++ ) {	    
+ 	for (ch=0 ; ch < stereo ; ch ++ ) sum[ch] = 0.0;
+ 	for ( l = start; l < end; l++ ) 	  {
+ 	  for (ch=0 ; ch < stereo ; ch ++ ) {
+ 	    qcoeff = ((*ix_s[ch])[l][i]<PRECALC_SIZE) ?
+ 	      pow43[(*ix_s[ch])[l][i]] * step_s[i][ch] :
+ 	      pow((double)(*ix_s[ch])[l][i],4.0/3.0)*step_s[i][ch]; 
+ 	    if ((*xr_s[ch])[l][i] < 0) qcoeff=-qcoeff;
+ 	    diff[ch] = (*xr_s[ch])[l][i] - qcoeff; 
+ 	  }
+ 	  sum[0] += (diff[0]+diff[1])*(diff[0]+diff[1])/(2.0);
+ 	  sum[1] += (diff[0]-diff[1])*(diff[0]-diff[1])/(2.0);
+ 	}
+ 	for (ch=0 ; ch < stereo ; ch ++ ) {
+ 	  xfsf[ch][i+1][sfb] = sum[ch] / bw;
+ 	  distort[ch][i+1][sfb] = 
+ 	    ( xfsf[ch][i+1][sfb] > l3_xmin->s[gr][ch][sfb][i] );
+ 	  if (distort[ch][i+1][sfb]) over[ch]++;
+ 	  if (distort[ch][i+1][sfb]) noise[ch] += xfsf[ch][i+1][sfb]-l3_xmin->s[gr][ch][sfb][i];
+ 	}
+ 	/* if there is audible distortion in left or right channel, set flags
+ 	 * to denote distortion in both mid and side channels */
+ 	for (ch=0 ; ch < stereo ; ch ++ ) 
+ 	  distort[ch][i+1][sfb] = 
+ 	    (distort[0][i+1][sfb]  || distort[1][i+1][sfb]  );
+       }
+     }
+     }
+ }
+     
+ 
+ 
  
  /*************************************************************************/
  /*            calc_xmin                                                  */
***************
*** 1012,1018 ****
  	   int gr, int ch )
  {
      int start, end, sfb, l, b;
!     double en, bw;
  
      D192_3 *xr_s;
  
--- 1480,1486 ----
  	   int gr, int ch )
  {
      int start, end, sfb, l, b;
!     double en0, bw;
  
      D192_3 *xr_s;
  
***************
*** 1025,1033 ****
  	bw = end - start;
          for ( b = 0; b < 3; b++ )
          {
!             for ( en = 0.0, l = start; l < end; l++ )
!                 en += (*xr_s)[l][b] * (*xr_s)[l][b];
!             l3_xmin->s[gr][ch][sfb][b] = ratio->s[gr][ch][sfb][b] * en / bw;
          }
      }
  
--- 1493,1501 ----
  	bw = end - start;
          for ( b = 0; b < 3; b++ )
          {
!             for ( en0 = 0.0, l = start; l < end; l++ )
!                 en0 += (*xr_s)[l][b] * (*xr_s)[l][b];
!             l3_xmin->s[gr][ch][sfb][b] = ratio->s[gr][ch][sfb][b] * en0 / bw;
          }
      }
  
***************
*** 1037,1045 ****
          end   = scalefac_band_long[ sfb+1 ];
  	bw = end - start;
  
!         for ( en = 0.0, l = start; l < end; l++ )
!             en += xr[gr][ch][l] * xr[gr][ch][l];
!         l3_xmin->l[gr][ch][sfb] = ratio->l[gr][ch][sfb] * en / bw;
      }
  }
  
--- 1505,1513 ----
          end   = scalefac_band_long[ sfb+1 ];
  	bw = end - start;
  
!         for ( en0 = 0.0, l = start; l < end; l++ )
!             en0 += xr[gr][ch][l] * xr[gr][ch][l];
!         l3_xmin->l[gr][ch][sfb] = ratio->l[gr][ch][sfb] * en0 / bw;
      }
  }
  
***************
*** 1056,1080 ****
  int loop_break( III_scalefac_t *scalefac, gr_info *cod_info,
  	    int gr, int ch )
  {
!     int i, sfb, temp = 1;
  
      for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
          if ( scalefac->l[gr][ch][sfb] == 0 )
!             temp = 0;
  
      for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
          for ( i = 0; i < 3; i++ )
              if ( scalefac->s[gr][ch][sfb][i] == 0 )
!                 temp = 0;
! #ifdef DEBUG
!     if ( temp != 0 )
!         printf( "---WARNING !! All scalefactor bands amplified\n" );
! #endif
!     return temp;
  }
  
  
  
  /*************************************************************************/
  /*            preemphasis                                                */
  /*************************************************************************/
--- 1524,1546 ----
  int loop_break( III_scalefac_t *scalefac, gr_info *cod_info,
  	    int gr, int ch )
  {
!     int i, sfb;
  
      for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
          if ( scalefac->l[gr][ch][sfb] == 0 )
! 	    return 0;
  
      for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
          for ( i = 0; i < 3; i++ )
              if ( scalefac->s[gr][ch][sfb][i] == 0 )
! 		return 0;
! 
!     return 1;
  }
  
  
  
+ 
  /*************************************************************************/
  /*            preemphasis                                                */
  /*************************************************************************/
***************
*** 1082,1091 ****
  /*
    See ISO 11172-3  section  C.1.5.4.3.4
  */
! 
! void preemphasis( double xr[576], double xfsf[4][CBLIMIT],
! 	     III_psy_xmin  *l3_xmin,
! 	     int gr, int ch, III_side_info_t *l3_side )
  {
      int i, sfb, start, end, scfsi_band, over;
      double ifqstep;
--- 1548,1556 ----
  /*
    See ISO 11172-3  section  C.1.5.4.3.4
  */
! int preemphasis2( double xr[576], double xrpow[576], 
!      III_psy_xmin  *l3_xmin,
!      int gr, int ch, III_side_info_t *l3_side, int distort[4][CBLIMIT] )
  {
      int i, sfb, start, end, scfsi_band, over;
      double ifqstep;
***************
*** 1102,1108 ****
  	    if ( l3_side->scfsi[ch][scfsi_band] )
  	    {
  		cod_info->preflag = l3_side->gr[0].ch[ch].tt.preflag;
! 		return;
  	    }
  	
      }
--- 1567,1573 ----
  	    if ( l3_side->scfsi[ch][scfsi_band] )
  	    {
  		cod_info->preflag = l3_side->gr[0].ch[ch].tt.preflag;
! 		return 0;
  	    }
  	
      }
***************
*** 1112,1143 ****
        bands the actual distortion exceeds the threshold after the
        first call of the inner loop
      */
      if ( cod_info->block_type != 2 && cod_info->preflag == 0 )
      {	
- 	over = 0;
  	for ( sfb = 17; sfb < 21; sfb++ )
! 	    if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
! 		over++;
  
  	if (over == 4 )
  	{
  	    cod_info->preflag = 1;
! 	    ifqstep = ( cod_info->scalefac_scale == 0 ) ? sqrt(2.)
! 		: pow( 2.0, (0.5 * (1.0 + (double) cod_info->scalefac_scale)) );
! 
! 	    for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
  	    {
! 		l3_xmin->l[gr][ch][sfb] *= pow( ifqstep, 2.0 * (double) pretab[sfb] );
  		start = scalefac_band_long[ sfb ];
  		end   = scalefac_band_long[ sfb+1 ];
! 		for( i = start; i < end; i++ )
! 		    xr[i] *= pow( ifqstep, (double) pretab[sfb] );
  	    }
  	}
      }
  }
  
  
  /*************************************************************************/
  /*            amp_scalefac_bands                                         */
  /*************************************************************************/
--- 1577,1611 ----
        bands the actual distortion exceeds the threshold after the
        first call of the inner loop
      */
+     over = 0;
      if ( cod_info->block_type != 2 && cod_info->preflag == 0 )
      {	
  	for ( sfb = 17; sfb < 21; sfb++ )
! 	    if ( distort[0][sfb] ) over++;
  
  	if (over == 4 )
  	{
+ 	    double t,t34;
  	    cod_info->preflag = 1;
! 	    ifqstep = ( cod_info->scalefac_scale == 0 ) ? SQRT2 : 2.0;
! 	    for ( sfb = 11; sfb < cod_info->sfb_lmax; sfb++ )
  	    {
! 		t=pow( ifqstep, (double) pretab[sfb] );
! 		t34=sqrt(sqrt(t)*t);
! 		l3_xmin->l[gr][ch][sfb] *= t*t;
  		start = scalefac_band_long[ sfb ];
  		end   = scalefac_band_long[ sfb+1 ];
! 		for( i = start; i < end; i++ ) xr[i]*=t;
! 		for( i = start; i < end; i++ ) xrpow[i]*=t34;
  	    }
  	}
      }
+     return (over == 4);
  }
  
  
+ 
+ 
  /*************************************************************************/
  /*            amp_scalefac_bands                                         */
  /*************************************************************************/
***************
*** 1146,1173 ****
    Amplify the scalefactor bands that violate the masking threshold.
    See ISO 11172-3 Section C.1.5.4.3.5
  */
! 
! int amp_scalefac_bands( double xr[576], double xfsf[4][CBLIMIT],
  		    III_psy_xmin *l3_xmin, III_side_info_t *l3_side,
  		    III_scalefac_t *scalefac,
! 		    int gr, int ch, int iteration )
  {
      int start, end, l, sfb, i, scfsi_band, over = 0;
!     double ifqstep, ifqstep2;
      D192_3 *xr_s;
      gr_info *cod_info, *gr0;
      int copySF, preventSF;
      cod_info = &l3_side->gr[gr].ch[ch].tt;
      gr0      = &l3_side->gr[0].ch[ch].tt;
  
      xr_s = (D192_3 *) xr;
      copySF = 0;
      preventSF = 0;
  
      if ( cod_info->scalefac_scale == 0 )
! 	ifqstep = sqrt( 2.0 );
      else
! 	ifqstep = pow( 2.0, 0.5 * (1.0 + (double) cod_info->scalefac_scale) );
  
      if ( gr == 1 )
      {
--- 1614,1643 ----
    Amplify the scalefactor bands that violate the masking threshold.
    See ISO 11172-3 Section C.1.5.4.3.5
  */
! int amp_scalefac_bands2( double xr[576], double xrpow[576], 
  		    III_psy_xmin *l3_xmin, III_side_info_t *l3_side,
  		    III_scalefac_t *scalefac,
! 		    int gr, int ch, int iteration, int distort[4][CBLIMIT])
  {
      int start, end, l, sfb, i, scfsi_band, over = 0;
!     double ifqstep, ifqstep2, ifqstep34;
      D192_3 *xr_s;
+     D192_3 *xrpow_s;
      gr_info *cod_info, *gr0;
      int copySF, preventSF;
      cod_info = &l3_side->gr[gr].ch[ch].tt;
      gr0      = &l3_side->gr[0].ch[ch].tt;
  
      xr_s = (D192_3 *) xr;
+     xrpow_s = (D192_3 *) xrpow;
      copySF = 0;
      preventSF = 0;
  
+ 
      if ( cod_info->scalefac_scale == 0 )
! 	ifqstep = SQRT2;
      else
! 	ifqstep = 2.0;
  
      if ( gr == 1 )
      {
***************
*** 1183,1191 ****
  		   first granule...
  		*/
  		if ( gr0->scalefac_scale == 0 )
! 		    ifqstep = sqrt( 2.0 );
  		else
! 		    ifqstep = pow( 2.0, 0.5 * (1.0 + (double) gr0->scalefac_scale) );
  
  		if ( iteration == 1 )
  		{
--- 1653,1661 ----
  		   first granule...
  		*/
  		if ( gr0->scalefac_scale == 0 )
! 		    ifqstep = SQRT2;
  		else
! 		    ifqstep = 2.0;
  
  		if ( iteration == 1 )
  		{
***************
*** 1212,1217 ****
--- 1682,1688 ----
  
      ifqstep2 = ifqstep * ifqstep;
      scfsi_band = 0;
+     ifqstep34=sqrt(sqrt(ifqstep)*ifqstep);
      
      for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
      {
***************
*** 1226,1240 ****
  		continue;
  	    }
  	}	    
! 	if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
  	{
  	    over++;
  	    l3_xmin->l[gr][ch][sfb] *= ifqstep2;
  	    scalefac->l[gr][ch][sfb]++;
  	    start = scalefac_band_long[sfb];
  	    end   = scalefac_band_long[sfb+1];
! 	    for ( l = start; l < end; l++ )
! 		xr[l] *= ifqstep;
  	}
      }
  
--- 1697,1713 ----
  		continue;
  	    }
  	}	    
! 
! 
! 	if ( distort[0][sfb]  ) 
  	{
  	    over++;
  	    l3_xmin->l[gr][ch][sfb] *= ifqstep2;
  	    scalefac->l[gr][ch][sfb]++;
  	    start = scalefac_band_long[sfb];
  	    end   = scalefac_band_long[sfb+1];
! 	    for ( l = start; l < end; l++ ) xr[l] *= ifqstep;
! 	    for ( l = start; l < end; l++ ) xrpow[l] *= ifqstep34;
  	}
      }
  
***************
*** 1243,1250 ****
        short blocks
      */
      for ( i = 0; i < 3; i++ )
!         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
!             if ( xfsf[i+1][sfb] > l3_xmin->s[gr][ch][sfb][i] )
              {
                  over++;
                  l3_xmin->s[gr][ch][sfb][i] *= ifqstep2;
--- 1716,1723 ----
        short blocks
      */
      for ( i = 0; i < 3; i++ )
!       for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ ) {
!             if ( distort[i+1][sfb])
              {
                  over++;
                  l3_xmin->s[gr][ch][sfb][i] *= ifqstep2;
***************
*** 1255,1330 ****
  #endif
                  start = scalefac_band_short[sfb];
                  end   = scalefac_band_short[sfb+1];
!                 for ( l = start; l < end; l++ )
!                     (*xr_s)[l][i] *= ifqstep;
              }
      return over;
  }
  
  
  
  
! /*************************************************************************/
! /*            quantize                                                   */
! /*************************************************************************/
! 
! /*
!   Function: Quantization of the vector xr ( -> ix)
! */
! 
! void quantize( double xr[576], int ix[576], gr_info *cod_info )
! {
!     int i, b, l_end, s_start;
!     double step, quantizerStepSize;
! 
!     D192_3 *xr_s;
!     I192_3 *ix_s;
! 
!     xr_s = (D192_3 *) xr;
!     ix_s = (I192_3 *) ix;
! 
!     quantizerStepSize = (double) cod_info->quantizerStepSize;
! 
!     for ( i = 0; i < 576; i++ )
! 	ix[i] = 0;
! 
!     if ( cod_info->quantizerStepSize == 0.0 )
! 	step = 1.0;
!     else
! 	step = pow ( 2.0, quantizerStepSize * 0.25 );
! 
!     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
! 	if ( cod_info->mixed_block_flag == 0 )
! 	{
! 	    l_end = 0;
! 	    s_start = 0;
! 	}
! 	else
! 	{
! 	    l_end = 18 * 2;
! 	    s_start = 6 * 2;
! 	}
!     else
      {
! 	l_end = 576;
! 	s_start = 192;
      }
- 
-     for ( i = 0; i < l_end; i++ )
- 	ix[i] = nint( pow(fabs(xr[i]) / step, 0.75) - 0.0946 );
-     
-     if ( s_start < 192 )
- 	for ( b = 0; b < 3; b++ )
- 	{
- 	    step = pow( 2.0, (quantizerStepSize + 8.0 * (double) cod_info->subblock_gain[b]) * 0.25 );
- 	    for ( i = s_start; i < 192; i++ )
- 		(*ix_s)[i][b] = nint( pow(fabs((*xr_s)[i][b]) / step, 0.75) - 0.0946 );
- 	}
  }
  
  
  
  
  /*************************************************************************/
  /*            ix_max                                                     */
  /*************************************************************************/
--- 1728,1787 ----
  #endif
                  start = scalefac_band_short[sfb];
                  end   = scalefac_band_short[sfb+1];
!                 for ( l = start; l < end; l++ ) (*xr_s)[l][i] *= ifqstep;
! 		for ( l = start; l < end; l++ ) (*xrpow_s)[l][i] *= ifqstep34;
              }
+       }
      return over;
  }
  
  
  
  
! 
! 
! void quantize_xrpow( double xr[576], int ix[576], gr_info *cod_info )
! {
!   /* quantize on xr^(3/4) instead of xr */
!   register int j;
!   double quantizerStepSize;
!   double istep_l,istep0,istep1,istep2;
!   
!   quantizerStepSize = cod_info->quantizerStepSize;
!   
!   istep_l = pow ( 2.0, quantizerStepSize * -0.1875 );
!   
!   if ((cod_info->block_type==2))
      {
!       istep0 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[0]);
!       istep1 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[1]);
!       istep2 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[2]);
!     }
!   else
!     {
!       istep0 = istep_l;
!       istep1 = istep_l;
!       istep2 = istep_l;
!     }
!   
!   for (j=192;j>0;j--) 
!     {
! #if defined(__GNUC__) && defined(__i386__)
!       asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep0*(*(xr++)) - 0.0946): "st");
!       asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep1*(*(xr++)) - 0.0946): "st");
!       asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep2*(*(xr++)) - 0.0946): "st");
! #else
!       *(ix++) = (int)( istep0*(*(xr++))  + 0.4054);
!       *(ix++) = (int)( istep1*(*(xr++))  + 0.4054);
!       *(ix++) = (int)( istep2*(*(xr++))  + 0.4054);
! #endif
      }
  }
  
  
  
  
+ 
  /*************************************************************************/
  /*            ix_max                                                     */
  /*************************************************************************/
***************
*** 1339,1345 ****
  
      for ( i = begin; i < end; i++ )
      {
!         int x = abs( ix[i] );
          if ( x > max )
              max = x;
      }
--- 1796,1802 ----
  
      for ( i = begin; i < end; i++ )
      {
!         int x =  ix[i];
          if ( x > max )
              max = x;
      }
***************
*** 1376,1389 ****
  /*************************************************************************/
  
  /*
! Function: Calculation of rzero, count1, big_values
  (Partitions ix into big values, quadruples and zeros).
  */
  
  void calc_runlen( int ix[576], gr_info *cod_info )
  {
      int i;
-     int rzero = 0; 
  
      if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
      {  /* short blocks */
--- 1833,1845 ----
  /*************************************************************************/
  
  /*
! Function: Calculation of  count1, big_values
  (Partitions ix into big values, quadruples and zeros).
  */
  
  void calc_runlen( int ix[576], gr_info *cod_info )
  {
      int i;
  
      if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
      {  /* short blocks */
***************
*** 1393,1416 ****
      else
      {
          for ( i = 576; i > 1; i -= 2 )
!             if ( ix[i-1] == 0 && ix[i-2] == 0 )
!                 rzero++;
!             else
!                 break;
!         
          cod_info->count1 = 0 ;
          for ( ; i > 3; i -= 4 )
!             if ( abs(ix[i-1]) <= 1
!               && abs(ix[i-2]) <= 1
!               && abs(ix[i-3]) <= 1
!               && abs(ix[i-4]) <= 1 )
                  cod_info->count1++;
              else
                  break;
          
          cod_info->big_values = i/2;
      }
-     assert( (2 * rzero + 4 * cod_info->count1 + 2 * cod_info->big_values) == 576 );
  }
  
  
--- 1849,1865 ----
      else
      {
          for ( i = 576; i > 1; i -= 2 )
! 	    if ( ix[i-1] | ix[i-2] ) break;
! 
          cod_info->count1 = 0 ;
          for ( ; i > 3; i -= 4 )
! 	    if ( (ix[i-1] | ix[i-2] | ix[i-3] | ix[i-4]) <= 1 )
                  cod_info->count1++;
              else
                  break;
          
          cod_info->big_values = i/2;
      }
  }
  
  
***************
*** 1432,1460 ****
      int sum0 = 0, sum1 = 0;
  
      for ( i = cod_info->big_values * 2, k = 0; k < cod_info->count1; i += 4, k++ )
!     {
          v = ix[ i ];
          w = ix[ i + 1 ];
          x = ix[ i + 2 ];
          y = ix[ i + 3 ];
          
          abs_and_sign( &v );
          abs_and_sign( &w );
          abs_and_sign( &x );
          abs_and_sign( &y );
! 
          p = v + (w << 1) + (x << 2) + (y << 3);
          
          signbits = 0;
  
          if ( v != 0 )
!             signbits += 1;
          if ( w != 0 )
!             signbits += 1;
          if ( x != 0 )
!             signbits += 1;
          if ( y != 0 )
!             signbits += 1;
  
          sum0 += signbits;
          sum1 += signbits;
--- 1881,1916 ----
      int sum0 = 0, sum1 = 0;
  
      for ( i = cod_info->big_values * 2, k = 0; k < cod_info->count1; i += 4, k++ )
!     { 
! 	v = ix[i];
! 	w = ix[i+1];
! 	x = ix[i+2];
! 	y = ix[i+3];
! 
!       /*
          v = ix[ i ];
          w = ix[ i + 1 ];
          x = ix[ i + 2 ];
          y = ix[ i + 3 ];
          
+ 
          abs_and_sign( &v );
          abs_and_sign( &w );
          abs_and_sign( &x );
          abs_and_sign( &y );
! 	*/
          p = v + (w << 1) + (x << 2) + (y << 3);
          
          signbits = 0;
  
          if ( v != 0 )
!             signbits ++;
          if ( w != 0 )
!             signbits ++;
          if ( x != 0 )
!             signbits ++;
          if ( y != 0 )
!             signbits ++;
  
          sum0 += signbits;
          sum1 += signbits;
***************
*** 1570,1576 ****
          }
          else
          {
!             if ( (cod_info->block_type == 2) && (cod_info->mixed_block_flag == 0) )
              { 
                  cod_info->region0_count =  8;
                  cod_info->region1_count =  36;
--- 2026,2032 ----
          }
          else
          {
!             if ( (cod_info->block_type == 2)  )
              { 
                  cod_info->region0_count =  8;
                  cod_info->region1_count =  36;
***************
*** 1594,1670 ****
  
  
  /*************************************************************************/
- /*            bigv_tab_select                                            */
- /*************************************************************************/
- 
- /*
- /*  Function: Select huffman code tables for bigvalues regions 
- */
- 
- void bigv_tab_select( int ix[576], gr_info *cod_info )
- {
-     /* int max; */
- 
-     cod_info->table_select[0] = 0;
-     cod_info->table_select[1] = 0;
-     cod_info->table_select[2] = 0;
-     
-     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
-     {
-         /*
-           Within each scalefactor band, data is given for successive
-           time windows, beginning with window 0 and ending with window 2.
-           Within each window, the quantized values are then arranged in
-           order of increasing frequency...
-           */
-         int sfb, window, line, start, end, max1, max2, x, y;
-         int region1Start;
-         int *pmax;
- 
-         region1Start = 12;
-         max1 = max2 = 0;
- 
-         for ( sfb = 0; sfb < 13; sfb++ )
-         {
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
-             
-             if ( start < region1Start )
-                 pmax = &max1;
-             else
-                 pmax = &max2;
-             
-             for ( window = 0; window < 3; window++ )
-                 for ( line = start; line < end; line += 2 )
-                 {
-                     assert( line >= 0 );
-                     assert( line < 576 );
-                     x = abs( ix[ (line * 3) + window ] );
-                     y = abs( ix[ ((line + 1) * 3) + window ]);
-                     *pmax = *pmax > x ? *pmax : x;
-                     *pmax = *pmax > y ? *pmax : y;
-                 }
-         }
-         cod_info->table_select[0] = choose_table( max1 );
-         cod_info->table_select[1] = choose_table( max2 );
-     }
-     else
-     {
-         if ( cod_info->address1 > 0 )
-             cod_info->table_select[0] = new_choose_table( ix, 0, cod_info->address1 );
- 
-         if ( cod_info->address2 > cod_info->address1 )
-             cod_info->table_select[1] = new_choose_table( ix, cod_info->address1, cod_info->address2 );
- 
-         if ( cod_info->big_values * 2 > cod_info->address2 )
-             cod_info->table_select[2] = new_choose_table( ix, cod_info->address2, cod_info->big_values * 2 );
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
  /*            new_choose table                                           */
  /*************************************************************************/
  
--- 2050,2055 ----
***************
*** 1677,1683 ****
    with any arbitrary tables.
  */
  
! int new_choose_table( int ix[576], unsigned int begin, unsigned int end )
  {
      int i, max;
      int choice[ 2 ];
--- 2062,2068 ----
    with any arbitrary tables.
  */
  
! int new_choose_table( int ix[576], unsigned int begin, unsigned int end, int * s )
  {
      int i, max;
      int choice[ 2 ];
***************
*** 1687,1694 ****
  
      if ( max == 0 )
          return 0;
-     
-     max = abs( max );
  
      choice[ 0 ] = 0;
      choice[ 1 ] = 0;
--- 2072,2077 ----
***************
*** 1702,1708 ****
  		choice[ 0 ] = i;
                  break;
  	    }
- 	assert( choice[0] );
  
  	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
  
--- 2085,2090 ----
***************
*** 1711,1723 ****
--- 2093,2111 ----
  	  case 2:
  	    sum[ 1 ] = count_bit( ix, begin, end, 3 );
  	    if ( sum[1] <= sum[0] )
+ 	    {
+ 		sum[0]=sum[1];
  		choice[ 0 ] = 3;
+ 	    }
  	    break;
  
  	  case 5:
  	    sum[ 1 ] = count_bit( ix, begin, end, 6 );
  	    if ( sum[1] <= sum[0] )
+ 	    {
+ 		sum[0]=sum[1];
  		choice[ 0 ] = 6;
+ 	    }
  	    break;
  
  	  case 7:
***************
*** 1729,1735 ****
--- 2117,2126 ----
  	    }
  	    sum[ 1 ] = count_bit( ix, begin, end, 9 );
  	    if ( sum[1] <= sum[0] )
+ 	    {
+ 		sum[0]=sum[1];
  		choice[ 0 ] = 9;
+ 	    }
  	    break;
  
  	  case 10:
***************
*** 1741,1753 ****
--- 2132,2150 ----
  	    }
  	    sum[ 1 ] = count_bit( ix, begin, end, 12 );
  	    if ( sum[1] <= sum[0] )
+ 	    {
+ 		sum[0]=sum[1];
  		choice[ 0 ] = 12;
+ 	    }
  	    break;
  
  	  case 13:
  	    sum[ 1 ] = count_bit( ix, begin, end, 15 );
  	    if ( sum[1] <= sum[0] )
+ 	    {
+ 		sum[0]=sum[1];
  		choice[ 0 ] = 15;
+ 	    }
  	    break;
  
  	  default:
***************
*** 1775,1793 ****
  		break;
  	    }
  	}
- 	assert( choice[0] );
- 	assert( choice[1] );
  	
  	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
  	sum[ 1 ] = count_bit( ix, begin, end, choice[1] );
  	if ( sum[1] < sum[0] )
  	    choice[ 0 ] = choice[ 1 ];
      }
      return choice[ 0 ];
  }
  
  
- 
  /*************************************************************************/
  /*            choose table                                               */
  /*************************************************************************/
--- 2172,2191 ----
  		break;
  	    }
  	}
  	
  	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
  	sum[ 1 ] = count_bit( ix, begin, end, choice[1] );
  	if ( sum[1] < sum[0] )
+ 	{
+ 	    sum[0]=sum[1];
  	    choice[ 0 ] = choice[ 1 ];
+ 	}
      }
+     *s=sum[0];
      return choice[ 0 ];
  }
  
  
  /*************************************************************************/
  /*            choose table                                               */
  /*************************************************************************/
***************
*** 1799,1805 ****
      if ( max == 0 )
          return 0;
      
-     max = abs( max );    
      choice = 0;
  
      if ( max < 15 )
--- 2197,2202 ----
***************
*** 1830,1848 ****
  }
  
  
  /*************************************************************************/
  /*            bigv_bitcount                                              */
  /*************************************************************************/
  
  /*
  Function: Count the number of bits necessary to code the bigvalues region.
  */
  
! int bigv_bitcount( int ix[576], gr_info *gi )
  {
      int bits = 0;
      
!     if ( gi->window_switching_flag && gi->block_type == 2 )
      {
          /*
            Within each scalefactor band, data is given for successive
--- 2227,2251 ----
  }
  
  
+ 
  /*************************************************************************/
  /*            bigv_bitcount                                              */
  /*************************************************************************/
  
  /*
+ Function: Select huffman code tables for bigvalues regions 
  Function: Count the number of bits necessary to code the bigvalues region.
  */
  
! int bigv_bitcount( int ix[576], gr_info *cod_info )
  {
      int bits = 0;
+ 
+     cod_info->table_select[0] = 0;
+     cod_info->table_select[1] = 0;
+     cod_info->table_select[2] = 0;
      
!     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
      {
          /*
            Within each scalefactor band, data is given for successive
***************
*** 1850,1867 ****
            Within each window, the quantized values are then arranged in
            order of increasing frequency...
            */
!         int sfb, window, line, start, end;
          I192_3 *ix_s;
  
-         if ( gi->mixed_block_flag )
-         {
-             unsigned int table;
  
!             if ( (table = gi->table_select[0]) != 0 )
!                 bits += count_bit( ix, 0, gi->address1, table );
!             sfb = 2;
          }
!         else
              sfb = 0;
  
          ix_s = (I192_3 *) &ix[0];
--- 2253,2296 ----
            Within each window, the quantized values are then arranged in
            order of increasing frequency...
            */
!         int sfb, window, line, start, end, max1, max2, x, y;
!         int region1Start;
!         int *pmax;
          I192_3 *ix_s;
  
  
!         region1Start = 12;
!         max1 = max2 = 0;
! 
!         for ( sfb = 0; sfb < 13; sfb++ )
!         {
!             start = scalefac_band_short[ sfb ];
!             end   = scalefac_band_short[ sfb+1 ];
!             
!             if ( start < region1Start )
!                 pmax = &max1;
!             else
!                 pmax = &max2;
!             
!             for ( window = 0; window < 3; window++ )
!                 for ( line = start; line < end; line += 2 )
!                 {
!                     x = ix[ (line * 3) + window ];
!                     y = ix[ ((line + 1) * 3) + window ];
!                     *pmax = *pmax > x ? *pmax : x;
!                     *pmax = *pmax > y ? *pmax : y;
!                 }
          }
!         cod_info->table_select[0] = choose_table( max1 );
!         cod_info->table_select[1] = choose_table( max2 );
! 
!         /*
!           Within each scalefactor band, data is given for successive
!           time windows, beginning with window 0 and ending with window 2.
!           Within each window, the quantized values are then arranged in
!           order of increasing frequency...
!           */
! 
              sfb = 0;
  
          ix_s = (I192_3 *) &ix[0];
***************
*** 1874,1883 ****
              end   = scalefac_band_short[ sfb+1 ];
  
              if ( start < 12 )
!                 tableindex = gi->table_select[ 0 ];
              else
!                 tableindex = gi->table_select[ 1 ];
!             assert( tableindex < 32 );
  
              for ( window = 0; window < 3; window++ )
                  for ( line = start; line < end; line += 2 )
--- 2303,2311 ----
              end   = scalefac_band_short[ sfb+1 ];
  
              if ( start < 12 )
!                 tableindex = cod_info->table_select[ 0 ];
              else
!                 tableindex = cod_info->table_select[ 1 ];
  
              for ( window = 0; window < 3; window++ )
                  for ( line = start; line < end; line += 2 )
***************
*** 1893,1905 ****
      else
      {
          unsigned int table;
          
!         if( (table=gi->table_select[0]) != 0 )  /* region0 */ 
!             bits += count_bit(ix, 0, gi->address1, table );
!         if( (table=gi->table_select[1]) != 0 )  /* region1 */ 
!             bits += count_bit(ix, gi->address1, gi->address2, table );
!         if( (table=gi->table_select[2]) != 0 )  /* region2 */ 
!             bits += count_bit(ix, gi->address2, gi->address3, table );
      }
      return bits;
  }
--- 2321,2348 ----
      else
      {
          unsigned int table;
+         int s;
          
!         if ( cod_info->address1 > 0 )
!         {
!             table = cod_info->table_select[0] = new_choose_table( ix, 0, cod_info->address1, &s );
!             if( table != 0 )  /* region0 */ 
!                bits += s;
!         }
! 
!         if ( cod_info->address2 > cod_info->address1 )
!         {
!             table = cod_info->table_select[1] = new_choose_table( ix, cod_info->address1, cod_info->address2, &s );
!            if( table != 0 )  /* region1 */ 
!                bits += s;
!         }
! 
!         if ( cod_info->big_values * 2 > cod_info->address2 )
!         {
!             table = cod_info->table_select[2] = new_choose_table( ix, cod_info->address2, cod_info->big_values * 2, &s );
!            if( table != 0 )  /* region2 */ 
!                bits += s;
!         }
      }
      return bits;
  }
***************
*** 1916,1930 ****
  
  int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table )
  {
!     int i, sum;
  
      sum = 0;
!     for ( i = start; i < end; i += 2 )
!     {
!         unsigned int code, ext;
!         int cbits, xbits;
!         sum += HuffmanCode( table, ix[i], ix[i+1], &code, &ext, &cbits, &xbits );
      }
      return sum;
  }
  
--- 2359,2414 ----
  
  int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table )
  {
!     unsigned            linbits;
!     register int        i, sum;
!     register int        x,y;
!     struct huffcodetab *h;
!     unsigned char *hlen;
  
+     if(table==0) return 0;
+     h   = &(ht[table]);
      sum = 0;
! 
!     linbits = h->linbits;
!     hlen=h->hlen;
! 
!     if(table>15)
!     { /* ESC-table is used */
!         for(i=start;i<end;i+=2)
!         {
!             x = ix[i];
!             y = ix[i+1];
! 
!             if(x>14)
!             {
!                 x = 15;
!                 sum += linbits;
!             }
!             if(y>14)
!             {
!                 y = 15;
!                 sum += linbits;
!             }
! 
!             sum += hlen[(x*16)+y];
!             if(x!=0) sum++;
!             if(y!=0) sum++;
!         }
!     }
!     else
!     { /* No ESC-words */
!         for(i=start;i<end;i+=2)
!         {
!             x = ix[i];
!             y = ix[i+1];
! 
!             sum += hlen[(x*16)+y];
! 
!             if(x!=0) sum++;
!             if(y!=0) sum++;
!         }
      }
+ 
      return sum;
  }
  
***************
*** 1941,1951 ****
  
      return(temp);
  }
- 
- double
- aint(double in) {
- 	return((long) in);
- }
  #endif
  
  
--- 2425,2430 ----
***************
*** 1967,1974 ****
    to account for wider frequency line.) 
    */
  
! 
! 
  /*************************************************************************/
  /*            gr_deco                                                    */
  /*************************************************************************/
--- 2446,2455 ----
    to account for wider frequency line.) 
    */
  
! /* mt 4/99:  ISO code cannot produces mixed blocks,
!  * Fhg Code also never seems to use them, so no need to add them
!  * to this code 
!  */
  /*************************************************************************/
  /*            gr_deco                                                    */
  /*************************************************************************/
***************
*** 1976,1993 ****
  void gr_deco( gr_info *cod_info )
  {
      if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-         if ( cod_info->mixed_block_flag == 0 )
          {
              cod_info->sfb_lmax = 0; /* No sb*/
              cod_info->sfb_smax = 0;
          }
-         else
-         {
-             cod_info->sfb_lmax = 8;
-             cod_info->sfb_smax = 3;
-         }
      else
      {
          cod_info->sfb_lmax = SFB_LMAX - 1;
          cod_info->sfb_smax = SFB_SMAX - 1;    /* No sb */
      }
--- 2457,2469 ----
  void gr_deco( gr_info *cod_info )
  {
      if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
          {
              cod_info->sfb_lmax = 0; /* No sb*/
              cod_info->sfb_smax = 0;
          }
      else
      {
+       /* MPEG 1 doesnt use last scalefactor band? */
          cod_info->sfb_lmax = SFB_LMAX - 1;
          cod_info->sfb_smax = SFB_SMAX - 1;    /* No sb */
      }
***************
*** 2000,2220 ****
  
  
  
- /* The following optional code written by Seymour Shlien
-    will speed up the outer_loop code which is called
-    by iteration_loop. When BIN_SEARCH is defined, the
-    outer_loop function precedes the call to the function inner_loop
-    with a call to bin_search gain defined below, which
-    returns a good starting quantizerStepSize.
- */
  
- #if defined(BIN_SEARCH) || defined(PERFORM) 
  int count_bits(ix,cod_info)  
  int  *ix; /*  I576  *ix; */
  gr_info *cod_info;
  {
! int bits,max;
!   calc_runlen(ix,cod_info);		/*rzero,count1,big_values*/
!   max = ix_max( ix, 0,576);
!   if(max > 8192) return 100000;         /* report unsuitable quantizer */
    bits = count1_bitcount(ix, cod_info); /*count1_table selection*/
    subdivide(cod_info);			/* bigvalues sfb division */
-   bigv_tab_select(ix,cod_info);		/* codebook selection*/
    bits += bigv_bitcount(ix,cod_info);	/* bit count */
  /* printf("\nglobal_gain = %f  bits= %d ",cod_info->quantizerStepSize,bits);*/
  return bits;
  }
- #endif
  
  
- #ifdef BIN_SEARCH
  
! int bin_search_StepSize(int desired_rate, double start, int *ix,
!            double xrs[576], gr_info * cod_info)
  {
! double top,bot,next,last;
  int bit;
  top = start;
- bot = 200;
  next = start;
  do
    {
    last = next;
!   next = aint((top+bot)/2.0);
    cod_info->quantizerStepSize = next;
!   quantize(xrs,ix,cod_info);
    bit = count_bits(ix,cod_info);
    if (bit>desired_rate) top = next;
    else bot = next;
! /*  printf("\n%f %f %f %d %d",next, top,bot,bit,desired_rate);*/
!   }
!   while ((bit != desired_rate) && fabs(last - next) > 1.0);
! return next;
! }
! 
! #endif
! 
! 
! 
! 
! #ifdef PERFORM
! 
! /* The following code is used for exposing some problems with
!    the outer_loop code. PERFORM should be defined to the
!    frame number you wish to have additional output recorded
!    in the file encode.log  - Seymour Shlien 14-Jan-97
! */
! 
! /*
! float worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,block_type,gr,ch)
! double xfsf[4][CBLIMIT];
! III_psy_xmin *l3_xmin;
! int block_type,gr,ch;
! */
! float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
!                              ,int block_type,int gr,int ch)
! 
! {
! float ratio,maxratio;
! int i,j;
! maxratio =-100.0;
! if (block_type != 2)
!   for(i=0;i<21;i++)
!     {
!     ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
!     if (ratio > maxratio) maxratio = ratio;
!     }
! else
!   {
!   for(j=0;j<3;j++)
! /* for(i = cod_info->sfb_smax; i <SFB_SMAX; i++) */
!      for(i = 0; i <11; i++)
!     {
!     ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
!     if (ratio > maxratio) maxratio = ratio;
!     }
!   }
! return maxratio;
! }
!  
! 
! print_ratios(handle_out,l3_xmin,xfsf,block_type,gr,ch)
! FILE *handle_out;
! double xfsf[4][CBLIMIT];
! III_psy_xmin *l3_xmin;
! int gr,ch;
! int block_type;
! {
! float ratio;
! int i,j;
! if(block_type !=2)
!  for (i=0;i<21;i++)
!   {
!    ratio = 100.0; /* signals undefined value in output */
!    if(l3_xmin->l[gr][ch][i] >1.0e-20)
!      ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
!    fprintf(handle_out,"%6.2f ",ratio);
!    if(i%5==4) fprintf(handle_out,"\n");
!   }
! else
!   
!   for(j=0;j<3;j++)
!    { fprintf(handle_out,"\n  block %d\n",j);
!      for(i = 0; i <11; i++)
!       {
!       ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
!       fprintf(handle_out,"%6.2f ",ratio);
!       if(i%5==4) fprintf(handle_out,"\n");
!       }
!    }
! fprintf(handle_out,"\n");
! }
! 
! 
! print_scalefacs(handle_out,scalefac,block_type,gr,ch)
! FILE *handle_out;
! III_scalefac_t *scalefac;
! int gr,ch;
! int block_type;
! {
! int sfb,j;
! 
! if(block_type !=2)
!  for ( sfb = 0; sfb < 21; sfb++ )
!    {
!    fprintf(handle_out,"%6d ", scalefac->l[gr][ch][sfb]);    
!    if(sfb%5==4) fprintf(handle_out,"\n");
!    }
! else
!  for (j=0;j<3;j++)
!   {
!   fprintf(handle_out,"\n block %d\n",j);
!   for (sfb=0;sfb<11;sfb++)
!    {
!    fprintf(handle_out,"%6d ",scalefac->s[gr][ch][sfb][j]);
!    if(sfb%5==4) fprintf(handle_out,"\n");
!    }
    }
! fprintf(handle_out,"\n");
! }
  
! 
! print_quantized_values(FILE *handle, int ix[576], gr_info *cod_info)
! {
! int sfb,start,end,i,bw;
! for (sfb=0;sfb<cod_info->sfb_lmax;sfb++)
!   {
!   start = scalefac_band_long[sfb];
!   end = scalefac_band_long[sfb+1];
!   bw = end - start;
!   fprintf(handle,"scalefac band %d from %d to %d\n",sfb,start,end);
!   for (i=0;i<bw;i++)
!     {
!     fprintf(handle,"%8d",ix[start+i]);
!     if(i%5==4) fprintf(handle,"\n");
!     }
!   fprintf(handle,"\n");
!   }
  }
  
  
- test_inner_loop(double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
-             gr_info *cod_info, int gr, int ch, double xfsf[4][CBLIMIT], 
-             III_psy_xmin  *l3_xmin) 
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
-  
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }  
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
-  
-     bits = count_bits(ix,cod_info);       
  
-         if(frameNum == PERFORM)
-         {
-           fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-             cod_info->quantizerStepSize,bits,max_bits);
-           calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf );
-                                              /* distortion calculation */
-           print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-           fprintf(log_output,"\n\n");
-           }
- 
-     }
-     while ( bits > max_bits );
-  
-     return bits;
- }
-  
- #endif PERFORM 
--- 2476,2594 ----
  
  
  
  
  int count_bits(ix,cod_info)  
  int  *ix; /*  I576  *ix; */
  gr_info *cod_info;
  {
! int bits,i;
!   for ( i = 0; i < 576; i++ )
!   {
!      if ( ix[i] > 8191 + 14)
! 	return 100000;		/* report unsuitable quantizer */
!   }
!   calc_runlen(ix,cod_info);		/*count1,big_values*/
    bits = count1_bitcount(ix, cod_info); /*count1_table selection*/
    subdivide(cod_info);			/* bigvalues sfb division */
    bits += bigv_bitcount(ix,cod_info);	/* bit count */
  /* printf("\nglobal_gain = %f  bits= %d ",cod_info->quantizerStepSize,bits);*/
  return bits;
  }
  
  
  
! static int OldValue = -30; /* guess it or so. */
! 
! typedef enum {
!     BINSEARCH_NONE,
!     BINSEARCH_UP, 
!     BINSEARCH_DOWN
! } binsearchDirection_t;
! 
! /*-------------------------------------------------------------------------*/
! int 
! bin_search_StepSize2(int      desired_rate, 
! 		    double   start, 
! 		    int      bot, 
! 		    int     *ix,
! 		    double   xrs[576], 
! 		    double   xrspow[576], 
! 		    gr_info *cod_info)
! /*-------------------------------------------------------------------------*/
! {
!     int flag_GoneOver = 0;
!     int CurrentStep = 4;
!     int nBits, Counter = 0;
!     int StepSize = OldValue;
!     binsearchDirection_t Direction = BINSEARCH_NONE;
!     do
!     {
! 	cod_info->quantizerStepSize = StepSize;
! 	quantize_xrpow(xrspow, ix, cod_info);
! 	nBits = count_bits(ix,cod_info);  
! 
! 	if (CurrentStep == 1 || Counter > 50)  
! 	  /* the 50 is for ''lock-up'' - havent found any.*/
! 	{
! 	    break; /* nothing to adjust anymore */
! 	}
! 	if (flag_GoneOver)
! 	{
! 	    CurrentStep /= 2;
! 	}
! 	if (nBits > desired_rate)  /* increase Quantize_StepSize */
! 	{
! 	    if (Direction == BINSEARCH_DOWN && !flag_GoneOver)
! 	    {
! 		flag_GoneOver = 1;
! 		CurrentStep /= 2; /* late adjust */
! 	    }
! 	    Direction = BINSEARCH_UP;
! 	    StepSize += CurrentStep;
! 	}
! 	else if (nBits < desired_rate)
! 	{
! 	    if (Direction == BINSEARCH_UP && !flag_GoneOver)
! 	    {
! 		flag_GoneOver = 1;
! 		CurrentStep /= 2; /* late adjust */
! 	    }
! 	    Direction = BINSEARCH_DOWN;
! 	    StepSize -= CurrentStep;
! 	}
! 	else break; /* nBits == desired_rate;; most unlikely to happen.
! */
!     } while (1); /* For-ever, break is adjusted. */
!     OldValue = StepSize;
!     return nBits;
! }
! 
! 
! 
! 
! int bin_search_StepSize(int desired_rate, double start, int bot, int *ix,
!            double xrs[576], double xrspow[576], gr_info * cod_info)
  {
! int top,next,last;
  int bit;
  top = start;
  next = start;
  do
    {
    last = next;
!   next = (top+bot)/2.0;
    cod_info->quantizerStepSize = next;
!   quantize_xrpow(xrspow,ix,cod_info);
    bit = count_bits(ix,cod_info);
    if (bit>desired_rate) top = next;
    else bot = next;
!   // printf("\n%f %f %f %f %d %d",start,next, top,bot,bit,desired_rate);
    }
!   while ((bit != desired_rate) && abs(last - next) > 1);
! //printf("\n done  %f %d %d",next,bit,desired_rate);
  
! return bit;
  }
  
  
  
diff -r -c -N encoder/loop.h lame3.13/loop.h
*** encoder/loop.h	Wed Jan 22 02:43:16 1997
--- lame3.13/loop.h	Sat Jun  5 16:46:15 1999
***************
*** 45,55 ****
  extern struct scalefac_struct sfBandIndex[];  /* Table B.8 -- in loop.c */
  
  
! void iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
! 		     III_side_info_t *l3_side, int l3_enc[2][2][576], int mean_bits,
! 		     int stereo, double xr_dec[2][2][576],
! 		     III_scalefac_t *scalefac, frame_params *fr_ps,
! 		     int ancillary_pad, int bitsPerFrame );
  
  
  int nint( double in );
--- 45,54 ----
  extern struct scalefac_struct sfBandIndex[];  /* Table B.8 -- in loop.c */
  
  
! void iteration_loop( double pe[][2], double ms_ratio[2], 
! 		     double xr_org[2][2][576], III_psy_ratio *ratio,
! 		     III_side_info_t *l3_side, int l3_enc[2][2][576], 
! 		     III_scalefac_t *scalefac, frame_params *fr_ps);
  
  
  int nint( double in );
diff -r -c -N encoder/makefile.unix lame3.13/makefile.unix
*** encoder/makefile.unix	Wed Jan 22 02:43:23 1997
--- lame3.13/makefile.unix	Wed Dec 31 17:00:00 1969
***************
*** 1,77 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: makefile.unix,v 1.1 1996/02/14 05:28:25 rowlands Exp $
- ##
- ## Makefile for encoder for vanilla UNIX platform using standard make.
- ##
- ## $Log: makefile.unix,v $
- ## Revision 1.1  1996/02/14 05:28:25  rowlands
- ## Initial revision
- ##
- ############################################################################
- 
- # MODE= -O -DUNIX
- MODE= -g -DUNIX
- #MODE= -DMSC60 -AH -Zi -Gt
- OBJ_SUFFIX=.o
- EXE_SUFFIX=
- 
- PROGRAM	= encode$(EXE_SUFFIX)
- 
- all: $(PROGRAM)
- 
- $(PROGRAM) : \
- 	common.c common.h encode.c encoder.h formatBitstream.c \
- 	formatBitstream.h huffman.c huffman.h ieeefloat.c ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.c l3bitstream.h l3psy.c l3psy.h \
- 	l3side.h loop-pvt.h loop.c loop.h mdct.c mdct.h musicin.c \
- 	portableio.c portableio.h psy.c reservoir.c reservoir.h subs.c tonal.c
- 
- HEDS =  \
- 	common.h encoder.h formatBitstream.h huffman.h ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.h l3psy.h l3side.h loop-pvt.h loop.h \
- 	mdct.h portableio.h reservoir.h
- 
- OBJS = \
- 	common$(OBJ_SUFFIX) \
- 	encode$(OBJ_SUFFIX) \
- 	formatBitstream$(OBJ_SUFFIX) \
- 	huffman$(OBJ_SUFFIX) \
- 	ieeefloat$(OBJ_SUFFIX) \
- 	l3bitstream$(OBJ_SUFFIX) \
- 	l3psy$(OBJ_SUFFIX) \
- 	loop$(OBJ_SUFFIX) \
- 	mdct$(OBJ_SUFFIX) \
- 	musicin$(OBJ_SUFFIX) \
- 	portableio$(OBJ_SUFFIX) \
- 	psy$(OBJ_SUFFIX) \
- 	reservoir$(OBJ_SUFFIX) \
- 	subs$(OBJ_SUFFIX) \
- 	tonal$(OBJ_SUFFIX)
- 
- LFLAG = 
- 
- CC    = gcc
- LN    = gcc
- LNEXTRA=-lm
- #CC    = cl
- #LN    = cl
- 
- .c$(OBJ_SUFFIX): $(HEDS)
- 	$(CC) -c $(MODE) $*.c
- 
- all: $(PROGRAM)
- 
- default: all
- 
- 
- $(PROGRAM) : $(OBJS) $(HEDS)
- 	$(LN) -o $(PROGRAM) $(MODE) $(LFLAG) $(OBJS) $(LNEXTRA)
- 
- clean:
- 	rm -f $(OBJS)
- 
- veryclean:
- 	rm -f $(PROGRAM) $(OBJS)
--- 0 ----
diff -r -c -N encoder/mdct.c lame3.13/mdct.c
*** encoder/mdct.c	Wed Jan 22 02:43:17 1997
--- lame3.13/mdct.c	Tue Jun  1 07:38:54 1999
***************
*** 54,62 ****
  	    /*
  	      Compensate for inversion in the analysis filter
  	    */
! 	    for ( band = 0; band < 32; band++ )
! 		for ( k = 0; k < 18; k++ )
! 		    if ( (band & 1) && (k & 1) )
  			(*sb_sample)[ch][gr+1][k][band] *= -1.0;
  	    
  	    /*
--- 54,61 ----
  	    /*
  	      Compensate for inversion in the analysis filter
  	    */
! 	    for ( band = 1; band < 32; band+=2 )
! 		for ( k = 1; k < 18; k+=2 )
  			(*sb_sample)[ch][gr+1][k][band] *= -1.0;
  	    
  	    /*
***************
*** 70,78 ****
  		    mdct_in[k]    = (*sb_sample)[ch][ gr ][k][band];
  		    mdct_in[k+18] = (*sb_sample)[ch][gr+1][k][band];
  		}
  		if ( cod_info->mixed_block_flag && (band < 2) )
  		    block_type = 0;
! 		
  		mdct( mdct_in, &mdct_enc[gr][ch][band][0], block_type );
  	    }
  	    
--- 69,78 ----
  		    mdct_in[k]    = (*sb_sample)[ch][ gr ][k][band];
  		    mdct_in[k+18] = (*sb_sample)[ch][gr+1][k][band];
  		}
+ #ifdef ALLOW_MIXED
  		if ( cod_info->mixed_block_flag && (band < 2) )
  		    block_type = 0;
! #endif
  		mdct( mdct_in, &mdct_enc[gr][ch][band][0], block_type );
  	    }
  	    
***************
*** 123,130 ****
    double sum;
    static double win[4][36];
    static int init = 0;
!   static double cos_s[6][12], cos_l[18][36];
! 
  
    if ( init == 0 )
    {
--- 123,131 ----
    double sum;
    static double win[4][36];
    static int init = 0;
!   static double cos_s[6][12], cos_l[18][18];
!   static double fin[18];
!   static double *cos_l0;
  
    if ( init == 0 )
    {
***************
*** 149,176 ****
        win[3][i] = 1.0;
      for ( i = 18; i < 36; i++ )
        win[3][i] = sin( PI/36 * (i + 0.5) );
-     /* type 2*/
-     for ( i = 0; i < 12; i++ )
-     win[2][i] = sin( PI/12 * (i + 0.5) );
-     for ( i = 12; i < 36; i++ )
-       win[2][i] = 0.0;
  
      N = 12;
      for ( m = 0; m < N / 2; m++ )
        for ( k = 0; k < N; k++ )
          cos_s[m][k] = cos( (PI /(2 * N)) * (2 * k + 1 + N / 2) *
!                      (2 * m + 1) ) / (N / 4);
  
      N = 36;
      for ( m = 0; m < N / 2; m++ )
!       for ( k = 0; k < N; k++ )
          cos_l[m][k] = cos( (PI / (2 * N)) * (2 * k + 1 + N / 2) *
                       (2 * m + 1) ) / (N / 4);
! 
      init++;
    }
  
!   if ( block_type == 2 )
    {
      N = 12;
      for ( l = 0; l < 3; l++ )
--- 150,177 ----
        win[3][i] = 1.0;
      for ( i = 18; i < 36; i++ )
        win[3][i] = sin( PI/36 * (i + 0.5) );
  
      N = 12;
      for ( m = 0; m < N / 2; m++ )
        for ( k = 0; k < N; k++ )
          cos_s[m][k] = cos( (PI /(2 * N)) * (2 * k + 1 + N / 2) *
!                      (2 * m + 1) ) / (N / 4) * sin( PI/12 * (k + 0.5) );
  
      N = 36;
      for ( m = 0; m < N / 2; m++ )
!     {
!       for ( k = 0; k < 9; k++ )
!       {
          cos_l[m][k] = cos( (PI / (2 * N)) * (2 * k + 1 + N / 2) *
                       (2 * m + 1) ) / (N / 4);
!         cos_l[m][9+k] = cos( (PI / (2 * N)) * (2 * (18 + k) + 1 + N / 2) *
!                      (2 * m + 1) ) / (N / 4);
!       }
!     }
      init++;
    }
  
!   if ( block_type == 2)
    {
      N = 12;
      for ( l = 0; l < 3; l++ )
***************
*** 178,212 ****
        for ( m = 0; m < N / 2; m++ )
        {
          for ( sum = 0.0, k = 0; k < N; k++ )
!           sum += win[block_type][k] * in[k + 6 * l + 6] * cos_s[m][k];
          out[ 3 * m + l] = sum;
        }
      }
    }
!   else
    {
!     N = 36;
!     for ( m = 0; m < N / 2; m++ )
!     {
!       for ( sum = 0.0, k = 0; k < N; k++ )
!         sum += win[block_type][k] * in[k] * cos_l[m][k];
!       out[m] = sum;
!     }
!   }
! }
  
! void
! delay( double (*xr)[2][576], int stereo )
! {
!     static double xr_buff[2][576];
!     double xr_buff2[2][576];
!     unsigned int i,j;
!     
!     for (i=0;i<stereo;i++)
!     {
! 	for (j=0;j<576;j++) xr_buff2[i][j] = xr_buff[i][j];
! 	for (j=0;j<576;j++) xr_buff[i][j]  = xr[1][i][j];
! 	for (j=0;j<576;j++) xr[1][i][j]    = xr[0][i][j];
! 	for (j=0;j<576;j++) xr[0][i][j]    = xr_buff2[i][j];
!     }
  }
--- 179,508 ----
        for ( m = 0; m < N / 2; m++ )
        {
          for ( sum = 0.0, k = 0; k < N; k++ )
!           sum += in[k + 6 * l + 6] * cos_s[m][k];
          out[ 3 * m + l] = sum;
        }
      }
    }
!   else 
    {
!       for (k=0;k<9;k++)
!       {
! 	 fin[k] = win[block_type][k] * in[k] - win[block_type][17-k] * in[17-k];
! 	 fin[9+k] = win[block_type][18+k] * in[18+k] + win[block_type][35-k] * in[35-k];
!       }
  
!       /* 0 */  
!       cos_l0= &cos_l[0][0];
! 	  sum = ( fin[0] ) * *cos_l0; /* 17 */
!       sum += ( fin[1] ) * *++cos_l0; /* 15 */
!       sum += ( fin[2] ) * *++cos_l0; /* 13 */
!       sum += ( fin[3] ) * *++cos_l0; /* 11 */
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 7  */
!       sum += ( fin[6] ) * *++cos_l0; /* 5  */
!       sum += ( fin[7] ) * *++cos_l0; /* 3 */
!       sum += ( fin[8] ) * *++cos_l0; /* 1  */
!       sum += ( fin[9] ) * *++cos_l0; /* 19*/
!       sum += ( fin[10] ) * *++cos_l0; /* 21 */
!       sum += ( fin[11] ) * *++cos_l0; /* 23 */
!       sum += ( fin[12] ) * *++cos_l0; /*25 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 29 */
!       sum += ( fin[15] ) * *++cos_l0; /* 31*/
!       sum += ( fin[16] ) * *++cos_l0; /* 33 */
!       sum += ( fin[17] ) * *++cos_l0; /* 35 */    
!       out[0]=sum; 
! 
! 
!       /* 1 */
!       sum = ( fin[2]+fin[3]+fin[17] ) * cos_l[1][2];  /* mfc=3 2*/
!       sum += ( fin[1]+fin[4]+fin[16] ) * cos_l[1][1];  /* mfc=9 1*/
!       sum += ( fin[0]+fin[5]+fin[15] ) * *++cos_l0;  /* mfc=15 0*/
!       sum += ( fin[6]-fin[9]+fin[14] ) * *(cos_l0+=6); /* mfc=21 6*/
!       sum += ( fin[7]-fin[10]+fin[13] ) * *++cos_l0; /* mfc=27 7*/
!       sum += ( fin[8]-fin[11]+fin[12] ) * *++cos_l0; /* mfc = 28 8*/
!       out[1]=sum;
! 
!       /* 2 */
!       cos_l0= &cos_l[2][0];
! 	  sum = ( fin[0] ) * *cos_l0;  /* mfc 23 */
!       sum += ( fin[1] ) * *++cos_l0;  /* mfc 33 */
!       sum += ( fin[2] ) * *++cos_l0;   /* mfc 29 */
!       sum += ( fin[3] ) * *++cos_l0;   /* mfc 19 */
!       sum += ( fin[4] ) * *++cos_l0;   /* mfc 9  */
!       sum += ( fin[5] ) * *++cos_l0;   /* mfc 1  */
!       sum += ( fin[6] ) * *++cos_l0;   /* mfc 11 */
!       sum += ( fin[7] ) * *++cos_l0;   /* mfc 21 */
!       sum += ( fin[8] ) * *++cos_l0;    /* mfc 31 */
!       sum += ( fin[9] ) * *++cos_l0; /* mfc 13 */
!       sum += ( fin[10] ) * *++cos_l0; /* mfc 3  */
!       sum += ( fin[11] ) * *++cos_l0; /* mfc 7  */
!       sum += ( fin[12] ) * *++cos_l0; /* mfc 17 */
!       sum += ( fin[13] ) * *++cos_l0; /* mfc 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* mfc 35 */
!       sum += ( fin[15] ) * *++cos_l0; /* mfc 25 */
!       sum += ( fin[16] ) * *++cos_l0; /* mfc 15 */
!       sum += ( fin[17] ) * *++cos_l0; /* mfc 5 */
!       out[2]=sum;
! 
!       /* 3 */;
! 	  sum = ( fin[0] ) * *++cos_l0; /* mfc 11 */
!       sum += ( fin[1] ) * *++cos_l0; /* mfc 3 */
!       sum += ( fin[2] ) * *++cos_l0; /* 17 */
!       sum += ( fin[3] ) * *++cos_l0; /* 31 */
!       sum += ( fin[4] ) * *++cos_l0; /* 27 */
!       sum += ( fin[5] ) * *++cos_l0; /* 13 */
!       sum += ( fin[6] ) * *++cos_l0; /* 1 */
!       sum += ( fin[7] ) * *++cos_l0; /* 15 */
!       sum += ( fin[8] ) * *++cos_l0; /* 29 */
!       sum += ( fin[9] ) * *++cos_l0; /* 25 */
!       sum += ( fin[10] ) * *++cos_l0; /* 33 */
!       sum += ( fin[11] ) * *++cos_l0; /* 19 */
!       sum += ( fin[12] ) * *++cos_l0; /* 5 */
!       sum += ( fin[13] ) * *++cos_l0; /* 9 */
!       sum += ( fin[14] ) * *++cos_l0; /* 23 */
!       sum += ( fin[15] ) * *++cos_l0; /* 35 */
!       sum += ( fin[16] ) * *++cos_l0; /* 21 */
!       sum += ( fin[17] ) * *++cos_l0; /* 7 */
!       out[3]=sum;
! 
!       /* 4 */
!       /* mfc 27 */
!       sum = ( fin[0]-fin[1]-fin[4]+fin[5]+fin[8] \
! 	       -fin[11]+fin[12]+fin[15]-fin[16] ) * *++cos_l0;
!       /* mfc 9 */
!       sum += ( -fin[2]-fin[3]+fin[6]+fin[7]-fin[9]-fin[10] \
! 	       +fin[13]+fin[14]-fin[17] ) * cos_l[4][6];
!       out[4]=sum;
! 
!       /* 5 */
!       cos_l0= &cos_l[5][0];
! 	  sum = ( fin[0] ) * *cos_l0; /* 7 */
!       sum += ( fin[1] ) * *++cos_l0; /* 15 */
!       sum += ( fin[2] ) * *++cos_l0; /* 35 */
!       sum += ( fin[3] ) * *++cos_l0; /* 13 */
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 31 */
!       sum += ( fin[6] ) * *++cos_l0; /* 19 */
!       sum += ( fin[7] ) * *++cos_l0; /* 3 */
!       sum += ( fin[8] ) * *++cos_l0; /* 8 */
!       sum += ( fin[9] ) * *++cos_l0; /* 29 */
!       sum += ( fin[10] ) * *++cos_l0; /* 21 */
!       sum += ( fin[11] ) * *++cos_l0; /* 1 */
!       sum += ( fin[12] ) * *++cos_l0; /* 23 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 5 */
!       sum += ( fin[15] ) * *++cos_l0; /* 17 */
!       sum += ( fin[16] ) * *++cos_l0; /* 33 */
!       sum += ( fin[17] ) * *++cos_l0; /* 11 */
!       out[5]=sum;
! 
!       /* 6 */
! 	  sum = ( fin[0] ) * *++cos_l0; /* 31 */
!       sum += ( fin[1] ) * *++cos_l0; /* 15 */
!       sum += ( fin[2] ) * *++cos_l0; /* 11 */
!       sum += ( fin[3] ) * *++cos_l0; /* 35 */
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 17 */
!       sum += ( fin[6] ) * *++cos_l0; /* 29 */
!       sum += ( fin[7] ) * *++cos_l0; /* 3 */
!       sum += ( fin[8] ) * *++cos_l0; /* 23 */
!       sum += ( fin[9] ) * *++cos_l0; /* 5 */
!       sum += ( fin[10] ) * *++cos_l0; /* 21 */
!       sum += ( fin[11] ) * *++cos_l0; /* 25 */
!       sum += ( fin[12] ) * *++cos_l0; /* 1 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 19 */
!       sum += ( fin[15] ) * *++cos_l0; /* 7 */
!       sum += ( fin[16] ) * *++cos_l0; /* 33 */
!       sum += ( fin[17] ) * *++cos_l0; /* 13 */    
!       out[6]=sum;
! 
!       /* 7 */
!       sum = ( fin[0]+fin[5]+fin[15] ) * *++cos_l0; /* 3 */
!       sum += ( fin[1]+fin[4]+fin[16] ) * *++cos_l0; /* 27*/
!       sum += ( fin[2]+fin[3]+fin[17] ) * *++cos_l0; /* 15 */
!       sum += ( fin[6]-fin[9]+fin[14] ) * *(cos_l0+=4); /* 33 */
!       sum += ( fin[7]-fin[10]+fin[13] ) * *++cos_l0; /* 9 */
!       sum += ( fin[8]-fin[11]+fin[12] ) * *++cos_l0; /* 21 */
!       out[7]=sum;
! 
!       /* 8 */
!       cos_l0= &cos_l[8][0];
! 	  sum = (  fin[0] ) * *cos_l0; /* 35 */
!       sum += ( fin[1] ) * *++cos_l0; /* 3  */
!       sum += ( fin[2] ) * *++cos_l0; /* 31 */
!       sum += ( fin[3] ) * *++cos_l0; /*  7 */
!       sum += ( fin[4] ) * *++cos_l0; /* 27*/
!       sum += ( fin[5] ) * *++cos_l0; /* 11 */
!       sum += ( fin[6] ) * *++cos_l0; /* 23 */
!       sum += ( fin[7] ) * *++cos_l0; /* 15*/
!       sum += ( fin[8] ) * *++cos_l0; /* 19 */
!       sum += ( fin[9] ) * *++cos_l0; /* 1 */
!       sum += ( fin[10] ) * *++cos_l0; /* 33 */
!       sum += ( fin[11] ) * *++cos_l0; /*  5 */
!       sum += ( fin[12] ) * *++cos_l0; /* 29*/
!       sum += ( fin[13] ) * *++cos_l0; /*  9 */
!       sum += ( fin[14] ) * *++cos_l0; /* 25 */
!       sum += ( fin[15] ) * *++cos_l0; /* 13*/
!       sum += ( fin[16] ) * *++cos_l0; /* 21 */
!       sum += ( fin[17] ) * *++cos_l0; /* 17 */    
!       out[8]=sum;
! 
!       /* 9 */
! 	  sum = ( fin[0] ) * *++cos_l0; /* 1  */
!       sum += ( fin[1] ) * *++cos_l0; /* 33 */
!       sum += ( fin[2] ) * *++cos_l0; /*  5 */
!       sum += ( fin[3] ) * *++cos_l0; /*  29*/
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 25 */
!       sum += ( fin[6] ) * *++cos_l0; /* 13 */
!       sum += ( fin[7] ) * *++cos_l0; /* 21*/
!       sum += ( fin[8] ) * *++cos_l0; /* 17 */
!       sum += ( fin[9] ) * *++cos_l0; /* 35*/
!       sum += ( fin[10] ) * *++cos_l0; /* 3  */
!       sum += ( fin[11] ) * *++cos_l0; /* 31 */
!       sum += ( fin[12] ) * *++cos_l0; /* 7 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 11 */
!       sum += ( fin[15] ) * *++cos_l0; /* 23*/
!       sum += ( fin[16] ) * *++cos_l0; /* 15 */
!       sum += ( fin[17] ) * *++cos_l0; /* 19 */    
!       out[9]=sum; 
! 
!       /* 10 */
!       sum = ( fin[0]+fin[5]+fin[15] ) * *++cos_l0; /* 33 */
!       sum += ( fin[1]+fin[4]+fin[16] ) * *++cos_l0; /* 9 */
!       sum += ( fin[2]+fin[3]+fin[17] ) * *++cos_l0; /* 21 */
!       sum += ( fin[6]-fin[9]+fin[14] ) * *(cos_l0+=4); /* 3 */
!       sum += ( fin[7]-fin[10]+fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[8]-fin[11]+fin[12] ) * *++cos_l0; /* 15 */
!       out[10]=sum;
! 
!       /* 11 */
!       cos_l0= &cos_l[11][0];
! 	  sum = ( fin[0] ) * *cos_l0; /* 5  */
!       sum += ( fin[1] ) * *++cos_l0; /* 21 */
!       sum += ( fin[2] ) * *++cos_l0; /* 25 */
!       sum += ( fin[3] ) * *++cos_l0; /*  1 */
!       sum += ( fin[4] ) * *++cos_l0; /*27 */
!       sum += ( fin[5] ) * *++cos_l0; /* 19 */
!       sum += ( fin[6] ) * *++cos_l0; /* 7  */
!       sum += ( fin[7] ) * *++cos_l0; /* 33*/
!       sum += ( fin[8] ) * *++cos_l0; /* 13 */
!       sum += ( fin[9] ) * *++cos_l0; /* 31*/
!       sum += ( fin[10] ) * *++cos_l0; /* 15 */
!       sum += ( fin[11] ) * *++cos_l0; /* 11 */
!       sum += ( fin[12] ) * *++cos_l0; /*35 */
!       sum += ( fin[13] ) * *++cos_l0; /*  9 */
!       sum += ( fin[14] ) * *++cos_l0; /* 17 */
!       sum += ( fin[15] ) * *++cos_l0; /* 29*/
!       sum += ( fin[16] ) * *++cos_l0; /* 3  */
!       sum += ( fin[17] ) * *++cos_l0; /* 23 */    
!       out[11]=sum; 
! 
!       /* 12 */
! 	  sum = ( fin[0] ) * *++cos_l0; /* 29 */
!       sum += ( fin[1] ) * *++cos_l0; /* 21 */
!       sum += ( fin[2] ) * *++cos_l0; /* 1  */
!       sum += ( fin[3] ) * *++cos_l0; /* 23 */
!       sum += ( fin[4] ) * *++cos_l0; /*27 */
!       sum += ( fin[5] ) * *++cos_l0; /* 5  */
!       sum += ( fin[6] ) * *++cos_l0; /* 17 */
!       sum += ( fin[7] ) * *++cos_l0; /* 33*/
!       sum += ( fin[8] ) * *++cos_l0; /* 11 */
!       sum += ( fin[9] ) * *++cos_l0; /* 7 */
!       sum += ( fin[10] ) * *++cos_l0; /* 15 */
!       sum += ( fin[11] ) * *++cos_l0; /* 35 */
!       sum += ( fin[12] ) * *++cos_l0; /*13 */
!       sum += ( fin[13] ) * *++cos_l0; /*  9 */
!       sum += ( fin[14] ) * *++cos_l0; /* 31 */
!       sum += ( fin[15] ) * *++cos_l0; /* 19*/
!       sum += ( fin[16] ) * *++cos_l0; /* 3  */
!       sum += ( fin[17] ) * *++cos_l0; /* 25 */    
!       out[12]=sum; 
! 
!       /* 13 */
!       sum = ( -fin[0]+fin[1]+fin[4]-fin[5]-fin[8]+fin[11]-fin[12] \
! 	      -fin[15]+fin[16] ) * -*++cos_l0; /* 9 */
!       sum += ( -fin[2]-fin[3]+fin[6]+fin[7]-fin[9]-fin[10]+fin[13] \
! 	       +fin[14]-fin[17] ) * -cos_l[13][2]; /* 27 */
!       out[13]=sum;
! 
!       /* 14 */
!       cos_l0= &cos_l[14][0];
! 	  sum = ( fin[0] ) * *cos_l0; /* 25 */
!       sum += ( fin[1] ) * *++cos_l0; /* 33 */
!       sum += ( fin[2] ) * *++cos_l0; /* 19 */
!       sum += ( fin[3] ) * *++cos_l0; /* 5  */
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 23 */
!       sum += ( fin[6] ) * *++cos_l0; /* 35 */
!       sum += ( fin[7] ) * *++cos_l0; /* 21*/
!       sum += ( fin[8] ) * *++cos_l0; /* 7  */
!       sum += ( fin[9] ) * *++cos_l0; /* 11*/
!       sum += ( fin[10] ) * *++cos_l0; /* 3  */
!       sum += ( fin[11] ) * *++cos_l0; /* 17 */
!       sum += ( fin[12] ) * *++cos_l0; /*31 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 13 */
!       sum += ( fin[15] ) * *++cos_l0; /* 1 */
!       sum += ( fin[16] ) * *++cos_l0; /* 15 */
!       sum += ( fin[17] ) * *++cos_l0; /* 29 */    
!       out[14]=sum; 
! 
!       /* 15 */
! 	  sum = ( fin[0] ) * *++cos_l0; /* 13 */
!       sum += ( fin[1] ) * *++cos_l0; /* 3  */
!       sum += ( fin[2] ) * *++cos_l0; /* 7  */
!       sum += ( fin[3] ) * *++cos_l0; /* 17 */
!       sum += ( fin[4] ) * *++cos_l0; /* 27*/
!       sum += ( fin[5] ) * *++cos_l0; /* 35 */
!       sum += ( fin[6] ) * *++cos_l0; /* 25 */
!       sum += ( fin[7] ) * *++cos_l0; /* 15*/
!       sum += ( fin[8] ) * *++cos_l0; /* 5  */
!       sum += ( fin[9] ) * *++cos_l0; /* 23*/
!       sum += ( fin[10] ) * *++cos_l0; /* 33 */
!       sum += ( fin[11] ) * *++cos_l0; /* 29 */
!       sum += ( fin[12] ) * *++cos_l0; /*19 */
!       sum += ( fin[13] ) * *++cos_l0; /* 9  */
!       sum += ( fin[14] ) * *++cos_l0; /* 1  */
!       sum += ( fin[15] ) * *++cos_l0; /* 11*/
!       sum += ( fin[16] ) * *++cos_l0; /* 21 */
!       sum += ( fin[17] ) * *++cos_l0; /* 31 */    
!       out[15]=sum; 
! 
!       /* 16 */
!       sum = ( fin[0]+fin[5]+fin[15] ) * *++cos_l0; /* 21 */
!       sum += ( fin[1]+fin[4]+fin[16] ) * *++cos_l0;  /* 27 */
!       sum += ( fin[2]+fin[3]+fin[17] ) * *++cos_l0; /* 33 */
!       sum += ( fin[6]-fin[9]+fin[14] ) * *(cos_l0+=4); /* 15 */
!       sum += ( fin[7]-fin[10]+fin[13] ) * *++cos_l0; /* 9 */
!       sum += ( fin[8]-fin[11]+fin[12] ) * *++cos_l0; /* 3 */
!       out[16]=sum;
! 
!       /* 17 */
!       cos_l0= &cos_l[17][0];
! 	  sum = ( fin[0] ) * *cos_l0; /* 17 */
!       sum += ( fin[1] ) * *++cos_l0; /* 15 */
!       sum += ( fin[2] ) * *++cos_l0; /* 13 */
!       sum += ( fin[3] ) * *++cos_l0; /* 11 */
!       sum += ( fin[4] ) * *++cos_l0; /* 9 */
!       sum += ( fin[5] ) * *++cos_l0; /* 7  */
!       sum += ( fin[6] ) * *++cos_l0; /* 5  */
!       sum += ( fin[7] ) * *++cos_l0; /* 3 */
!       sum += ( fin[8] ) * *++cos_l0; /* 1  */
!       sum += ( fin[9] ) * *++cos_l0; /* 19*/
!       sum += ( fin[10] ) * *++cos_l0; /* 21 */
!       sum += ( fin[11] ) * *++cos_l0; /* 23 */
!       sum += ( fin[12] ) * *++cos_l0; /*25 */
!       sum += ( fin[13] ) * *++cos_l0; /* 27 */
!       sum += ( fin[14] ) * *++cos_l0; /* 29 */
!       sum += ( fin[15] ) * *++cos_l0; /* 31*/
!       sum += ( fin[16] ) * *++cos_l0; /* 33 */
!       sum += ( fin[17] ) * *++cos_l0; /* 35 */    
!       out[17]=sum; 
!    }
  }
+ 
diff -r -c -N encoder/mlame lame3.13/mlame
*** encoder/mlame	Wed Dec 31 17:00:00 1969
--- lame3.13/mlame	Sun Jun 13 12:03:00 1999
***************
*** 0 ****
--- 1,81 ----
+ #!/bin/bash 
+ #!/usr/local/bin/bash
+ ############################################################################
+ #   
+ #  Run the LAME encoder on multible files, with option to delete .wav files
+ #  after encoding.  "mlame -h" will give instructions.
+ #
+ #  Robert Hegemann <Robert.Hegemann@gmx.de>
+ #
+ ############################################################################
+ 
+ mp3coder="lame"
+ options="-h -m f -b 128"
+ rmsrc=false
+ 
+ helptext="\
+ \nThis script runs the LAME mp3 encoder on multiple files: \n\n\
+ $0 [options] <file 1> ... <file n>\n\
+ \n\
+   options:\n\
+     -h                  this help text\n\
+     -r                  remove files after encoding\n\
+     -o \"<lame options>\" overrides script default options \"${options}\"\n\
+ \n\
+   example:\n\
+     $0 -r -o \"-v -V 0 -b 112\" a*.wav z*.aif\n\
+     \n\
+ "
+ 
+ #   process command-line options
+ #   this could be extended to fake the 
+ #   commandline interface of the mp3encoder
+ 
+ while getopts ":o:r" optn; do
+     case $optn in
+     o ) options=$OPTARG # replace default options
+         ;; 
+     r ) rmsrc=true
+         ;;
+     \? ) printf "$helptext"
+         exit 1  
+         ;;
+     esac
+ done
+ shift $(($OPTIND - 1))
+ 
+ #   process input-files
+ 
+ for filename in "$@"; do
+     case $filename in
+     *[*?]*  )   # means shell couldn�t extend *.wav, etc.
+         echo "warning: no $filename file(s) found"
+         ;;
+     *[.][wW][aA][vV]  )
+         name=${filename%[.][wW][aA][vV]}
+         if $mp3coder $options $filename ${name}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     *[.][aA][iI][fF]  )
+         name=${filename%[.][aA][iI][fF]}
+         if $mp3coder $options $filename ${name}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     *   )
+         if $mp3coder $options $filename ${filename}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     esac
+ done
diff -r -c -N encoder/mpglib/Makefile lame3.13/mpglib/Makefile
*** encoder/mpglib/Makefile	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/Makefile	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,22 ----
+ 
+ CC=gcc
+ CFLAGS=-Wall -g
+ 
+ all: mpglib
+ 
+ 
+ *.o: mpg123.h mpglib.h
+ 
+ mpglib: common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	$(CC) -o mpglib common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o main.o -lm
+ 
+ lib:    common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	ar -svru libmpg123.a main.o common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o 
+ 
+ 
+ clean:
+ 	rm *.o mpglib
+ 
+ 
diff -r -c -N encoder/mpglib/README lame3.13/mpglib/README
*** encoder/mpglib/README	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/README	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,33 ----
+ MP3 library
+ -----------
+ Version 0.2
+ 
+ This decoder is a 'light' version (thrown out all unnecessay parts)
+ from the mpg123 package. I made this for a company.
+ 
+ Currently only Layer3 is enabled to save some space. Layer1,2 isn't
+ tested at all. The interface will not change significantly. 
+ A backport to the mpg123 package is planed.
+ 
+ comiled and tested only on Solaris 2.6
+ main.c contains a simple demo application for library.
+ 
+ COPYING: you may use this source under GPL terms!
+ 
+ PLEASE NOTE: This software may contain patented alogrithm (at least
+   patented in some countries). It may be not allowed to sell/use products
+   based on this source code in these countries. Check this out first!
+ 
+ COPYRIGHT of MP3 music:
+   Please note, that the duplicating of copyrighted music without explicit
+   permission violates the rights of the owner.
+ 
+ SENDING PATCHES:
+   Maybe I change the copyright policy (ie some kind of more free BSD licencse).
+   Please consider this when sending patches/changes.
+ 
+ FEEDBACK:
+   I'm interessted to here from you, when you use this package as part
+   of another project.
+ 
+ 
diff -r -c -N encoder/mpglib/TODO lame3.13/mpglib/TODO
*** encoder/mpglib/TODO	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/TODO	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,2 ----
+ 
+ apply 'VBR' bug 
diff -r -c -N encoder/mpglib/common.c lame3.13/mpglib/common.c
*** encoder/mpglib/common.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/common.c	Sun Apr 25 22:13:19 1999
***************
*** 0 ****
--- 1,263 ----
+ #ifdef HAVEGTK
+ #include <ctype.h>
+ #include <stdlib.h>
+ #include <signal.h>
+ 
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <fcntl.h>
+ 
+ #include "mpg123.h"
+ 
+ struct parameter param = { 1 , 1 , 0 , 0 };
+ 
+ int tabsel_123[2][3][16] = {
+    { {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,},
+      {0,32,48,56, 64, 80, 96,112,128,160,192,224,256,320,384,},
+      {0,32,40,48, 56, 64, 80, 96,112,128,160,192,224,256,320,} },
+ 
+    { {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,} }
+ };
+ 
+ long freqs[9] = { 44100, 48000, 32000,
+                   22050, 24000, 16000 ,
+                   11025 , 12000 , 8000 };
+ 
+ int bitindex;
+ unsigned char *wordpointer;
+ unsigned char *pcm_sample;
+ int pcm_point = 0;
+ 
+ 
+ #if 0
+ static void get_II_stuff(struct frame *fr)
+ {
+   static int translate[3][2][16] = 
+    { { { 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 } ,
+        { 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 } } ,
+      { { 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 } ,
+        { 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 } } ,
+      { { 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 } ,
+        { 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 } } };
+ 
+   int table,sblim;
+   static struct al_table *tables[5] = 
+        { alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
+   static int sblims[5] = { 27 , 30 , 8, 12 , 30 };
+ 
+   if(fr->lsf)
+     table = 4;
+   else
+     table = translate[fr->sampling_frequency][2-fr->stereo][fr->bitrate_index];
+   sblim = sblims[table];
+ 
+   fr->alloc = tables[table];
+   fr->II_sblimit = sblim;
+ }
+ #endif
+ 
+ #define HDRCMPMASK 0xfffffd00
+ 
+ #if 0
+ int head_check(unsigned long head)
+ {
+     if( (head & 0xffe00000) != 0xffe00000)
+ 	return FALSE;
+     if(!((head>>17)&3))
+ 	return FALSE;
+     if( ((head>>12)&0xf) == 0xf)
+ 	return FALSE;
+     if( ((head>>10)&0x3) == 0x3 )
+ 	return FALSE;
+     return TRUE;
+ }
+ #endif
+ 
+ /*
+  * the code a header and write the information
+  * into the frame structure
+  */
+ int decode_header(struct frame *fr,unsigned long newhead)
+ {
+ 
+ 
+     if( newhead & (1<<20) ) {
+       fr->lsf = (newhead & (1<<19)) ? 0x0 : 0x1;
+       fr->mpeg25 = 0;
+     }
+     else {
+       fr->lsf = 1;
+       fr->mpeg25 = 1;
+     }
+     
+     fr->lay = 4-((newhead>>17)&3);
+     if( ((newhead>>10)&0x3) == 0x3) {
+       fprintf(stderr,"Stream error\n");
+       exit(1);
+     }
+     if(fr->mpeg25) {
+       fr->sampling_frequency = 6 + ((newhead>>10)&0x3);
+     }
+     else
+       fr->sampling_frequency = ((newhead>>10)&0x3) + (fr->lsf*3);
+     fr->error_protection = ((newhead>>16)&0x1)^0x1;
+ 
+     if(fr->mpeg25) /* allow Bitrate change for 2.5 ... */
+       fr->bitrate_index = ((newhead>>12)&0xf);
+ 
+     fr->bitrate_index = ((newhead>>12)&0xf);
+     fr->padding   = ((newhead>>9)&0x1);
+     fr->extension = ((newhead>>8)&0x1);
+     fr->mode      = ((newhead>>6)&0x3);
+     fr->mode_ext  = ((newhead>>4)&0x3);
+     fr->copyright = ((newhead>>3)&0x1);
+     fr->original  = ((newhead>>2)&0x1);
+     fr->emphasis  = newhead & 0x3;
+ 
+     fr->stereo    = (fr->mode == MPG_MD_MONO) ? 1 : 2;
+ 
+     if(!fr->bitrate_index)
+     {
+       fprintf(stderr,"Free format not supported.\n");
+       return (0);
+     }
+ 
+     switch(fr->lay)
+     {
+       case 1:
+ #if 0
+ 		fr->do_layer = do_layer1;
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ? 
+                          (fr->mode_ext<<2)+4 : 32;
+         fr->framesize  = (long) tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize  = ((fr->framesize+fr->padding)<<2)-4;
+ #else
+         fprintf(stderr,"Not supported!\n");
+ #endif
+         break;
+       case 2:
+ #if 0
+ 		fr->do_layer = do_layer2;
+         get_II_stuff(fr);
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ?
+                          (fr->mode_ext<<2)+4 : fr->II_sblimit;
+         fr->framesize = (long) tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize += fr->padding - 4;
+ #else
+         fprintf(stderr,"Not supported!\n");
+ #endif
+         break;
+       case 3:
+ #if 0
+         fr->do_layer = do_layer3;
+         if(fr->lsf)
+           ssize = (fr->stereo == 1) ? 9 : 17;
+         else
+           ssize = (fr->stereo == 1) ? 17 : 32;
+ #endif
+ 
+ #if 0
+         if(fr->error_protection)
+           ssize += 2;
+ #endif
+           fr->framesize  = (long) tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000;
+           fr->framesize /= freqs[fr->sampling_frequency]<<(fr->lsf);
+           fr->framesize = fr->framesize + fr->padding - 4;
+         break; 
+       default:
+         fprintf(stderr,"Sorry, unknown layer type.\n"); 
+         return (0);
+     }
+ 
+     /*    print_header(fr); */
+ 
+     return 1;
+ }
+ 
+ 
+ #if 1
+ void print_header(struct frame *fr)
+ {
+ 	static char *modes[4] = { "Stereo", "Joint-Stereo", "Dual-Channel", "Single-Channel" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+ 
+ 	fprintf(stderr,"MPEG %s, Layer: %s, Freq: %ld, mode: %s, modext: %d, BPF : %d\n", 
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],freqs[fr->sampling_frequency],
+ 		modes[fr->mode],fr->mode_ext,fr->framesize+4);
+ 	fprintf(stderr,"Channels: %d, copyright: %s, original: %s, CRC: %s, emphasis: %d.\n",
+ 		fr->stereo,fr->copyright?"Yes":"No",
+ 		fr->original?"Yes":"No",fr->error_protection?"Yes":"No",
+ 		fr->emphasis);
+ 	fprintf(stderr,"Bitrate: %d Kbits/s, Extension value: %d\n",
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],fr->extension);
+ }
+ 
+ void print_header_compact(struct frame *fr)
+ {
+ 	static char *modes[4] = { "stereo", "joint-stereo", "dual-channel", "mono" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+  
+ 	fprintf(stderr,"MPEG %s layer %s, %d kbit/s, %ld Hz %s\n",
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],
+ 		freqs[fr->sampling_frequency], modes[fr->mode]);
+ }
+ 
+ #endif
+ 
+ unsigned int getbits(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   if(!number_of_bits)
+     return 0;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;
+     rval |= wordpointer[1];
+     rval <<= 8;
+     rval |= wordpointer[2];
+     rval <<= bitindex;
+     rval &= 0xffffff;
+ 
+     bitindex += number_of_bits;
+ 
+     rval >>= (24-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ unsigned int getbits_fast(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;	
+     rval |= wordpointer[1];
+     rval <<= bitindex;
+     rval &= 0xffff;
+     bitindex += number_of_bits;
+ 
+     rval >>= (16-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/dct64_i386.c lame3.13/mpglib/dct64_i386.c
*** encoder/mpglib/dct64_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/dct64_i386.c	Sun Apr 25 22:13:34 1999
***************
*** 0 ****
--- 1,316 ----
+ #ifdef HAVEGTK
+ /*
+  * Discrete Cosine Tansform (DCT) for subband synthesis
+  * optimized for machines with no auto-increment. 
+  * The performance is highly compiler dependend. Maybe
+  * the dct64.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include "mpg123.h"
+ 
+ static void dct64_1(real *out0,real *out1,real *b1,real *b2,real *samples)
+ {
+ 
+  {
+   register real *costab = pnts[0];
+ 
+   b1[0x00] = samples[0x00] + samples[0x1F];
+   b1[0x1F] = (samples[0x00] - samples[0x1F]) * costab[0x0];
+ 
+   b1[0x01] = samples[0x01] + samples[0x1E];
+   b1[0x1E] = (samples[0x01] - samples[0x1E]) * costab[0x1];
+ 
+   b1[0x02] = samples[0x02] + samples[0x1D];
+   b1[0x1D] = (samples[0x02] - samples[0x1D]) * costab[0x2];
+ 
+   b1[0x03] = samples[0x03] + samples[0x1C];
+   b1[0x1C] = (samples[0x03] - samples[0x1C]) * costab[0x3];
+ 
+   b1[0x04] = samples[0x04] + samples[0x1B];
+   b1[0x1B] = (samples[0x04] - samples[0x1B]) * costab[0x4];
+ 
+   b1[0x05] = samples[0x05] + samples[0x1A];
+   b1[0x1A] = (samples[0x05] - samples[0x1A]) * costab[0x5];
+ 
+   b1[0x06] = samples[0x06] + samples[0x19];
+   b1[0x19] = (samples[0x06] - samples[0x19]) * costab[0x6];
+ 
+   b1[0x07] = samples[0x07] + samples[0x18];
+   b1[0x18] = (samples[0x07] - samples[0x18]) * costab[0x7];
+ 
+   b1[0x08] = samples[0x08] + samples[0x17];
+   b1[0x17] = (samples[0x08] - samples[0x17]) * costab[0x8];
+ 
+   b1[0x09] = samples[0x09] + samples[0x16];
+   b1[0x16] = (samples[0x09] - samples[0x16]) * costab[0x9];
+ 
+   b1[0x0A] = samples[0x0A] + samples[0x15];
+   b1[0x15] = (samples[0x0A] - samples[0x15]) * costab[0xA];
+ 
+   b1[0x0B] = samples[0x0B] + samples[0x14];
+   b1[0x14] = (samples[0x0B] - samples[0x14]) * costab[0xB];
+ 
+   b1[0x0C] = samples[0x0C] + samples[0x13];
+   b1[0x13] = (samples[0x0C] - samples[0x13]) * costab[0xC];
+ 
+   b1[0x0D] = samples[0x0D] + samples[0x12];
+   b1[0x12] = (samples[0x0D] - samples[0x12]) * costab[0xD];
+ 
+   b1[0x0E] = samples[0x0E] + samples[0x11];
+   b1[0x11] = (samples[0x0E] - samples[0x11]) * costab[0xE];
+ 
+   b1[0x0F] = samples[0x0F] + samples[0x10];
+   b1[0x10] = (samples[0x0F] - samples[0x10]) * costab[0xF];
+  }
+ 
+ 
+  {
+   register real *costab = pnts[1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x0F]; 
+   b2[0x0F] = (b1[0x00] - b1[0x0F]) * costab[0];
+   b2[0x01] = b1[0x01] + b1[0x0E]; 
+   b2[0x0E] = (b1[0x01] - b1[0x0E]) * costab[1];
+   b2[0x02] = b1[0x02] + b1[0x0D]; 
+   b2[0x0D] = (b1[0x02] - b1[0x0D]) * costab[2];
+   b2[0x03] = b1[0x03] + b1[0x0C]; 
+   b2[0x0C] = (b1[0x03] - b1[0x0C]) * costab[3];
+   b2[0x04] = b1[0x04] + b1[0x0B]; 
+   b2[0x0B] = (b1[0x04] - b1[0x0B]) * costab[4];
+   b2[0x05] = b1[0x05] + b1[0x0A]; 
+   b2[0x0A] = (b1[0x05] - b1[0x0A]) * costab[5];
+   b2[0x06] = b1[0x06] + b1[0x09]; 
+   b2[0x09] = (b1[0x06] - b1[0x09]) * costab[6];
+   b2[0x07] = b1[0x07] + b1[0x08]; 
+   b2[0x08] = (b1[0x07] - b1[0x08]) * costab[7];
+ 
+   b2[0x10] = b1[0x10] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x10]) * costab[0];
+   b2[0x11] = b1[0x11] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x11]) * costab[1];
+   b2[0x12] = b1[0x12] + b1[0x1D];
+   b2[0x1D] = (b1[0x1D] - b1[0x12]) * costab[2];
+   b2[0x13] = b1[0x13] + b1[0x1C];
+   b2[0x1C] = (b1[0x1C] - b1[0x13]) * costab[3];
+   b2[0x14] = b1[0x14] + b1[0x1B];
+   b2[0x1B] = (b1[0x1B] - b1[0x14]) * costab[4];
+   b2[0x15] = b1[0x15] + b1[0x1A];
+   b2[0x1A] = (b1[0x1A] - b1[0x15]) * costab[5];
+   b2[0x16] = b1[0x16] + b1[0x19];
+   b2[0x19] = (b1[0x19] - b1[0x16]) * costab[6];
+   b2[0x17] = b1[0x17] + b1[0x18];
+   b2[0x18] = (b1[0x18] - b1[0x17]) * costab[7];
+  }
+ 
+  {
+   register real *costab = pnts[2];
+ 
+   b1[0x00] = b2[0x00] + b2[0x07];
+   b1[0x07] = (b2[0x00] - b2[0x07]) * costab[0];
+   b1[0x01] = b2[0x01] + b2[0x06];
+   b1[0x06] = (b2[0x01] - b2[0x06]) * costab[1];
+   b1[0x02] = b2[0x02] + b2[0x05];
+   b1[0x05] = (b2[0x02] - b2[0x05]) * costab[2];
+   b1[0x03] = b2[0x03] + b2[0x04];
+   b1[0x04] = (b2[0x03] - b2[0x04]) * costab[3];
+ 
+   b1[0x08] = b2[0x08] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x08]) * costab[0];
+   b1[0x09] = b2[0x09] + b2[0x0E];
+   b1[0x0E] = (b2[0x0E] - b2[0x09]) * costab[1];
+   b1[0x0A] = b2[0x0A] + b2[0x0D];
+   b1[0x0D] = (b2[0x0D] - b2[0x0A]) * costab[2];
+   b1[0x0B] = b2[0x0B] + b2[0x0C];
+   b1[0x0C] = (b2[0x0C] - b2[0x0B]) * costab[3];
+ 
+   b1[0x10] = b2[0x10] + b2[0x17];
+   b1[0x17] = (b2[0x10] - b2[0x17]) * costab[0];
+   b1[0x11] = b2[0x11] + b2[0x16];
+   b1[0x16] = (b2[0x11] - b2[0x16]) * costab[1];
+   b1[0x12] = b2[0x12] + b2[0x15];
+   b1[0x15] = (b2[0x12] - b2[0x15]) * costab[2];
+   b1[0x13] = b2[0x13] + b2[0x14];
+   b1[0x14] = (b2[0x13] - b2[0x14]) * costab[3];
+ 
+   b1[0x18] = b2[0x18] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x18]) * costab[0];
+   b1[0x19] = b2[0x19] + b2[0x1E];
+   b1[0x1E] = (b2[0x1E] - b2[0x19]) * costab[1];
+   b1[0x1A] = b2[0x1A] + b2[0x1D];
+   b1[0x1D] = (b2[0x1D] - b2[0x1A]) * costab[2];
+   b1[0x1B] = b2[0x1B] + b2[0x1C];
+   b1[0x1C] = (b2[0x1C] - b2[0x1B]) * costab[3];
+  }
+ 
+  {
+   register real const cos0 = pnts[3][0];
+   register real const cos1 = pnts[3][1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x03];
+   b2[0x03] = (b1[0x00] - b1[0x03]) * cos0;
+   b2[0x01] = b1[0x01] + b1[0x02];
+   b2[0x02] = (b1[0x01] - b1[0x02]) * cos1;
+ 
+   b2[0x04] = b1[0x04] + b1[0x07];
+   b2[0x07] = (b1[0x07] - b1[0x04]) * cos0;
+   b2[0x05] = b1[0x05] + b1[0x06];
+   b2[0x06] = (b1[0x06] - b1[0x05]) * cos1;
+ 
+   b2[0x08] = b1[0x08] + b1[0x0B];
+   b2[0x0B] = (b1[0x08] - b1[0x0B]) * cos0;
+   b2[0x09] = b1[0x09] + b1[0x0A];
+   b2[0x0A] = (b1[0x09] - b1[0x0A]) * cos1;
+   
+   b2[0x0C] = b1[0x0C] + b1[0x0F];
+   b2[0x0F] = (b1[0x0F] - b1[0x0C]) * cos0;
+   b2[0x0D] = b1[0x0D] + b1[0x0E];
+   b2[0x0E] = (b1[0x0E] - b1[0x0D]) * cos1;
+ 
+   b2[0x10] = b1[0x10] + b1[0x13];
+   b2[0x13] = (b1[0x10] - b1[0x13]) * cos0;
+   b2[0x11] = b1[0x11] + b1[0x12];
+   b2[0x12] = (b1[0x11] - b1[0x12]) * cos1;
+ 
+   b2[0x14] = b1[0x14] + b1[0x17];
+   b2[0x17] = (b1[0x17] - b1[0x14]) * cos0;
+   b2[0x15] = b1[0x15] + b1[0x16];
+   b2[0x16] = (b1[0x16] - b1[0x15]) * cos1;
+ 
+   b2[0x18] = b1[0x18] + b1[0x1B];
+   b2[0x1B] = (b1[0x18] - b1[0x1B]) * cos0;
+   b2[0x19] = b1[0x19] + b1[0x1A];
+   b2[0x1A] = (b1[0x19] - b1[0x1A]) * cos1;
+ 
+   b2[0x1C] = b1[0x1C] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x1C]) * cos0;
+   b2[0x1D] = b1[0x1D] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x1D]) * cos1;
+  }
+ 
+  {
+   register real const cos0 = pnts[4][0];
+ 
+   b1[0x00] = b2[0x00] + b2[0x01];
+   b1[0x01] = (b2[0x00] - b2[0x01]) * cos0;
+   b1[0x02] = b2[0x02] + b2[0x03];
+   b1[0x03] = (b2[0x03] - b2[0x02]) * cos0;
+   b1[0x02] += b1[0x03];
+ 
+   b1[0x04] = b2[0x04] + b2[0x05];
+   b1[0x05] = (b2[0x04] - b2[0x05]) * cos0;
+   b1[0x06] = b2[0x06] + b2[0x07];
+   b1[0x07] = (b2[0x07] - b2[0x06]) * cos0;
+   b1[0x06] += b1[0x07];
+   b1[0x04] += b1[0x06];
+   b1[0x06] += b1[0x05];
+   b1[0x05] += b1[0x07];
+ 
+   b1[0x08] = b2[0x08] + b2[0x09];
+   b1[0x09] = (b2[0x08] - b2[0x09]) * cos0;
+   b1[0x0A] = b2[0x0A] + b2[0x0B];
+   b1[0x0B] = (b2[0x0B] - b2[0x0A]) * cos0;
+   b1[0x0A] += b1[0x0B];
+ 
+   b1[0x0C] = b2[0x0C] + b2[0x0D];
+   b1[0x0D] = (b2[0x0C] - b2[0x0D]) * cos0;
+   b1[0x0E] = b2[0x0E] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x0E]) * cos0;
+   b1[0x0E] += b1[0x0F];
+   b1[0x0C] += b1[0x0E];
+   b1[0x0E] += b1[0x0D];
+   b1[0x0D] += b1[0x0F];
+ 
+   b1[0x10] = b2[0x10] + b2[0x11];
+   b1[0x11] = (b2[0x10] - b2[0x11]) * cos0;
+   b1[0x12] = b2[0x12] + b2[0x13];
+   b1[0x13] = (b2[0x13] - b2[0x12]) * cos0;
+   b1[0x12] += b1[0x13];
+ 
+   b1[0x14] = b2[0x14] + b2[0x15];
+   b1[0x15] = (b2[0x14] - b2[0x15]) * cos0;
+   b1[0x16] = b2[0x16] + b2[0x17];
+   b1[0x17] = (b2[0x17] - b2[0x16]) * cos0;
+   b1[0x16] += b1[0x17];
+   b1[0x14] += b1[0x16];
+   b1[0x16] += b1[0x15];
+   b1[0x15] += b1[0x17];
+ 
+   b1[0x18] = b2[0x18] + b2[0x19];
+   b1[0x19] = (b2[0x18] - b2[0x19]) * cos0;
+   b1[0x1A] = b2[0x1A] + b2[0x1B];
+   b1[0x1B] = (b2[0x1B] - b2[0x1A]) * cos0;
+   b1[0x1A] += b1[0x1B];
+ 
+   b1[0x1C] = b2[0x1C] + b2[0x1D];
+   b1[0x1D] = (b2[0x1C] - b2[0x1D]) * cos0;
+   b1[0x1E] = b2[0x1E] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x1E]) * cos0;
+   b1[0x1E] += b1[0x1F];
+   b1[0x1C] += b1[0x1E];
+   b1[0x1E] += b1[0x1D];
+   b1[0x1D] += b1[0x1F];
+  }
+ 
+  out0[0x10*16] = b1[0x00];
+  out0[0x10*12] = b1[0x04];
+  out0[0x10* 8] = b1[0x02];
+  out0[0x10* 4] = b1[0x06];
+  out0[0x10* 0] = b1[0x01];
+  out1[0x10* 0] = b1[0x01];
+  out1[0x10* 4] = b1[0x05];
+  out1[0x10* 8] = b1[0x03];
+  out1[0x10*12] = b1[0x07];
+ 
+  b1[0x08] += b1[0x0C];
+  out0[0x10*14] = b1[0x08];
+  b1[0x0C] += b1[0x0a];
+  out0[0x10*10] = b1[0x0C];
+  b1[0x0A] += b1[0x0E];
+  out0[0x10* 6] = b1[0x0A];
+  b1[0x0E] += b1[0x09];
+  out0[0x10* 2] = b1[0x0E];
+  b1[0x09] += b1[0x0D];
+  out1[0x10* 2] = b1[0x09];
+  b1[0x0D] += b1[0x0B];
+  out1[0x10* 6] = b1[0x0D];
+  b1[0x0B] += b1[0x0F];
+  out1[0x10*10] = b1[0x0B];
+  out1[0x10*14] = b1[0x0F];
+ 
+  b1[0x18] += b1[0x1C];
+  out0[0x10*15] = b1[0x10] + b1[0x18];
+  out0[0x10*13] = b1[0x18] + b1[0x14];
+  b1[0x1C] += b1[0x1a];
+  out0[0x10*11] = b1[0x14] + b1[0x1C];
+  out0[0x10* 9] = b1[0x1C] + b1[0x12];
+  b1[0x1A] += b1[0x1E];
+  out0[0x10* 7] = b1[0x12] + b1[0x1A];
+  out0[0x10* 5] = b1[0x1A] + b1[0x16];
+  b1[0x1E] += b1[0x19];
+  out0[0x10* 3] = b1[0x16] + b1[0x1E];
+  out0[0x10* 1] = b1[0x1E] + b1[0x11];
+  b1[0x19] += b1[0x1D];
+  out1[0x10* 1] = b1[0x11] + b1[0x19];
+  out1[0x10* 3] = b1[0x19] + b1[0x15];
+  b1[0x1D] += b1[0x1B];
+  out1[0x10* 5] = b1[0x15] + b1[0x1D];
+  out1[0x10* 7] = b1[0x1D] + b1[0x13];
+  b1[0x1B] += b1[0x1F];
+  out1[0x10* 9] = b1[0x13] + b1[0x1B];
+  out1[0x10*11] = b1[0x1B] + b1[0x17];
+  out1[0x10*13] = b1[0x17] + b1[0x1F];
+  out1[0x10*15] = b1[0x1F];
+ }
+ 
+ /*
+  * the call via dct64 is a trick to force GCC to use
+  * (new) registers for the b1,b2 pointer to the bufs[xx] field
+  */
+ void dct64(real *a,real *b,real *c)
+ {
+   real bufs[0x40];
+   dct64_1(a,b,bufs,bufs+0x20,c);
+ }
+ 
+ #endif
diff -r -c -N encoder/mpglib/decode_i386.c lame3.13/mpglib/decode_i386.c
*** encoder/mpglib/decode_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/decode_i386.c	Sun Apr 25 22:13:48 1999
***************
*** 0 ****
--- 1,155 ----
+ #ifdef HAVEGTK
+ /* 
+  * Mpeg Layer-1,2,3 audio decoder 
+  * ------------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+  * See also 'README'
+  *
+  * slighlty optimized for machines without autoincrement/decrement.
+  * The performance is highly compiler dependend. Maybe
+  * the decode.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include <stdlib.h>
+ #include <math.h>
+ #include <string.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ extern struct mpstr *gmp;
+ 
+  /* old WRITE_SAMPLE */
+ #define WRITE_SAMPLE(samples,sum,clip) \
+   if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+   else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+   else { *(samples) = sum; }
+ 
+ int synth_1to1_mono(real *bandPtr,unsigned char *samples,int *pnt)
+ {
+   short samples_tmp[64];
+   short *tmp1 = samples_tmp;
+   int i,ret;
+   int pnt1 = 0;
+ 
+   ret = synth_1to1(bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+   samples += *pnt;
+ 
+   for(i=0;i<32;i++) {
+     *( (short *) samples) = *tmp1;
+     samples += 2;
+     tmp1 += 2;
+   }
+   *pnt += 64;
+ 
+   return ret;
+ }
+ 
+ 
+ int synth_1to1(real *bandPtr,int channel,unsigned char *out,int *pnt)
+ {
+   static const int step = 2;
+   int bo;
+   short *samples = (short *) (out + *pnt);
+ 
+   real *b0,(*buf)[0x110];
+   int clip = 0; 
+   int bo1;
+ 
+   bo = gmp->synth_bo;
+ 
+   if(!channel) {
+     bo--;
+     bo &= 0xf;
+     buf = gmp->synth_buffs[0];
+   }
+   else {
+     samples++;
+     buf = gmp->synth_buffs[1];
+   }
+ 
+   if(bo & 0x1) {
+     b0 = buf[0];
+     bo1 = bo;
+     dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+   }
+   else {
+     b0 = buf[1];
+     bo1 = bo+1;
+     dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+   }
+ 
+   gmp->synth_bo = bo;
+   
+   {
+     register int j;
+     real *window = decwin + 16 - bo1;
+ 
+     for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum -= window[0x1] * b0[0x1];
+       sum += window[0x2] * b0[0x2];
+       sum -= window[0x3] * b0[0x3];
+       sum += window[0x4] * b0[0x4];
+       sum -= window[0x5] * b0[0x5];
+       sum += window[0x6] * b0[0x6];
+       sum -= window[0x7] * b0[0x7];
+       sum += window[0x8] * b0[0x8];
+       sum -= window[0x9] * b0[0x9];
+       sum += window[0xA] * b0[0xA];
+       sum -= window[0xB] * b0[0xB];
+       sum += window[0xC] * b0[0xC];
+       sum -= window[0xD] * b0[0xD];
+       sum += window[0xE] * b0[0xE];
+       sum -= window[0xF] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+ 
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum += window[0x2] * b0[0x2];
+       sum += window[0x4] * b0[0x4];
+       sum += window[0x6] * b0[0x6];
+       sum += window[0x8] * b0[0x8];
+       sum += window[0xA] * b0[0xA];
+       sum += window[0xC] * b0[0xC];
+       sum += window[0xE] * b0[0xE];
+       WRITE_SAMPLE(samples,sum,clip);
+       b0-=0x10,window-=0x20,samples+=step;
+     }
+     window += bo1<<1;
+ 
+     for (j=15;j;j--,b0-=0x10,window-=0x20,samples+=step)
+     {
+       real sum;
+       sum = -window[-0x1] * b0[0x0];
+       sum -= window[-0x2] * b0[0x1];
+       sum -= window[-0x3] * b0[0x2];
+       sum -= window[-0x4] * b0[0x3];
+       sum -= window[-0x5] * b0[0x4];
+       sum -= window[-0x6] * b0[0x5];
+       sum -= window[-0x7] * b0[0x6];
+       sum -= window[-0x8] * b0[0x7];
+       sum -= window[-0x9] * b0[0x8];
+       sum -= window[-0xA] * b0[0x9];
+       sum -= window[-0xB] * b0[0xA];
+       sum -= window[-0xC] * b0[0xB];
+       sum -= window[-0xD] * b0[0xC];
+       sum -= window[-0xE] * b0[0xD];
+       sum -= window[-0xF] * b0[0xE];
+       sum -= window[-0x0] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+   }
+   *pnt += 128;
+ 
+   return clip;
+ }
+ 
+ #endif
diff -r -c -N encoder/mpglib/huffman.h lame3.13/mpglib/huffman.h
*** encoder/mpglib/huffman.h	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/huffman.h	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,332 ----
+ /*
+  * huffman tables ... recalcualted to work with my optimzed
+  * decoder scheme (MH)
+  * 
+  * probably we could save a few bytes of memory, because the 
+  * smaller tables are often the part of a bigger table
+  */
+ 
+ struct newhuff 
+ {
+   unsigned int linbits;
+   short *table;
+ };
+ 
+ static short tab0[] = 
+ { 
+    0
+ };
+ 
+ static short tab1[] =
+ {
+   -5,  -3,  -1,  17,   1,  16,   0
+ };
+ 
+ static short tab2[] =
+ {
+  -15, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  17,  -1,   1,
+   16,   0
+ };
+ 
+ static short tab3[] =
+ {
+  -13, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  16,  17,  -1,
+    1,   0
+ };
+ 
+ static short tab5[] =
+ {
+  -29, -25, -23, -15,  -7,  -5,  -3,  -1,  51,  35,  50,  49,  -3,  -1,  19,
+    3,  -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab6[] =
+ {
+  -25, -19, -13,  -9,  -5,  -3,  -1,  51,   3,  35,  -1,  50,  48,  -1,  19,
+   49,  -3,  -1,  34,   2,  18,  -3,  -1,  33,  32,   1,  -1,  17,  -1,  16,
+    0
+ };
+ 
+ static short tab7[] =
+ {
+  -69, -65, -57, -39, -29, -17, -11,  -7,  -3,  -1,  85,  69,  -1,  84,  83,
+   -1,  53,  68,  -3,  -1,  37,  82,  21,  -5,  -1,  81,  -1,   5,  52,  -1,
+   80,  -1,  67,  51,  -5,  -3,  -1,  36,  66,  20,  -1,  65,  64, -11,  -7,
+   -3,  -1,   4,  35,  -1,  50,   3,  -1,  19,  49,  -3,  -1,  48,  34,  18,
+   -5,  -1,  33,  -1,   2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab8[] =
+ {
+  -65, -63, -59, -45, -31, -19, -13,  -7,  -5,  -3,  -1,  85,  84,  69,  83,
+   -3,  -1,  53,  68,  37,  -3,  -1,  82,   5,  21,  -5,  -1,  81,  -1,  52,
+   67,  -3,  -1,  80,  51,  36,  -5,  -3,  -1,  66,  20,  65,  -3,  -1,   4,
+   64,  -1,  35,  50,  -9,  -7,  -3,  -1,  19,  49,  -1,   3,  48,  34,  -1,
+    2,  32,  -1,  18,  33,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab9[] =
+ {
+  -63, -53, -41, -29, -19, -11,  -5,  -3,  -1,  85,  69,  53,  -1,  83,  -1,
+   84,   5,  -3,  -1,  68,  37,  -1,  82,  21,  -3,  -1,  81,  52,  -1,  67,
+   -1,  80,   4,  -7,  -3,  -1,  36,  66,  -1,  51,  64,  -1,  20,  65,  -5,
+   -3,  -1,  35,  50,  19,  -1,  49,  -1,   3,  48,  -5,  -3,  -1,  34,   2,
+   18,  -1,  33,  32,  -3,  -1,  17,   1,  -1,  16,   0
+ };
+ 
+ static short tab10[] =
+ {
+ -125,-121,-111, -83, -55, -35, -21, -13,  -7,  -3,  -1, 119, 103,  -1, 118,
+   87,  -3,  -1, 117, 102,  71,  -3,  -1, 116,  86,  -1, 101,  55,  -9,  -3,
+   -1, 115,  70,  -3,  -1,  85,  84,  99,  -1,  39, 114, -11,  -5,  -3,  -1,
+  100,   7, 112,  -1,  98,  -1,  69,  53,  -5,  -1,   6,  -1,  83,  68,  23,
+  -17,  -5,  -1, 113,  -1,  54,  38,  -5,  -3,  -1,  37,  82,  21,  -1,  81,
+   -1,  52,  67,  -3,  -1,  22,  97,  -1,  96,  -1,   5,  80, -19, -11,  -7,
+   -3,  -1,  36,  66,  -1,  51,   4,  -1,  20,  65,  -3,  -1,  64,  35,  -1,
+   50,   3,  -3,  -1,  19,  49,  -1,  48,  34,  -7,  -3,  -1,  18,  33,  -1,
+    2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab11[] =
+ {
+ -121,-113, -89, -59, -43, -27, -17,  -7,  -3,  -1, 119, 103,  -1, 118, 117,
+   -3,  -1, 102,  71,  -1, 116,  -1,  87,  85,  -5,  -3,  -1,  86, 101,  55,
+   -1, 115,  70,  -9,  -7,  -3,  -1,  69,  84,  -1,  53,  83,  39,  -1, 114,
+   -1, 100,   7,  -5,  -1, 113,  -1,  23, 112,  -3,  -1,  54,  99,  -1,  96,
+   -1,  68,  37, -13,  -7,  -5,  -3,  -1,  82,   5,  21,  98,  -3,  -1,  38,
+    6,  22,  -5,  -1,  97,  -1,  81,  52,  -5,  -1,  80,  -1,  67,  51,  -1,
+   36,  66, -15, -11,  -7,  -3,  -1,  20,  65,  -1,   4,  64,  -1,  35,  50,
+   -1,  19,  49,  -5,  -3,  -1,   3,  48,  34,  33,  -5,  -1,  18,  -1,   2,
+   32,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab12[] =
+ {
+ -115, -99, -73, -45, -27, -17,  -9,  -5,  -3,  -1, 119, 103, 118,  -1,  87,
+  117,  -3,  -1, 102,  71,  -1, 116, 101,  -3,  -1,  86,  55,  -3,  -1, 115,
+   85,  39,  -7,  -3,  -1, 114,  70,  -1, 100,  23,  -5,  -1, 113,  -1,   7,
+  112,  -1,  54,  99, -13,  -9,  -3,  -1,  69,  84,  -1,  68,  -1,   6,   5,
+   -1,  38,  98,  -5,  -1,  97,  -1,  22,  96,  -3,  -1,  53,  83,  -1,  37,
+   82, -17,  -7,  -3,  -1,  21,  81,  -1,  52,  67,  -5,  -3,  -1,  80,   4,
+   36,  -1,  66,  20,  -3,  -1,  51,  65,  -1,  35,  50, -11,  -7,  -5,  -3,
+   -1,  64,   3,  48,  19,  -1,  49,  34,  -1,  18,  33,  -7,  -5,  -3,  -1,
+    2,  32,   0,  17,  -1,   1,  16
+ };
+ 
+ static short tab13[] =
+ {
+ -509,-503,-475,-405,-333,-265,-205,-153,-115, -83, -53, -35, -21, -13,  -9,
+   -7,  -5,  -3,  -1, 254, 252, 253, 237, 255,  -1, 239, 223,  -3,  -1, 238,
+  207,  -1, 222, 191,  -9,  -3,  -1, 251, 206,  -1, 220,  -1, 175, 233,  -1,
+  236, 221,  -9,  -5,  -3,  -1, 250, 205, 190,  -1, 235, 159,  -3,  -1, 249,
+  234,  -1, 189, 219, -17,  -9,  -3,  -1, 143, 248,  -1, 204,  -1, 174, 158,
+   -5,  -1, 142,  -1, 127, 126, 247,  -5,  -1, 218,  -1, 173, 188,  -3,  -1,
+  203, 246, 111, -15,  -7,  -3,  -1, 232,  95,  -1, 157, 217,  -3,  -1, 245,
+  231,  -1, 172, 187,  -9,  -3,  -1,  79, 244,  -3,  -1, 202, 230, 243,  -1,
+   63,  -1, 141, 216, -21,  -9,  -3,  -1,  47, 242,  -3,  -1, 110, 156,  15,
+   -5,  -3,  -1, 201,  94, 171,  -3,  -1, 125, 215,  78, -11,  -5,  -3,  -1,
+  200, 214,  62,  -1, 185,  -1, 155, 170,  -1,  31, 241, -23, -13,  -5,  -1,
+  240,  -1, 186, 229,  -3,  -1, 228, 140,  -1, 109, 227,  -5,  -1, 226,  -1,
+   46,  14,  -1,  30, 225, -15,  -7,  -3,  -1, 224,  93,  -1, 213, 124,  -3,
+   -1, 199,  77,  -1, 139, 184,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -1,
+  198,  61, -37, -21,  -9,  -5,  -3,  -1, 211, 123,  45,  -1, 210,  29,  -5,
+   -1, 183,  -1,  92, 197,  -3,  -1, 153, 122, 195,  -7,  -5,  -3,  -1, 167,
+  151,  75, 209,  -3,  -1,  13, 208,  -1, 138, 168, -11,  -7,  -3,  -1,  76,
+  196,  -1, 107, 182,  -1,  60,  44,  -3,  -1, 194,  91,  -3,  -1, 181, 137,
+   28, -43, -23, -11,  -5,  -1, 193,  -1, 152,  12,  -1, 192,  -1, 180, 106,
+   -5,  -3,  -1, 166, 121,  59,  -1, 179,  -1, 136,  90, -11,  -5,  -1,  43,
+   -1, 165, 105,  -1, 164,  -1, 120, 135,  -5,  -1, 148,  -1, 119, 118, 178,
+  -11,  -3,  -1,  27, 177,  -3,  -1,  11, 176,  -1, 150,  74,  -7,  -3,  -1,
+   58, 163,  -1,  89, 149,  -1,  42, 162, -47, -23,  -9,  -3,  -1,  26, 161,
+   -3,  -1,  10, 104, 160,  -5,  -3,  -1, 134,  73, 147,  -3,  -1,  57,  88,
+   -1, 133, 103,  -9,  -3,  -1,  41, 146,  -3,  -1,  87, 117,  56,  -5,  -1,
+  131,  -1, 102,  71,  -3,  -1, 116,  86,  -1, 101, 115, -11,  -3,  -1,  25,
+  145,  -3,  -1,   9, 144,  -1,  72, 132,  -7,  -5,  -1, 114,  -1,  70, 100,
+   40,  -1, 130,  24, -41, -27, -11,  -5,  -3,  -1,  55,  39,  23,  -1, 113,
+   -1,  85,   7,  -7,  -3,  -1, 112,  54,  -1,  99,  69,  -3,  -1,  84,  38,
+   -1,  98,  53,  -5,  -1, 129,  -1,   8, 128,  -3,  -1,  22,  97,  -1,   6,
+   96, -13,  -9,  -5,  -3,  -1,  83,  68,  37,  -1,  82,   5,  -1,  21,  81,
+   -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20, -19, -11,
+   -5,  -1,  65,  -1,   4,  64,  -3,  -1,  35,  50,  19,  -3,  -1,  49,   3,
+   -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab15[] =
+ {
+ -495,-445,-355,-263,-183,-115, -77, -43, -27, -13,  -7,  -3,  -1, 255, 239,
+   -1, 254, 223,  -1, 238,  -1, 253, 207,  -7,  -3,  -1, 252, 222,  -1, 237,
+  191,  -1, 251,  -1, 206, 236,  -7,  -3,  -1, 221, 175,  -1, 250, 190,  -3,
+   -1, 235, 205,  -1, 220, 159, -15,  -7,  -3,  -1, 249, 234,  -1, 189, 219,
+   -3,  -1, 143, 248,  -1, 204, 158,  -7,  -3,  -1, 233, 127,  -1, 247, 173,
+   -3,  -1, 218, 188,  -1, 111,  -1, 174,  15, -19, -11,  -3,  -1, 203, 246,
+   -3,  -1, 142, 232,  -1,  95, 157,  -3,  -1, 245, 126,  -1, 231, 172,  -9,
+   -3,  -1, 202, 187,  -3,  -1, 217, 141,  79,  -3,  -1, 244,  63,  -1, 243,
+  216, -33, -17,  -9,  -3,  -1, 230,  47,  -1, 242,  -1, 110, 240,  -3,  -1,
+   31, 241,  -1, 156, 201,  -7,  -3,  -1,  94, 171,  -1, 186, 229,  -3,  -1,
+  125, 215,  -1,  78, 228, -15,  -7,  -3,  -1, 140, 200,  -1,  62, 109,  -3,
+   -1, 214, 227,  -1, 155, 185,  -7,  -3,  -1,  46, 170,  -1, 226,  30,  -5,
+   -1, 225,  -1,  14, 224,  -1,  93, 213, -45, -25, -13,  -7,  -3,  -1, 124,
+  199,  -1,  77, 139,  -1, 212,  -1, 184, 154,  -7,  -3,  -1, 169, 108,  -1,
+  198,  61,  -1, 211, 210,  -9,  -5,  -3,  -1,  45,  13,  29,  -1, 123, 183,
+   -5,  -1, 209,  -1,  92, 208,  -1, 197, 138, -17,  -7,  -3,  -1, 168,  76,
+   -1, 196, 107,  -5,  -1, 182,  -1, 153,  12,  -1,  60, 195,  -9,  -3,  -1,
+  122, 167,  -1, 166,  -1, 192,  11,  -1, 194,  -1,  44,  91, -55, -29, -15,
+   -7,  -3,  -1, 181,  28,  -1, 137, 152,  -3,  -1, 193,  75,  -1, 180, 106,
+   -5,  -3,  -1,  59, 121, 179,  -3,  -1, 151, 136,  -1,  43,  90, -11,  -5,
+   -1, 178,  -1, 165,  27,  -1, 177,  -1, 176, 105,  -7,  -3,  -1, 150,  74,
+   -1, 164, 120,  -3,  -1, 135,  58, 163, -17,  -7,  -3,  -1,  89, 149,  -1,
+   42, 162,  -3,  -1,  26, 161,  -3,  -1,  10, 160, 104,  -7,  -3,  -1, 134,
+   73,  -1, 148,  57,  -5,  -1, 147,  -1, 119,   9,  -1,  88, 133, -53, -29,
+  -13,  -7,  -3,  -1,  41, 103,  -1, 118, 146,  -1, 145,  -1,  25, 144,  -7,
+   -3,  -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  71,  -7,
+   -3,  -1,  40, 130,  -1,  24, 129,  -7,  -3,  -1, 116,   8,  -1, 128,  86,
+   -3,  -1, 101,  55,  -1, 115,  70, -17,  -7,  -3,  -1,  39, 114,  -1, 100,
+   23,  -3,  -1,  85, 113,  -3,  -1,   7, 112,  54,  -7,  -3,  -1,  99,  69,
+   -1,  84,  38,  -3,  -1,  98,  22,  -3,  -1,   6,  96,  53, -33, -19,  -9,
+   -5,  -1,  97,  -1,  83,  68,  -1,  37,  82,  -3,  -1,  21,  81,  -3,  -1,
+    5,  80,  52,  -7,  -3,  -1,  67,  36,  -1,  66,  51,  -1,  65,  -1,  20,
+    4,  -9,  -3,  -1,  35,  50,  -3,  -1,  64,   3,  19,  -3,  -1,  49,  48,
+   34,  -9,  -7,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -3,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab16[] =
+ {
+ -509,-503,-461,-323,-103, -37, -27, -15,  -7,  -3,  -1, 239, 254,  -1, 223,
+  253,  -3,  -1, 207, 252,  -1, 191, 251,  -5,  -1, 175,  -1, 250, 159,  -3,
+   -1, 249, 248, 143,  -7,  -3,  -1, 127, 247,  -1, 111, 246, 255,  -9,  -5,
+   -3,  -1,  95, 245,  79,  -1, 244, 243, -53,  -1, 240,  -1,  63, -29, -19,
+  -13,  -7,  -5,  -1, 206,  -1, 236, 221, 222,  -1, 233,  -1, 234, 217,  -1,
+  238,  -1, 237, 235,  -3,  -1, 190, 205,  -3,  -1, 220, 219, 174, -11,  -5,
+   -1, 204,  -1, 173, 218,  -3,  -1, 126, 172, 202,  -5,  -3,  -1, 201, 125,
+   94, 189, 242, -93,  -5,  -3,  -1,  47,  15,  31,  -1, 241, -49, -25, -13,
+   -5,  -1, 158,  -1, 188, 203,  -3,  -1, 142, 232,  -1, 157, 231,  -7,  -3,
+   -1, 187, 141,  -1, 216, 110,  -1, 230, 156, -13,  -7,  -3,  -1, 171, 186,
+   -1, 229, 215,  -1,  78,  -1, 228, 140,  -3,  -1, 200,  62,  -1, 109,  -1,
+  214, 155, -19, -11,  -5,  -3,  -1, 185, 170, 225,  -1, 212,  -1, 184, 169,
+   -5,  -1, 123,  -1, 183, 208, 227,  -7,  -3,  -1,  14, 224,  -1,  93, 213,
+   -3,  -1, 124, 199,  -1,  77, 139, -75, -45, -27, -13,  -7,  -3,  -1, 154,
+  108,  -1, 198,  61,  -3,  -1,  92, 197,  13,  -7,  -3,  -1, 138, 168,  -1,
+  153,  76,  -3,  -1, 182, 122,  60, -11,  -5,  -3,  -1,  91, 137,  28,  -1,
+  192,  -1, 152, 121,  -1, 226,  -1,  46,  30, -15,  -7,  -3,  -1, 211,  45,
+   -1, 210, 209,  -5,  -1,  59,  -1, 151, 136,  29,  -7,  -3,  -1, 196, 107,
+   -1, 195, 167,  -1,  44,  -1, 194, 181, -23, -13,  -7,  -3,  -1, 193,  12,
+   -1,  75, 180,  -3,  -1, 106, 166, 179,  -5,  -3,  -1,  90, 165,  43,  -1,
+  178,  27, -13,  -5,  -1, 177,  -1,  11, 176,  -3,  -1, 105, 150,  -1,  74,
+  164,  -5,  -3,  -1, 120, 135, 163,  -3,  -1,  58,  89,  42, -97, -57, -33,
+  -19, -11,  -5,  -3,  -1, 149, 104, 161,  -3,  -1, 134, 119, 148,  -5,  -3,
+   -1,  73,  87, 103, 162,  -5,  -1,  26,  -1,  10, 160,  -3,  -1,  57, 147,
+   -1,  88, 133,  -9,  -3,  -1,  41, 146,  -3,  -1, 118,   9,  25,  -5,  -1,
+  145,  -1, 144,  72,  -3,  -1, 132, 117,  -1,  56, 131, -21, -11,  -5,  -3,
+   -1, 102,  40, 130,  -3,  -1,  71, 116,  24,  -3,  -1, 129, 128,  -3,  -1,
+    8,  86,  55,  -9,  -5,  -1, 115,  -1, 101,  70,  -1,  39, 114,  -5,  -3,
+   -1, 100,  85,   7,  23, -23, -13,  -5,  -1, 113,  -1, 112,  54,  -3,  -1,
+   99,  69,  -1,  84,  38,  -3,  -1,  98,  22,  -1,  97,  -1,   6,  96,  -9,
+   -5,  -1,  83,  -1,  53,  68,  -1,  37,  82,  -1,  81,  -1,  21,   5, -33,
+  -23, -13,  -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20,
+   -5,  -1,  65,  -1,   4,  64,  -1,  35,  50,  -3,  -1,  19,  49,  -3,  -1,
+    3,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab24[] =
+ {
+ -451,-117, -43, -25, -15,  -7,  -3,  -1, 239, 254,  -1, 223, 253,  -3,  -1,
+  207, 252,  -1, 191, 251,  -5,  -1, 250,  -1, 175, 159,  -1, 249, 248,  -9,
+   -5,  -3,  -1, 143, 127, 247,  -1, 111, 246,  -3,  -1,  95, 245,  -1,  79,
+  244, -71,  -7,  -3,  -1,  63, 243,  -1,  47, 242,  -5,  -1, 241,  -1,  31,
+  240, -25,  -9,  -1,  15,  -3,  -1, 238, 222,  -1, 237, 206,  -7,  -3,  -1,
+  236, 221,  -1, 190, 235,  -3,  -1, 205, 220,  -1, 174, 234, -15,  -7,  -3,
+   -1, 189, 219,  -1, 204, 158,  -3,  -1, 233, 173,  -1, 218, 188,  -7,  -3,
+   -1, 203, 142,  -1, 232, 157,  -3,  -1, 217, 126,  -1, 231, 172, 255,-235,
+ -143, -77, -45, -25, -15,  -7,  -3,  -1, 202, 187,  -1, 141, 216,  -5,  -3,
+   -1,  14, 224,  13, 230,  -5,  -3,  -1, 110, 156, 201,  -1,  94, 186,  -9,
+   -5,  -1, 229,  -1, 171, 125,  -1, 215, 228,  -3,  -1, 140, 200,  -3,  -1,
+   78,  46,  62, -15,  -7,  -3,  -1, 109, 214,  -1, 227, 155,  -3,  -1, 185,
+  170,  -1, 226,  30,  -7,  -3,  -1, 225,  93,  -1, 213, 124,  -3,  -1, 199,
+   77,  -1, 139, 184, -31, -15,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -3,
+   -1, 198,  61,  -1, 211,  45,  -7,  -3,  -1, 210,  29,  -1, 123, 183,  -3,
+   -1, 209,  92,  -1, 197, 138, -17,  -7,  -3,  -1, 168, 153,  -1,  76, 196,
+   -3,  -1, 107, 182,  -3,  -1, 208,  12,  60,  -7,  -3,  -1, 195, 122,  -1,
+  167,  44,  -3,  -1, 194,  91,  -1, 181,  28, -57, -35, -19,  -7,  -3,  -1,
+  137, 152,  -1, 193,  75,  -5,  -3,  -1, 192,  11,  59,  -3,  -1, 176,  10,
+   26,  -5,  -1, 180,  -1, 106, 166,  -3,  -1, 121, 151,  -3,  -1, 160,   9,
+  144,  -9,  -3,  -1, 179, 136,  -3,  -1,  43,  90, 178,  -7,  -3,  -1, 165,
+   27,  -1, 177, 105,  -1, 150, 164, -17,  -9,  -5,  -3,  -1,  74, 120, 135,
+   -1,  58, 163,  -3,  -1,  89, 149,  -1,  42, 162,  -7,  -3,  -1, 161, 104,
+   -1, 134, 119,  -3,  -1,  73, 148,  -1,  57, 147, -63, -31, -15,  -7,  -3,
+   -1,  88, 133,  -1,  41, 103,  -3,  -1, 118, 146,  -1,  25, 145,  -7,  -3,
+   -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  40, -17,  -7,
+   -3,  -1, 130,  24,  -1,  71, 116,  -5,  -1, 129,  -1,   8, 128,  -1,  86,
+  101,  -7,  -5,  -1,  23,  -1,   7, 112, 115,  -3,  -1,  55,  39, 114, -15,
+   -7,  -3,  -1,  70, 100,  -1,  85, 113,  -3,  -1,  54,  99,  -1,  69,  84,
+   -7,  -3,  -1,  38,  98,  -1,  22,  97,  -5,  -3,  -1,   6,  96,  53,  -1,
+   83,  68, -51, -37, -23, -15,  -9,  -3,  -1,  37,  82,  -1,  21,  -1,   5,
+   80,  -1,  81,  -1,  52,  67,  -3,  -1,  36,  66,  -1,  51,  20,  -9,  -5,
+   -1,  65,  -1,   4,  64,  -1,  35,  50,  -1,  19,  49,  -7,  -5,  -3,  -1,
+    3,  48,  34,  18,  -1,  33,  -1,   2,  32,  -3,  -1,  17,   1,  -1,  16,
+    0
+ };
+ 
+ static short tab_c0[] =
+ {
+  -29, -21, -13,  -7,  -3,  -1,  11,  15,  -1,  13,  14,  -3,  -1,   7,   5,
+    9,  -3,  -1,   6,   3,  -1,  10,  12,  -3,  -1,   2,   1,  -1,   4,   8,
+    0
+ };
+ 
+ static short tab_c1[] =
+ {
+  -15,  -7,  -3,  -1,  15,  14,  -1,  13,  12,  -3,  -1,  11,  10,  -1,   9,
+    8,  -7,  -3,  -1,   7,   6,  -1,   5,   4,  -3,  -1,   3,   2,  -1,   1,
+    0
+ };
+ 
+ 
+ 
+ static struct newhuff ht[] = 
+ {
+  { /* 0 */ 0 , tab0  } ,
+  { /* 2 */ 0 , tab1  } ,
+  { /* 3 */ 0 , tab2  } ,
+  { /* 3 */ 0 , tab3  } ,
+  { /* 0 */ 0 , tab0  } ,
+  { /* 4 */ 0 , tab5  } ,
+  { /* 4 */ 0 , tab6  } ,
+  { /* 6 */ 0 , tab7  } ,
+  { /* 6 */ 0 , tab8  } ,
+  { /* 6 */ 0 , tab9  } ,
+  { /* 8 */ 0 , tab10 } ,
+  { /* 8 */ 0 , tab11 } ,
+  { /* 8 */ 0 , tab12 } ,
+  { /* 16 */ 0 , tab13 } ,
+  { /* 0  */ 0 , tab0  } ,
+  { /* 16 */ 0 , tab15 } ,
+ 
+  { /* 16 */ 1 , tab16 } ,
+  { /* 16 */ 2 , tab16 } ,
+  { /* 16 */ 3 , tab16 } ,
+  { /* 16 */ 4 , tab16 } ,
+  { /* 16 */ 6 , tab16 } ,
+  { /* 16 */ 8 , tab16 } ,
+  { /* 16 */ 10, tab16 } ,
+  { /* 16 */ 13, tab16 } ,
+  { /* 16 */ 4 , tab24 } ,
+  { /* 16 */ 5 , tab24 } ,
+  { /* 16 */ 6 , tab24 } ,
+  { /* 16 */ 7 , tab24 } ,
+  { /* 16 */ 8 , tab24 } ,
+  { /* 16 */ 9 , tab24 } ,
+  { /* 16 */ 11, tab24 } ,
+  { /* 16 */ 13, tab24 }
+ };
+ 
+ static struct newhuff htc[] = 
+ {
+  { /* 1 , 1 , */ 0 , tab_c0 } ,
+  { /* 1 , 1 , */ 0 , tab_c1 }
+ };
+ 
+ 
diff -r -c -N encoder/mpglib/interface.c lame3.13/mpglib/interface.c
*** encoder/mpglib/interface.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/interface.c	Sun Apr 25 22:14:06 1999
***************
*** 0 ****
--- 1,219 ----
+ #ifdef HAVEGTK
+ #include <stdlib.h>
+ #include <stdio.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ 
+ /* Global mp .. it's a hack */
+ struct mpstr *gmp;
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp) 
+ {
+ 	memset(mp,0,sizeof(struct mpstr));
+ 
+ 	mp->framesize = 0;
+ 	mp->fsizeold = -1;
+ 	mp->bsize = 0;
+ 	mp->head = mp->tail = NULL;
+ 	mp->fr.single = -1;
+ 	mp->bsnum = 0;
+ 	mp->synth_bo = 1;
+ 
+ 	make_decode_tables(32767);
+ 	init_layer3(SBLIMIT);
+ 
+ 	return !0;
+ }
+ 
+ void ExitMP3(struct mpstr *mp)
+ {
+ 	struct buf *b,*bn;
+ 	
+ 	b = mp->tail;
+ 	while(b) {
+ 		free(b->pnt);
+ 		bn = b->next;
+ 		free(b);
+ 		b = bn;
+ 	}
+ }
+ 
+ static struct buf *addbuf(struct mpstr *mp,char *buf,int size)
+ {
+ 	struct buf *nbuf;
+ 
+ 	nbuf = malloc( sizeof(struct buf) );
+ 	if(!nbuf) {
+ 		fprintf(stderr,"Out of memory!\n");
+ 		return NULL;
+ 	}
+ 	nbuf->pnt = malloc(size);
+ 	if(!nbuf->pnt) {
+ 		free(nbuf);
+ 		return NULL;
+ 	}
+ 	nbuf->size = size;
+ 	memcpy(nbuf->pnt,buf,size);
+ 	nbuf->next = NULL;
+ 	nbuf->prev = mp->head;
+ 	nbuf->pos = 0;
+ 
+ 	if(!mp->tail) {
+ 		mp->tail = nbuf;
+ 	}
+ 	else {
+ 	  mp->head->next = nbuf;
+ 	}
+ 
+ 	mp->head = nbuf;
+ 	mp->bsize += size;
+ 
+ 	return nbuf;
+ }
+ 
+ static void remove_buf(struct mpstr *mp)
+ {
+   struct buf *buf = mp->tail;
+   
+   mp->tail = buf->next;
+   if(mp->tail)
+     mp->tail->prev = NULL;
+   else {
+     mp->tail = mp->head = NULL;
+   }
+   
+   free(buf->pnt);
+   free(buf);
+ 
+ }
+ 
+ static int read_buf_byte(struct mpstr *mp)
+ {
+ 	unsigned int b;
+ 
+ 	int pos;
+ 
+ 	pos = mp->tail->pos;
+ 	while(pos >= mp->tail->size) {
+ 		remove_buf(mp);
+ 		pos = mp->tail->pos;
+ 		if(!mp->tail) {
+ 			fprintf(stderr,"Fatal error!\n");
+ 			exit(1);
+ 		}
+ 	}
+ 
+ 	b = mp->tail->pnt[pos];
+ 	mp->bsize--;
+ 	mp->tail->pos++;
+ 	
+ 
+ 	return b;
+ }
+ 
+ static void read_head(struct mpstr *mp)
+ {
+ 	unsigned long head;
+ 
+ 	head = read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 
+ 	mp->header = head;
+ }
+ 
+ int decodeMP3(struct mpstr *mp,char *in,int isize,char *out,
+ 		int osize,int *done)
+ {
+ 	int len;
+ 
+ 	gmp = mp;
+ 
+ 	if(osize < 4608) {
+ 		fprintf(stderr,"To less out space\n");
+ 		return MP3_ERR;
+ 	}
+ 
+ 	if(in) {
+ 		if(addbuf(mp,in,isize) == NULL) {
+ 			return MP3_ERR;
+ 		}
+ 	}
+ 
+ 
+ 	/* First decode header */
+ 	if(mp->framesize == 0) {
+ 		if(mp->bsize < 4) {
+ 			return MP3_NEED_MORE;
+ 		}
+ 		read_head(mp);
+ 		decode_header(&mp->fr,mp->header);
+ 		mp->framesize = mp->fr.framesize;
+ 	}
+ 
+ 	/*	  printf(" fr.framesize = %i \n",mp->fr.framesize);
+ 		  printf(" bsize        = %i \n",mp->bsize);
+ 	*/
+ 
+ 	if(mp->fr.framesize > mp->bsize) {
+ 	  return MP3_NEED_MORE;
+ 	}
+ 	wordpointer = mp->bsspace[mp->bsnum] + 512;
+ 	mp->bsnum = (mp->bsnum + 1) & 0x1;
+ 	bitindex = 0;
+ 
+ 	len = 0;
+ 	while(len < mp->framesize) {
+ 		int nlen;
+ 		int blen = mp->tail->size - mp->tail->pos;
+ 		if( (mp->framesize - len) <= blen) {
+                   nlen = mp->framesize-len;
+ 		}
+ 		else {
+                   nlen = blen;
+                 }
+ 		memcpy(wordpointer+len,mp->tail->pnt+mp->tail->pos,nlen);
+                 len += nlen;
+                 mp->tail->pos += nlen;
+ 		mp->bsize -= nlen;
+                 if(mp->tail->pos == mp->tail->size) {
+                    remove_buf(mp);
+                 }
+ 	}
+ 
+ 	*done = 0;
+ 	if(mp->fr.error_protection)
+            getbits(16);
+ 	do_layer3(&mp->fr,(unsigned char *) out,done);
+ 
+ 	mp->fsizeold = mp->framesize;
+ 	mp->framesize = 0;
+ 	return MP3_OK;
+ }
+ 
+ int set_pointer(long backstep)
+ {
+   unsigned char *bsbufold;
+   if(gmp->fsizeold < 0 && backstep > 0) {
+     fprintf(stderr,"Can't step back %ld!\n",backstep);
+     return MP3_ERR; 
+   }
+   bsbufold = gmp->bsspace[gmp->bsnum] + 512;
+   wordpointer -= backstep;
+   if (backstep)
+     memcpy(wordpointer,bsbufold+gmp->fsizeold-backstep,backstep);
+   bitindex = 0;
+   return MP3_OK;
+ }
+ 
+ #endif
+ 
+ 
+ 
diff -r -c -N encoder/mpglib/layer3.c lame3.13/mpglib/layer3.c
*** encoder/mpglib/layer3.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/layer3.c	Tue Jun 22 01:39:00 1999
***************
*** 0 ****
--- 1,2088 ----
+ #ifdef HAVEGTK
+ /* 
+  * Mpeg Layer-3 audio decoder 
+  * --------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp.
+  * All rights reserved. See also 'README'
+  */ 
+ 
+ #include <stdlib.h>
+ #include "mpg123.h"
+ #include "mpglib.h"
+ #include "huffman.h"
+ #include "../gtkanal.h"
+ 
+ 
+ extern struct mpstr *gmp;
+ 
+ #define MPEG1
+ 
+ 
+ static real ispow[8207];
+ static real aa_ca[8],aa_cs[8];
+ static real COS1[12][6];
+ static real win[4][36];
+ static real win1[4][36];
+ static real gainpow2[256+118+4];
+ static real COS9[9];
+ static real COS6_1,COS6_2;
+ static real tfcos36[9];
+ static real tfcos12[3];
+ 
+ struct bandInfoStruct {
+   short longIdx[23];
+   short longDiff[22];
+   short shortIdx[14];
+   short shortDiff[13];
+ };
+ 
+ int longLimit[9][23];
+ int shortLimit[9][14];
+ 
+ struct bandInfoStruct bandInfo[9] = { 
+ 
+ /* MPEG 1.0 */
+  { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
+    {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
+    {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
+    {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
+    {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
+    {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
+    {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
+    {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,
+ 
+ /* MPEG 2.0 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
+    {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
+    {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,
+ 
+  { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
+    {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
+    {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,
+ 
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,
+ /* MPEG 2.5 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
+    {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
+    {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
+    {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
+ };
+ 
+ static int mapbuf0[9][152];
+ static int mapbuf1[9][156];
+ static int mapbuf2[9][44];
+ static int *map[9][3];
+ static int *mapend[9][3];
+ 
+ static unsigned int n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
+ static unsigned int i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */
+ 
+ static real tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
+ static real pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
+ 
+ static unsigned int get1bit(void)
+ {
+   unsigned char rval;
+   rval = *wordpointer << bitindex;
+ 
+   bitindex++;
+   wordpointer += (bitindex>>3);
+   bitindex &= 7;
+ 
+   return rval>>7;
+ }
+ 
+ 
+ 
+ 
+ /* 
+  * init tables for layer-3 
+  */
+ void init_layer3(int down_sample_sblimit)
+ {
+   int i,j,k,l;
+ 
+   for(i=-256;i<118+4;i++)
+     gainpow2[i+256] = pow((double)2.0,-0.25 * (double) (i+210) );
+ 
+   for(i=0;i<8207;i++)
+     ispow[i] = pow((double)i,(double)4.0/3.0);
+ 
+   for (i=0;i<8;i++)
+   {
+     static double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};
+     double sq=sqrt(1.0+Ci[i]*Ci[i]);
+     aa_cs[i] = 1.0/sq;
+     aa_ca[i] = Ci[i]/sq;
+   }
+ 
+   for(i=0;i<18;i++)
+   {
+     win[0][i]    = win[1][i]    = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+0) +1) ) / cos ( M_PI * (double) (2*(i+0) +19) / 72.0 );
+     win[0][i+18] = win[3][i+18] = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+18)+1) ) / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+   }
+   for(i=0;i<6;i++)
+   {
+     win[1][i+18] = 0.5 / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+     win[3][i+12] = 0.5 / cos ( M_PI * (double) (2*(i+12)+19) / 72.0 );
+     win[1][i+24] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+13) ) / cos ( M_PI * (double) (2*(i+24)+19) / 72.0 );
+     win[1][i+30] = win[3][i] = 0.0;
+     win[3][i+6 ] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) )  / cos ( M_PI * (double) (2*(i+6 )+19) / 72.0 );
+   }
+ 
+   for(i=0;i<9;i++)
+     COS9[i] = cos( M_PI / 18.0 * (double) i);
+ 
+   for(i=0;i<9;i++)
+     tfcos36[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 36.0 );
+   for(i=0;i<3;i++)
+     tfcos12[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 12.0 );
+ 
+   COS6_1 = cos( M_PI / 6.0 * (double) 1);
+   COS6_2 = cos( M_PI / 6.0 * (double) 2);
+ 
+   for(i=0;i<12;i++)
+   {
+     win[2][i]  = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) ) / cos ( M_PI * (double) (2*i+7) / 24.0 );
+     for(j=0;j<6;j++)
+       COS1[i][j] = cos( M_PI / 24.0 * (double) ((2*i+7)*(2*j+1)) );
+   }
+ 
+   for(j=0;j<4;j++) {
+     static int len[4] = { 36,36,12,36 };
+     for(i=0;i<len[j];i+=2)
+       win1[j][i] = + win[j][i];
+     for(i=1;i<len[j];i+=2)
+       win1[j][i] = - win[j][i];
+   }
+ 
+   for(i=0;i<16;i++)
+   {
+     double t = tan( (double) i * M_PI / 12.0 );
+     tan1_1[i] = t / (1.0+t);
+     tan2_1[i] = 1.0 / (1.0 + t);
+     tan1_2[i] = M_SQRT2 * t / (1.0+t);
+     tan2_2[i] = M_SQRT2 / (1.0 + t);
+ 
+     for(j=0;j<2;j++) {
+       double base = pow(2.0,-0.25*(j+1.0));
+       double p1=1.0,p2=1.0;
+       if(i > 0) {
+         if( i & 1 )
+           p1 = pow(base,(i+1.0)*0.5);
+         else
+           p2 = pow(base,i*0.5);
+       }
+       pow1_1[j][i] = p1;
+       pow2_1[j][i] = p2;
+       pow1_2[j][i] = M_SQRT2 * p1;
+       pow2_2[j][i] = M_SQRT2 * p2;
+     }
+   }
+ 
+   for(j=0;j<9;j++)
+   {
+    struct bandInfoStruct *bi = &bandInfo[j];
+    int *mp;
+    int cb,lwin;
+    short *bdf;
+ 
+    mp = map[j][0] = mapbuf0[j];
+    bdf = bi->longDiff;
+    for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
+      *mp++ = (*bdf) >> 1;
+      *mp++ = i;
+      *mp++ = 3;
+      *mp++ = cb;
+    }
+    bdf = bi->shortDiff+3;
+    for(cb=3;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][0] = mp;
+ 
+    mp = map[j][1] = mapbuf1[j];
+    bdf = bi->shortDiff+0;
+    for(i=0,cb=0;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][1] = mp;
+ 
+    mp = map[j][2] = mapbuf2[j];
+    bdf = bi->longDiff;
+    for(cb = 0; cb < 22 ; cb++) {
+      *mp++ = (*bdf++) >> 1;
+      *mp++ = cb;
+    }
+    mapend[j][2] = mp;
+ 
+   }
+ 
+   for(j=0;j<9;j++) {
+     for(i=0;i<23;i++) {
+       longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
+       if(longLimit[j][i] > (down_sample_sblimit) )
+         longLimit[j][i] = down_sample_sblimit;
+     }
+     for(i=0;i<14;i++) {
+       shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
+       if(shortLimit[j][i] > (down_sample_sblimit) )
+         shortLimit[j][i] = down_sample_sblimit;
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<6;j++) {
+       for(k=0;k<6;k++) {
+         int n = k + j * 6 + i * 36;
+         i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<4;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 16;
+         i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<3;j++) {
+       int n = j + i * 3;
+       i_slen2[n+244] = i|(j<<3) | (5<<12);
+       n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         for(l=0;l<4;l++) {
+           int n = l + k * 4 + j * 16 + i * 80;
+           n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
+         }
+       }
+     }
+   }
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 20;
+         n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
+       }
+     }
+   }
+ }
+ 
+ /*
+  * read additional side information
+  */
+ #ifdef MPEG1 
+ static void III_get_side_info_1(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch, gr;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(9);
+    if (stereo == 1)
+      si->private_bits = getbits_fast(5);
+    else 
+      si->private_bits = getbits_fast(3);
+ 
+    for (ch=0; ch<stereo; ch++) {
+        si->ch[ch].gr[0].scfsi = -1;
+        si->ch[ch].gr[1].scfsi = getbits_fast(4);
+    }
+ 
+    for (gr=0; gr<2; gr++) 
+    {
+      for (ch=0; ch<stereo; ch++) 
+      {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+           fprintf(stderr,"big_values too large!\n");
+           gr_info->big_values = 288;
+        }
+        {
+ 	 unsigned int qss = getbits_fast(8);
+ 	 gr_info->pow2gain = gainpow2+256 - qss + powdiff;
+ #ifdef HAVEGTK
+ 	 pinfo->qss[gr][ch]=qss;
+ #endif
+        }
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits_fast(4);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+ 
+ 
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+ 	   unsigned int sbg = (getbits_fast(3)<<3);
+            gr_info->full_gain[i] = gr_info->pow2gain + sbg;
+ #ifdef HAVEGTK
+ 	   pinfo->sub_gain[gr][ch][i]=sbg/8;
+ #endif
+ 	 }
+ 
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+          gr_info->region1start = 36>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->preflag = get1bit();
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        pinfo->scalefac_scale[gr][ch]=gr_info->scalefac_scale;
+ #endif
+      }
+    }
+ }
+ #endif
+ 
+ /*
+  * Side Info for MPEG 2.0 / LSF
+  */
+ static void III_get_side_info_2(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(8);
+    if (stereo == 1)
+      si->private_bits = get1bit();
+    else 
+      si->private_bits = getbits_fast(2);
+ 
+    for (ch=0; ch<stereo; ch++) 
+    {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[0]);
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+          fprintf(stderr,"big_values too large!\n");
+          gr_info->big_values = 288;
+        }
+        gr_info->pow2gain = gainpow2+256 - getbits_fast(8) + powdiff;
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits(9);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+            gr_info->full_gain[i] = gr_info->pow2gain + (getbits_fast(3)<<3);
+ 	 }
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+ /* check this again! */
+          if(gr_info->block_type == 2)
+            gr_info->region1start = 36>>1;
+          else if(sfreq == 8)
+ /* check this for 2.5 and sfreq=8 */
+            gr_info->region1start = 108>>1;
+          else
+            gr_info->region1start = 54>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        pinfo->scalefac_scale[0][ch]=gr_info->scalefac_scale;
+ #endif
+    }
+ }
+ 
+ /*
+  * read scalefactors
+  */
+ #ifdef MPEG1
+ static int III_get_scale_factors_1(int *scf,struct gr_info_s *gr_info)
+ {
+    static unsigned char slen[2][16] = {
+      {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
+      {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
+    };
+    int numbits;
+    int num0 = slen[0][gr_info->scalefac_compress];
+    int num1 = slen[1][gr_info->scalefac_compress];
+ 
+     if (gr_info->block_type == 2) 
+     {
+       int i=18;
+       numbits = (num0 + num1) * 18;
+ 
+       if (gr_info->mixed_block_flag) {
+          for (i=8;i;i--)
+            *scf++ = getbits_fast(num0);
+          i = 9;
+          numbits -= num0; /* num0 * 17 + num1 * 18 */
+       }
+ 
+       for (;i;i--)
+         *scf++ = getbits_fast(num0);
+       for (i = 18; i; i--)
+         *scf++ = getbits_fast(num1);
+       *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
+     }
+     else 
+     {
+       int i;
+       int scfsi = gr_info->scfsi;
+ 
+       if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
+          for(i=11;i;i--)
+            *scf++ = getbits_fast(num0);
+          for(i=10;i;i--)
+            *scf++ = getbits_fast(num1);
+          numbits = (num0 + num1) * 10 + num0;
+       }
+       else {
+         numbits = 0;
+         if(!(scfsi & 0x8)) {
+           for (i=6;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 6;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x4)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x2)) {
+           for(i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x1)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+       }
+ 
+       *scf++ = 0;  /* no l[21] in original sources */
+     }
+     return numbits;
+ }
+ #endif
+ 
+ static int III_get_scale_factors_2(int *scf,struct gr_info_s *gr_info,int i_stereo)
+ {
+   unsigned char *pnt;
+   int i,j;
+   unsigned int slen;
+   int n = 0;
+   int numbits = 0;
+ 
+   static unsigned char stab[3][6][4] = {
+    { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
+      { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
+    { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
+      {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
+    { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
+      { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } }; 
+ 
+   if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
+     slen = i_slen2[gr_info->scalefac_compress>>1];
+   else
+     slen = n_slen2[gr_info->scalefac_compress];
+ 
+   gr_info->preflag = (slen>>15) & 0x1;
+ 
+   n = 0;  
+   if( gr_info->block_type == 2 ) {
+     n++;
+     if(gr_info->mixed_block_flag)
+       n++;
+   }
+ 
+   pnt = stab[n][(slen>>12)&0x7];
+ 
+   for(i=0;i<4;i++) {
+     int num = slen & 0x7;
+     slen >>= 3;
+     if(num) {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = getbits_fast(num);
+       numbits += pnt[i] * num;
+     }
+     else {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = 0;
+     }
+   }
+   
+   n = (n << 1) + 1;
+   for(i=0;i<n;i++)
+     *scf++ = 0;
+ 
+   return numbits;
+ }
+ 
+ static int pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
+ static int pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+ 
+ /*
+  * don't forget to apply the same changes to III_dequantize_sample_ms() !!! 
+  */
+ static int III_dequantize_sample(real xr[SBLIMIT][SSLIMIT],int *scf,
+    struct gr_info_s *gr_info,int sfreq,int part2bits)
+ {
+   int shift = 1 + gr_info->scalefac_scale;
+   real *xrpnt = (real *) xr;
+   int l[3],l3;
+   int part2remain = gr_info->part2_3_length - part2bits;
+   int *me;
+ 
+   {
+     int bv       = gr_info->big_values;
+     int region1  = gr_info->region1start;
+     int region2  = gr_info->region2start;
+ 
+     l3 = ((576>>1)-bv)>>1;   
+ /*
+  * we may lose the 'odd' bit here !! 
+  * check this later again 
+  */
+     if(bv <= region1) {
+       l[0] = bv; l[1] = 0; l[2] = 0;
+     }
+     else {
+       l[0] = region1;
+       if(bv <= region2) {
+         l[1] = bv - l[0];  l[2] = 0;
+       }
+       else {
+         l[1] = region2 - l[0]; l[2] = bv - region2;
+       }
+     }
+   }
+  
+   if(gr_info->block_type == 2) {
+     /*
+      * decoding with short or mixed mode BandIndex table 
+      */
+     int i,max[4];
+     int step=0,lwin=0,cb=0;
+     register real v = 0.0;
+     register int *m,mc;
+ 
+     if(gr_info->mixed_block_flag) {
+       max[3] = -1;
+       max[0] = max[1] = max[2] = 2;
+       m = map[sfreq][0];
+       me = mapend[sfreq][0];
+     }
+     else {
+       max[0] = max[1] = max[2] = max[3] = -1;
+       /* max[3] not really needed in this case */
+       m = map[sfreq][1];
+       me = mapend[sfreq][1];
+     }
+ 
+     mc = 0;
+     for(i=0;i<2;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+       for(;lp;lp--,mc--) {
+         register int x,y;
+         if( (!mc) ) {
+           mc = *m++;
+           xrpnt = ((real *) xr) + (*m++);
+           lwin = *m++;
+           cb = *m++;
+           if(lwin == 3) {
+             v = gr_info->pow2gain[(*scf++) << shift];
+             step = 1;
+           }
+           else {
+             v = gr_info->full_gain[lwin][(*scf++) << shift];
+             step = 3;
+           }
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if(x == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+         }
+         else if(x) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+         if(y == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+         }
+         else if(y) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+ 
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             xrpnt = ((real *) xr) + (*m++);
+             lwin = *m++;
+             cb = *m++;
+             if(lwin == 3) {
+               v = gr_info->pow2gain[(*scf++) << shift];
+               step = 1;
+             }
+             else {
+               v = gr_info->full_gain[lwin][(*scf++) << shift];
+               step = 3;
+             }
+           }
+           mc--;
+         }
+         if( (a & (0x8>>i)) ) {
+           max[lwin] = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit()) 
+             *xrpnt = -v;
+           else
+             *xrpnt = v;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+  
+     while( m < me ) {
+       if(!mc) {
+         mc = *m++;
+         xrpnt = ((real *) xr) + *m++;
+         if( (*m++) == 3)
+           step = 1;
+         else
+           step = 3;
+         m++; /* cb */
+       }
+       mc--;
+       *xrpnt = 0.0;
+       xrpnt += step;
+       *xrpnt = 0.0;
+       xrpnt += step;
+ /* we could add a little opt. here:
+  * if we finished a band for window 3 or a long band
+  * further bands could copied in a simple loop without a
+  * special 'map' decoding
+  */
+     }
+ 
+     gr_info->maxband[0] = max[0]+1;
+     gr_info->maxband[1] = max[1]+1;
+     gr_info->maxband[2] = max[2]+1;
+     gr_info->maxbandl = max[3]+1;
+ 
+     {
+       int rmax = max[0] > max[1] ? max[0] : max[1];
+       rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+       gr_info->maxb = rmax ? shortLimit[sfreq][rmax] : longLimit[sfreq][max[3]+1];
+     }
+ 
+   }
+   else {
+ 	/*
+      * decoding with 'long' BandIndex table (block_type != 2)
+      */
+     int *pretab = gr_info->preflag ? pretab1 : pretab2;
+     int i,max = -1;
+     int cb = 0;
+     register int *m = map[sfreq][2];
+     register real v = 0.0;
+     register int mc = 0;
+ #if 0
+     me = mapend[sfreq][2];
+ #endif
+ 
+ 	/*
+      * long hash table values
+      */
+     for(i=0;i<3;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+ 
+       for(;lp;lp--,mc--) {
+         int x,y;
+ 
+         if(!mc) {
+           mc = *m++;
+           v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           cb = *m++;
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if (x == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+         }
+         else if(x) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+ 
+         if (y == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+         }
+         else if(y) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/*
+      * short (count1table) values
+      */
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+ 
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             cb = *m++;
+             v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           }
+           mc--;
+         }
+         if ( (a & (0x8>>i)) ) {
+           max = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit())
+             *xrpnt++ = -v;
+           else
+             *xrpnt++ = v;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/* 
+      * zero part
+      */
+     for(i=(&xr[SBLIMIT][0]-xrpnt)>>1;i;i--) {
+       *xrpnt++ = 0.0;
+       *xrpnt++ = 0.0;
+     }
+ 
+     gr_info->maxbandl = max+1;
+     gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+   }
+ 
+   while( part2remain > 16 ) {
+     getbits(16); /* Dismiss stuffing Bits */
+     part2remain -= 16;
+   }
+   if(part2remain > 0)
+     getbits(part2remain);
+   else if(part2remain < 0) {
+     fprintf(stderr,"mpg123: Can't rewind stream by %d bits!\n",-part2remain);
+     return 1; /* -> error */
+   }
+   return 0;
+ }
+ 
+ #if 0
+ static int III_dequantize_sample_ms(real xr[2][SBLIMIT][SSLIMIT],int *scf,
+    struct gr_info_s *gr_info,int sfreq,int part2bits)
+ {
+   int shift = 1 + gr_info->scalefac_scale;
+   real *xrpnt = (real *) xr[1];
+   real *xr0pnt = (real *) xr[0];
+   int l[3],l3;
+   int part2remain = gr_info->part2_3_length - part2bits;
+   int *me;
+ 
+   {
+     int bv       = gr_info->big_values;
+     int region1  = gr_info->region1start;
+     int region2  = gr_info->region2start;
+ 
+     l3 = ((576>>1)-bv)>>1;   
+ /*
+  * we may lose the 'odd' bit here !! 
+  * check this later gain 
+  */
+     if(bv <= region1) {
+       l[0] = bv; l[1] = 0; l[2] = 0;
+     }
+     else {
+       l[0] = region1;
+       if(bv <= region2) {
+         l[1] = bv - l[0];  l[2] = 0;
+       }
+       else {
+         l[1] = region2 - l[0]; l[2] = bv - region2;
+       }
+     }
+   }
+  
+   if(gr_info->block_type == 2) {
+     int i,max[4];
+     int step=0,lwin=0,cb=0;
+     register real v = 0.0;
+     register int *m,mc = 0;
+ 
+     if(gr_info->mixed_block_flag) {
+       max[3] = -1;
+       max[0] = max[1] = max[2] = 2;
+       m = map[sfreq][0];
+       me = mapend[sfreq][0];
+     }
+     else {
+       max[0] = max[1] = max[2] = max[3] = -1;
+       /* max[3] not really needed in this case */
+       m = map[sfreq][1];
+       me = mapend[sfreq][1];
+     }
+ 
+     for(i=0;i<2;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+       for(;lp;lp--,mc--) {
+         int x,y;
+ 
+         if(!mc) {
+           mc = *m++;
+           xrpnt = ((real *) xr[1]) + *m;
+           xr0pnt = ((real *) xr[0]) + *m++;
+           lwin = *m++;
+           cb = *m++;
+           if(lwin == 3) {
+             v = gr_info->pow2gain[(*scf++) << shift];
+             step = 1;
+           }
+           else {
+             v = gr_info->full_gain[lwin][(*scf++) << shift];
+             step = 3;
+           }
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if(x == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit()) {
+             real a = ispow[x] * v;
+             *xrpnt = *xr0pnt + a;
+             *xr0pnt -= a;
+           }
+           else {
+             real a = ispow[x] * v;
+             *xrpnt = *xr0pnt - a;
+             *xr0pnt += a;
+           }
+         }
+         else if(x) {
+           max[lwin] = cb;
+           if(get1bit()) {
+             real a = ispow[x] * v;
+             *xrpnt = *xr0pnt + a;
+             *xr0pnt -= a;
+           }
+           else {
+             real a = ispow[x] * v;
+             *xrpnt = *xr0pnt - a;
+             *xr0pnt += a;
+           }
+           part2remain--;
+         }
+         else
+           *xrpnt = *xr0pnt;
+         xrpnt += step;
+         xr0pnt += step;
+ 
+         if(y == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit()) {
+             real a = ispow[y] * v;
+             *xrpnt = *xr0pnt + a;
+             *xr0pnt -= a;
+           }
+           else {
+             real a = ispow[y] * v;
+             *xrpnt = *xr0pnt - a;
+             *xr0pnt += a;
+           }
+         }
+         else if(y) {
+           max[lwin] = cb;
+           if(get1bit()) {
+             real a = ispow[y] * v;
+             *xrpnt = *xr0pnt + a;
+             *xr0pnt -= a;
+           }
+           else {
+             real a = ispow[y] * v;
+             *xrpnt = *xr0pnt - a;
+             *xr0pnt += a;
+           }
+           part2remain--;
+         }
+         else
+           *xrpnt = *xr0pnt;
+         xrpnt += step;
+         xr0pnt += step;
+       }
+     }
+ 
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+ 
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             xrpnt = ((real *) xr[1]) + *m;
+             xr0pnt = ((real *) xr[0]) + *m++;
+             lwin = *m++;
+             cb = *m++;
+             if(lwin == 3) {
+               v = gr_info->pow2gain[(*scf++) << shift];
+               step = 1;
+             }
+             else {
+               v = gr_info->full_gain[lwin][(*scf++) << shift];
+               step = 3;
+             }
+           }
+           mc--;
+         }
+         if( (a & (0x8>>i)) ) {
+           max[lwin] = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit()) {
+             *xrpnt = *xr0pnt + v;
+             *xr0pnt -= v;
+           }
+           else {
+             *xrpnt = *xr0pnt - v;
+             *xr0pnt += v;
+           }
+         }
+         else
+           *xrpnt = *xr0pnt;
+         xrpnt += step;
+         xr0pnt += step;
+       }
+     }
+  
+     while( m < me ) {
+       if(!mc) {
+         mc = *m++;
+         xrpnt = ((real *) xr[1]) + *m;
+         xr0pnt = ((real *) xr[0]) + *m++;
+         if(*m++ == 3)
+           step = 1;
+         else
+           step = 3;
+         m++; /* cb */
+       }
+       mc--;
+       *xrpnt = *xr0pnt;
+       xrpnt += step;
+       xr0pnt += step;
+       *xrpnt = *xr0pnt;
+       xrpnt += step;
+       xr0pnt += step;
+ /* we could add a little opt. here:
+  * if we finished a band for window 3 or a long band
+  * further bands could copied in a simple loop without a
+  * special 'map' decoding
+  */
+     }
+ 
+     gr_info->maxband[0] = max[0]+1;
+     gr_info->maxband[1] = max[1]+1;
+     gr_info->maxband[2] = max[2]+1;
+     gr_info->maxbandl = max[3]+1;
+ 
+     {
+       int rmax = max[0] > max[1] ? max[0] : max[1];
+       rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+       gr_info->maxb = rmax ? shortLimit[sfreq][rmax] : longLimit[sfreq][max[3]+1];
+     }
+   }
+   else {
+     int *pretab = gr_info->preflag ? pretab1 : pretab2;
+     int i,max = -1;
+     int cb = 0;
+     register int mc=0,*m = map[sfreq][2];
+     register real v = 0.0;
+ #if 0
+     me = mapend[sfreq][2];
+ #endif
+ 
+     for(i=0;i<3;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+ 
+       for(;lp;lp--,mc--) {
+         int x,y;
+         if(!mc) {
+           mc = *m++;
+           cb = *m++;
+           v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if (x == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit()) {
+             real a = ispow[x] * v;
+             *xrpnt++ = *xr0pnt + a;
+             *xr0pnt++ -= a;
+           }
+           else {
+             real a = ispow[x] * v;
+             *xrpnt++ = *xr0pnt - a;
+             *xr0pnt++ += a;
+           }
+         }
+         else if(x) {
+           max = cb;
+           if(get1bit()) {
+             real a = ispow[x] * v;
+             *xrpnt++ = *xr0pnt + a;
+             *xr0pnt++ -= a;
+           }
+           else {
+             real a = ispow[x] * v;
+             *xrpnt++ = *xr0pnt - a;
+             *xr0pnt++ += a;
+           }
+           part2remain--;
+         }
+         else
+           *xrpnt++ = *xr0pnt++;
+ 
+         if (y == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit()) {
+             real a = ispow[y] * v;
+             *xrpnt++ = *xr0pnt + a;
+             *xr0pnt++ -= a;
+           }
+           else {
+             real a = ispow[y] * v;
+             *xrpnt++ = *xr0pnt - a;
+             *xr0pnt++ += a;
+           }
+         }
+         else if(y) {
+           max = cb;
+           if(get1bit()) {
+             real a = ispow[y] * v;
+             *xrpnt++ = *xr0pnt + a;
+             *xr0pnt++ -= a;
+           }
+           else {
+             real a = ispow[y] * v;
+             *xrpnt++ = *xr0pnt - a;
+             *xr0pnt++ += a;
+           }
+           part2remain--;
+         }
+         else
+           *xrpnt++ = *xr0pnt++;
+       }
+     }
+ 
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+ 
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             cb = *m++;
+             v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           }
+           mc--;
+         }
+         if ( (a & (0x8>>i)) ) {
+           max = cb;
+           part2remain--;
+           if(part2remain <= 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit()) {
+             *xrpnt++ = *xr0pnt + v;
+             *xr0pnt++ -= v;
+           }
+           else {
+             *xrpnt++ = *xr0pnt - v;
+             *xr0pnt++ += v;
+           }
+         }
+         else
+           *xrpnt++ = *xr0pnt++;
+       }
+     }
+     for(i=(&xr[1][SBLIMIT][0]-xrpnt)>>1;i;i--) {
+       *xrpnt++ = *xr0pnt++;
+       *xrpnt++ = *xr0pnt++;
+     }
+ 
+     gr_info->maxbandl = max+1;
+     gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+   }
+ 
+   while ( part2remain > 16 ) {
+     getbits(16); /* Dismiss stuffing Bits */
+     part2remain -= 16;
+   }
+   if(part2remain > 0 )
+     getbits(part2remain);
+   else if(part2remain < 0) {
+     fprintf(stderr,"mpg123_ms: Can't rewind stream by %d bits!\n",-part2remain);
+     return 1; /* -> error */
+   }
+   return 0;
+ }
+ #endif
+ 
+ /* 
+  * III_stereo: calculate real channel values for Joint-I-Stereo-mode
+  */
+ static void III_i_stereo(real xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
+    struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
+ {
+       real (*xr)[SBLIMIT*SSLIMIT] = (real (*)[SBLIMIT*SSLIMIT] ) xr_buf;
+       struct bandInfoStruct *bi = &bandInfo[sfreq];
+       real *tab1,*tab2;
+ 
+       if(lsf) {
+         int p = gr_info->scalefac_compress & 0x1;
+ 	    if(ms_stereo) {
+           tab1 = pow1_2[p]; tab2 = pow2_2[p];
+         }
+         else {
+           tab1 = pow1_1[p]; tab2 = pow2_1[p];
+         }
+       }
+       else {
+         if(ms_stereo) {
+           tab1 = tan1_2; tab2 = tan2_2;
+         }
+         else {
+           tab1 = tan1_1; tab2 = tan2_1;
+         }
+       }
+ 
+       if (gr_info->block_type == 2)
+       {
+          int lwin,do_l = 0;
+          if( gr_info->mixed_block_flag )
+            do_l = 1;
+ 
+          for (lwin=0;lwin<3;lwin++) /* process each window */
+          {
+              /* get first band with zero values */
+            int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
+            if(sfb > 3)
+              do_l = 0;
+ 
+            for(;sfb<12;sfb++)
+            {
+              is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */ 
+              if(is_p != 7) {
+                real t1,t2;
+                sb = bi->shortDiff[sfb];
+                idx = bi->shortIdx[sfb] + lwin;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for (; sb > 0; sb--,idx+=3)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+            }
+ 
+ #if 1
+ /* in the original: copy 10 to 11 , here: copy 11 to 12 
+ maybe still wrong??? (copy 12 to 13?) */
+            is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[12];
+            idx = bi->shortIdx[12] + lwin;
+ #else
+            is_p = scalefac[10*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[11];
+            idx = bi->shortIdx[11] + lwin;
+ #endif
+            if(is_p != 7)
+            {
+              real t1,t2;
+              t1 = tab1[is_p]; t2 = tab2[is_p];
+              for ( ; sb > 0; sb--,idx+=3 )
+              {  
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+              }
+            }
+          } /* end for(lwin; .. ; . ) */
+ 
+          if (do_l)
+          {
+ /* also check l-part, if ALL bands in the three windows are 'empty'
+  * and mode = mixed_mode 
+  */
+            int sfb = gr_info->maxbandl;
+            int idx = bi->longIdx[sfb];
+ 
+            for ( ; sfb<8; sfb++ )
+            {
+              int sb = bi->longDiff[sfb];
+              int is_p = scalefac[sfb]; /* scale: 0-15 */
+              if(is_p != 7) {
+                real t1,t2;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for ( ; sb > 0; sb--,idx++)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+              else 
+                idx += sb;
+            }
+          }     
+       } 
+       else /* ((gr_info->block_type != 2)) */
+       {
+         int sfb = gr_info->maxbandl;
+         int is_p,idx = bi->longIdx[sfb];
+         for ( ; sfb<21; sfb++)
+         {
+           int sb = bi->longDiff[sfb];
+           is_p = scalefac[sfb]; /* scale: 0-15 */
+           if(is_p != 7) {
+             real t1,t2;
+             t1 = tab1[is_p]; t2 = tab2[is_p];
+             for ( ; sb > 0; sb--,idx++)
+             {
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+             }
+           }
+           else
+             idx += sb;
+         }
+ 
+         is_p = scalefac[20]; /* copy l-band 20 to l-band 21 */
+         if(is_p != 7)
+         {
+           int sb;
+           real t1 = tab1[is_p],t2 = tab2[is_p]; 
+ 
+           for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
+           {
+             real v = xr[0][idx];
+             xr[0][idx] = v * t1;
+             xr[1][idx] = v * t2;
+           }
+         }
+       } /* ... */
+ }
+ 
+ static void III_antialias(real xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info)
+ {
+    int sblim;
+ 
+    if(gr_info->block_type == 2)
+    {
+       if(!gr_info->mixed_block_flag) 
+         return;
+       sblim = 1; 
+    }
+    else {
+      sblim = gr_info->maxb-1;
+    }
+ 
+    /* 31 alias-reduction operations between each pair of sub-bands */
+    /* with 8 butterflies between each pair                         */
+ 
+    {
+      int sb;
+      real *xr1=(real *) xr[1];
+ 
+      for(sb=sblim;sb;sb--,xr1+=10)
+      {
+        int ss;
+        real *cs=aa_cs,*ca=aa_ca;
+        real *xr2 = xr1;
+ 
+        for(ss=7;ss>=0;ss--)
+        {       /* upper and lower butterfly inputs */
+          register real bu = *--xr2,bd = *xr1;
+          *xr2   = (bu * (*cs)   ) - (bd * (*ca)   );
+          *xr1++ = (bd * (*cs++) ) + (bu * (*ca++) );
+        }
+      }
+   }
+ }
+ 
+ /*
+  DCT insipired by Jeff Tsay's DCT from the maplay package
+  this is an optimized version with manual unroll.
+ 
+  References:
+  [1] S. Winograd: "On Computing the Discrete Fourier Transform",
+      Mathematics of Computation, Volume 32, Number 141, January 1978,
+      Pages 175-199
+ */
+ 
+ static void dct36(real *inbuf,real *o1,real *o2,real *wintab,real *tsbuf)
+ {
+   {
+     register real *in = inbuf;
+ 
+     in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
+     in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
+     in[11]+=in[10]; in[10]+=in[9];  in[9] +=in[8];
+     in[8] +=in[7];  in[7] +=in[6];  in[6] +=in[5];
+     in[5] +=in[4];  in[4] +=in[3];  in[3] +=in[2];
+     in[2] +=in[1];  in[1] +=in[0];
+ 
+     in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
+     in[9] +=in[7];  in[7] +=in[5];  in[5] +=in[3];  in[3] +=in[1];
+ 
+ 
+   {
+ 
+ #define MACRO0(v) { \
+     real tmp; \
+     out2[9+(v)] = (tmp = sum0 + sum1) * w[27+(v)]; \
+     out2[8-(v)] = tmp * w[26-(v)];  } \
+     sum0 -= sum1; \
+     ts[SBLIMIT*(8-(v))] = out1[8-(v)] + sum0 * w[8-(v)]; \
+     ts[SBLIMIT*(9+(v))] = out1[9+(v)] + sum0 * w[9+(v)]; 
+ #define MACRO1(v) { \
+ 	real sum0,sum1; \
+     sum0 = tmp1a + tmp2a; \
+ 	sum1 = (tmp1b + tmp2b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ #define MACRO2(v) { \
+     real sum0,sum1; \
+     sum0 = tmp2a - tmp1a; \
+     sum1 = (tmp2b - tmp1b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ 
+     register const real *c = COS9;
+     register real *out2 = o2;
+ 	register real *w = wintab;
+ 	register real *out1 = o1;
+ 	register real *ts = tsbuf;
+ 
+     real ta33,ta66,tb33,tb66;
+ 
+     ta33 = in[2*3+0] * c[3];
+     ta66 = in[2*6+0] * c[6];
+     tb33 = in[2*3+1] * c[3];
+     tb66 = in[2*6+1] * c[6];
+ 
+     { 
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[1] + ta33 + in[2*5+0] * c[5] + in[2*7+0] * c[7];
+       tmp1b =             in[2*1+1] * c[1] + tb33 + in[2*5+1] * c[5] + in[2*7+1] * c[7];
+       tmp2a = in[2*0+0] + in[2*2+0] * c[2] + in[2*4+0] * c[4] + ta66 + in[2*8+0] * c[8];
+       tmp2b = in[2*0+1] + in[2*2+1] * c[2] + in[2*4+1] * c[4] + tb66 + in[2*8+1] * c[8];
+ 
+       MACRO1(0);
+       MACRO2(8);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a = ( in[2*1+0] - in[2*5+0] - in[2*7+0] ) * c[3];
+       tmp1b = ( in[2*1+1] - in[2*5+1] - in[2*7+1] ) * c[3];
+       tmp2a = ( in[2*2+0] - in[2*4+0] - in[2*8+0] ) * c[6] - in[2*6+0] + in[2*0+0];
+       tmp2b = ( in[2*2+1] - in[2*4+1] - in[2*8+1] ) * c[6] - in[2*6+1] + in[2*0+1];
+ 
+       MACRO1(1);
+       MACRO2(7);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[5] - ta33 - in[2*5+0] * c[7] + in[2*7+0] * c[1];
+       tmp1b =             in[2*1+1] * c[5] - tb33 - in[2*5+1] * c[7] + in[2*7+1] * c[1];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[8] - in[2*4+0] * c[2] + ta66 + in[2*8+0] * c[4];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[8] - in[2*4+1] * c[2] + tb66 + in[2*8+1] * c[4];
+ 
+       MACRO1(2);
+       MACRO2(6);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[7] - ta33 + in[2*5+0] * c[1] - in[2*7+0] * c[5];
+       tmp1b =             in[2*1+1] * c[7] - tb33 + in[2*5+1] * c[1] - in[2*7+1] * c[5];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[4] + in[2*4+0] * c[8] + ta66 - in[2*8+0] * c[2];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[4] + in[2*4+1] * c[8] + tb66 - in[2*8+1] * c[2];
+ 
+       MACRO1(3);
+       MACRO2(5);
+     }
+ 
+ 	{
+ 		real sum0,sum1;
+     	sum0 =  in[2*0+0] - in[2*2+0] + in[2*4+0] - in[2*6+0] + in[2*8+0];
+     	sum1 = (in[2*0+1] - in[2*2+1] + in[2*4+1] - in[2*6+1] + in[2*8+1] ) * tfcos36[4];
+ 		MACRO0(4);
+ 	}
+   }
+ 
+   }
+ }
+ 
+ /*
+  * new DCT12
+  */
+ static void dct12(real *in,real *rawout1,real *rawout2,register real *wi,register real *ts)
+ {
+ #define DCT12_PART1 \
+              in5 = in[5*3];  \
+      in5 += (in4 = in[4*3]); \
+      in4 += (in3 = in[3*3]); \
+      in3 += (in2 = in[2*3]); \
+      in2 += (in1 = in[1*3]); \
+      in1 += (in0 = in[0*3]); \
+                              \
+      in5 += in3; in3 += in1; \
+                              \
+      in2 *= COS6_1; \
+      in3 *= COS6_1; \
+ 
+ #define DCT12_PART2 \
+      in0 += in4 * COS6_2; \
+                           \
+      in4 = in0 + in2;     \
+      in0 -= in2;          \
+                           \
+      in1 += in5 * COS6_2; \
+                           \
+      in5 = (in1 + in3) * tfcos12[0]; \
+      in1 = (in1 - in3) * tfcos12[2]; \
+                          \
+      in3 = in4 + in5;    \
+      in4 -= in5;         \
+                          \
+      in2 = in0 + in1;    \
+      in0 -= in1;
+ 
+ 
+    {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out1 = rawout1;
+      ts[SBLIMIT*0] = out1[0]; ts[SBLIMIT*1] = out1[1]; ts[SBLIMIT*2] = out1[2];
+      ts[SBLIMIT*3] = out1[3]; ts[SBLIMIT*4] = out1[4]; ts[SBLIMIT*5] = out1[5];
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        ts[(17-1)*SBLIMIT] = out1[17-1] + tmp0 * wi[11-1];
+        ts[(12+1)*SBLIMIT] = out1[12+1] + tmp0 * wi[6+1];
+        ts[(6 +1)*SBLIMIT] = out1[6 +1] + tmp1 * wi[1];
+        ts[(11-1)*SBLIMIT] = out1[11-1] + tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      ts[(17-0)*SBLIMIT] = out1[17-0] + in2 * wi[11-0];
+      ts[(12+0)*SBLIMIT] = out1[12+0] + in2 * wi[6+0];
+      ts[(12+2)*SBLIMIT] = out1[12+2] + in3 * wi[6+2];
+      ts[(17-2)*SBLIMIT] = out1[17-2] + in3 * wi[11-2];
+ 
+      ts[(6+0)*SBLIMIT]  = out1[6+0] + in0 * wi[0];
+      ts[(11-0)*SBLIMIT] = out1[11-0] + in0 * wi[5-0];
+      ts[(6+2)*SBLIMIT]  = out1[6+2] + in4 * wi[2];
+      ts[(11-2)*SBLIMIT] = out1[11-2] + in4 * wi[5-2];
+   }
+ 
+   in++;
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[5-1] = tmp0 * wi[11-1];
+        out2[0+1] = tmp0 * wi[6+1];
+        ts[(12+1)*SBLIMIT] += tmp1 * wi[1];
+        ts[(17-1)*SBLIMIT] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[5-0] = in2 * wi[11-0];
+      out2[0+0] = in2 * wi[6+0];
+      out2[0+2] = in3 * wi[6+2];
+      out2[5-2] = in3 * wi[11-2];
+ 
+      ts[(12+0)*SBLIMIT] += in0 * wi[0];
+      ts[(17-0)*SBLIMIT] += in0 * wi[5-0];
+      ts[(12+2)*SBLIMIT] += in4 * wi[2];
+      ts[(17-2)*SBLIMIT] += in4 * wi[5-2];
+   }
+ 
+   in++; 
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+      out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
+ 
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[11-1] = tmp0 * wi[11-1];
+        out2[6 +1] = tmp0 * wi[6+1];
+        out2[0+1] += tmp1 * wi[1];
+        out2[5-1] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[11-0] = in2 * wi[11-0];
+      out2[6 +0] = in2 * wi[6+0];
+      out2[6 +2] = in3 * wi[6+2];
+      out2[11-2] = in3 * wi[11-2];
+ 
+      out2[0+0] += in0 * wi[0];
+      out2[5-0] += in0 * wi[5-0];
+      out2[0+2] += in4 * wi[2];
+      out2[5-2] += in4 * wi[5-2];
+   }
+ }
+ 
+ /*
+  * III_hybrid
+  */
+ static void III_hybrid(real fsIn[SBLIMIT][SSLIMIT],real tsOut[SSLIMIT][SBLIMIT],
+    int ch,struct gr_info_s *gr_info)
+ {
+    real *tspnt = (real *) tsOut;
+    real (*block)[2][SBLIMIT*SSLIMIT] = gmp->hybrid_block;
+    int *blc = gmp->hybrid_blc;
+    real *rawout1,*rawout2;
+    int bt;
+    int sb = 0;
+ 
+    {
+      int b = blc[ch];
+      rawout1=block[b][ch];
+      b=-b+1;
+      rawout2=block[b][ch];
+      blc[ch] = b;
+    }
+ 
+   
+    if(gr_info->mixed_block_flag) {
+      sb = 2;
+      dct36(fsIn[0],rawout1,rawout2,win[0],tspnt);
+      dct36(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+      rawout1 += 36; rawout2 += 36; tspnt += 2;
+    }
+  
+    bt = gr_info->block_type;
+    if(bt == 2) {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct12(fsIn[sb],rawout1,rawout2,win[2],tspnt);
+        dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
+      }
+    }
+    else {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct36(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+        dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+      }
+    }
+ 
+    for(;sb<SBLIMIT;sb++,tspnt++) {
+      int i;
+      for(i=0;i<SSLIMIT;i++) {
+        tspnt[i*SBLIMIT] = *rawout1++;
+        *rawout2++ = 0.0;
+      }
+    }
+ }
+ 
+ /*
+  * main layer3 handler
+  */
+ int do_layer3(struct frame *fr,unsigned char *pcm_sample,int *pcm_point)
+ {
+   int gr, ch, ss,clip=0;
+   int scalefacs[39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
+   struct III_sideinfo sideinfo;
+   int stereo = fr->stereo;
+   int single = fr->single;
+   int ms_stereo,i_stereo;
+   int sfreq = fr->sampling_frequency;
+   int stereo1,granules;
+ 
+ 
+ 
+   if(stereo == 1) { /* stream is mono */
+     stereo1 = 1;
+     single = 0;
+   }
+   else if(single >= 0) /* stream is stereo, but force to mono */
+     stereo1 = 1;
+   else
+     stereo1 = 2;
+ 
+   if(fr->mode == MPG_MD_JOINT_STEREO) {
+     ms_stereo = fr->mode_ext & 0x2;
+     i_stereo  = fr->mode_ext & 0x1;
+   }
+   else
+     ms_stereo = i_stereo = 0;
+ 
+ 
+   if(fr->lsf) {
+     granules = 1;
+     III_get_side_info_2(&sideinfo,stereo,ms_stereo,sfreq,single);
+   }
+   else {
+     granules = 2;
+ #ifdef MPEG1
+     III_get_side_info_1(&sideinfo,stereo,ms_stereo,sfreq,single);
+ #else
+     fprintf(stderr,"Not supported\n");
+ #endif
+   }
+ 
+   if(set_pointer(sideinfo.main_data_begin) == MP3_ERR)
+     return 0; 
+ 
+ 
+   for (gr=0;gr<granules;gr++) 
+   {
+     static real hybridIn[2][SBLIMIT][SSLIMIT];
+     static real hybridOut[2][SSLIMIT][SBLIMIT];
+ 
+     {
+       struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
+       long part2bits;
+       if(fr->lsf)
+         part2bits = III_get_scale_factors_2(scalefacs,gr_info,0);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs,gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+       if(III_dequantize_sample(hybridIn[0], scalefacs,gr_info,sfreq,part2bits))
+         return clip;
+     }
+     if(stereo == 2) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[1].gr[gr]);
+       long part2bits;
+       if(fr->lsf) 
+         part2bits = III_get_scale_factors_2(scalefacs,gr_info,i_stereo);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs,gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+ 
+       if(III_dequantize_sample(hybridIn[1],scalefacs,gr_info,sfreq,part2bits))
+           return clip;
+ 
+       if(ms_stereo) {
+         int i;
+         for(i=0;i<SBLIMIT*SSLIMIT;i++) {
+           real tmp0,tmp1;
+           tmp0 = ((real *) hybridIn[0])[i];
+           tmp1 = ((real *) hybridIn[1])[i];
+           ((real *) hybridIn[1])[i] = tmp0 - tmp1;  
+           ((real *) hybridIn[0])[i] = tmp0 + tmp1;
+         }
+       }
+ 
+       if(i_stereo)
+         III_i_stereo(hybridIn,scalefacs,gr_info,sfreq,ms_stereo,fr->lsf);
+ 
+       if(ms_stereo || i_stereo || (single == 3) ) {
+         if(gr_info->maxb > sideinfo.ch[0].gr[gr].maxb) 
+           sideinfo.ch[0].gr[gr].maxb = gr_info->maxb;
+         else
+           gr_info->maxb = sideinfo.ch[0].gr[gr].maxb;
+       }
+ 
+       switch(single) {
+         case 3:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++,in0++)
+               *in0 = (*in0 + *in1++); /* *0.5 done by pow-scale */ 
+           }
+           break;
+         case 1:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++)
+               *in0++ = *in1++;
+           }
+           break;
+       }
+     }
+ 
+ #ifdef HAVEGTK
+   {
+     extern int tabsel_123[2][3][16];
+     int sb;
+     
+     pinfo->bitrate = 
+       tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index];
+     pinfo->sampfreq = freqs[sfreq];
+     pinfo->emph = fr->emphasis;
+     pinfo->stereo = fr->stereo;
+     pinfo->js =   (fr->mode == MPG_MD_JOINT_STEREO);
+     pinfo->ms_stereo = ms_stereo;
+     pinfo->i_stereo = i_stereo;
+     pinfo->maindata = sideinfo.main_data_begin;
+     
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       pinfo->mixed[gr][ch] = gr_info->mixed_block_flag;
+       pinfo->mpg123blocktype[gr][ch]=gr_info->block_type;
+       pinfo->mainbits[gr][ch] = gr_info->part2_3_length;
+       pinfo->scfsi = gr_info->scfsi;
+     }
+     for(ch=0;ch<stereo1;ch++) { 
+       int j=0;
+       for (sb=0;sb<SBLIMIT;sb++)
+ 	for(ss=0;ss<SSLIMIT;ss++,j++) 
+ 	  pinfo->mpg123xr[gr][ch][j]=hybridIn[ch][sb][ss];
+     }
+   }
+ 
+ #endif
+ 
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       III_antialias(hybridIn[ch],gr_info);
+       III_hybrid(hybridIn[ch], hybridOut[ch], ch,gr_info);
+     }
+ 
+     for(ss=0;ss<SSLIMIT;ss++) {
+       if(single >= 0) {
+         clip += synth_1to1_mono(hybridOut[0][ss],pcm_sample,pcm_point);
+       }
+       else {
+         int p1 = *pcm_point;
+         clip += synth_1to1(hybridOut[0][ss],0,pcm_sample,&p1);
+         clip += synth_1to1(hybridOut[1][ss],1,pcm_sample,pcm_point);
+       }
+     }
+   }
+   
+   return clip;
+ }
+ 
+ 
+ #endif
+ 
diff -r -c -N encoder/mpglib/main.c lame3.13/mpglib/main.c
*** encoder/mpglib/main.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/main.c	Tue Jun 22 00:11:55 1999
***************
*** 0 ****
--- 1,142 ----
+ #ifdef HAVEGTK
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ char buf[16384]={16384*(char)0};
+ struct mpstr mp;
+ 
+ #if 0
+ void main(void)
+ {
+ 	int size;
+ 	char out[8192];
+ 	int len,ret;
+ 	
+ 
+ 	InitMP3(&mp);
+ 
+ 	while(1) {
+ 		len = read(0,buf,16384);
+ 		if(len <= 0)
+ 			break;
+ 		ret = decodeMP3(&mp,buf,len,out,8192,&size);
+ 		while(ret == MP3_OK) {
+ 			write(1,out,size);
+ 			ret = decodeMP3(&mp,NULL,0,out,8192,&size);
+ 		}
+ 	}
+ 
+ }
+ #endif
+ 
+ int is_syncword(char *header)
+ {
+ 
+ /*
+ unsigned int s0,s1;
+ s0 = (unsigned char) header[0];
+ s1 = (unsigned char) header[1] ;
+ printf(" syncword:  %2X   %2X   \n ",s0, s1);
+ */
+ 
+ /*
+ printf(" integer  %i \n",(int) ( header[0] == (char) 0xFF));
+ printf(" integer  %i \n",(int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ */
+ 
+ return 
+ ((int) ( header[0] == (char) 0xFF)) &&
+ ((int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ 
+ 
+ }
+ 
+ 
+ 
+ int decode1file(int fd,short pcm[][1152],int *stereo)
+ {
+   int size;
+ #define FSIZE 8192  
+   char out[FSIZE];
+   int outsize=0,j,i,ret,len;
+   static int firstcall=1;
+ 
+   size=0;
+   if (firstcall) {
+     InitMP3(&mp);
+     firstcall=0;
+     /* skip RIFF type proprietary headers  */
+     /* look for sync word  FFF */
+     while (!is_syncword(buf)) {
+       buf[0]=buf[1]; 
+       if (read(fd,&buf[1],1) <= 0) return 0;
+     }
+     len = 2;
+   }
+   else len = read(fd,buf,64); 
+   if (len <=0 ) return 0;
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+ 
+ 
+   /* read more until we get a valid output frame */
+   while((ret == MP3_NEED_MORE) || !size) {
+     len = read(fd,buf,100);  if (len <=0 ) return 0;
+     ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+     /* if (ret ==MP3_ERR) return 0;  lets ignore errors and keep reading... */
+     /*
+     printf("ret = %i size= %i  %i   %i  %i \n",ret,size,
+ 	   MP3_NEED_MORE,MP3_ERR,MP3_OK); 
+     */
+   }
+ 
+   *stereo=mp.fr.stereo;
+   if (ret == MP3_OK) {
+     /*    write(1,out,size); */
+     outsize = size/(2*(*stereo));
+     if ((outsize!=576) && (outsize!=1152)) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  Cant handle this... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<*stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	pcm[j][i] = ((short *) out)[*stereo*i+j];
+   }
+   return outsize;
+ }
+ 
+ 
+ int decode1(char *buf,int len,short pcm[][1152],int stereo)
+ {
+   int size;
+ #define FSIZE 8192 
+   char out[FSIZE];
+   int outsize=0,j,i,ret;
+   static int firstcall=1;
+   
+   if (firstcall) {
+     InitMP3(&mp);
+     firstcall=0;
+   }
+   
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+   if (ret==MP3_OK) {
+     /*    printf("mpg123 output one frame out=%i \n",size/4);  */
+     outsize = size/(2*stereo);
+     if (outsize > 1152) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  shouldn't happen... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	pcm[j][i] = ((short *) out)[stereo*i+j];
+   }
+   /* printf("mpg123 returned %i \n",outsize); */
+   return outsize;
+ }
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/mpg123.h lame3.13/mpglib/mpg123.h
*** encoder/mpglib/mpg123.h	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/mpg123.h	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,180 ----
+ #include        <stdio.h>
+ #include        <string.h>
+ #include        <signal.h>
+ 
+ #ifndef WIN32
+ #include        <sys/signal.h>
+ #include        <unistd.h>
+ #endif
+ 
+ #include        <math.h>
+ 
+ #ifdef _WIN32
+ # undef WIN32
+ # define WIN32
+ 
+ # define M_PI       3.14159265358979323846
+ # define M_SQRT2	1.41421356237309504880
+ # define REAL_IS_FLOAT
+ # define NEW_DCT9
+ 
+ # define random rand
+ # define srandom srand
+ 
+ #endif
+ 
+ #ifdef REAL_IS_FLOAT
+ #  define real float
+ #elif defined(REAL_IS_LONG_DOUBLE)
+ #  define real long double
+ #else
+ #  define real double
+ #endif
+ 
+ #ifdef __GNUC__
+ #define INLINE inline
+ #else
+ #define INLINE
+ #endif
+ 
+ /* AUDIOBUFSIZE = n*64 with n=1,2,3 ...  */
+ #define		AUDIOBUFSIZE		16384
+ 
+ #define         FALSE                   0
+ #define         TRUE                    1
+ 
+ #define         SBLIMIT                 32
+ #define         SSLIMIT                 18
+ 
+ #define         MPG_MD_STEREO           0
+ #define         MPG_MD_JOINT_STEREO     1
+ #define         MPG_MD_DUAL_CHANNEL     2
+ #define         MPG_MD_MONO             3
+ 
+ #define MAXFRAMESIZE 1792
+ 
+ 
+ /* Pre Shift fo 16 to 8 bit converter table */
+ #define AUSHIFT (3)
+ 
+ struct frame {
+     int stereo;
+     int jsbound;
+     int single;
+     int lsf;
+     int mpeg25;
+     int header_change;
+     int lay;
+     int error_protection;
+     int bitrate_index;
+     int sampling_frequency;
+     int padding;
+     int extension;
+     int mode;
+     int mode_ext;
+     int copyright;
+     int original;
+     int emphasis;
+     int framesize; /* computed framesize */
+ };
+ 
+ struct parameter {
+ 	int quiet;	/* shut up! */
+ 	int tryresync;  /* resync stream after error */
+ 	int verbose;    /* verbose level */
+ 	int checkrange;
+ };
+ 
+ /* extern unsigned int   get1bit(void); */
+ extern unsigned int   getbits(int);
+ extern unsigned int   getbits_fast(int);
+ extern int set_pointer(long);
+ 
+ extern unsigned char *wordpointer;
+ extern int bitindex;
+ 
+ extern void make_decode_tables(long scaleval);
+ extern int do_layer3(struct frame *fr,unsigned char *,int *);
+ extern int decode_header(struct frame *fr,unsigned long newhead);
+ 
+ 
+ 
+ struct gr_info_s {
+       int scfsi;
+       unsigned part2_3_length;
+       unsigned big_values;
+       unsigned scalefac_compress;
+       unsigned block_type;
+       unsigned mixed_block_flag;
+       unsigned table_select[3];
+       unsigned subblock_gain[3];
+       unsigned maxband[3];
+       unsigned maxbandl;
+       unsigned maxb;
+       unsigned region1start;
+       unsigned region2start;
+       unsigned preflag;
+       unsigned scalefac_scale;
+       unsigned count1table_select;
+       real *full_gain[3];
+       real *pow2gain;
+ };
+ 
+ struct III_sideinfo
+ {
+   unsigned main_data_begin;
+   unsigned private_bits;
+   struct {
+     struct gr_info_s gr[2];
+   } ch[2];
+ };
+ 
+ extern int synth_1to1 (real *,int,unsigned char *,int *);
+ extern int synth_1to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_1to1_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_2to1 (real *,int,unsigned char *,int *);
+ extern int synth_2to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_2to1_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_4to1 (real *,int,unsigned char *,int *);
+ extern int synth_4to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_4to1_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_ntom (real *,int,unsigned char *,int *);
+ extern int synth_ntom_8bit (real *,int,unsigned char *,int *);
+ extern int synth_ntom_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern void rewindNbits(int bits);
+ extern int  hsstell(void);
+ extern int get_songlen(struct frame *fr,int no);
+ 
+ extern void init_layer3(int);
+ extern void init_layer2(void);
+ extern void make_decode_tables(long scale);
+ extern void make_conv16to8_table(int);
+ extern void dct64(real *,real *,real *);
+ 
+ extern void synth_ntom_set_step(long,long);
+ 
+ extern unsigned char *conv16to8;
+ extern long freqs[9];
+ extern real muls[27][64];
+ extern real decwin[512+32];
+ extern real *pnts[5];
+ 
+ extern struct parameter param;
+ 
+ 
diff -r -c -N encoder/mpglib/mpglib.dsp lame3.13/mpglib/mpglib.dsp
*** encoder/mpglib/mpglib.dsp	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/mpglib.dsp	Mon May 24 15:43:30 1999
***************
*** 0 ****
--- 1,118 ----
+ # Microsoft Developer Studio Project File - Name="mpglib" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Static Library" 0x0104
+ 
+ CFG=mpglib - Win32 Debug
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak" CFG="mpglib - Win32 Debug"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "mpglib - Win32 Release" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Debug" (based on "Win32 (x86) Static Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ 
+ !IF  "$(CFG)" == "mpglib - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "HAVEGTK" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "HAVEGTK" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "mpglib - Win32 Release"
+ # Name "mpglib - Win32 Debug"
+ # Begin Source File
+ 
+ SOURCE=.\common.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\dct64_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\decode_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\interface.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\layer3.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\main.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpg123.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpglib.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tabinit.c
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/mpglib/mpglib.h lame3.13/mpglib/mpglib.h
*** encoder/mpglib/mpglib.h	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/mpglib.h	Tue Apr 20 22:27:37 1999
***************
*** 0 ****
--- 1,44 ----
+ 
+ struct buf {
+         unsigned char *pnt;
+ 	long size;
+ 	long pos;
+         struct buf *next;
+         struct buf *prev;
+ };
+ 
+ struct framebuf {
+ 	struct buf *buf;
+ 	long pos;
+ 	struct frame *next;
+ 	struct frame *prev;
+ };
+ 
+ struct mpstr {
+ 	struct buf *head,*tail;
+ 	int bsize;
+ 	int framesize;
+         int fsizeold;
+ 	struct frame fr;
+         unsigned char bsspace[2][MAXFRAMESIZE+512]; /* MAXFRAMESIZE */
+ 	real hybrid_block[2][2][SBLIMIT*SSLIMIT];
+ 	int hybrid_blc[2];
+ 	unsigned long header;
+ 	int bsnum;
+ 	real synth_buffs[2][2][0x110];
+         int  synth_bo;
+ 	
+ };
+ 
+ #define BOOL int
+ 
+ #define MP3_ERR -1
+ #define MP3_OK  0
+ #define MP3_NEED_MORE 1
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp);
+ int decodeMP3(struct mpstr *mp,char *inmemory,int inmemsize,
+      char *outmemory,int outmemsize,int *done);
+ void ExitMP3(struct mpstr *mp);
+ 
diff -r -c -N encoder/mpglib/tabinit.c lame3.13/mpglib/tabinit.c
*** encoder/mpglib/tabinit.c	Wed Dec 31 17:00:00 1969
--- lame3.13/mpglib/tabinit.c	Sun Apr 25 22:14:54 1999
***************
*** 0 ****
--- 1,82 ----
+ #ifdef HAVEGTK
+ #include <stdlib.h>
+ 
+ #include "mpg123.h"
+ 
+ real decwin[512+32];
+ static real cos64[16],cos32[8],cos16[4],cos8[2],cos4[1];
+ real *pnts[] = { cos64,cos32,cos16,cos8,cos4 };
+ 
+ #if 0
+ static unsigned char *conv16to8_buf = NULL;
+ unsigned char *conv16to8;
+ #endif
+ 
+ static long intwinbase[] = {
+      0,    -1,    -1,    -1,    -1,    -1,    -1,    -2,    -2,    -2,
+     -2,    -3,    -3,    -4,    -4,    -5,    -5,    -6,    -7,    -7,
+     -8,    -9,   -10,   -11,   -13,   -14,   -16,   -17,   -19,   -21,
+    -24,   -26,   -29,   -31,   -35,   -38,   -41,   -45,   -49,   -53,
+    -58,   -63,   -68,   -73,   -79,   -85,   -91,   -97,  -104,  -111,
+   -117,  -125,  -132,  -139,  -147,  -154,  -161,  -169,  -176,  -183,
+   -190,  -196,  -202,  -208,  -213,  -218,  -222,  -225,  -227,  -228,
+   -228,  -227,  -224,  -221,  -215,  -208,  -200,  -189,  -177,  -163,
+   -146,  -127,  -106,   -83,   -57,   -29,     2,    36,    72,   111,
+    153,   197,   244,   294,   347,   401,   459,   519,   581,   645,
+    711,   779,   848,   919,   991,  1064,  1137,  1210,  1283,  1356,
+   1428,  1498,  1567,  1634,  1698,  1759,  1817,  1870,  1919,  1962,
+   2001,  2032,  2057,  2075,  2085,  2087,  2080,  2063,  2037,  2000,
+   1952,  1893,  1822,  1739,  1644,  1535,  1414,  1280,  1131,   970,
+    794,   605,   402,   185,   -45,  -288,  -545,  -814, -1095, -1388,
+  -1692, -2006, -2330, -2663, -3004, -3351, -3705, -4063, -4425, -4788,
+  -5153, -5517, -5879, -6237, -6589, -6935, -7271, -7597, -7910, -8209,
+  -8491, -8755, -8998, -9219, -9416, -9585, -9727, -9838, -9916, -9959,
+  -9966, -9935, -9863, -9750, -9592, -9389, -9139, -8840, -8492, -8092,
+  -7640, -7134, -6574, -5959, -5288, -4561, -3776, -2935, -2037, -1082,
+    -70,   998,  2122,  3300,  4533,  5818,  7154,  8540,  9975, 11455,
+  12980, 14548, 16155, 17799, 19478, 21189, 22929, 24694, 26482, 28289,
+  30112, 31947, 33791, 35640, 37489, 39336, 41176, 43006, 44821, 46617,
+  48390, 50137, 51853, 53534, 55178, 56778, 58333, 59838, 61289, 62684,
+  64019, 65290, 66494, 67629, 68692, 69679, 70590, 71420, 72169, 72835,
+  73415, 73908, 74313, 74630, 74856, 74992, 75038 };
+ 
+ void make_decode_tables(long scaleval)
+ {
+   int i,j,k,kr,divv;
+   real *table,*costab;
+ 
+   
+   for(i=0;i<5;i++)
+   {
+     kr=0x10>>i; divv=0x40>>i;
+     costab = pnts[i];
+     for(k=0;k<kr;k++)
+       costab[k] = 1.0 / (2.0 * cos(M_PI * ((double) k * 2.0 + 1.0) / (double) divv));
+   }
+ 
+   table = decwin;
+   scaleval = -scaleval;
+   for(i=0,j=0;i<256;i++,j++,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ 
+   for( /* i=256 */ ;i<512;i++,j--,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ }
+ 
+ 
+ #endif
+ 
diff -r -c -N encoder/musicin.c lame3.13/musicin.c
*** encoder/musicin.c	Wed Jan 22 02:43:17 1997
--- lame3.13/musicin.c	Thu Jun 24 18:15:58 1999
***************
*** 13,401 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
!  *          Davis Pan                                                 *
!  * 3/06/91  Douglas Wong,       rename: setup.h to endef.h            *
!  *                              removed extraneous variables          *
!  * 3/21/91  J.Georges Fritsch   introduction of the bit-stream        *
!  *                              package. This package allows you      *
!  *                              to generate the bit-stream in a       *
!  *                              binary or ascii format                *
!  * 3/31/91  Bill Aspromonte     replaced the read of the SB matrix    *
!  *                              by an "code generated" one            *
!  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
!  *                              Incorporated Jean-Georges Fritsch's   *
!  *                              "bitstream.c" package.                *
!  *                              Modified to strictly adhere to        *
!  *                              encoded bitstream specs, including    *
!  *                              "Berlin changes".                     *
!  *                              Modified user interface dialog & code *
!  *                              to accept any input & output          *
!  *                              filenames desired.  Also added        *
!  *                              de-emphasis prompt and final bail-out *
!  *                              opportunity before encoding.          *
!  *                              Added AIFF PCM sound file reading     *
!  *                              capability.                           *
!  *                              Modified PCM sound file handling to   *
!  *                              process all incoming samples and fill *
!  *                              out last encoded frame with zeros     *
!  *                              (silence) if needed.                  *
!  *                              Located and fixed numerous software   *
!  *                              bugs and table data errors.           *
!  * 27jun91  dpwe (Aware Inc)    Used new frame_params struct.         *
!  *                              Clear all automatic arrays.           *
!  *                              Changed some variable names,          *
!  *                              simplified some code.                 *
!  *                              Track number of bits actually sent.   *
!  *                              Fixed padding slot, stereo bitrate    *
!  *                              Added joint-stereo : scales L+R.      *
!  * 6/12/91  Earle Jennings      added fix for MS_DOS in obtain_param  *
!  * 6/13/91  Earle Jennings      added stack length adjustment before  *
!  *                              main for MS_DOS                       *
!  * 7/10/91  Earle Jennings      conversion of all float to FLOAT      *
!  *                              port to MsDos from MacIntosh completed*
!  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
!  * 8/22/91  Jens Spille         new obtain_parameters()               *
!  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
!  *          Don H. Lee,                                               *
!  *          Peter W. Farrett                                          *
!  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
!  *                              newly introduced functions are        *
!  *                              I_CRC_calc, II_CRC_calc and encode_CRC*
!  *                              Additions and revisions are marked    *
!  *                              with "dhl" for clarity                *
!  *11/11/91 Katherine Wang       Documentation of code.                *
!  *                                (variables in documentation are     *
!  *                                surround by the # symbol, and an '*'*
!  *                                denotes layer I or II versions)     *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  * 2/25/92  Masahiro Iwadare    made code cleaner and more consistent *
!  * 8/07/92  Mike Coleman        make exit() codes return error status *
!  *                              made slight changes for portability   *
!  *19 aug 92 Soren H. Nielsen    Changed MS-DOS file name extensions.  *
!  * 8/25/92  Shaun Astarabadi    Replaced rint() function with explicit*
!  *                              rounding for portability with MSDOS.  *
!  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() calls.     *
!  *10/19/92  Masahiro Iwadare    added info->mode and info->mode_ext   *
!  *                              updates for AIFF format files         *
!  * 3/10/93  Kevin Peterson      In parse_args, only set non default   *
!  *                              bit rate if specified in arg list.    *
!  *                              Use return value from aiff_read_hdrs  *
!  *                              to fseek to start of sound data       *
!  * 7/26/93  Davis Pan           fixed bug in printing info->mode_ext  *
!  *                              value for joint stereo condition      *
!  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
!  *         Daniel Lauzon, and                                         *
!  *         Bill Truerniet                                             *
!  * 11/7/95 Soeren H. Nielsen    LSF added. Bug fix in MSDOS ext.      *
!  * 8/02/95 mc@fivebats.com      Changed default bitrate selection so  *
!  *                              it works with the new LSF stuff       *
!  *10/01/95 mc@fivebats.com      Added layer3                          *
!  **********************************************************************/
! 
! #ifdef MS_DOS
! #include <dos.h>
! #endif
  #include <stdlib.h>
  #include "common.h"
  #include "encoder.h"
  #include "l3psy.h"
  #include "mdct.h"
  #include "loop.h"
  #include "l3bitstream.h"
! #include <assert.h>
  
- /* Global variable definitions for "musicin.c" */
  
! FILE               *musicin;
! Bit_stream_struc   bs;
! char               *programName;
  
- /* Implementations */
  
! /************************************************************************
! *
! * obtain_parameters
! *
! * PURPOSE:  Prompts for and reads user input for encoding parameters
! *
! * SEMANTICS:  The parameters read are:
! * - input and output filenames
! * - sampling frequency (if AIFF file, will read from the AIFF file header)
! * - layer number
! * - mode (stereo, joint stereo, dual channel or mono)
! * - psychoacoustic model (I or II)
! * - total bitrate, irrespective of the mode
! * - de-emphasis, error protection, copyright and original or copy flags
! *
! ************************************************************************/
  
- void
- obtain_parameters(fr_ps,psy,num_samples,original_file_name,encoded_file_name)
- frame_params    *fr_ps;
- int             *psy;
- unsigned long   *num_samples;
- char            original_file_name[MAX_NAME_SIZE];
- char            encoded_file_name[MAX_NAME_SIZE];
- {
-     int j;
-     long int freq;
-     int model, brt;
-     char t[50];
-     IFF_AIFF pcm_aiff_data;
-     layer *info = fr_ps->header;
-     long soundPosition;
- #ifdef  MS_DOS
-     char temp_str[MAX_NAME_SIZE];
- #endif 
- 
-     do  {
-        printf("Enter PCM input file name <required>: ");
-        gets(original_file_name);
-        if (original_file_name[0] == NULL_CHAR)
-        printf("PCM input file name is required.\n");
-     } while (original_file_name[0] == NULL_CHAR);
-     printf(">>> PCM input file name is: %s\n", original_file_name);
-  
-     if ((musicin = fopen(original_file_name, "rb")) == NULL) {
-        printf("Could not find \"%s\".\n", original_file_name);
-        exit(1);
-     }
  
! #ifdef  MS_DOS
!     /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
!     new_ext(original_file_name, DFLT_EXT, temp_str);
!     printf("Enter MPEG encoded output file name <%s>: ",
!            temp_str);
! #else
!     printf("Enter MPEG encoded output file name <%s%s>: ",
!            original_file_name, DFLT_EXT);
! #endif
!  
!     gets(encoded_file_name);
!     
!     if (encoded_file_name[0] == NULL_CHAR) {
! #ifdef  MS_DOS
!   strcpy(encoded_file_name, temp_str);
! #else
!         strcat(strcpy(encoded_file_name, original_file_name), DFLT_EXT);
  #endif
!     }
!         
  
-     printf(">>> MPEG encoded output file name is: %s\n", encoded_file_name);
-  
-     open_bit_stream_w(&bs, encoded_file_name, BUFFER_SIZE);
-  
-     if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
  
-        printf(">>> Using Audio IFF sound file headers\n");
  
-        aiff_check(original_file_name, &pcm_aiff_data, &info->version);
  
!        if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
!           printf("Could not seek to PCM sound data in \"%s\".\n",
!                  original_file_name);
!           exit(1);
!        }
! 
!        info->sampling_frequency =
!       SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
!        printf(">>> %f Hz sampling frequency selected\n",
!               pcm_aiff_data.sampleRate);
! 
!        /* Determine number of samples in sound file */
! #ifndef MS_DOS
!        *num_samples = pcm_aiff_data.numChannels *
!                       pcm_aiff_data.numSampleFrames;
  #else
!        *num_samples = (long)(pcm_aiff_data.numChannels) *
!                       (long)(pcm_aiff_data.numSampleFrames);
  #endif
  
-     }
-     else {    /* Not using Audio IFF sound file headers. */
  
-        printf("What is the sampling frequency? <44100>[Hz]: ");
-        gets(t);
-        freq = atol(t);
-        switch (freq) {
-           case 48000 : info->sampling_frequency = 1;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 44100 : info->sampling_frequency = 0;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 32000 : info->sampling_frequency = 2;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 24000 : info->sampling_frequency = 1;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 22050 : info->sampling_frequency = 0;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 16000 : info->sampling_frequency = 2;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           default:    info->sampling_frequency = 0;
-               printf(">>> Default 44.1 kHz samp freq selected\n");
-        }
-        printf(">>> Encoding algorithm is %s\n", version_names[info->version]);
-        if (fseek(musicin, 0, SEEK_SET) != 0) {
-           printf("Could not seek to PCM sound data in \"%s\".\n",
-                   original_file_name);
-           exit(1);
-        }
-  
-        /* Declare sound file to have "infinite" number of samples. */
-        *num_samples = MAX_U_32_NUM;
  
-     }
  
-     printf("Which layer do you want to use?\n");
-     printf("Available: Layer (1), Layer (<2>), Layer (3): ");
-     gets(t);
-     switch(*t){
-        case '1': info->lay = 1; printf(">>> Using Layer %s\n",t); break;
-        case '2': info->lay = 2; printf(">>> Using Layer %s\n",t); break;
-      case '3': info->lay = 3; printf(">>> Using Layer %s\n",t); break;
-        default:  info->lay = 2; printf(">>> Using default Layer 2\n"); break;
-     }
- 
-     printf("Which mode do you want?\n");
-     printf("Available: (<s>)tereo, (j)oint stereo, ");
-     printf("(d)ual channel, s(i)ngle Channel: ");
-     gets(t);
-     switch(*t){
-        case 's':
-        case 'S':
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'j':
-        case 'J':
-           info->mode = MPG_MD_JOINT_STEREO;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'd':
-        case 'D':
-           info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'i':
-        case 'I':
-           info->mode = MPG_MD_MONO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        default:
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using default stereo mode\n");
-           break;
-     }
- 
-     printf("Which psychoacoustic model do you want to use? <1>: ");
-     gets(t);
-     model = atoi(t);
-     if (model > 2 || model < 1) {
-        printf(">>> Default model 1 selected\n");
-        *psy = 1;
-     }
-     else {
-        *psy = model;
-        printf(">>> Using psychoacoustic model %d\n", model);
-     }
-     
-     /* set default bitrate to highest allowed, which is index 14 */
-   brt = bitrate[info->version][info->lay-1][14];
-     printf( "What is the total bitrate? <%u>[kbps]: ", brt );
-     gets( t );
-     brt = atoi( t );
-     if ( brt == 0 )
-       j = 15;
-     else
-       j = 0;
-     while ( j < 15 )
-     {
-     if ( bitrate[info->version][info->lay-1][j] == brt )
-           break;
-     j++;
-     }
-     if ( j == 15 )
-     {
-     brt = bitrate[info->version][info->lay-1][14];
-         printf( ">>> Using default %u kbps\n", brt );
-         info->bitrate_index = 14;
-     }
-     else
-     {
-        info->bitrate_index = j;
-        printf( ">>> Bitrate = %d kbps\n", bitrate[info->version][info->lay-1][j] );
-     }
-  
-     printf("What type of de-emphasis should the decoder use?\n");
-     printf("Available: (<n>)one, (5)0/15 microseconds, (c)citt j.17: ");
-     gets(t);
-     if (*t != 'n' && *t != '5' && *t != 'c') {
-        printf(">>> Using default no de-emphasis\n");
-        info->emphasis = 0;
-     }
-     else {
-        if (*t == 'n')      info->emphasis = 0;
-        else if (*t == '5') info->emphasis = 1;
-        else if (*t == 'c') info->emphasis = 3;
-        printf(">>> Using de-emphasis %s\n",t);
-     }
-  
- /*  Start 2. Part changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want to set the private bit? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->extension = 1;
-     else                        info->extension = 0;
-     if(info->extension) printf(">>> Private bit set\n");
-     else                printf(">>> Private bit not set\n");
-  
- /*  End changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want error protection? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->error_protection = TRUE;
-     else                        info->error_protection = FALSE;
-     if(info->error_protection) printf(">>> Error protection used\n");
-     else printf(">>> Error protection not used\n");
-  
-     printf("Is the material copyrighted? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->copyright = 1;
-     else                        info->copyright = 0;
-     if(info->copyright) printf(">>> Copyrighted material\n");
-     else                printf(">>> Material not copyrighted\n");
-  
-     printf("Is this the original? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->original = 1;
-     else                        info->original = 0;
-     if(info->original) printf(">>> Original material\n");
-     else               printf(">>> Material not original\n");
-  
-     printf("Do you wish to exit (last chance before encoding)? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') exit(0);
- }
  
  /************************************************************************
  *
--- 13,168 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
! #include <sys/types.h>
! #include <sys/stat.h>
! #include <sys/times.h>
! #include <fcntl.h>
  #include <stdlib.h>
+ #include <time.h>
+ #include <assert.h>
+ #ifdef _WIN32
+ #include <io.h> 
+ #endif
+ #ifdef __FreeBSD__
+ #include <floatingpoint.h>
+ #endif
+ #ifdef ABORTFP
+ #include <fpu_control.h>
+ #endif
+ 
  #include "common.h"
+ #include "globalflags.h"
  #include "encoder.h"
  #include "l3psy.h"
  #include "mdct.h"
  #include "loop.h"
  #include "l3bitstream.h"
! #include "gtkanal.h"
! #include "version.h"
! #include "VbrTag.h"
! #include "wavheader.h"
! #ifdef LIBSNDFILE
! #include "get_audio.h"
! #endif
  
  
! /* Global flags.  set defaults here, defined extern in common.h */
! int autoconvert=FALSE;
! int force_ms=FALSE;
! int gpsycho=1;
! int sfb21=1;
! int experimentalX = 0;
! int experimentalY = 0;
! int experimentalZ = 0;
! int VBR=0;
! int VBR_q=4;
! int VBR_min_bitrate=6;   /* 80kbs */
! int VBR_max_bitrate=13;  /* 256kbs */
! #ifdef _BLADEDLL
! int silent=1;
! #else
! int silent=0;
! #endif
! int highq=0;
! int fast_mode=0;
! int allow_diff_short=0;
! #ifdef DISTRIB
! int gtkflag=1;
! #else
! int gtkflag=0;
! #endif
! int g_bWriteVbrTag=1;
  
  
! void usage();
  
  
! 
! /* Global variable definitions for "musicin.c" */
! struct stat sb;
! int firstcall = 1; /* define like this so Dll/BladeMP3EncDll.c can change value */
! int target_bitrate;
! long totalframes;
! int swapbytes = FALSE; /* force byte swapping */
! FILE               *musicin;
! Bit_stream_struc   bs;
! char               *programName;
! int iswav=0;
! III_side_info_t l3_side;
! frame_params fr_ps;
! unsigned long num_samples;
! int frameNum=0;
! #ifdef HAVEGTK
! static int MPGLAG=1;
  #endif
! int original_file_type;  /* 0=WAV, 1=MP3 */
! int original_file_fd;    /* file descriptor */
! 
  
  
  
  
! /*********************************************************/
! /* Timeconvert: convert given time (in secs) to hh:mm:ss */
! /*********************************************************/
! void timestatus(int frameNum, int totalframes, int samp_rate)
! {   
!   clock_t time_so_far;
!   clock_t remain, estimated;
!   double speedup;
!   static int firstcall=1;
!   static clock_t last_clock_value=0,reference_clock_value=0;
!   clock_t clock_value;
!   static int accum_time=0;
!   struct tms tms_buf;
!   static divider;
!   if (firstcall) {
!     reference_clock_value = times(&tms_buf);
! #ifdef CLK_TCK
!     divider=CLK_TCK;
  #else
!     divider= HZ;         /* for old BSD systems */
  #endif
+     /*    divider=CLOCKS_PER_SEC;   */  /* used with clock() */
+     firstcall=0;
+   }
+ 
+ 
+   /*  clock_value = clock();*/     /* cpu time */
+   clock_value = times(&tms_buf);   /* wall clock more usefull than cpu time */
+ 
+   if ((clock_value<0 && last_clock_value>0) ||
+       (clock_value>0 && last_clock_value<0)) {
+     accum_time+=(last_clock_value-reference_clock_value)/divider;
+     accum_time+=(clock_value-last_clock_value)/divider;
+     reference_clock_value=clock_value;
+   }
+   last_clock_value = clock_value;
+   time_so_far = (clock_value-reference_clock_value)/divider + accum_time;
+ 
+   /* calc estimated total CPU time */
+   estimated = (int)((float)totalframes/(float)frameNum*(float)time_so_far);
+   remain = estimated - time_so_far;
+ 
+   /* estimated encoding time / playing time.  (protected from divide by 0) */
+   if (samp_rate*estimated) {
+     speedup = (totalframes*1.152)/(samp_rate*estimated);
+   }
+   else {
+     speedup = 0.0;
+   }
+ 
+  fprintf(stderr,
+   "Frame: [%4d/%4d]   Encoding Time %02d:%02d/%02d:%02d  (%.2fx)   ETA %02d:%02d\r",
+   frameNum, totalframes, (int)((time_so_far/60)),(int)( time_so_far%60),
+   (int)((estimated/60)),(int)( estimated%60), speedup, 
+   (int) ( (remain/60)), (int)( remain%60));
+   fflush(stderr);
+ }
  
  
  
  
  
  /************************************************************************
  *
***************
*** 405,423 ****
  * command line.  Default settings are used for parameters
  * not specified in the command line.
  *
- * SEMANTICS:  The command line is parsed according to the following
- * syntax:
- *
- * -l  is followed by the layer number
- * -m  is followed by the mode
- * -p  is followed by the psychoacoustic model number
- * -s  is followed by the sampling rate
- * -b  is followed by the total bitrate, irrespective of the mode
- * -d  is followed by the emphasis flag
- * -c  is followed by the copyright/no_copyright flag
- * -o  is followed by the original/not_original flag
- * -e  is followed by the error_protection on/off flag
- *
  * If the input file is in AIFF format, the sampling frequency is read
  * from the AIFF header.
  *
--- 172,177 ----
***************
*** 435,661 ****
  char    inPath[MAX_NAME_SIZE];
  char    outPath[MAX_NAME_SIZE];
  {
!    FLOAT srate;
!    int   brate;
!    layer *info = fr_ps->header;
!    int   err = 0, i = 0;
!    IFF_AIFF pcm_aiff_data;
!    long samplerate;
!    long soundPosition;
!  
!    /* preset defaults */
!    inPath[0] = '\0';   outPath[0] = '\0';
!    info->lay = DFLT_LAY;
!    switch(DFLT_MOD) {
!       case 's': info->mode = MPG_MD_STEREO; info->mode_ext = 0; break;
!       case 'd': info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; break;
!       case 'j': info->mode = MPG_MD_JOINT_STEREO; break;
!       case 'm': info->mode = MPG_MD_MONO; info->mode_ext = 0; break;
!       default:
!          fprintf(stderr, "%s: Bad mode dflt %c\n", programName, DFLT_MOD);
!          abort();
!    }
!    *psy = DFLT_PSY;
!    if((info->sampling_frequency = SmpFrqIndex((long)(1000*DFLT_SFQ), &info->version)) < 0) {
!       fprintf(stderr, "%s: bad sfrq default %.2f\n", programName, DFLT_SFQ);
!       abort();
!    }
!   info->bitrate_index = 14;
    brate = 0;
!    switch(DFLT_EMP) {
!       case 'n': info->emphasis = 0; break;
!       case '5': info->emphasis = 1; break;
!       case 'c': info->emphasis = 3; break;
!       default: 
!          fprintf(stderr, "%s: Bad emph dflt %c\n", programName, DFLT_EMP);
!          abort();
!    }
!    info->copyright = 0; info->original = 0; info->error_protection = FALSE;
!  
!    /* process args */
!    while(++i<argc && err == 0) {
!       char c, *token, *arg, *nextArg;
!       int  argUsed;
!  
!       token = argv[i];
!       if(*token++ == '-') {
!          if(i+1 < argc) nextArg = argv[i+1];
!          else           nextArg = "";
!          argUsed = 0;
!          while( (c = *token++) ) {
!             if(*token /* NumericQ(token) */) arg = token;
!             else                             arg = nextArg;
!             switch(c) {
!                case 'l':        info->lay = atoi(arg); argUsed = 1;
!                   if(info->lay<1 || info->lay>3) {
!                      fprintf(stderr,"%s: -l layer must be 1, 2, or 3, not %s\n",
!                           programName, arg);
!                      err = 1;
!                   }
!                   break;
!                case 'm':        argUsed = 1;
!                   if (*arg == 's')
!                     { info->mode = MPG_MD_STEREO; info->mode_ext = 0; }
!                   else if (*arg == 'd')
!                     { info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; }
!                   else if (*arg == 'j')
!                     { info->mode = MPG_MD_JOINT_STEREO; }
!                   else if (*arg == 'm')
!                     { info->mode = MPG_MD_MONO; info->mode_ext = 0; }
!                   else {
!                     fprintf(stderr,"%s: -m mode must be s/d/j/m not %s\n",
!                             programName, arg);
!                     err = 1;
!                   }
!                   break;
!                case 'p':        *psy = atoi(arg); argUsed = 1;
!                   if(*psy<1 || *psy>2) {
!                      fprintf(stderr,"%s: -p model must be 1 or 2, not %s\n",
!                              programName, arg);
!                      err = 1;
!                   }
!                   break;
! 
!                case 's':
!                   argUsed = 1;
!                   srate = atof( arg );
!                   /* samplerate = rint( 1000.0 * srate ); $A  */
!                   samplerate = (long) (( 1000.0 * srate ) + 0.5);
!                   if( (info->sampling_frequency =
!           SmpFrqIndex((long) samplerate, &info->version)) < 0 )
!                       err = 1;
!                   break;
!                   
!                case 'b':        
!         argUsed = 1;
!       brate = atoi(arg); 
!       break;
!                case 'd':        argUsed = 1;
!                   if (*arg == 'n')                    info->emphasis = 0;
!                   else if (*arg == '5')               info->emphasis = 1;
!                   else if (*arg == 'c')               info->emphasis = 3;
!                   else {
!                      fprintf(stderr,"%s: -d emp must be n/5/c not %s\n",
!                              programName, arg);
!                      err = 1;
!                   }
!                   break;
!                 case 'c':       info->copyright = 1; break;
!                 case 'o':       info->original  = 1; break;
!                 case 'e':       info->error_protection = TRUE; break;
!                 default:        fprintf(stderr,"%s: unrec option %c\n",
!                                         programName, c);
!                                 err = 1; break;
!             }
!             if(argUsed) {
!                if(arg == token)    token = "";   /* no more from token */
!                else                ++i;          /* skip arg we used */
!                arg = ""; argUsed = 0;
!             }
!          }
        }
        else {
!          if(inPath[0] == '\0')       strcpy(inPath, argv[i]);
!          else if(outPath[0] == '\0') strcpy(outPath, argv[i]);
!          else {
!             fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
!             err = 1;
!          }
        }
!    }
  
!    if(err || inPath[0] == '\0') usage();  /* never returns */
!  
!    if(outPath[0] == '\0') {
! #ifdef MS_DOS
!       /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
!       new_ext(inPath, DFLT_EXT, outPath);
! #else
        strcpy(outPath, inPath);
        strcat(outPath, DFLT_EXT);
! #endif
!    }
! 
!    if ((musicin = fopen(inPath, "rb")) == NULL) {
!       printf("Could not find \"%s\".\n", inPath);
        exit(1);
!    }
!  
!    open_bit_stream_w(&bs, outPath, BUFFER_SIZE);
  
-    if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
  
!       printf(">>> Using Audio IFF sound file headers\n");
  
        aiff_check(inPath, &pcm_aiff_data, &info->version);
- 
        if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
!          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
!          exit(1);
        }
- 
        info->sampling_frequency = SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
!       printf(">>> %f Hz sampling frequency selected\n",
!              pcm_aiff_data.sampleRate);
! 
        /* Determine number of samples in sound file */
- #ifndef MS_DOS
-       *num_samples = pcm_aiff_data.numChannels *
-                      pcm_aiff_data.numSampleFrames;
- #else
        *num_samples = (long)(pcm_aiff_data.numChannels) *
!                      (long)(pcm_aiff_data.numSampleFrames);
! #endif
        if ( pcm_aiff_data.numChannels == 1 ) {
!         info->mode = MPG_MD_MONO;
!         info->mode_ext = 0;
        }
!    }
!    else {    /* Not using Audio IFF sound file headers. */
  
!       if (fseek(musicin, 0, SEEK_SET) != 0) {
!          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
!          exit(1);
        }
!  
!       /* Declare sound file to have "infinite" number of samples. */
!       *num_samples = MAX_U_32_NUM;
  
!    }
!    if ( brate == 0 )
!     brate = bitrate[info->version][info->lay-1][14];
!    if( (info->bitrate_index = BitrateIndex(info->lay, brate, info->version)) < 0) err=1;
!    if(err || inPath[0] == '\0') usage();  /* never returns */
  
  }
  
  /************************************************************************
! *
! * print_config
! *
! * PURPOSE:  Prints the encoding parameters used
! *
! ************************************************************************/
!  
  void print_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
  {
!  layer *info = fr_ps->header;
!  
!    printf("Encoding configuration:\n");
!    printf("Algorithm=%s\n", version_names[info->version]);
!    if(info->mode != MPG_MD_JOINT_STEREO)
!       printf("Layer=%s   mode=%s   extn=%d   psy model=%d\n",
!              layer_names[info->lay-1], mode_names[info->mode],
!              info->mode_ext, *psy);
!    else printf("Layer=%s   mode=%s   extn=data dependant   psy model=%d\n",
!                layer_names[info->lay-1], mode_names[info->mode], *psy);
!    printf("samp frq=%.1f kHz   total bitrate=%d kbps\n",
!           s_freq[info->version][info->sampling_frequency],
!           bitrate[info->version][info->lay-1][info->bitrate_index]);
!    printf("de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",
!           info->emphasis, info->copyright, info->original,
!           ((info->error_protection) ? "on" : "off"));
!    printf("input file: '%s'   output file: '%s'\n", inPath, outPath);
  }
  
  
--- 189,1020 ----
  char    inPath[MAX_NAME_SIZE];
  char    outPath[MAX_NAME_SIZE];
  {
!   FLOAT srate;
!   int   brate;
!   layer *info = fr_ps->header;
!   int   err = 0, i = 0;
!   int mode_given=0;
! #ifndef LIBSNDFILE
!   IFF_AIFF pcm_aiff_data;
!   long soundPosition;
!   char ckwav[5]={0,0,0,0,0};
! #endif
!   long samplerate;
!   WaveHeader wavhead;
!   
!   /* preset defaults */
!   inPath[0] = '\0';   outPath[0] = '\0';
!   info->lay = DFLT_LAY;
!   switch(DFLT_MOD) {
!   case 's': info->mode = MPG_MD_STEREO; info->mode_ext = 0; break;
!   case 'd': info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; break;
!   case 'j': info->mode = MPG_MD_JOINT_STEREO; info->mode_ext=0; break;
!   case 'm': info->mode = MPG_MD_MONO; info->mode_ext = 0; break;
!   default:
!     fprintf(stderr, "%s: Bad mode dflt %c\n", programName, DFLT_MOD);
!     abort();
!   }
!   *psy = DFLT_PSY;
!   if((info->sampling_frequency = SmpFrqIndex((long)(1000*DFLT_SFQ), &info->version)) < 0) {
!     fprintf(stderr, "%s: bad sfrq default %.2f\n", programName, DFLT_SFQ);
!     abort();
!   }
!   info->bitrate_index = 9;
    brate = 0;
!   switch(DFLT_EMP) {
!   case 'n': info->emphasis = 0; break;
!   case '5': info->emphasis = 1; break;
!   case 'c': info->emphasis = 3; break;
!   default: 
!     fprintf(stderr, "%s: Bad emph dflt %c\n", programName, DFLT_EMP);
!     abort();
!   }
!   info->copyright = 0;
!   info->original = 1;
!   info->error_protection = FALSE;
!   
!   /* process args */
!   while(++i<argc && err == 0) {
!     char c, *token, *arg, *nextArg;
!     int  argUsed;
!     
!     token = argv[i];
!     if(*token++ == '-') {
!       if(i+1 < argc) nextArg = argv[i+1];
!       else           nextArg = "";
!       argUsed = 0;
!       if (! *token) {
! 	/* The user wants to use stdin and/or stdout. */
! 	if(inPath[0] == '\0')       strcpy(inPath, argv[i]);
! 	else if(outPath[0] == '\0') strcpy(outPath, argv[i]);
!       } 
!       while( (c = *token++) ) {
! 	if(*token ) arg = token;
! 	else                             arg = nextArg;
! 	switch(c) {
! 	case 'm':        argUsed = 1;
! 	  mode_given=1;
! 	  if (*arg == 's')
! 	    { info->mode = MPG_MD_STEREO; info->mode_ext = 0; }
! 	  else if (*arg == 'd')
! 	    { info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; }
! 	  else if (*arg == 'j')
! 	    { info->mode = MPG_MD_JOINT_STEREO; info->mode_ext=0; }
! 	  else if (*arg == 'f')
! 	    { info->mode = MPG_MD_JOINT_STEREO; force_ms=1; info->mode_ext=0; }
! 	  else if (*arg == 'm')
! 	    { info->mode = MPG_MD_MONO; info->mode_ext = 0; }
! 	  else {
! 	    fprintf(stderr,"%s: -m mode must be s/d/j/f/m not %s\n",
! 		    programName, arg);
! 	    err = 1;
! 	  }
! 	  break;
! 	case 'V':        argUsed = 1;   VBR = 1;
! 	  if (*arg == '0')
! 	    { VBR_q=0; }
! 	  else if (*arg == '1')
! 	    { VBR_q=1; }
! 	  else if (*arg == '2')
! 	    { VBR_q=2; }
! 	  else if (*arg == '3')
! 	    { VBR_q=3; }
! 	  else if (*arg == '4')
! 	    { VBR_q=4; }
! 	  else if (*arg == '5')
! 	    { VBR_q=5; }
! 	  else if (*arg == '6')
! 	    { VBR_q=6; }
! 	  else if (*arg == '7')
! 	    { VBR_q=7; }
! 	  else if (*arg == '8')
! 	    { VBR_q=8; }
! 	  else if (*arg == '9')
! 	    { VBR_q=9; }
! 	  else {
! 	    fprintf(stderr,"%s: -V n must be 0-9 not %s\n",
! 		    programName, arg);
! 	    err = 1;
! 	  }
! 	  break;
! 	  
! 	case 's':
! 	  argUsed = 1;
! 	  srate = atof( arg );
! 	  /* samplerate = rint( 1000.0 * srate ); $A  */
! 	  samplerate = (long) (( 1000.0 * srate ) + 0.5);
! 	  if( (info->sampling_frequency =
! 	       SmpFrqIndex((long) samplerate, &info->version)) < 0 )
! 	    err = 1;
! 	  break;
! 	  
! 	case 'b':        
! 	  argUsed = 1;
! 	  brate = atoi(arg); 
! 	  break;
! 
! // AF ADDED
! 	case 't':  /* write VBR tag */
! 		g_bWriteVbrTag=0;
! 	  break;
! // AF END
! 
! 	case 'x':  /* force byte swapping */
! 	  swapbytes=TRUE;
! 	  break;
! 	case 'p': /* (jo) error_protection: add crc16 information to stream */
! 	  info->error_protection = 1; 
! 	  break;
! 	case 'a': /* autoconvert input file from stereo to mono - for mono mp3 encoding */
! 	  autoconvert = TRUE;
! 	  break;
! 	case 'h': 
! 	  highq = TRUE;
! 	  break;
! 	case 'k': 
! 	  sfb21 = FALSE;
! 	  break;
! 	case 'd': 
! 	  allow_diff_short = 1;
! 	  break;
! 	case 'v': 
! 	  VBR = 1;
! 	  break;
! 	case 'S': 
! 	  silent = TRUE;
! 	  break;
! 	case 'X': 
! 	  experimentalX = TRUE;
! 	  break;
! 	case 'Y': 
! 	  experimentalY = TRUE;
! 	  break;
! 	case 'Z': 
! 	  experimentalZ = TRUE;
! 	  break;
! 	case 'f': 
! 	  fast_mode = TRUE;
! 	  break;
! #ifdef HAVEGTK
! 	case 'g': /* turn on gtk analysis */
! 	  gtkflag = TRUE;
! 	  break;
! #endif
! 	case 'e':        argUsed = 1;
! 	  if (*arg == 'n')                    info->emphasis = 0;
! 	  else if (*arg == '5')               info->emphasis = 1;
! 	  else if (*arg == 'c')               info->emphasis = 3;
! 	  else {
! 	    fprintf(stderr,"%s: -e emp must be n/5/c not %s\n",
! 		    programName, arg);
! 	    err = 1;
! 	  }
! 	  break;
! 	case 'c':       info->copyright = 1; break;
! 	case 'o':       info->original  = 0; break;
! 	default:        fprintf(stderr,"%s: unrec option %c\n",
! 				programName, c);
! 	err = 1; break;
! 	}
! 	if(argUsed) {
! 	  if(arg == token)    token = "";   /* no more from token */
! 	  else                ++i;          /* skip arg we used */
! 	  arg = ""; argUsed = 0;
! 	}
        }
+     }
+     else {
+       if(inPath[0] == '\0')       strcpy(inPath, argv[i]);
+       else if(outPath[0] == '\0') strcpy(outPath, argv[i]);
        else {
! 	fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
! 	err = 1;
        }
!     }
!   }
  
!   // Do not write VBR tag if VBR flag is not specified
!   if (g_bWriteVbrTag==1 && VBR==0) g_bWriteVbrTag=0;
! 
!   if(err || inPath[0] == '\0') usage();  /* never returns */
!   if (inPath[0]=='-') silent=1;  /* turn off status - it's broken for stdin */
!   if(outPath[0] == '\0') {
!     if (inPath[0]=='-') {
!       /* if input is stdin, default output is stdout */
!       strcpy(outPath,"-");
!     }else {
        strcpy(outPath, inPath);
        strcat(outPath, DFLT_EXT);
!     }
!   }
!   if (outPath[0]=='-') g_bWriteVbrTag=0; /* turn off VBR tag */
!   
!   // SPECIAL FOR BLADE ENCODER
! #ifdef _BLADEDLL
!   open_bit_stream_w(&bs, outPath, BUFFER_SIZE);
!   
! #else
!   // are we encoding to .mp3, or analyzing a .mp3 file:
!   original_file_type=!(strcmp((char *) &inPath[strlen(inPath)-4],".mp3"));
!   
!   if (original_file_type)    {
!     /* MP3 file.  */
!     totalframes = -1;
!     original_file_fd = open(inPath,O_RDONLY);
!     if (original_file_fd == -1) {
!       fprintf(stderr,"Could not find \"%s\".\n", inPath);
        exit(1);
!     }
!     if (!gtkflag) {
!       fprintf(stderr,"Use option -g to analyze mp3 files.\n");
!       exit(1);
!     }
!      
!   }else{
!     /* open the output file */
! #ifdef DISTRIB
!     outPath="/dev/null";
! #endif
!     open_bit_stream_w(&bs, outPath, BUFFER_SIZE);
  
  
!     
!     /**************************************************************************/
!     /* new code which uses LIBSNDFILE                                         */
!     /**************************************************************************/
! #ifdef LIBSNDFILE
!     if (!strcmp(inPath, "-"))
!       {
! 	/* Read from standard input. */
! 	/* so do not open libsnd */
!       } 
!     else
!       {
! 	// Open snd File
! 	OpenSndFile(inPath);
! 	
! 	// Set sample frequency
! 	info->sampling_frequency = SmpFrqIndex(GetSndSampleRate(), &info->version);
! 	
! 	if (GetSndChannels()==1)
! 	  {
! 	    info->mode = MPG_MD_MONO;
! 	    info->mode_ext = 0;
! 	  }
! 	
! 	/* Declare sound file to have "infinite" number of samples. */
! 	*num_samples = MAX_U_32_NUM;
!       }
  
+ #else
+     /***********************************************************************/
+     /* old code with native AIFF, PCM and WAV support                      */
+     /***********************************************************************/
+ 
+     /* Declare sound file to have "infinite" number of samples */
+     /* as long as we do not know more about the file... */
+     *num_samples = MAX_U_32_NUM;
+ 
+     if (!strcmp(inPath, "-")) {
+       /* Read from standard input. */
+       musicin = stdin;
+     } else {
+       if ((musicin = fopen(inPath, "rb")) == NULL) {
+ 	fprintf(stderr, "Could not find \"%s\".\n", inPath);
+ 	exit(1);
+       }
+     }
+     if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
+       fprintf(stderr, "Found Audio IFF sound file headers: ");
        aiff_check(inPath, &pcm_aiff_data, &info->version);
        if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
! 	fprintf(stderr,"Could not seek to PCM sound data in \"%s\".\n",inPath);
! 	fprintf(stderr,"Crossing Fingers.....\n");
        }
        info->sampling_frequency = SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
!       fprintf(stderr, "%.1f kHz samples\n",
! 	      pcm_aiff_data.sampleRate/1000);
        /* Determine number of samples in sound file */
        *num_samples = (long)(pcm_aiff_data.numChannels) *
! 	(long)(pcm_aiff_data.numSampleFrames);
        if ( pcm_aiff_data.numChannels == 1 ) {
! 	info->mode = MPG_MD_MONO;
! 	info->mode_ext = 0;
!       }
!     } else {    /* Not using Audio IFF sound file headers. */
!       if (fseek(musicin, 8, SEEK_SET) != 0) {
! 	fprintf(stderr,"Could not seek to PCM sound data in \"%s\".\n",inPath);
! 	fprintf(stderr,"Crossing Fingers.....\n");
        }
!       fread(ckwav, 4, 1, musicin);
  
!       if (strncmp(ckwav, "WAVE",4)==0) {
! 	iswav = 1;
! 	{
! 	  fseek(musicin, 0, SEEK_SET);
! 	  fread(&wavhead,sizeof(WaveHeader),1,musicin);
! 	  if (DetermineByteOrder()==order_bigEndian) 
! 	    endswap_wave_fmt(&wavhead);
! 	  fprintf(stderr,"Found WAV header:  %3.1fkHz %s\n",
! 		  wavhead.sample_fq/1000.0,
! 		  (wavhead.modus==WAVE_MONO ? "mono" : "stereo"));
! 	  /*
! 	  fprintf(stderr," Format: %s\n",wavhead.format==PCM_CODE ? "PCM" : "unknown");
! 	  fprintf(stderr," Mode  : %s\n",wavhead.modus==WAVE_STEREO ? "stereo" : "mono");
! 	  fprintf(stderr," Freq  : %d\n",wavhead.sample_fq);
! 	  fprintf(stderr," Bits  : %d\n",wavhead.bit_p_spl);
! 	  fprintf(stderr," Len   : %d\n",wavhead.data_length);
! 	  fprintf(stderr," FLen  : %d\n",wavhead.length);
! 	  */
! 	  if (wavhead.bit_p_spl != 16) {
! 	    fprintf(stderr," Bits  : %d not supported!\n",wavhead.bit_p_spl);
! 	    exit(1);
! 	  }
! 
! 	  
! 	  if (wavhead.modus==WAVE_MONO) {
! 	    info->mode = MPG_MD_MONO;
! 	    info->mode_ext = 0;
! 	  }
! 	  info->sampling_frequency = 
! 	    SmpFrqIndex((long)wavhead.sample_fq, &info->version);
! 	  *num_samples = (wavhead.length / (wavhead.bit_p_spl / 8)) * (wavhead.modus==WAVE_STEREO ? 2 : 1);
! 	}
        }
!       else {
! 	fseek(musicin, 0, SEEK_SET);
! 	fprintf(stderr, "Assuming raw pcm input file");
! 	if (swapbytes==TRUE)
! 	  fprintf(stderr, " : Forcing byte-swapping\n");
! 	else
! 	  fprintf(stderr, "\n");
!       }
!     }  
! #endif  /* NO LIBSNDFILE */
!   } // MP3 or PCM file?
! #endif   /* BLADEDLL*/
  
! // AF ADDED
!   	if (g_bWriteVbrTag)
! 	{
! 		// Write initial VBR Header to bitstream
! 		InitVbrTag(&bs,info->version-1,info->mode,info->sampling_frequency);
! 	}
! // AF END
!   
!   
!   /* Timing, autoconvert and resampling checks and setup */
!   /* dont do this if analyzing a mp3 file */
!   if (!original_file_type)    {
!     stat(inPath,&sb);
!     totalframes = sb.st_size/4608;
!     if ((info->mode == MPG_MD_MONO)&&(autoconvert==FALSE))
!       totalframes *= 2;
!     if (autoconvert==TRUE) {
!       fprintf(stderr, "Autoconverting from stereo to mono. Setting encoding to mono mode.\n");
!       info->mode = MPG_MD_MONO; 
!       info->mode_ext = 0;
!     }
!   }
!   
!   
!   if ( brate == 0 ) {
!     brate = bitrate[info->version][info->lay-1][9];
!     info->bitrate_index=9;
!   } else {
!     if( (info->bitrate_index = BitrateIndex(info->lay, brate, info->version)) < 0)
!       err=1;
!     /* a bit rate was specified.  for VBR, take this to be the minimum */
!     VBR_min_bitrate=info->bitrate_index;
!   }
!   if ((!mode_given) && (brate >= 192)) {
!     /* default is STEREO for higher bitrates, not JSTEREO */
!     if (info->mode != MPG_MD_MONO){
!       info->mode = MPG_MD_STEREO; info->mode_ext = 0;
!     }
!   }
  
+ 
+ 
+   if(err || inPath[0] == '\0') usage();  /* never returns */
+   if (info->bitrate_index==14) VBR=0;  /* dont bother with VBR at 320kbs */
+   /* we do not normally allow 320bps frams with VBR, unless: */
+   if (info->bitrate_index==13) VBR_max_bitrate=14;  
+   if (VBR_q == 0) VBR_max_bitrate=14;  
+   if (VBR) fast_mode = FALSE; 
+   /* MPEG2 specific requirements */
+   if (info->version==0) {
+     totalframes *= 2;
+     g_bWriteVbrTag=0;      /* no MPEG2 Xing VBR tags yet */
+   }
  }
  
+ 
+ 
+ 
  /************************************************************************
!  *
!  * print_config
!  *
!  * PURPOSE:  Prints the encoding parameters used
!  *
!  ************************************************************************/
  void print_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
  {
!   layer *info = fr_ps->header;
! #if 0 
!   fprintf(stderr, "Encoding configuration:\n");
!   fprintf(stderr, "Algorithm=%s\n", version_names[info->version]);
!   if(info->mode != MPG_MD_JOINT_STEREO)
!     fprintf(stderr, "Layer=III   mode=%s   extn=%d   psy model=%d\n",
! 	    mode_names[info->mode], info->mode_ext, *psy);
!   else fprintf(stderr, "Layer=III   mode=%s   extn=data dependant   psy model=%d\n",
! 	       mode_names[info->mode], *psy);
!   fprintf(stderr, "samp frq=%.1f kHz   total bitrate=%d kbps\n",
! 	  s_freq[info->version][info->sampling_frequency],
! 	  bitrate[info->version][info->lay-1][info->bitrate_index]);
!   fprintf(stderr, "de-emph=%d   c/right=%d   orig=%d\n",
! 	  info->emphasis, info->copyright, info->original);
!   fprintf(stderr, "input file: '%s'   output file: '%s'\n", inPath, outPath);
! #endif
!   if (original_file_type) {
!     fprintf(stderr, "Analyzing %s \n",inPath);
!   }
!   else {
!     fprintf(stderr, "Encoding %s to %s\n",
! 	    (strcmp(inPath, "-")? inPath : "stdin"),
! 	    (strcmp(outPath, "-")? outPath : "stdout"));
!     if (VBR)
!       fprintf(stderr, "Encoding as %.1f kHz VBR(q=%i) %s MPEG%i LayerIII file\n",
! 	      s_freq[info->version][info->sampling_frequency],
! 	      VBR_q,mode_names[info->mode],2-info->version);
!     else
!       fprintf(stderr, "Encoding as %.1f kHz %d kbps %s MPEG%i LayerIII file\n",
! 	      s_freq[info->version][info->sampling_frequency],
! 	      bitrate[info->version][info->lay-1][info->bitrate_index],
! 	      mode_names[info->mode],2-info->version);
!   }
! }
! 
! #ifdef HAVEGTK
! int readframe()
! {
!   int j,ch,stereo,out=0;
!   int adj;
!   short mpg123pcm[2][1152];
!   static int frameNum=0;
! 
!   frameNum++;
! 
!   /* create a 1 frame lag so MP3 analysis syncs with WAV analysis */
!   if (frameNum == 1 ) out=1152;
!   else out=decode1file(original_file_fd,mpg123pcm,&stereo);
!   if (!out) return out;
! 
!   adj=0;
!   if (out==576) adj=576;
! 
!   fr_ps.stereo=stereo;
!   /* Compensate for the decoder_delay.  add DECDELAY, where
!    * decoder_delay + DECDELAY = 1152, so data is delayed
!    * by exactly one frame */
!   for ( ch = 0; ch < stereo; ch++ ) {
!     for ( j = 0; j < DECDELAY-adj; j++ )
!       pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+1152-adj];
!     for ( j = 0; j < 1152-adj; j++ ) 
!       pinfo->pcmdata2[ch][j+DECDELAY-adj] = mpg123pcm[ch][j];
!   }
! 
!   MPGLAG = 2;
!   pinfo->frameNum = frameNum;
!   pinfo->mpglag = MPGLAG;
!   return out;
! }
! #endif
! 
! 
! 
! 
! 
! encodeframe(short int Buffer[2][1152])
! {
!   static unsigned long frameBits;
!   static unsigned long bitsPerSlot;
!   static double frac_SpF;
!   static double slot_lag;
!   static int mode_gr;
!   static int mpg123count=0;
!   static int old_bitrate;
!   static unsigned long sentBits = 0;
!   static L3SBS  FAR     l3_sb_sample;
!   /* set to 56 to sync with FhG */
! #define EXTRADELAY 56
!   static int samplesPerFrame;
!   static short int mfbuf[2][1152+576+EXTRADELAY];   /* 3 granule internal buffer */
!   double xr[2][2][576];
!   double win_que[2][HAN_SIZE];
!   int l3_enc[2][2][576];
! 
!   III_psy_ratio ratio;
!   III_scalefac_t scalefac;
! 
!   int j,ch,gr,mean_bits;
!   int bitsPerFrame;
!   double pe[2][2];
!   short *win_buf[2];
!   int stereo;
!   layer *info;
!   int i;
! 
! 
! #ifdef HAVEGTK
!   char mpg123bs[BUFFER_SIZE];
!   short mpg123pcm[2][1152];
! #endif
!   int check_ms_stereo;
!   int bit_rate;
!   double samp;
!   double ms_ener_ratio[2];
! 
! 
!   stereo = fr_ps.stereo;
!   info = fr_ps.header;
! #ifdef HAVEGTK
!   if (gtkflag) {
!     pinfo->frameNum = frameNum;
!     pinfo->sampfreq=s_freq[info->version][info->sampling_frequency]*1000.0;
!   }
! #endif
! 
!   info->mode_ext = 0; 
! 
!   /* use m/s stereo? */
!   check_ms_stereo =   ((info->mode == MPG_MD_JOINT_STEREO) && 
! 		       (!force_ms) && (info->version == 1) &&
! 		       (stereo==2));
! 
! 
!   if (firstcall) old_bitrate=info->bitrate_index;
! 
!   /* what bitrate should we try first? */
!   if (VBR){
!     info->bitrate_index = old_bitrate-1;
!     if (info->bitrate_index < VBR_min_bitrate)
!       info->bitrate_index=VBR_min_bitrate;
!   } else {
!     info->bitrate_index = old_bitrate;
!   }
! 
!   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
!   samp =      s_freq[info->version][info->sampling_frequency];
!   
!   if (firstcall)  {    
!     double avg_slots_per_frame;
!     int whole_SpF;
!     firstcall = 0;
!     mpg123count=0;
!     sentBits = 0;
!     memset((char *) mfbuf, 0, sizeof(mfbuf));
! 
!     /* Figure average number of 'slots' per frame. */
!     /* Bitrate means TOTAL for both channels, not per side. */
!     bitsPerSlot = 8;
!     samplesPerFrame = info->version == 1 ? 1152 : 576;
!     avg_slots_per_frame = ((double)samplesPerFrame /samp) *
!       ((double)bit_rate /  (double)bitsPerSlot);
!     whole_SpF = (int) avg_slots_per_frame;
!     frac_SpF  = avg_slots_per_frame - (double)whole_SpF;
!     slot_lag  = -frac_SpF;
!     info->padding = 1;
!     if (fabs(frac_SpF) < 1e-9) info->padding = 0;
!     mode_gr = (info->version == 1) ? 2 : 1;  /* mode_gr = 2 */
!   }
! 
! 
!   /* shift in new samples, delayed by 576+EXTRADELAY */
!    for (ch=0; ch<stereo; ch++)
!      for (i=0; i<576+EXTRADELAY; i++)
!        mfbuf[ch][i]=mfbuf[ch][i+samplesPerFrame];
!    for (ch=0; ch<stereo; ch++)
!      for (i=0; i<samplesPerFrame; i++)
!        mfbuf[ch][i+576+EXTRADELAY]=Buffer[ch][i];
! 
! 
! 
! 
!   /********************** padding *****************************/
!   if (VBR) {
!   /* leave info_padding as it was set above */
!   } else {
!     if (frac_SpF != 0) {
!       if (slot_lag > (frac_SpF-1.0) ) {
! 	slot_lag -= frac_SpF;
! 	info->padding = 0;
!       }
!       else {
! 	info->padding = 1;
! 	slot_lag += (1-frac_SpF);
!       }
!     }
!   }
! 
! 
! 
! 
! 
!   /********************** process InputBuffer *****************************/
!   frameNum++;
! 
!   if (force_ms)
!     for (i=0; i< samplesPerFrame; i++) {
!       double mid = (mfbuf[0][576+i]+mfbuf[1][576+i])/(2.0);
!       double side= (mfbuf[0][576+i]-mfbuf[1][576+i])/(2.0);
!       mfbuf[0][576+i]=mid;
!       mfbuf[1][576+i]=side;
!     }
! 
!   if (frameNum%10==0 && !gtkflag && !silent) {
!     timestatus(frameNum,totalframes,s_freq[info->version][info->sampling_frequency]);
!   }
! 
!   
!   /***************************** Layer 3 **********************************
!    * mfbuf contains 3 granules:  [0 1 2 ] 
!    * encoder will encode granules 0 1 
!    * psy-model will be fed granules 1 2, and because of its 1 granule delay 
!    * it will return thresholds for granules 0 1 */
!   
!   win_buf[0] = &mfbuf[0][0];
!   win_buf[1] = &mfbuf[1][0];
! 
!   
!   if (!fast_mode) {  
!     /* psychoacoustic model 
!      * psy model adds a 544 delay to sync with the filterbanks
!      * in addition to this delay, it also adds a 1 granule (576) delay
!      * that we must compensate for (mt 6/99). 
!      */
!     short int *bufp[2];  /* address of beginning of left & right granule */
!     int blocktype[2];
!     
!     for (gr=0; gr < mode_gr ; gr++) {
!       for ( ch = 0; ch < stereo; ch++ ) bufp[ch]=&mfbuf[ch][576 + gr*576];
!       L3psycho_anal( bufp, stereo, gr, info,
!          s_freq[info->version][info->sampling_frequency] * 1000.0,
! 	 check_ms_stereo,&ms_ener_ratio[gr],
!          ratio.l[gr], ratio.s[gr], pe[gr], blocktype);
!       for ( ch = 0; ch < stereo; ch++ ) 
! 	l3_side.gr[gr].ch[ch].tt.block_type=blocktype[ch];
!     }
!   }else{
!     for (gr=0; gr < mode_gr ; gr++) 
!       for ( ch = 0; ch < stereo; ch++ ) 
! 	l3_side.gr[gr].ch[ch].tt.block_type=NORM_TYPE;
!   }
! 
!   
! 
! 
!   /* block type flags */
!   for( gr = 0; gr < mode_gr; gr++ ) {
!     for ( ch = 0; ch < stereo; ch++ ) {
!       gr_info *cod_info = &l3_side.gr[gr].ch[ch].tt;
!       cod_info->mixed_block_flag = 0;     /* never used by this model */
!       if (cod_info->block_type == NORM_TYPE )
! 	cod_info->window_switching_flag = 0;
!       else
! 	cod_info->window_switching_flag = 1;
!     }
!   }
! 
!   
!   /* polyphase filtering  */
!   for( gr = 0; gr < mode_gr; gr++ )
!     for ( ch = 0; ch < stereo; ch++ )
!       for ( j = 0; j < 18; j++ )   {
! 	window_subband( &win_buf[ch], &win_que[ch][0], ch );
! 	filter_subband( &win_que[ch][0],  &(l3_sb_sample)[ch][gr+1][j][0] ); }
!   
!   /* apply mdct to the polyphase outputs */
!   mdct_sub( &l3_sb_sample, xr, stereo, &l3_side, mode_gr );
! 
! 
!   /* data was scaled by 1/2.  fix so effectively it was scaled by 1/sqrt(2) */
!   if (force_ms) {
!     for ( gr = 0; gr < mode_gr; gr++ )
!       for ( ch = 0; ch < stereo; ch++ ) 
! 	for (i =0 ; i< 576; i++) 
! 	  xr[gr][ch][i] *= sqrt(2.0);
!   }
! 
! 
!   if (check_ms_stereo) {
!     /* make sure block type is the same in each channel */
!     check_ms_stereo = 
!       (l3_side.gr[0].ch[0].tt.block_type==l3_side.gr[0].ch[1].tt.block_type) &&
!       (l3_side.gr[1].ch[0].tt.block_type==l3_side.gr[1].ch[1].tt.block_type);
!   }
!   if (check_ms_stereo) {
!     if ( (ms_ener_ratio[0] + ms_ener_ratio[1])<.70) info->mode_ext = 2;
!   }
! 
! #ifdef HAVEGTK
!   if (gtkflag) { 
!     for ( gr = 0; gr < mode_gr; gr++ )
!       for ( ch = 0; ch < stereo; ch++ ) {
! 	pinfo->ms_ratio[gr]=ms_ener_ratio[gr];
! 	pinfo->blocktype[gr][ch]=
! 	  l3_side.gr[gr].ch[ch].tt.block_type;
! 	for ( j = 0; j < 576; j++ ) pinfo->xr[gr][ch][j]=xr[gr][ch][j];
!       }
!   }
! #endif
! 
!   
!   /* bit and noise allocation */
!   iteration_loop( pe, ms_ener_ratio, xr, &ratio, &l3_side, l3_enc, 
!      &scalefac, &fr_ps);
! 
! 
!   /* flag for our ms_stereo with psy-model on mid & side channels */
!   if (force_ms) info->mode_ext = 2;
! 
! 
!   /*  write the frame to the bitstream  */
!   old_bitrate = info->bitrate_index;
!   getframebits(info,stereo,&bitsPerFrame,&mean_bits);
!   III_format_bitstream( bitsPerFrame, &fr_ps, l3_enc, &l3_side, 
! 			&scalefac, &bs, xr, NULL, 0 );
! 
! 
!   frameBits = sstell( &bs ) - sentBits;
! 
!   
!   if ( frameBits % bitsPerSlot )   /* a program failure */
!     fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
! 	     frameBits, frameBits/bitsPerSlot,
! 	     frameBits%bitsPerSlot );
!   sentBits += frameBits;
! 
! 
! #ifdef HAVEGTK
!   /* copy bit buffer into array and send to mpg123 to synthesis the pcm data */
!   if (gtkflag) { 
!     mpg123count=0;
!     for (i=bs.buf_size-1 ; i > bs.buf_byte_idx ; (i-- ))
!       mpg123bs[mpg123count++]=bs.buf[i];
!     /* re-synthesize pcm data from mp3 frame */
!     if (!decode1(mpg123bs,mpg123count,&mpg123pcm,stereo)) {
!       if (MPGLAG == MAXMPGLAG) 
! 	fprintf(stderr, "MAXMPGLAG set too low.  The following frames will be mis-aligned \n");
!       else MPGLAG+=1; 
!     }
!     pinfo->mpglag = MPGLAG;
!   }
! 
!   /* empty data from bit buffer into mp3 file  */
!   empty_buffer(&bs, 1+bs.buf_byte_idx);
!   bs.buf[bs.buf_byte_idx] = 0;  
!   
!   if (gtkflag) { 
!     int adj;
!     adj=0;
!     if (info->version == 0) adj=576;
!     for ( ch = 0; ch < stereo; ch++ ) {
!       for ( j = 0; j < WINDELAY; j++ )
! 	pinfo->pcmdata[ch][j] = pinfo->pcmdata[ch][j+1152-adj];
!       for ( j = 0; j < 1152-adj; j++ ) {
! 	pinfo->pcmdata[ch][j+WINDELAY] = mfbuf[ch][j];
!       }
!     }
!     for ( ch = 0; ch < stereo; ch++ ) {
!       for ( j = 0; j < DECDELAY-adj; j++ )
! 	pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+1152-adj];
!       for ( j = 0; j < 1152-adj; j++ ) {
! 	pinfo->pcmdata2[ch][j+DECDELAY-adj] = mpg123pcm[ch][j];
!       }
!     }
!     pinfo->frameNum = frameNum;
!   }
! #endif
!   if (g_bWriteVbrTag) AddVbrFrame(sentBits/8);
!   return 1152;
! }
! 
! 
! /**********************************************************************
!  * read one frame and encode it 
!  **********************************************************************/
! int makeframe()
! {
!   int iread;
!   short int Buffer[2][1152];
!   iread = get_audio(musicin,Buffer[0],Buffer[1],num_samples,
! 		      fr_ps.stereo,fr_ps.header);
!   /* if iread=0, get_audio hit EOF and returned Buffer=all 0's.  call
!    * makeframe() one last time to flush all buffers */
!   encodeframe(Buffer);
!   return iread;
  }
  
  
***************
*** 666,673 ****
  *
  * main
  *
! * PURPOSE:  MPEG I Encoder supporting layers 1 and 2, and 3, with
! * psychoacoustic models 1 (MUSICAM) and 2 (AT&T)
  *
  * SEMANTICS:  One overlapping frame of audio of up to 2 channels are
  * processed at a time in the following order:
--- 1025,1032 ----
  *
  * main
  *
! * PURPOSE:  MPEG-1 Layer III encoder, with
! * psychoacoustic models ISO-2 (AT&T) and GPSYCHO
  *
  * SEMANTICS:  One overlapping frame of audio of up to 2 channels are
  * processed at a time in the following order:
***************
*** 677,1076 ****
  * samples per channel.
  * (window_subband,filter_subband)
  *
! * 2.  If joint stereo mode, combine left and right channels
! * for subbands above #jsbound#.
! * (*_combine_LR)
! *
! * 3.  Calculate scalefactors for the frame, and if layer 2,
  * also calculate scalefactor select information.
  * (*_scale_factor_calc)
  *
! * 4.  Calculate psychoacoustic masking levels using selected
  * psychoacoustic model.
  * (*_Psycho_One, psycho_anal)
  *
! * 5.  Perform iterative bit allocation for subbands with low
  * mask_to_noise ratios using masking levels from step 4.
  * (*_main_bit_allocation)
  *
! * 6.  If error protection flag is active, add redundancy for
! * error protection.
! * (*_CRC_calc)
! *
! * 7.  Pack bit allocation, scalefactors, and scalefactor select
! * information (layer 2) onto bitstream.
! * (*_encode_bit_alloc,*_encode_scale,II_transmission_pattern)
  *
! * 8.  Quantize subbands and pack them into bitstream
  * (*_subband_quantization, *_sample_encoding)
  *
  ************************************************************************/
  
! int frameNum=0;
! 
! void main(argc, argv)
  int     argc;
  char    **argv;
  {
-     typedef double SBS[2][3][SCALE_BLOCK][SBLIMIT];
-     SBS  FAR        *sb_sample;
-     L3SBS  FAR        *l3_sb_sample;
-     typedef double JSBS[3][SCALE_BLOCK][SBLIMIT];
-     JSBS FAR        *j_sample;
-     typedef double IN[2][HAN_SIZE];
-     IN   FAR        *win_que;
-     typedef unsigned int SUB[2][3][SCALE_BLOCK][SBLIMIT];
-     SUB  FAR        *subband;
      
-     frame_params fr_ps;
-     layer info;
      char original_file_name[MAX_NAME_SIZE];
      char encoded_file_name[MAX_NAME_SIZE];
!     short FAR **win_buf;
!     static short FAR buffer[2][1152];
!     static unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
!     static unsigned int scalar[2][3][SBLIMIT], j_scale[3][SBLIMIT];
!     static double FAR ltmin[2][SBLIMIT], lgmin[2][SBLIMIT], max_sc[2][SBLIMIT];
!     FLOAT snr32[32];
!     short sam[2][1344]; /* was [1056]; */
!     int whole_SpF, extra_slot = 0;
!     double avg_slots_per_frame, frac_SpF, slot_lag;
!     int model, stereo, error_protection;
!     static unsigned int crc;
!     int i, j, k, adb;
!     unsigned long bitsPerSlot, samplesPerFrame;
!     unsigned long frameBits, sentBits = 0;
!     unsigned long num_samples;
!     
! #ifdef  MACINTOSH
!     argc = ccommand( &argv );
  #endif
-     
  
!     /* Most large variables are declared dynamically to ensure
!        compatibility with smaller machines */
!     
!     sb_sample = (SBS FAR *) mem_alloc(sizeof(SBS), "sb_sample");
!     l3_sb_sample = (L3SBS FAR *) mem_alloc(sizeof(SBS), "l3_sb_sample");
!     j_sample = (JSBS FAR *) mem_alloc(sizeof(JSBS), "j_sample");
!     win_que = (IN FAR *) mem_alloc(sizeof(IN), "Win_que");
!     subband = (SUB FAR *) mem_alloc(sizeof(SUB),"subband");
!     win_buf = (short FAR **) mem_alloc(sizeof(short *)*2, "win_buf");
!  
!     /* clear buffers */
!     memset((char *) buffer, 0, sizeof(buffer));
!     memset((char *) bit_alloc, 0, sizeof(bit_alloc));
!     memset((char *) scalar, 0, sizeof(scalar));
!     memset((char *) j_scale, 0, sizeof(j_scale));
!     memset((char *) scfsi, 0, sizeof(scfsi));
!     memset((char *) ltmin, 0, sizeof(ltmin));
!     memset((char *) lgmin, 0, sizeof(lgmin));
!     memset((char *) max_sc, 0, sizeof(max_sc));
!     memset((char *) snr32, 0, sizeof(snr32));
!     memset((char *) sam, 0, sizeof(sam));
!  
!     fr_ps.header = &info;
!     fr_ps.tab_num = -1;             /* no table loaded */
!     fr_ps.alloc = NULL;
!     info.version = MPEG_AUDIO_ID;   /* Default: MPEG-1 */
! 
!     programName = argv[0];
!     if(argc==1)     /* no command-line args */
!        obtain_parameters(&fr_ps, &model, &num_samples,
!                          original_file_name, encoded_file_name);
!     else
! 	parse_args(argc, argv, &fr_ps, &model, &num_samples,
! 		   original_file_name, encoded_file_name);
!     print_config(&fr_ps, &model,
!                  original_file_name, encoded_file_name);
!     
!     hdr_to_frps(&fr_ps);
!     stereo = fr_ps.stereo;
!     error_protection = info.error_protection;
!     
!     if (info.lay == 1)
!     { bitsPerSlot = 32; samplesPerFrame = 384;  }
!     else 
! 	if ( info.lay == 2 )
! 	{ bitsPerSlot = 8;  samplesPerFrame = 1152; }
! 	else	
! 	{  /* layer 3 */
! 	    bitsPerSlot = 8;
! 	    samplesPerFrame = info.version == 1 ? 1152 : 576;
! 	    
! 	    /* Apologize for missing features */
! 	    if ( info.mode == MPG_MD_JOINT_STEREO )
! 	    {
! 		fprintf( stderr, "Sorry, joint stereo not yet available for layer3\n" );
! 		exit( 1 );
! 	    }
! #if 0
! 	    if ( info.version != MPEG_AUDIO_ID )
! 	    {
! 		fprintf( stderr, "Sorry, MPEG2-LSF not yet available for layer3\n" );
! 		exit( 1 );
! 	    }
! #endif
! 	    if ( model != 2 )
! 	    {
! 		fprintf( stderr, "Sorry, psycho model 1 not available for layer3\n" );
! 		exit( 1 );
! 	    }
! 	}
!     /* Figure average number of 'slots' per frame. */
!     /* Bitrate means TOTAL for both channels, not per side. */
!     avg_slots_per_frame = ((double)samplesPerFrame /
!                            s_freq[info.version][info.sampling_frequency]) *
! 			   ((double)bitrate[info.version][info.lay-1][info.bitrate_index] /
! 			    (double)bitsPerSlot);
!     whole_SpF = (int) avg_slots_per_frame;
!     printf("slots/frame = %d\n",whole_SpF);
!     frac_SpF  = avg_slots_per_frame - (double)whole_SpF;
!     slot_lag  = -frac_SpF;
!     printf("frac SpF=%.3f, tot bitrate=%d kbps, s freq=%.1f kHz\n",
!            frac_SpF, bitrate[info.version][info.lay-1][info.bitrate_index],
!            s_freq[info.version][info.sampling_frequency]);
!     
!     if (frac_SpF != 0)
! 	printf("Fractional number of slots, padding required\n");
!     else info.padding = 0;
!     
!     while ( get_audio(musicin, buffer, num_samples, stereo, &info) > 0 )
      {
! 	fprintf(stderr, "{%4lu}", frameNum++); fflush(stderr);
! 	win_buf[0] = &buffer[0][0];
! 	win_buf[1] = &buffer[1][0];
! 	if (frac_SpF != 0) {
! 	    if (slot_lag > (frac_SpF-1.0) ) {
! 		slot_lag -= frac_SpF;
! 		extra_slot = 0;
! 		info.padding = 0;
! 		/*  printf("No padding for this frame\n"); */
! 	    }
! 	    else {
! 		extra_slot = 1;
! 		info.padding = 1;
! 		slot_lag += (1-frac_SpF);
! 		/*  printf("Padding for this frame\n");    */
! 	    }
! 	}
! 	adb = (whole_SpF+extra_slot) * bitsPerSlot;
! 	
! 	switch (info.lay)
! 	{
! 	    
! /***************************** Layer I **********************************/
! 	    
!           case 1 :
! 	    for (j=0;j<SCALE_BLOCK;j++)
! 		for (k=0;k<stereo;k++) {
! 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
! 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][0][j][0]);
! 		}
! 	    
! 	    I_scale_factor_calc(*sb_sample, scalar, stereo);
! 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
!                 I_combine_LR(*sb_sample, *j_sample);
!                 I_scale_factor_calc(j_sample, &j_scale, 1);
! 	    }
! 	    
! 	    put_scale(scalar, &fr_ps, max_sc);
! 	    
! 	    if (model == 1) I_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
! 	    else {
!                 for (k=0;k<stereo;k++) {
! 		    psycho_anal(&buffer[k][0],&sam[k][0], k, info.lay, snr32,
! 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
! 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
!                 }
! 	    }
! 	    
! 	    I_main_bit_allocation(ltmin, bit_alloc, &adb, &fr_ps);
! 	    
! 	    if (error_protection) I_CRC_calc(&fr_ps, bit_alloc, &crc);
! 	    
! 	    encode_info(&fr_ps, &bs);
! 	    
! 	    if (error_protection) encode_CRC(crc, &bs);
! 	    
! 	    I_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
! 	    I_encode_scale(scalar, bit_alloc, &fr_ps, &bs);
! 	    I_subband_quantization(scalar, *sb_sample, j_scale, *j_sample,
! 				   bit_alloc, *subband, &fr_ps);
! 	    I_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
! 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
! 	    break;
! 	    
! /***************************** Layer 2 **********************************/
! 	    
!           case 2 :
! 	    for (i=0;i<3;i++) for (j=0;j<SCALE_BLOCK;j++)
!                 for (k=0;k<stereo;k++) {
! 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
! 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][i][j][0]);
!                 }
! 	    
! 	    II_scale_factor_calc(*sb_sample, scalar, stereo, fr_ps.sblimit);
! 	    pick_scale(scalar, &fr_ps, max_sc);
! 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
! 		II_combine_LR(*sb_sample, *j_sample, fr_ps.sblimit);
! 		II_scale_factor_calc(j_sample, &j_scale, 1, fr_ps.sblimit);
! 	    }       /* this way we calculate more mono than we need */
! 	    /* but it is cheap */
! 	    
! 	    if (model == 1) II_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
! 	    else {
! 		for (k=0;k<stereo;k++) {
! 		    psycho_anal(&buffer[k][0],&sam[k][0], k, 
! 				info.lay, snr32,
! 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
! 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
! 		}
! 	    }
! 	    
! 	    II_transmission_pattern(scalar, scfsi, &fr_ps);
! 	    II_main_bit_allocation(ltmin, scfsi, bit_alloc, &adb, &fr_ps);
! 	    
! 	    if (error_protection)
! 		II_CRC_calc(&fr_ps, bit_alloc, scfsi, &crc);
! 	    
! 	    encode_info(&fr_ps, &bs);
! 	    
! 	    if (error_protection) encode_CRC(crc, &bs);
! 	    
! 	    II_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
! 	    II_encode_scale(bit_alloc, scfsi, scalar, &fr_ps, &bs);
! 	    II_subband_quantization(scalar, *sb_sample, j_scale,
! 				    *j_sample, bit_alloc, *subband, &fr_ps);
! 	    II_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
! 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
! 	    break;
! 	    
! /***************************** Layer 3 **********************************/
! 
! 	  case 3:
! 	  {
! 	      /*
! 		large "auto" vars are static due to the Macintosh linker
! 	      */ 
! 	      static double xr[2][2][576];
! 	      static double xr_dec[2][2][576];
! 	      static double pe[2][2];
! 	      static int l3_enc[2][2][576];
! 	      static III_psy_ratio ratio;
! 	      static III_side_info_t l3_side;
! 	      static III_scalefac_t  scalefac;
! 	      int gr, mode_gr, ch;
! 	      int mean_bits, sideinfo_len;
! 	      
! 	      int bitsPerFrame = 8 * whole_SpF + (info.padding * 8);
! 	      mode_gr = (info.version == 1) ? 2 : 1;
! 
! 	      /*
! 		determine the mean bitrate for main data
! 	      */
! 	      sideinfo_len = 32;
! 	      if ( info.version == 1 )
! 	      {   /* MPEG 1 */
! 		  if ( stereo == 1 )
! 		      sideinfo_len += 136;
! 		  else
! 		      sideinfo_len += 256;
! 	      }
! 	      else
! 	      {   /* MPEG 2 */
! 		  if ( stereo == 1 )
! 		      sideinfo_len += 72;
! 		  else
! 		      sideinfo_len += 136;
! 	      }
! 	      if ( info.error_protection )
! 		  sideinfo_len += 16;
! 	      mean_bits = (bitsPerFrame - sideinfo_len) / mode_gr;
! 
! 	      /*
! 		psychoacoustic model
! 	      */
! 	      for ( gr = 0; gr < mode_gr; gr++ )
! 		  for ( ch = 0; ch < stereo; ch++ )
! 		  {
! 		      L3psycho_anal( &buffer[ch][gr*576], &sam[ch][0], ch, info.lay,
! 				     snr32, s_freq[info.version][info.sampling_frequency] * 1000.0,
! 				     &ratio.l[gr][ch][0], &ratio.s[gr][ch][0],
! 				     &pe[gr][ch], &l3_side.gr[gr].ch[ch].tt );
! 		  }
! 
! 	      /*
! 		polyphase filtering
! 	      */
! 	      for( gr = 0; gr < mode_gr; gr++ )
! 		  for ( ch = 0; ch < stereo; ch++ )
! 		      for ( j = 0; j < 18; j++ )
! 		      {
! 			  window_subband( &win_buf[ch], &(*win_que)[ch][0], ch );
! 			  filter_subband( &(*win_que)[ch][0],  &(*l3_sb_sample)[ch][gr+1][j][0] );
! 		      }
! 
! 	      /*
! 		apply mdct to the polyphase outputs
! 	      */
! 	      mdct_sub( l3_sb_sample, xr, stereo, &l3_side, mode_gr );
! #if 0
! 	      delay( xr, stereo );
! #endif
! 	      /*
! 		bit and noise allocation
! 	      */
! 	      iteration_loop( pe, xr, &ratio, &l3_side, l3_enc, mean_bits,
! 			      stereo, xr_dec, &scalefac, &fr_ps, 0, bitsPerFrame );
! 
! 	      /*
! 		write the frame to the bitstream
! 	      */
! 	      III_format_bitstream( bitsPerFrame, &fr_ps, l3_enc, &l3_side, &scalefac, &bs,
! 				    xr, NULL, 0 );
! 	  }
! 	    break;  /* end of layer 3 */
! 	    
! 
! 	} /* end switch  */
! 	
! 	frameBits = sstell( &bs ) - sentBits;
! 	if ( frameBits % bitsPerSlot )   /* a program failure */
! 	    fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
! 		     frameBits, frameBits/bitsPerSlot,
! 		     frameBits%bitsPerSlot );
! 	sentBits += frameBits;
! 
!     }    
! 
!     if ( info.lay == 3 )
! 	III_FlushBitstream();
! 
      close_bit_stream_w( &bs );
! 
!     printf("Avg slots/frame = %.3f; b/smp = %.2f; br = %.3f kbps\n",
!            (FLOAT) sentBits / (frameNum * bitsPerSlot),
!            (FLOAT) sentBits / (frameNum * samplesPerFrame),
!            (FLOAT) sentBits / (frameNum * samplesPerFrame) *
!            s_freq[info.version][info.sampling_frequency]);
! 
      if (fclose(musicin) != 0){
! 	printf("Could not close \"%s\".\n", original_file_name);
! 	exit(2);
      }
- 
- #ifdef  MACINTOSH
-     set_mac_file_attr( encoded_file_name, VOL_REF_NUM, CREATOR_ENCODE,
- 		       FILETYPE_ENCODE );
  #endif
! 
!     printf("Encoding of \"%s\" with psychoacoustic model %d is finished\n",
!            original_file_name, model);
!     printf("The MPEG encoded output file name is \"%s\"\n",
! 	   encoded_file_name);
!     exit(0);
  }
   
  /************************************************************************
  *
--- 1036,1164 ----
  * samples per channel.
  * (window_subband,filter_subband)
  *
! * 2.  Calculate scalefactors for the frame, and if layer 2,
  * also calculate scalefactor select information.
  * (*_scale_factor_calc)
  *
! * 3.  Calculate psychoacoustic masking levels using selected
  * psychoacoustic model.
  * (*_Psycho_One, psycho_anal)
  *
! * 4.  Perform iterative bit allocation for subbands with low
  * mask_to_noise ratios using masking levels from step 4.
  * (*_main_bit_allocation)
  *
! * 5.  Pack bit allocation and scalefactors onto bitstream.
! * (*_encode_bit_alloc,*_encode_scale)
  *
! * 6.  Quantize subbands and pack them into bitstream
  * (*_subband_quantization, *_sample_encoding)
  *
  ************************************************************************/
  
! #ifndef _BLADEDLL
! int main(argc, argv)
  int     argc;
  char    **argv;
  {
      
      char original_file_name[MAX_NAME_SIZE];
      char encoded_file_name[MAX_NAME_SIZE];
!     int model, stereo;
!     layer info;
! 
! #ifdef __FreeBSD__
!   {
!   fp_except_t mask;
!   mask=fpgetmask();
!   /*  printf("FreeBSD mask is 0x%x\n",mask); */
!   }
! #endif
! #ifdef ABORTFP
!   {
!   unsigned int mask;
!   _FPU_GETCW(mask);
!   /* Set the Linux mask to the FreeBSD default mask */
!   mask &= ~( _FPU_MASK_IM | _FPU_MASK_ZM | _FPU_MASK_OM );
!   _FPU_SETCW(mask);
!   }
  #endif
  
!   // Clear info structure
!   memset(&info,0,sizeof(info));
!   
!   fr_ps.header = &info;
!   fr_ps.tab_num = -1;             /* no table loaded */
!   fr_ps.alloc = NULL;
!   info.version = MPEG_AUDIO_ID;   /* =1   Default: MPEG-1 */
!   info.extension = 0;       
!   
!   /* get version string */
!   if (gpsycho && !original_file_type)
!     fprintf(stderr,"LAME version %s (www.sulaco.org/mp3) \n",get_lame_version());
!   
!   
!   programName = argv[0];
!   if(argc==1)     /* no command-line args 
! 		     obtain_parameters(&fr_ps, &model, &num_samples,
! 		     original_file_name, encoded_file_name);*/
!     usage();
!   else
!     parse_args(argc, argv, &fr_ps, &model, &num_samples,
! 	       original_file_name, encoded_file_name);
!   print_config(&fr_ps, &model,
! 	       original_file_name, encoded_file_name);
!   
!   hdr_to_frps(&fr_ps);
!   stereo = fr_ps.stereo;
!   if (gpsycho && !original_file_type) fprintf(stderr,
! 					      "using GPSYCHO: GPL'd psycho-acoustic model \n");
!   
! #ifdef HAVEGTK
!   if (gtkflag) gtk_init (&argc, &argv);
!   if (gtkflag) gtkcontrol(totalframes,original_file_type,original_file_name,gpsycho); 
!   else 
! #endif
      {
!       while (makeframe());
!     }
!   
!   /* clean up if we were producing an mp3 file */
!   if (!original_file_type) {
!     if ( info.lay == 3 ) III_FlushBitstream();
      close_bit_stream_w( &bs );
! #ifdef LIBSNDFILE
!     CloseSndFile();
! #else
      if (fclose(musicin) != 0){
!       fprintf(stderr, "Could not close \"%s\".\n", original_file_name);
!       exit(2);
      }
  #endif
!     
!     frameNum--;
!     timestatus(frameNum,frameNum,s_freq[info.version][info.sampling_frequency]);
!     fprintf(stderr,"\n");
!   }
!   fflush(stderr);
!   
!   
!   // AF ADDED
!   if (g_bWriteVbrTag)
!     {
!       // Calculate relative quality of VBR stream 
!       // 0=best, 100=worst
!       int nQuality=VBR_q*100/9;
!       
!       // Write Xing header again
!       PutVbrTag(encoded_file_name,nQuality);
!     }
!   // AF END
!   
!   return 0;
  }
+ #endif // IFNDEF _BLADEDLL
+ 
   
  /************************************************************************
  *
***************
*** 1082,1111 ****
  
  void usage()  /* print syntax & exit */
  {
!     fprintf(stderr,
!     "usage: %s                         queries for all arguments, or\n",
!             programName);
!     fprintf(stderr,
!     "       %s [-l lay][-m mode][-p psy][-s sfrq][-b br][-d emp]\n",
!             programName);
!     fprintf(stderr,
!     "          [-c][-o][-e] inputPCM [outBS]\n");
!     fprintf(stderr,"where\n");
!     fprintf(stderr," -l lay   use layer <lay> coding   (dflt %4u)\n",DFLT_LAY);
!     fprintf(stderr," -m mode  channel mode : s/d/j/m   (dflt %4c)\n",DFLT_MOD);
!     fprintf(stderr," -p psy   psychoacoustic model 1/2 (dflt %4u)\n",DFLT_PSY);
!     fprintf(stderr," -s sfrq  input smpl rate in kHz   (dflt %4.1f)\n",DFLT_SFQ);
!     fprintf(stderr," -b br    total bitrate in kbps    (dflt highest)\n");
!     fprintf(stderr," -d emp   de-emphasis n/5/c        (dflt %4c)\n",DFLT_EMP);
!     fprintf(stderr," -c       mark as copyright\n");
!     fprintf(stderr," -o       mark as original\n");
!     fprintf(stderr," -e       add error protection\n");
!     fprintf(stderr," inputPCM input PCM sound file (standard or AIFF)\n");
!     fprintf(stderr," outBS    output bit stream of encoded audio (dflt inName+%s)\n",
!             DFLT_EXT);
!     exit(1);
  }
  
  /************************************************************************
  *
  * aiff_check
--- 1170,1212 ----
  
  void usage()  /* print syntax & exit */
  {
!   fprintf(stderr,"        LAMER Ain't an Mp3 Encoder (Reconstruction-iso)\n");
!   fprintf(stderr,"        version %s\n",get_lame_version());
!   fprintf(stderr,"        with GPSYCHO psycho-acoustic model (version %s). \n\n",get_psy_version());
!   fprintf(stderr,"USAGE   :  %s [options] <infile> <outfile>\n",programName);
!   fprintf(stderr,"OPTIONS :\n");
!   fprintf(stderr,"          -m mode         (s)tereo, (j)oint, (f)orce or (m)ono  (default %c)\n",DFLT_MOD);
!   fprintf(stderr,"                          force = force ms_stereo on all frames. Faster and\n");
!   fprintf(stderr,"                          uses special Mid & Side masking thresholds\n");
!   fprintf(stderr,"          -s sample freq  frequency of input file (kHz) - default %4.1f\n",DFLT_SFQ);
!   fprintf(stderr,"          -b <bitrate>    set the bitrate, default 128kbps\n");
!   fprintf(stderr,"                          (for VBR, this sets the allowed minimum bitrate)\n");
!   fprintf(stderr,"          -x              force byte-swapping of input\n");
!   fprintf(stderr,"          -a              downmix from stereo to mono file for mono encoding\n");
!   fprintf(stderr,"          -e emp          de-emphasis n/5/c        (default %4c)\n",DFLT_EMP);
!   fprintf(stderr,"          -p              add CRC error protection (now working!)\n");
!   fprintf(stderr,"          -c              mark as copyright\n");
!   fprintf(stderr,"          -o              mark as non-original\n");
!   fprintf(stderr,"          -f              fast mode (low quality)\n");
!   fprintf(stderr,"          -k              disable sfb=21 cutoff\n");
!   fprintf(stderr,"          -d              allow channels to have different blocktypes\n");
!   fprintf(stderr,"          -v              use variable bitrate (VBR)\n");
!   fprintf(stderr,"          -V n            quality setting for VBR.  default n=%i\n",VBR_q);
!   fprintf(stderr,"                          0=high quality,bigger files. 9=smaller files\n");
!   fprintf(stderr,"          -h              use (maybe) some experimental quality improvements\n");
! #ifdef HAVEGTK
!   fprintf(stderr,"          -g              run graphical analysis on <infile>\n");
! #endif
!   fprintf(stderr,"          -S              don't print progress report\n");
!   fprintf(stderr,"          -t              Disable Xing VBR Tag (only valid if -v flag is specified\n");
!   fprintf(stderr,"\n<infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n");
! 
!   exit(1);
  }
  
+ 
+ 
+ #ifndef LIBSNDFILE
  /************************************************************************
  *
  * aiff_check
***************
*** 1118,1151 ****
  void aiff_check( char *file_name, IFF_AIFF *pcm_aiff_data, int *version)
  {
      if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
!        printf("Sound data is not PCM in \"%s\".\n", file_name);
         exit(1);
      }
  
      if(SmpFrqIndex((long)pcm_aiff_data->sampleRate, version) < 0) {
!        printf("in \"%s\".\n", file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
!         printf("Sound data is not %d bits in \"%s\".\n",
!                sizeof(short) * BITS_IN_A_BYTE, file_name);
          exit(1);
      }
  
      if (pcm_aiff_data->numChannels != MONO &&
          pcm_aiff_data->numChannels != STEREO) {
!        printf("Sound data is not mono or stereo in \"%s\".\n", file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->blkAlgn.blockSize != 0) {
!        printf("Block size is not %d bytes in \"%s\".\n", 0, file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->blkAlgn.offset != 0) {
!        printf("Block offset is not %d bytes in \"%s\".\n", 0, file_name);
         exit(1);
      }
  }
--- 1219,1258 ----
  void aiff_check( char *file_name, IFF_AIFF *pcm_aiff_data, int *version)
  {
      if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
!        fprintf(stderr, "Sound data is not PCM in \"%s\".\n", file_name);
         exit(1);
      }
  
      if(SmpFrqIndex((long)pcm_aiff_data->sampleRate, version) < 0) {
!        fprintf(stderr, "in \"%s\".\n", file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
!         fprintf(stderr, "Sound data is not %d bits in \"%s\".\n",
! 		(unsigned int) sizeof(short) * BITS_IN_A_BYTE, file_name);
          exit(1);
      }
  
      if (pcm_aiff_data->numChannels != MONO &&
          pcm_aiff_data->numChannels != STEREO) {
!        fprintf(stderr, "Sound data is not mono or stereo in \"%s\".\n",
! 	       file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->blkAlgn.blockSize != 0) {
!        fprintf(stderr, "Block size is not %d bytes in \"%s\".\n",
! 	       0, file_name);
         exit(1);
      }
  
      if (pcm_aiff_data->blkAlgn.offset != 0) {
!        fprintf(stderr, "Block offset is not %d bytes in \"%s\".\n",
! 	       0, file_name);
         exit(1);
      }
  }
+ 
+ #endif
+ 
diff -r -c -N encoder/portableio.c lame3.13/portableio.c
*** encoder/portableio.c	Wed Jan 22 02:43:12 1997
--- lame3.13/portableio.c	Sat Jun  5 13:45:37 1999
***************
*** 1,3 ****
--- 1,4 ----
+ #ifndef LIBSNDFILE
  /* Copyright (C) 1988-1991 Apple Computer, Inc.
   * All Rights Reserved.
   *
***************
*** 226,232 ****
  char	*p;
  int	n;
  {
! 	while (!feof(fp) & n-- > 0)
  		*p++ = getc(fp);
  }
  
--- 227,233 ----
  char	*p;
  int	n;
  {
! 	while (!feof(fp) & (n-- > 0))
  		*p++ = getc(fp);
  }
  
***************
*** 237,243 ****
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & n-- > 0)
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
--- 238,244 ----
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & (n-- > 0))
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
***************
*** 394,396 ****
--- 395,398 ----
  }
  
  
+ #endif
diff -r -c -N encoder/psy.c lame3.13/psy.c
*** encoder/psy.c	Wed Jan 22 02:43:18 1997
--- lame3.13/psy.c	Wed Dec 31 17:00:00 1969
***************
*** 1,454 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: psy.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: psy.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
-  *                              replace of floats with FLOAT          *
-  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
-  * 7/24/92  M. Iwadare          HANN window coefficients modified.    *
-  * 7/27/92  Masahiro Iwadare    Bug fix, FFT modification for Layer 3 *
-  * 7/27/92  Masahiro Iwadare    Bug fix, "new", "old", and "oldest"   *
-  *                              updates                               *
-  * 8/07/92  Mike Coleman        Bug fix, read_absthr()                *
-  * 95/3/21  Jon Rowlands        Removed extra debug statements        *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- FILE		*fpo;	/* file pointer */
- void psycho_anal(buffer,savebuf,chn,lay,snr32,sfreq)
- short int *buffer;
- short int savebuf[1056];
- int   chn, lay;
- FLOAT snr32[32];
- double sfreq;        /* to match prototype : float args are always double */
- {
-  unsigned int   i, j, k;
-  FLOAT          r_prime, phi_prime;
-  FLOAT          freq_mult, bval_lo, minthres, sum_energy;
-  double         tb, temp1, temp2, temp3;
- 
- /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
- /* to be remembered for the unpredictability measure.  For "r" and        */
- /* "phi_sav", the first index from the left is the channel select and     */
- /* the second index is the "age" of the data.                             */
- 
-  static int     new = 0, old = 1, oldest = 0;
-  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
- 
- /* The following static variables are constants.                           */
- 
-  static double  nmt = 5.5;
- 
-  static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
-                                920, 1080, 1270,1480,1720,2000,2320, 2700,
-                               3150, 3700, 4400,5300,6400,7700,9500,12000,
-                              15500,25000,30000};
- 
-  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
-                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
- 
- /* The following pointer variables point to large areas of memory         */
- /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
- /* allocation is used in order to avoid stack frame or data area          */
- /* overflow errors that otherwise would have occurred at compile time     */
- /* on the Macintosh computer.                                             */
- 
-  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
-  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
-  FLOAT          *c, *fthr;
-  F32            *snrtmp;
- 
-  static int     *numlines;
-  static int     *partition;
-  static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
-  static double  *tmn;
-  static FCB     *s;
-  static FHBLK   *lthr;
-  static F2HBLK  *r, *phi_sav;
- 
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
- 
-  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
-  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
-  nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
-  cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
-  ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
-  bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
-  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
-  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
-  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
-  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
-  c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
-  fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
-  snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
- 
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
- 
-      numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
-      partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
-      fpo = fopen("out.dat", "wb");
- 	if(fpo==NULL) {
- 		puts("\t The attempt to open the output file failed.\n");
- 		exit(-1);}
-      cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
-      rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
-      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
-      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr");
-      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
-      s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
-      lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
-      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
-      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
- 
-      i = sfreq + 0.5;
-      switch(i){
-         case 32000: sfreq_idx = 0; break;
-         case 44100: sfreq_idx = 1; break;
-         case 48000: sfreq_idx = 2; break;
-         default:    printf("error, invalid sampling frequency: %d Hz\n",i);
-         exit(-1);
-      }
-      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
-      read_absthr(absthr, sfreq_idx);
-      if(lay==1){
-         flush = 384;
-         syncsize = 1024;
-         sync_flush = 576;
-      }
-      else {
-         flush = 384*3.0/2.0;
-         syncsize = 1056;
-         sync_flush = syncsize - flush;
-      }
- /* calculate HANN window coefficients */
- /*   for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0))); */
-      for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
- /* reset states used in unpredictability measure */
-      for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
-         lthr[0][i] = 60802371420160.0;
-         lthr[1][i] = 60802371420160.0;
-      }
- /*****************************************************************************
-  * Initialization: Compute the following constants for use later             *
-  *    partition[HBLKSIZE] = the partition number associated with each        *
-  *                          frequency line                                   *
-  *    cbval[CBANDS]       = the center (average) bark value of each          *
-  *                          partition                                        *
-  *    numlines[CBANDS]    = the number of frequency lines in each partition  *
-  *    tmn[CBANDS]         = tone masking noise                               *
-  *****************************************************************************/
- /* compute fft frequency multiplicand */
-      freq_mult = sfreq/BLKSIZE;
-  
- /* calculate fft frequency, then bval of each line (use fthr[] as tmp storage)*/
-      for(i=0;i<HBLKSIZE;i++){
-         temp1 = i*freq_mult;
-         j = 1;
-         while(temp1>crit_band[j])j++;
-         fthr[i]=j-1+(temp1-crit_band[j-1])/(crit_band[j]-crit_band[j-1]);
-      }
-      partition[0] = 0;
- /* temp2 is the counter of the number of frequency lines in each partition */
-      temp2 = 1;
-      cbval[0]=fthr[0];
-      bval_lo=fthr[0];
-      for(i=1;i<HBLKSIZE;i++){
-         if((fthr[i]-bval_lo)>0.33){
-            partition[i]=partition[i-1]+1;
-            cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-            cbval[partition[i]] = fthr[i];
-            bval_lo = fthr[i];
-            numlines[partition[i-1]] = temp2;
-            temp2 = 1;
-         }
-         else {
-            partition[i]=partition[i-1];
-            cbval[partition[i]] += fthr[i];
-            temp2++;
-         }
-      }
-      numlines[partition[i-1]] = temp2;
-      cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-  
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
-      for(j=0;j<CBANDS;j++){
-         for(i=0;i<CBANDS;i++){
-            temp1 = (cbval[i] - cbval[j])*1.05;
-            if(temp1>=0.5 && temp1<=2.5){
-               temp2 = temp1 - 0.5;
-               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
-            }
-            else temp2 = 0;
-            temp1 += 0.474;
-            temp3 = 15.811389+7.5*temp1-17.5*sqrt((double) (1.0+temp1*temp1));
-            if(temp3 <= -100) s[i][j] = 0;
-            else {
-               temp3 = (temp2 + temp3)*LN_TO_LOG10;
-               s[i][j] = exp(temp3);
-            }
-         }
-      }
- 
-   /* Calculate Tone Masking Noise values */
-      for(j=0;j<CBANDS;j++){
-         temp1 = 15.5 + cbval[j];
-         tmn[j] = (temp1>24.5) ? temp1 : 24.5;
-   /* Calculate normalization factors for the net spreading functions */
-         rnorm[j] = 0;
-         for(i=0;i<CBANDS;i++){
-            rnorm[j] += s[j][i];
-         }
-      }
-      init++;
-  }
-  
- /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
-      for(i=0; i<lay; i++){
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-         for(j=0; j<syncsize; j++){
-            if(j<(sync_flush))savebuf[j] = savebuf[j+flush];
-            else savebuf[j] = *buffer++;
-            if(j<BLKSIZE){
- /**window data with HANN window***********************************************/
-               wsamp_r[j] = window[j]*((FLOAT) savebuf[j]);
-               wsamp_i[j] = 0;
-            }
-         }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
- /*only update data "age" pointers after you are done with both channels      */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-          if(lay==2 || (lay==1 && chn==0) ){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- temp1=r[chn][new][j] * cos((double) phi[j]) - r_prime * cos((double) phi_prime);
- temp2=r[chn][new][j] * sin((double) phi[j]) - r_prime * sin((double) phi_prime);
-            temp3=r[chn][new][j] + fabs((double)r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- 
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- 
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
-            tb = -0.434294482*log((double) cb[j])-0.301029996;
- 	   cb[j]=tb;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- 
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
- /*temp1 is the preliminary threshold */
-            temp1=nb[partition[j]];
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- 
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            minthres = 60802371420160.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               if(minthres>fthr[j+k])minthres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(minthres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            minthres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               minthres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/minthres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
-   case 3:
-      printf("layer 3 is not currently supported\n");
-      break;
-   default:
-      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
-  }
- 
- /* These mem_free() calls must correspond with the mem_alloc() calls     */
- /* used at the beginning of this function to simulate "automatic"        */
- /* variables placed on the stack.                                        */
- 
-  mem_free((void **) &grouped_c);
-  mem_free((void **) &grouped_e);
-  mem_free((void **) &nb);
-  mem_free((void **) &cb);
-  mem_free((void **) &ecb);
-  mem_free((void **) &bc);
-  mem_free((void **) &wsamp_r);
-  mem_free((void **) &wsamp_i);
-  mem_free((void **) &phi);
-  mem_free((void **) &energy);
-  mem_free((void **) &c);
-  mem_free((void **) &fthr);
-  mem_free((void **) &snrtmp);
- }
- 
- /******************************************************************************
- routine to read in absthr table from a file.
- ******************************************************************************/
- 
- void read_absthr(absthr, table)
- FLOAT *absthr;
- int table;
- {
-  FILE *fp;
-  long j,index;
-  float a;
-  char t[80];
-  char ta[16];
- 
-  strcpy( ta, "absthr_0" );
-  
-  switch(table){
-     case 0 : ta[7] = '0';
-              break;
-     case 1 : ta[7] = '1';
-              break;
-     case 2 : ta[7] = '2';
-              break;
-     default : printf("absthr table: Not valid table number\n");
-  }
-  if(!(fp = OpenTableFile(ta) ) ){
-     printf("Please check %s table\n", ta);
-     exit(1);
-  }
-  fgets(t, 150, fp);
-  sscanf(t, "table %ld", &index);
-  if(index != table){
-     printf("error in absthr table %s",ta);
-     exit(1);
-  }
-  for(j=0; j<HBLKSIZE; j++){
-     fgets(t,80,fp);
-     sscanf(t,"%f", &a);
-     absthr[j] =  a;
-  }
-  fclose(fp);
- }
--- 0 ----
diff -r -c -N encoder/reservoir.c lame3.13/reservoir.c
*** encoder/reservoir.c	Wed Jan 22 02:43:18 1997
--- lame3.13/reservoir.c	Sat Jun 19 17:33:22 1999
***************
*** 27,32 ****
--- 27,33 ----
  #include "huffman.h"
  #include "l3bitstream.h"
  #include "reservoir.h"
+ #include "gtkanal.h"
  
  /*
    Layer3 bit reservoir:
***************
*** 36,48 ****
  static int ResvSize = 0; /* in bits */
  static int ResvMax  = 0; /* in bits */
  
  /*
    ResvFrameBegin:
    Called at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! void
  ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
      layer *info;
--- 37,55 ----
  static int ResvSize = 0; /* in bits */
  static int ResvMax  = 0; /* in bits */
  
+ void InitReservoir(void)
+ {
+ 	ResvSize = 0;
+ 	ResvMax  = 0;
+ }
+ 
  /*
    ResvFrameBegin:
    Called at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! int
  ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
      layer *info;
***************
*** 71,78 ****
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
      assert( expectedResvSize == ResvSize );
! 
!     fullFrameBits = mean_bits * mode_gr;
  
      /*
        determine maximum size of reservoir:
--- 78,84 ----
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
      assert( expectedResvSize == ResvSize );
!     fullFrameBits = mean_bits * mode_gr + ResvSize;
  
      /*
        determine maximum size of reservoir:
***************
*** 90,95 ****
--- 96,110 ----
        */
      if ( ResvMax > resvLimit )
  	ResvMax = resvLimit;
+ 
+ #ifdef HAVEGTK
+   if (gtkflag){
+     pinfo->mean_bits=mean_bits/2;  /* expected bits per channel per granule */
+     pinfo->resvsize=ResvSize;
+   }
+ #endif
+ 
+     return fullFrameBits;
  }
  
  /*
***************
*** 99,105 ****
    and perceptual entropy.
  */
  int
! ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits )
  {
      int more_bits, max_bits, add_bits, over_bits;
  
--- 114,120 ----
    and perceptual entropy.
  */
  int
! ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits,int gr,int ch)
  {
      int more_bits, max_bits, add_bits, over_bits;
  
***************
*** 113,118 ****
--- 128,134 ----
  	return max_bits;
  
      more_bits = *pe * 3.1 - mean_bits;
+ 
      add_bits = 0;
      if ( more_bits > 100 )
      {
***************
*** 123,128 ****
--- 139,146 ----
  	else
  	    add_bits = more_bits;
      }
+ 
+ 
      over_bits = ResvSize - ((ResvMax * 8) / 10) - add_bits;
      if ( over_bits > 0 )
  	add_bits += over_bits;
***************
*** 130,139 ****
--- 148,197 ----
      max_bits += add_bits;
      if ( max_bits > 4095 )
  	max_bits = 4095;
+ 
      return max_bits;
  }
  
  /*
+   ResvMaxBits2:
+   As above, but now it *really* is bits per granule (both channels).  
+   Mark Taylor 4/99
+ */
+ void ResvMaxBits2(int mean_bits, int *targ_bits, int *extra_bits, int gr)
+ {
+   int add_bits;
+ 
+ 
+   *targ_bits = mean_bits ;
+   /* extra bits if the reservoir is almost full */
+   if (ResvSize > ((ResvMax * 9) / 10)) {
+     add_bits= ResvSize-((ResvMax * 9) / 10);
+     *targ_bits += add_bits;
+   }else {
+     add_bits =0 ;
+     /* build up reservoir.  this builds the reservoir a little slower
+      * than FhG.  It could simple be mean_bits/15, but this was rigged
+      * to always produce 100 (the old value) at 128kbs */
+     *targ_bits -= (int) (mean_bits/15.2);
+   }
+ 
+   
+   /* amount from the reservoir we are allowed to use */
+   *extra_bits =    
+     (ResvSize  < (ResvMax*6)/10  ? ResvSize : (ResvMax*6)/10);
+   *extra_bits -= add_bits;
+   
+   if (*extra_bits < 0) *extra_bits=0;
+ 
+ 
+   if ( *targ_bits > 4095 )
+     *targ_bits = 4095;
+   if ( *targ_bits + *extra_bits > 4095 )
+     *extra_bits = 4095 - *targ_bits;
+   
+ }
+ 
+ /*
    ResvAdjust:
    Called after a granule's bit allocation. Readjusts the size of
    the reservoir to reflect the granule's usage.
***************
*** 143,148 ****
--- 201,207 ----
  {
      ResvSize += (mean_bits / fr_ps->stereo) - gi->part2_3_length;
  }
+ 
  
  /*
    ResvFrameEnd:
diff -r -c -N encoder/reservoir.h lame3.13/reservoir.h
*** encoder/reservoir.h	Wed Jan 22 02:43:18 1997
--- lame3.13/reservoir.h	Thu Jun  3 00:09:03 1999
***************
*** 22,29 ****
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! void ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength );
! int  ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits );
  void ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits );
  void ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits );
  
--- 22,30 ----
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! int ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength );
! int  ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits, int gr, int ch );
! void ResvMaxBits2( int mean_bits, int *targ_bits, int *max_bits, int gr);
  void ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits );
  void ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits );
  
diff -r -c -N encoder/subs.c lame3.13/subs.c
*** encoder/subs.c	Wed Jan 22 02:43:18 1997
--- lame3.13/subs.c	Sat Jun  5 16:52:21 1999
***************
*** 1,163 ****
! /**********************************************************************
!  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
!  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
!  *
!  * $Id: subs.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
!  *
!  * $Log: subs.c,v $
!  * Revision 1.1  1996/02/14 04:04:23  rowlands
!  * Initial revision
!  *
!  * Received from Mike Coleman
!  **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 2/25/91  Davis Pan           start of version 1.0 records          *
!  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
!  * 7/10/91  Earle Jennings      Ported to MsDos from Macintosh        *
!  *                              Replacement of one float with FLOAT   *
!  * 2/11/92  W. Joseph Carter    Added type casting to memset() args.  *
!  * 4/27/92  Masahiro Iwadare    Added 256 point version for Layer III *
!  **********************************************************************/
  
  #include "common.h"
- #include "encoder.h"
  
! /*****************************************************************************
!  ************************** Start of Subroutines *****************************
!  *****************************************************************************/
! 
! /*****************************************************************************
!  * FFT computes fast fourier transform of BLKSIZE samples of data            *
!  *   uses decimation-in-frequency algorithm described in "Digital            *
!  *   Signal Processing" by Oppenheim and Schafer, refer to pages 304         *
!  *   (flow graph) and 330-332 (Fortran program in problem 5)                 *
!  *   to get the inverse fft, change line 20 from                             *
!  *                 w_imag[L] = -sin(PI/le1);                                 *
!  *                          to                                               *
!  *                 w_imag[L] = sin(PI/le1);                                  *
!  *                                                                           *
!  *   required constants:                                                     *
!  *         #define      PI          3.14159265358979                         *
!  *         #define      BLKSIZE     1024                                     *
!  *         #define      LOGBLKSIZE  10                                       *
!  *         #define      BLKSIZE_S   256                                      *
!  *         #define      LOGBLKSIZE_S 8                                       *
!  *                                                                           *
!  *****************************************************************************/
! #define      BLKSIZE_S   256
! #define      LOGBLKSIZE_S 8
! 
! void fft(x_real,x_imag, energy, phi, N)
! FLOAT x_real[BLKSIZE], x_imag[BLKSIZE], energy[BLKSIZE], phi[BLKSIZE];
! int	N;
  {
!  int     M,MM1;
!  static int     init=0;
!  int     NV2, NM1, MP;
!  static double  w_real[2][LOGBLKSIZE], w_imag[2][LOGBLKSIZE];
!  int            i,j,k,L;
!  int            ip, le,le1;
!  double         t_real, t_imag, u_real, u_imag;
! 
!  if(init==0) {
!     memset((char *) w_real, 0, sizeof(w_real));  /* preset statics to 0 */
!     memset((char *) w_imag, 0, sizeof(w_imag));  /* preset statics to 0 */
!     M = LOGBLKSIZE;
!     for(L=0; L<M; L++){
!        le = 1 << (M-L);
!        le1 = le >> 1;
!        w_real[0][L] = cos(PI/le1);
!        w_imag[0][L] = -sin(PI/le1);
!     }          
!     M = LOGBLKSIZE_S;
!     for(L=0; L<M; L++){
!        le = 1 << (M-L);
!        le1 = le >> 1;
!        w_real[1][L] = cos(PI/le1);
!        w_imag[1][L] = -sin(PI/le1);
!     }          
!     init++;
!  }
!  switch(N) {
! 	case BLKSIZE:
! 			M = LOGBLKSIZE;
! 			MP = 0;
! 			break;
! 	case BLKSIZE_S:
! 			M = LOGBLKSIZE_S;
! 			MP = 1;
! 			break;
! 	default:	printf("Error: Bad FFT Size in subs.c\n");
! 			exit(-1);
!  }
!  MM1 = M-1;
!  NV2 = N >> 1;
!  NM1 = N - 1;
!  for(L=0; L<MM1; L++){
!     le = 1 << (M-L);
!     le1 = le >> 1;
!     u_real = 1;
!     u_imag = 0;
!     for(j=0; j<le1; j++){
!        for(i=j; i<N; i+=le){
!           ip = i + le1;
!           t_real = x_real[i] + x_real[ip];
!           t_imag = x_imag[i] + x_imag[ip];
!           x_real[ip] = x_real[i] - x_real[ip];
!           x_imag[ip] = x_imag[i] - x_imag[ip];
!           x_real[i] = t_real;
!           x_imag[i] = t_imag;
!           t_real = x_real[ip];
!           x_real[ip] = x_real[ip]*u_real - x_imag[ip]*u_imag;
!           x_imag[ip] = x_imag[ip]*u_real + t_real*u_imag;
!        }
!        t_real = u_real;
!        u_real = u_real*w_real[MP][L] - u_imag*w_imag[MP][L];
!        u_imag = u_imag*w_real[MP][L] + t_real*w_imag[MP][L];
      }
   }
!  /* special case: L = M-1; all Wn = 1 */
!  for(i=0; i<N; i+=2){
!     ip = i + 1;
!     t_real = x_real[i] + x_real[ip];
!     t_imag = x_imag[i] + x_imag[ip];
!     x_real[ip] = x_real[i] - x_real[ip];
!     x_imag[ip] = x_imag[i] - x_imag[ip];
!     x_real[i] = t_real;
!     x_imag[i] = t_imag;
!     energy[i] = x_real[i]*x_real[i] + x_imag[i]*x_imag[i];
!     if(energy[i] <= 0.0005){phi[i] = 0;energy[i] = 0.0005;}
!     else phi[i] = atan2((double) x_imag[i],(double) x_real[i]);
!     energy[ip] = x_real[ip]*x_real[ip] + x_imag[ip]*x_imag[ip];
!     if(energy[ip] == 0)phi[ip] = 0;
!     else phi[ip] = atan2((double) x_imag[ip],(double) x_real[ip]);
   }
!  /* this section reorders the data to the correct ordering */
!  j = 0;
!  for(i=0; i<NM1; i++){
!     if(i<j){
! /* use this section only if you need the FFT in complex number form *
!  * (and in the correct ordering)                                    */
!        t_real = x_real[j];
!        t_imag = x_imag[j];
!        x_real[j] = x_real[i];
!        x_imag[j] = x_imag[i];
!        x_real[i] = t_real;
!        x_imag[i] = t_imag;
! /* reorder the energy and phase, phi                                        */
!        t_real = energy[j];
!        energy[j] = energy[i];
!        energy[i] = t_real;
!        t_real = phi[j];
!        phi[j] = phi[i];
!        phi[i] = t_real;
!     }
!     k=NV2;
!     while(k<=j){
!        j = j-k;
!        k = k >> 1;
!     }
!     j = j+k;
   }
  }
--- 1,246 ----
! /*
! ** FFT and FHT routines
! **  Copyright 1988, 1993; Ron Mayer
! **  
! **  fht(fz,n);
! **      Does a hartley transform of "n" points in the array "fz".
! **      
! ** NOTE: This routine uses at least 2 patented algorithms, and may be
! **       under the restrictions of a bunch of different organizations.
! **       Although I wrote it completely myself; it is kind of a derivative
! **       of a routine I once authored and released under the GPL, so it
! **       may fall under the free software foundation's restrictions;
! **       it was worked on as a Stanford Univ project, so they claim
! **       some rights to it; it was further optimized at work here, so
! **       I think this company claims parts of it.  The patents are
! **       held by R. Bracewell (the FHT algorithm) and O. Buneman (the
! **       trig generator), both at Stanford Univ.
! **       If it were up to me, I'd say go do whatever you want with it;
! **       but it would be polite to give credit to the following people
! **       if you use this anywhere:
! **           Euler     - probable inventor of the fourier transform.
! **           Gauss     - probable inventor of the FFT.
! **           Hartley   - probable inventor of the hartley transform.
! **           Buneman   - for a really cool trig generator
! **           Mayer(me) - for authoring this particular version and
! **                       including all the optimizations in one package.
! **       Thanks,
! **       Ron Mayer; mayer@acuson.com
! **
! */
  
+ #include <math.h>
  #include "common.h"
  
! static FLOAT costab[20]=
!     {
!      .00000000000000000000000000000000000000000000000000,
!      .70710678118654752440084436210484903928483593768847,
!      .92387953251128675612818318939678828682241662586364,
!      .98078528040323044912618223613423903697393373089333,
!      .99518472667219688624483695310947992157547486872985,
!      .99879545620517239271477160475910069444320361470461,
!      .99969881869620422011576564966617219685006108125772,
!      .99992470183914454092164649119638322435060646880221,
!      .99998117528260114265699043772856771617391725094433,
!      .99999529380957617151158012570011989955298763362218,
!      .99999882345170190992902571017152601904826792288976,
!      .99999970586288221916022821773876567711626389934930,
!      .99999992646571785114473148070738785694820115568892,
!      .99999998161642929380834691540290971450507605124278,
!      .99999999540410731289097193313960614895889430318945,
!      .99999999885102682756267330779455410840053741619428
!     };
! static FLOAT sintab[20]=
!     {
!      1.0000000000000000000000000000000000000000000000000,
!      .70710678118654752440084436210484903928483593768846,
!      .38268343236508977172845998403039886676134456248561,
!      .19509032201612826784828486847702224092769161775195,
!      .09801714032956060199419556388864184586113667316749,
!      .04906767432741801425495497694268265831474536302574,
!      .02454122852291228803173452945928292506546611923944,
!      .01227153828571992607940826195100321214037231959176,
!      .00613588464915447535964023459037258091705788631738,
!      .00306795676296597627014536549091984251894461021344,
!      .00153398018628476561230369715026407907995486457522,
!      .00076699031874270452693856835794857664314091945205,
!      .00038349518757139558907246168118138126339502603495,
!      .00019174759731070330743990956198900093346887403385,
!      .00009587379909597734587051721097647635118706561284,
!      .00004793689960306688454900399049465887274686668768
!     };
! 
! /* This is a simplified version for n an even power of 2 */
! 
! static void fht(FLOAT *fz, int n)
  {
!  int i,k,k1,k2,k3,k4,kx;
!  FLOAT *fi,*fn,*gi;
!  FLOAT t_c,t_s;
! 
!  for (k1=1,k2=0;k1<n;k1++)
!     {
!      FLOAT a;
!      for (k=n>>1; (!((k2^=k)&k)); k>>=1);
!      if (k1>k2)
! 	{
! 	     a=fz[k1];fz[k1]=fz[k2];fz[k2]=a;
! 	}
      }
+   for (fi=fz,fn=fz+n;fi<fn;fi+=4)
+      {
+       FLOAT f0,f1,f2,f3;
+       f1     = fi[0 ]-fi[1 ];
+       f0     = fi[0 ]+fi[1 ];
+       f3     = fi[2 ]-fi[3 ];
+       f2     = fi[2 ]+fi[3 ];
+       fi[2 ] = (f0-f2);	
+       fi[0 ] = (f0+f2);
+       fi[3 ] = (f1-f3);	
+       fi[1 ] = (f1+f3);
+      }
+ 
+  k=0;
+  do
+     {
+      FLOAT s1,c1;
+      k  += 2;
+      k1  = 1  << k;
+      k2  = k1 << 1;
+      k4  = k2 << 1;
+      k3  = k2 + k1;
+      kx  = k1 >> 1;
+ 	 fi  = fz;
+ 	 gi  = fi + kx;
+ 	 fn  = fz + n;
+ 	 do
+ 	    {
+ 	     FLOAT g0,f0,f1,g1,f2,g2,f3,g3;
+ 	     f1      = fi[0 ] - fi[k1];
+ 	     f0      = fi[0 ] + fi[k1];
+ 	     f3      = fi[k2] - fi[k3];
+ 	     f2      = fi[k2] + fi[k3];
+ 	     fi[k2]  = f0	  - f2;
+ 	     fi[0 ]  = f0	  + f2;
+ 	     fi[k3]  = f1	  - f3;
+ 	     fi[k1]  = f1	  + f3;
+ 	     g1      = gi[0 ] - gi[k1];
+ 	     g0      = gi[0 ] + gi[k1];
+ 	     g3      = SQRT2  * gi[k3];
+ 	     g2      = SQRT2  * gi[k2];
+ 	     gi[k2]  = g0	  - g2;
+ 	     gi[0 ]  = g0	  + g2;
+ 	     gi[k3]  = g1	  - g3;
+ 	     gi[k1]  = g1	  + g3;
+ 	     gi     += k4;
+ 	     fi     += k4;
+ 	    } while (fi<fn);
+      t_c = costab[k];
+      t_s = sintab[k];
+      c1 = 1;
+      s1 = 0;
+      for (i=1;i<kx;i++)
+         {
+ 	 FLOAT c2,s2;
+          FLOAT t = c1;
+          c1 = t*t_c - s1*t_s;
+          s1 = t*t_s + s1*t_c;
+          c2 = c1*c1 - s1*s1;
+          s2 = 2*(c1*s1);
+ 	     fn = fz + n;
+ 	     fi = fz +i;
+ 	     gi = fz +k1-i;
+ 	     do
+ 		{
+ 		 FLOAT a,b,g0,f0,f1,g1,f2,g2,f3,g3;
+ 		 b       = s2*fi[k1] - c2*gi[k1];
+ 		 a       = c2*fi[k1] + s2*gi[k1];
+ 		 f1      = fi[0 ]    - a;
+ 		 f0      = fi[0 ]    + a;
+ 		 g1      = gi[0 ]    - b;
+ 		 g0      = gi[0 ]    + b;
+ 		 b       = s2*fi[k3] - c2*gi[k3];
+ 		 a       = c2*fi[k3] + s2*gi[k3];
+ 		 f3      = fi[k2]    - a;
+ 		 f2      = fi[k2]    + a;
+ 		 g3      = gi[k2]    - b;
+ 		 g2      = gi[k2]    + b;
+ 		 b       = s1*f2     - c1*g3;
+ 		 a       = c1*f2     + s1*g3;
+ 		 fi[k2]  = f0        - a;
+ 		 fi[0 ]  = f0        + a;
+ 		 gi[k3]  = g1        - b;
+ 		 gi[k1]  = g1        + b;
+ 		 b       = c1*g2     - s1*f3;
+ 		 a       = s1*g2     + c1*f3;
+ 		 gi[k2]  = g0        - a;
+ 		 gi[0 ]  = g0        + a;
+ 		 fi[k3]  = f1        - b;
+ 		 fi[k1]  = f1        + b;
+ 		 gi     += k4;
+ 		 fi     += k4;
+ 		} while (fi<fn);
+         }
+     } while (k4<n);
+ }
+ 
+ void fft(FLOAT *x_real, FLOAT *energy, FLOAT *ax, FLOAT *bx, int N)
+ {
+  FLOAT a,b;
+  int i,j;
+ 
+  fht(x_real,N);
+ 
+ 
+  energy[0] = x_real[0] * x_real[0];
+  ax[0] = bx[0] = x_real[0];
+ 
+  for (i=1,j=N-1;i<N/2;i++,j--) {
+    a = ax[i] = x_real[i];
+    b = bx[i] = x_real[j];
+    energy[i]=(a*a + b*b)/2;
+    
+    if (energy[i] < 0.0005) {
+      energy[i] = 0.0005;
+      ax[i] = bx[i] =  0.0223606797749978970790696308768019662239; /* was sqrt(0.0005) */
+    }
   }
!  energy[N/2] = x_real[N/2] * x_real[N/2];
!  ax[N/2] = bx[N/2] = x_real[N/2];
! }
! 
! 
! 
! 
! double fft_side( FLOAT in[2][1024], int s)
! {
!  double energy,t;
!  FLOAT a,b;
!  int i,j;
! 
!  if(!s)
!  {
!   energy = (in[0][0] - in[1][0]) * (in[0][0] - in[1][0])/2;
!   s++;
   }
!  else
!   energy=0.0;
! 
!  for (i=s,j=1024-s;i<512;i++,j--) {
!   a = in[0][i] - in[1][i];
!   b = in[0][j] - in[1][j];
! 
!   t=(a*a + b*b)/4;
! 
!      if (t < 0.0005) {
!        t = 0.0005;
!      }
!    energy += t;
   }
+  return energy + (in[0][512] - in[1][512]) * (in[0][512] - in[1][512])/2;
+ 
+ 
  }
+ 
+ 
diff -r -c -N encoder/subs.h lame3.13/subs.h
*** encoder/subs.h	Wed Dec 31 17:00:00 1969
--- lame3.13/subs.h	Wed Jun  2 21:37:52 1999
***************
*** 0 ****
--- 1,12 ----
+ #ifndef FFT_H
+ #define FFT_H
+ 
+ #include "types.h"
+ 
+ void fft(float x_real[BLKSIZE],
+          float energy[BLKSIZE],
+          float ax[BLKSIZE], bx[BLKSIZE],
+          int N);
+ 
+ 
+ #endif
diff -r -c -N encoder/tables.c lame3.13/tables.c
*** encoder/tables.c	Wed Dec 31 17:00:00 1969
--- lame3.13/tables.c	Thu Jun 17 23:30:58 1999
***************
*** 0 ****
--- 1,969 ----
+ double psy_data[] =
+ {48000.0, 61,
+  0, 1, 24.5, 4.532, 0.970, 0.000,
+  1, 1, 24.5, 4.532, 0.755, 0.469,
+  2, 1, 24.5, 4.532, 0.738, 0.938,
+  3, 1, 24.5, 0.904, 0.730, 1.406,
+  4, 1, 24.5, 0.904, 0.724, 1.875,
+  5, 1, 20.0, 0.090, 0.723, 2.344,
+  6, 1, 20.0, 0.090, 0.723, 2.813,
+  7, 1, 20.0, 0.029, 0.723, 3.281,
+  8, 1, 20.0, 0.029, 0.718, 3.750,
+  9, 1, 20.0, 0.009, 0.690, 4.199,
+  10, 1, 20.0, 0.009, 0.660, 4.625,
+  11, 1, 18.0, 0.009, 0.641, 5.047,
+  12, 1, 18.0, 0.009, 0.600, 5.438,
+  13, 1, 18.0, 0.009, 0.584, 5.828,
+  14, 1, 12.0, 0.009, 0.532, 6.188,
+  15, 1, 12.0, 0.009, 0.537, 6.522,
+  16, 2, 6.0, 0.018, 0.857, 7.174,
+  17, 2, 6.0, 0.018, 0.858, 7.801,
+  18, 2, 3.0, 0.018, 0.853, 8.402,
+  19, 2, 3.0, 0.018, 0.824, 8.966,
+  20, 2, 3.0, 0.018, 0.778, 9.484,
+  21, 2, 3.0, 0.018, 0.740, 9.966,
+  22, 2, 0.0, 0.018, 0.709, 10.426,
+  23, 2, 0.0, 0.018, 0.676, 10.866,
+  24, 2, 0.0, 0.018, 0.632, 11.279,
+  25, 2, 0.0, 0.018, 0.592, 11.669,
+  26, 2, 0.0, 0.018, 0.553, 12.042,
+  27, 2, 0.0, 0.018, 0.510, 12.386,
+  28, 2, 0.0, 0.018, 0.513, 12.721,
+  29, 3, 0.0, 0.027, 0.608, 13.115,
+  30, 3, 0.0, 0.027, 0.673, 13.562,
+  31, 3, 0.0, 0.027, 0.637, 13.984,
+  32, 3, 0.0, 0.027, 0.586, 14.371,
+  33, 3, 0.0, 0.027, 0.571, 14.741,
+  34, 4, 0.0, 0.036, 0.616, 15.140,
+  35, 4, 0.0, 0.036, 0.640, 15.563,
+  36, 4, 0.0, 0.036, 0.598, 15.962,
+  37, 4, 0.0, 0.036, 0.538, 16.324,
+  38, 4, 0.0, 0.036, 0.512, 16.665,
+  39, 5, 0.0, 0.045, 0.528, 17.020,
+  40, 5, 0.0, 0.045, 0.517, 17.373,
+  41, 5, 0.0, 0.045, 0.493, 17.708,
+  42, 6, 0.0, 0.054, 0.499, 18.045,
+  43, 7, 0.0, 0.063, 0.525, 18.398,
+  44, 7, 0.0, 0.063, 0.541, 18.762,
+  45, 8, 0.0, 0.072, 0.528, 19.120,
+  46, 8, 0.0, 0.072, 0.510, 19.466,
+  47, 8, 0.0, 0.072, 0.506, 19.807,
+  48, 10, 0.0, 0.180, 0.525, 20.159,
+  49, 10, 0.0, 0.180, 0.536, 20.522,
+  50, 10, 0.0, 0.180, 0.518, 20.874,
+  51, 13, 0.0, 0.372, 0.501, 21.214,
+  52, 13, 0.0, 0.372, 0.497, 21.553,
+  53, 14, 0.0, 0.400, 0.497, 21.892,
+  54, 18, 0.0, 1.627, 0.495, 22.231,
+  55, 18, 0.0, 1.627, 0.494, 22.569,
+  56, 20, 0.0, 1.808, 0.497, 22.909,
+  57, 25, 0.0, 22.607, 0.494, 23.248,
+  58, 25, 0.0, 22.607, 0.487, 23.583,
+  59, 35, 0.0, 31.650, 0.483, 23.915,
+  60, 67, 0.0, 605.867, 0.482, 24.246,
+  61, 67, 0.0, 605.867, 0.524, 24.576,
+  44100.0, 62,
+  0, 1, 24.5, 4.532, 0.951, 0.000,
+  1, 1, 24.5, 4.532, 0.700, 0.431,
+  2, 1, 24.5, 4.532, 0.681, 0.861,
+  3, 1, 24.5, 0.904, 0.675, 1.292,
+  4, 1, 24.5, 0.904, 0.667, 1.723,
+  5, 1, 20.0, 0.090, 0.665, 2.153,
+  6, 1, 20.0, 0.090, 0.664, 2.584,
+  7, 1, 20.0, 0.029, 0.664, 3.015,
+  8, 1, 20.0, 0.029, 0.664, 3.445,
+  9, 1, 20.0, 0.029, 0.655, 3.876,
+  10, 1, 20.0, 0.009, 0.616, 4.279,
+  11, 1, 20.0, 0.009, 0.597, 4.670,
+  12, 1, 18.0, 0.009, 0.578, 5.057,
+  13, 1, 18.0, 0.009, 0.541, 5.416,
+  14, 1, 18.0, 0.009, 0.575, 5.774,
+  15, 2, 12.0, 0.018, 0.856, 6.422,
+  16, 2, 6.0, 0.018, 0.846, 7.026,
+  17, 2, 6.0, 0.018, 0.840, 7.609,
+  18, 2, 3.0, 0.018, 0.822, 8.168,
+  19, 2, 3.0, 0.018, 0.800, 8.710,
+  20, 2, 3.0, 0.018, 0.753, 9.207,
+  21, 2, 3.0, 0.018, 0.704, 9.662,
+  22, 2, 0.0, 0.018, 0.674, 10.099,
+  23, 2, 0.0, 0.018, 0.640, 10.515,
+  24, 2, 0.0, 0.018, 0.609, 10.917,
+  25, 2, 0.0, 0.018, 0.566, 11.293,
+  26, 2, 0.0, 0.018, 0.535, 11.652,
+  27, 2, 0.0, 0.018, 0.531, 11.997,
+  28, 3, 0.0, 0.027, 0.615, 12.394,
+  29, 3, 0.0, 0.027, 0.686, 12.850,
+  30, 3, 0.0, 0.027, 0.650, 13.277,
+  31, 3, 0.0, 0.027, 0.612, 13.681,
+  32, 3, 0.0, 0.027, 0.567, 14.062,
+  33, 3, 0.0, 0.027, 0.520, 14.411,
+  34, 3, 0.0, 0.027, 0.513, 14.751,
+  35, 4, 0.0, 0.036, 0.557, 15.119,
+  36, 4, 0.0, 0.036, 0.584, 15.508,
+  37, 4, 0.0, 0.036, 0.570, 15.883,
+  38, 5, 0.0, 0.045, 0.579, 16.263,
+  39, 5, 0.0, 0.045, 0.585, 16.654,
+  40, 5, 0.0, 0.045, 0.548, 17.020,
+  41, 6, 0.0, 0.054, 0.536, 17.374,
+  42, 6, 0.0, 0.054, 0.550, 17.744,
+  43, 7, 0.0, 0.063, 0.532, 18.104,
+  44, 7, 0.0, 0.063, 0.504, 18.447,
+  45, 7, 0.0, 0.063, 0.496, 18.782,
+  46, 9, 0.0, 0.081, 0.517, 19.130,
+  47, 9, 0.0, 0.081, 0.527, 19.487,
+  48, 9, 0.0, 0.081, 0.516, 19.838,
+  49, 10, 0.0, 0.180, 0.497, 20.179,
+  50, 10, 0.0, 0.180, 0.489, 20.510,
+  51, 11, 0.0, 0.198, 0.502, 20.852,
+  52, 14, 0.0, 0.400, 0.501, 21.196,
+  53, 14, 0.0, 0.400, 0.491, 21.531,
+  54, 15, 0.0, 0.429, 0.497, 21.870,
+  55, 20, 0.0, 1.808, 0.504, 22.214,
+  56, 20, 0.0, 1.808, 0.504, 22.558,
+  57, 21, 0.0, 1.898, 0.495, 22.898,
+  58, 27, 0.0, 24.416, 0.486, 23.232,
+  59, 27, 0.0, 24.416, 0.484, 23.564,
+  60, 36, 0.0, 32.554, 0.483, 23.897,
+  61, 73, 0.0, 660.124, 0.475, 24.229,
+  62, 18, 0.0, 162.770, 0.515, 24.442,
+  32000.0, 58,
+  0, 2, 24.5, 4.532, 0.997, 0.313,
+  1, 2, 24.5, 4.532, 0.893, 0.938,
+  2, 2, 24.5, 1.809, 0.881, 1.563,
+  3, 2, 20.0, 0.181, 0.873, 2.188,
+  4, 2, 20.0, 0.181, 0.872, 2.813,
+  5, 2, 20.0, 0.057, 0.871, 3.438,
+  6, 2, 20.0, 0.018, 0.860, 4.045,
+  7, 2, 20.0, 0.018, 0.839, 4.625,
+  8, 2, 18.0, 0.018, 0.812, 5.173,
+  9, 2, 18.0, 0.018, 0.784, 5.698,
+  10, 2, 12.0, 0.018, 0.741, 6.185,
+  11, 2, 12.0, 0.018, 0.697, 6.634,
+  12, 2, 6.0, 0.018, 0.674, 7.070,
+  13, 2, 6.0, 0.018, 0.651, 7.492,
+  14, 2, 6.0, 0.018, 0.633, 7.905,
+  15, 2, 3.0, 0.018, 0.611, 8.305,
+  16, 2, 3.0, 0.018, 0.589, 8.695,
+  17, 2, 3.0, 0.018, 0.575, 9.064,
+  18, 3, 3.0, 0.027, 0.654, 9.484,
+  19, 3, 3.0, 0.027, 0.724, 9.966,
+  20, 3, 0.0, 0.027, 0.701, 10.426,
+  21, 3, 0.0, 0.027, 0.673, 10.866,
+  22, 3, 0.0, 0.027, 0.631, 11.279,
+  23, 3, 0.0, 0.027, 0.592, 11.669,
+  24, 3, 0.0, 0.027, 0.553, 12.042,
+  25, 3, 0.0, 0.027, 0.510, 12.386,
+  26, 3, 0.0, 0.027, 0.506, 12.721,
+  27, 4, 0.0, 0.036, 0.562, 13.091,
+  28, 4, 0.0, 0.036, 0.598, 13.488,
+  29, 4, 0.0, 0.036, 0.589, 13.873,
+  30, 5, 0.0, 0.045, 0.607, 14.268,
+  31, 5, 0.0, 0.045, 0.620, 14.679,
+  32, 5, 0.0, 0.045, 0.580, 15.067,
+  33, 5, 0.0, 0.045, 0.532, 15.424,
+  34, 5, 0.0, 0.045, 0.517, 15.771,
+  35, 6, 0.0, 0.054, 0.517, 16.120,
+  36, 6, 0.0, 0.054, 0.509, 16.466,
+  37, 6, 0.0, 0.054, 0.506, 16.807,
+  38, 8, 0.0, 0.072, 0.522, 17.158,
+  39, 8, 0.0, 0.072, 0.531, 17.518,
+  40, 8, 0.0, 0.072, 0.519, 17.869,
+  41, 10, 0.0, 0.090, 0.512, 18.215,
+  42, 10, 0.0, 0.090, 0.509, 18.563,
+  43, 10, 0.0, 0.090, 0.498, 18.902,
+  44, 12, 0.0, 0.109, 0.494, 19.239,
+  45, 12, 0.0, 0.109, 0.501, 19.580,
+  46, 13, 0.0, 0.118, 0.508, 19.925,
+  47, 14, 0.0, 0.252, 0.502, 20.269,
+  48, 14, 0.0, 0.252, 0.493, 20.606,
+  49, 16, 0.0, 0.288, 0.497, 20.944,
+  50, 20, 0.0, 0.572, 0.506, 21.288,
+  51, 20, 0.0, 0.572, 0.510, 21.635,
+  52, 23, 0.0, 0.658, 0.504, 21.980,
+  53, 27, 0.0, 2.441, 0.496, 22.319,
+  54, 27, 0.0, 2.441, 0.493, 22.656,
+  55, 32, 0.0, 2.893, 0.490, 22.993,
+  56, 37, 0.0, 33.458, 0.482, 23.326,
+  57, 37, 0.0, 33.458, 0.458, 23.656,
+  58, 12, 0.0, 10.851, 0.500, 23.937,
+  24000, 59,
+  0, 2, 15, 17.8250179, 0.697374165, 0.236874461,
+  1, 2, 15, 17.8250179, 0.455024809, 0.71016103,
+  2, 2, 15, 1.78250182, 0.431440443, 1.18193281,
+  3, 2, 15, 1.78250182, 0.42391625, 1.65102732,
+  4, 2, 13, 0.178250194, 0.418206781, 2.11632562,
+  5, 2, 13, 0.178250194, 0.41158545, 2.57676744,
+  6, 2, 13, 0.0563676581, 0.405409157, 3.03136396,
+  7, 2, 13, 0.0563676581, 0.399695486, 3.47920918,
+  8, 2, 13, 0.0563676581, 0.393753231, 3.91948748,
+  9, 2, 12, 0.0178250186, 0.387357473, 4.35147953,
+  10, 2, 12, 0.0178250186, 0.38045457, 4.77456427,
+  11, 2, 10, 0.0178250186, 0.373053908, 5.18822002,
+  12, 2, 10, 0.0178250186, 0.365188122, 5.59202194,
+  13, 2, 10, 0.0178250186, 0.356897771, 5.98564005,
+  14, 2, 9, 0.0178250186, 0.348700613, 6.36883163,
+  15, 2, 9, 0.0178250186, 0.340260029, 6.74143791,
+  16, 2, 6, 0.0178250186, 0.332341045, 7.10337448,
+  17, 2, 6, 0.0178250186, 0.330462843, 7.45462418,
+  18, 2, 6, 0.0178250186, 0.345568359, 7.79523182,
+  19, 3, 3, 0.0267375279, 0.377859652, 8.20455742,
+  20, 3, 3, 0.0267375279, 0.396689415, 8.67640114,
+  21, 3, 3, 0.0267375279, 0.391237885, 9.12561035,
+  22, 3, 3, 0.0267375279, 0.37761277, 9.55298138,
+  23, 3, 3, 0.0267375279, 0.362836808, 9.95940971,
+  24, 3, 0, 0.0267375279, 0.349010617, 10.3458519,
+  25, 3, 0, 0.0267375279, 0.339673489, 10.7132998,
+  26, 3, 0, 0.0267375279, 0.343845725, 11.0627575,
+  27, 4, 0, 0.0356500372, 0.355822682, 11.447506,
+  28, 4, 0, 0.0356500372, 0.358104348, 11.8627586,
+  29, 4, 0, 0.0356500372, 0.34745428, 12.2520256,
+  30, 4, 0, 0.0356500372, 0.334927917, 12.6173973,
+  31, 4, 0, 0.0356500372, 0.331643254, 12.9608269,
+  32, 5, 0, 0.0445625484, 0.333368897, 13.3219252,
+  33, 5, 0, 0.0445625484, 0.332313001, 13.6976833,
+  34, 5, 0, 0.0445625484, 0.3314417, 14.047802,
+  35, 6, 0, 0.0534750558, 0.330947191, 14.405302,
+  36, 6, 0, 0.0534750558, 0.332477689, 14.7684803,
+  37, 7, 0, 0.062387567, 0.332647532, 15.1315956,
+  38, 7, 0, 0.062387567, 0.330841452, 15.4940481,
+  39, 8, 0, 0.0713000745, 0.327769846, 15.8516159,
+  40, 8, 0, 0.0713000745, 0.324572712, 16.204628,
+  41, 9, 0, 0.0802125856, 0.323825002, 16.5502281,
+  42, 10, 0, 0.0891250968, 0.321414798, 16.9067478,
+  43, 10, 0, 0.0891250968, 0.318189293, 17.2537231,
+  44, 11, 0, 0.0980376005, 0.315934151, 17.5901108,
+  45, 12, 0, 0.106950112, 0.315639287, 17.931406,
+  46, 13, 0, 0.115862623, 0.316569835, 18.2750721,
+  47, 14, 0, 0.124775134, 0.31656, 18.6191597,
+  48, 15, 0, 0.133687645, 0.315465957, 18.9621754,
+  49, 16, 0, 0.142600149, 0.313576341, 19.3029613,
+  50, 17, 0, 0.151512653, 0.311635971, 19.6405869,
+  51, 18, 0, 0.160425171, 0.311066717, 19.9742699,
+  52, 20, 0, 0.355655879, 0.311465651, 20.3115921,
+  53, 21, 0, 0.373438686, 0.311872005, 20.6507797,
+  54, 23, 0, 0.409004271, 0.311015964, 20.9890823,
+  55, 24, 0, 0.676411927, 0.309207708, 21.3251152,
+  56, 26, 0, 0.732779562, 0.3081128, 21.6565971,
+  57, 28, 0, 0.789147198, 0.310006589, 21.9881554,
+  58, 31, 0, 2.76287794, 0.327113092, 22.3222847,
+  59, 34, 0, 3.03025317, 0.416082352, 22.6605186,
+  22050, 59,
+  0, 2, 15, 17.8250179, 0.658683598, 0.217637643,
+  1, 2, 15, 17.8250179, 0.432554901, 0.652563453,
+  2, 2, 15, 1.78250182, 0.405113578, 1.08633137,
+  3, 2, 15, 1.78250182, 0.397231787, 1.51803517,
+  4, 2, 15, 1.78250182, 0.392088681, 1.94679713,
+  5, 2, 13, 0.178250194, 0.386788279, 2.37177849,
+  6, 2, 13, 0.178250194, 0.380574644, 2.79218864,
+  7, 2, 13, 0.0563676581, 0.375309765, 3.20729256,
+  8, 2, 13, 0.0563676581, 0.370087624, 3.61641645,
+  9, 2, 12, 0.0178250186, 0.364568561, 4.01895428,
+  10, 2, 12, 0.0178250186, 0.358959526, 4.4143672,
+  11, 2, 12, 0.0178250186, 0.352938265, 4.80218887,
+  12, 2, 10, 0.0178250186, 0.3465029, 5.18202305,
+  13, 2, 10, 0.0178250186, 0.33968094, 5.55354261,
+  14, 2, 10, 0.0178250186, 0.332571507, 5.91648674,
+  15, 2, 9, 0.0178250186, 0.326015651, 6.27065945,
+  16, 2, 9, 0.0178250186, 0.325442046, 6.61592293,
+  17, 2, 9, 0.0178250186, 0.341315031, 6.95219517,
+  18, 3, 6, 0.0267375279, 0.374984443, 7.3584404,
+  19, 3, 6, 0.0267375279, 0.396138102, 7.8290925,
+  20, 3, 3, 0.0267375279, 0.39271906, 8.27975655,
+  21, 3, 3, 0.0267375279, 0.380755007, 8.71083069,
+  22, 3, 3, 0.0267375279, 0.367386311, 9.12284088,
+  23, 3, 3, 0.0267375279, 0.354351997, 9.51640987,
+  24, 3, 3, 0.0267375279, 0.341508389, 9.89222908,
+  25, 3, 0, 0.0267375279, 0.333577901, 10.2510386,
+  26, 3, 0, 0.0267375279, 0.338108748, 10.5936022,
+  27, 4, 0, 0.0356500372, 0.350744486, 10.9723492,
+  28, 4, 0, 0.0356500372, 0.354519457, 11.38272,
+  29, 4, 0, 0.0356500372, 0.345274031, 11.7689981,
+  30, 4, 0, 0.0356500372, 0.333828837, 12.1329184,
+  31, 4, 0, 0.0356500372, 0.331436664, 12.4761295,
+  32, 5, 0, 0.0445625484, 0.334172577, 12.8381901,
+  33, 5, 0, 0.0445625484, 0.334024847, 13.2160273,
+  34, 5, 0, 0.0445625484, 0.33392629, 13.5690479,
+  35, 6, 0, 0.0534750558, 0.334218502, 13.9303951,
+  36, 6, 0, 0.0534750558, 0.336405039, 14.298193,
+  37, 7, 0, 0.062387567, 0.337080389, 14.666563,
+  38, 7, 0, 0.062387567, 0.335603535, 15.0346909,
+  39, 8, 0, 0.0713000745, 0.332515866, 15.398139,
+  40, 8, 0, 0.0713000745, 0.327727586, 15.7570457,
+  41, 9, 0, 0.0802125856, 0.322346836, 16.1083431,
+  42, 9, 0, 0.0802125856, 0.317575186, 16.4528522,
+  43, 10, 0, 0.0891250968, 0.31632933, 16.7886105,
+  44, 11, 0, 0.0980376005, 0.317602783, 17.132,
+  45, 12, 0, 0.106950112, 0.319945186, 17.4796028,
+  46, 13, 0, 0.115862623, 0.320881754, 17.8287659,
+  47, 14, 0, 0.124775134, 0.320346534, 18.1774921,
+  48, 15, 0, 0.133687645, 0.318628669, 18.5243168,
+  49, 16, 0, 0.142600149, 0.316125751, 18.8681736,
+  50, 17, 0, 0.151512653, 0.313746184, 19.2082729,
+  51, 18, 0, 0.160425171, 0.312971771, 19.5440025,
+  52, 20, 0, 0.178250194, 0.313278913, 19.8831882,
+  53, 21, 0, 0.373438686, 0.313735574, 20.224247,
+  54, 23, 0, 0.409004271, 0.31308493, 20.5646286,
+  55, 24, 0, 0.426787049, 0.31156227, 20.903141,
+  56, 26, 0, 0.732779562, 0.310435742, 21.2376747,
+  57, 28, 0, 0.789147198, 0.31132248, 21.5730591,
+  58, 30, 0, 0.845514894, 0.32730341, 21.9066811,
+  59, 33, 0, 2.94112802, 0.414659739, 22.2411156,
+  16000, 55,
+  0, 3, 15, 26.7375278, 0.697374165, 0.236874461,
+  1, 3, 15, 26.7375278, 0.455024809, 0.71016103,
+  2, 3, 15, 2.67375278, 0.431440443, 1.18193281,
+  3, 3, 15, 2.67375278, 0.42391625, 1.65102732,
+  4, 3, 13, 0.26737529, 0.418206781, 2.11632562,
+  5, 3, 13, 0.26737529, 0.41158545, 2.57676744,
+  6, 3, 13, 0.0845514908, 0.405409157, 3.03136396,
+  7, 3, 13, 0.0845514908, 0.399695486, 3.47920918,
+  8, 3, 13, 0.0845514908, 0.393753231, 3.91948748,
+  9, 3, 12, 0.0267375279, 0.387357473, 4.35147953,
+  10, 3, 12, 0.0267375279, 0.38045457, 4.77456427,
+  11, 3, 10, 0.0267375279, 0.373053908, 5.18822002,
+  12, 3, 10, 0.0267375279, 0.365188122, 5.59202194,
+  13, 3, 10, 0.0267375279, 0.356897742, 5.98564005,
+  14, 3, 9, 0.0267375279, 0.34869957, 6.36883163,
+  15, 3, 9, 0.0267375279, 0.340241522, 6.74143791,
+  16, 3, 6, 0.0267375279, 0.332089454, 7.10337448,
+  17, 3, 6, 0.0267375279, 0.328292668, 7.45462418,
+  18, 3, 6, 0.0267375279, 0.336574793, 7.79523182,
+  19, 4, 3, 0.0356500372, 0.354600489, 8.17827797,
+  20, 4, 3, 0.0356500372, 0.364343345, 8.59994984,
+  21, 4, 3, 0.0356500372, 0.359369367, 9.00363636,
+  22, 4, 3, 0.0356500372, 0.347775847, 9.38988018,
+  23, 4, 3, 0.0356500372, 0.335562587, 9.7592926,
+  24, 4, 0, 0.0356500372, 0.326988578, 10.1125278,
+  25, 4, 0, 0.0356500372, 0.327966213, 10.4502735,
+  26, 5, 0, 0.0445625484, 0.334450752, 10.811614,
+  27, 5, 0, 0.0445625484, 0.335228145, 11.1935263,
+  28, 5, 0, 0.0445625484, 0.329595625, 11.5549288,
+  29, 5, 0, 0.0445625484, 0.326683223, 11.8971443,
+  30, 6, 0, 0.0534750558, 0.326986551, 12.2520256,
+  31, 6, 0, 0.0534750558, 0.325072199, 12.6173973,
+  32, 6, 0, 0.0534750558, 0.323560268, 12.9608269,
+  33, 7, 0, 0.062387567, 0.322494298, 13.3093863,
+  34, 7, 0, 0.062387567, 0.323403448, 13.6617231,
+  35, 8, 0, 0.0713000745, 0.323232353, 14.0134668,
+  36, 8, 0, 0.0713000745, 0.322662383, 14.3639784,
+  37, 9, 0, 0.0802125856, 0.324054241, 14.7098465,
+  38, 10, 0, 0.0891250968, 0.323228806, 15.0686541,
+  39, 10, 0, 0.0891250968, 0.320751846, 15.4191036,
+  40, 11, 0, 0.0980376005, 0.318823338, 15.7594051,
+  41, 12, 0, 0.106950112, 0.318418682, 16.104557,
+  42, 13, 0, 0.115862623, 0.318762124, 16.451416,
+  43, 14, 0, 0.124775134, 0.317806393, 16.7975388,
+  44, 15, 0, 0.133687645, 0.315653771, 17.1411018,
+  45, 16, 0, 0.142600149, 0.313369036, 17.4808159,
+  46, 17, 0, 0.151512653, 0.312513858, 17.8158207,
+  47, 19, 0, 0.169337675, 0.312785119, 18.1543369,
+  48, 20, 0, 0.178250194, 0.31343773, 18.4948578,
+  49, 22, 0, 0.196075201, 0.313258767, 18.8350143,
+  50, 23, 0, 0.20498772, 0.312570423, 19.1740704,
+  51, 25, 0, 0.222812727, 0.312572777, 19.5104179,
+  52, 27, 0, 0.240637749, 0.313047856, 19.8497677,
+  53, 29, 0, 0.515701056, 0.315029174, 20.1900635,
+  54, 31, 0, 0.551266611, 0.330613613, 20.5294952,
+  55, 33, 0, 0.586832225, 0.41819948, 20.8664398,
+  48000.0, 37,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.989, -8.240, 1.875,
+  2, 1, 0.029, 0.989, -8.240, 3.750,
+  3, 1, 0.009, 0.981, -8.240, 5.438,
+  4, 1, 0.009, 0.985, -8.240, 6.857,
+  5, 1, 0.009, 0.984, -8.240, 8.109,
+  6, 1, 0.009, 0.980, -8.240, 9.237,
+  7, 1, 0.009, 0.968, -8.240, 10.202,
+  8, 1, 0.009, 0.954, -8.240, 11.083,
+  9, 1, 0.009, 0.929, -8.240, 11.865,
+  10, 1, 0.009, 0.906, -7.447, 12.554,
+  11, 1, 0.009, 0.883, -7.447, 13.195,
+  12, 1, 0.009, 0.844, -7.447, 13.781,
+  13, 1, 0.009, 0.792, -7.447, 14.309,
+  14, 1, 0.009, 0.747, -7.447, 14.803,
+  15, 1, 0.009, 0.689, -7.447, 15.250,
+  16, 1, 0.009, 0.644, -7.447, 15.667,
+  17, 1, 0.009, 0.592, -7.447, 16.068,
+  18, 1, 0.009, 0.553, -7.447, 16.409,
+  19, 2, 0.018, 0.850, -7.447, 17.045,
+  20, 2, 0.018, 0.811, -6.990, 17.607,
+  21, 2, 0.018, 0.736, -6.990, 18.097,
+  22, 2, 0.018, 0.665, -6.990, 18.528,
+  23, 2, 0.018, 0.610, -6.990, 18.931,
+  24, 2, 0.018, 0.544, -6.990, 19.295,
+  25, 2, 0.018, 0.528, -6.990, 19.636,
+  26, 3, 0.054, 0.621, -6.990, 20.038,
+  27, 3, 0.054, 0.673, -6.990, 20.486,
+  28, 3, 0.054, 0.635, -6.990, 20.900,
+  29, 4, 0.114, 0.626, -6.990, 21.306,
+  30, 4, 0.114, 0.636, -6.020, 21.722,
+  31, 5, 0.452, 0.615, -6.020, 22.128,
+  32, 5, 0.452, 0.579, -6.020, 22.513,
+  33, 5, 0.452, 0.551, -6.020, 22.877,
+  34, 7, 6.330, 0.552, -5.229, 23.241,
+  35, 7, 6.330, 0.559, -5.229, 23.616,
+  36, 11, 9.947, 0.528, -5.229, 23.974,
+  37, 17, 153.727, 0.479, -5.229, 24.313,
+  44100.0, 38,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.983, -8.240, 1.723,
+  2, 1, 0.029, 0.983, -8.240, 3.445,
+  3, 1, 0.009, 0.982, -8.240, 5.057,
+  4, 1, 0.009, 0.985, -8.240, 6.422,
+  5, 1, 0.009, 0.983, -8.240, 7.609,
+  6, 1, 0.009, 0.978, -8.240, 8.710,
+  7, 1, 0.009, 0.967, -8.240, 9.662,
+  8, 1, 0.009, 0.948, -8.240, 10.515,
+  9, 1, 0.009, 0.930, -8.240, 11.293,
+  10, 1, 0.009, 0.914, -7.447, 12.009,
+  11, 1, 0.009, 0.870, -7.447, 12.625,
+  12, 1, 0.009, 0.845, -7.447, 13.210,
+  13, 1, 0.009, 0.800, -7.447, 13.748,
+  14, 1, 0.009, 0.749, -7.447, 14.241,
+  15, 1, 0.009, 0.701, -7.447, 14.695,
+  16, 1, 0.009, 0.653, -7.447, 15.125,
+  17, 1, 0.009, 0.590, -7.447, 15.508,
+  18, 1, 0.009, 0.616, -7.447, 15.891,
+  19, 2, 0.018, 0.860, -7.447, 16.537,
+  20, 2, 0.018, 0.823, -6.990, 17.112,
+  21, 2, 0.018, 0.762, -6.990, 17.621,
+  22, 2, 0.018, 0.688, -6.990, 18.073,
+  23, 2, 0.018, 0.612, -6.990, 18.470,
+  24, 2, 0.018, 0.594, -6.990, 18.849,
+  25, 3, 0.027, 0.658, -6.990, 19.271,
+  26, 3, 0.027, 0.706, -6.990, 19.741,
+  27, 3, 0.054, 0.660, -6.990, 20.177,
+  28, 3, 0.054, 0.606, -6.990, 20.576,
+  29, 3, 0.054, 0.565, -6.990, 20.950,
+  30, 4, 0.114, 0.560, -6.020, 21.316,
+  31, 4, 0.114, 0.579, -6.020, 21.699,
+  32, 5, 0.452, 0.567, -6.020, 22.078,
+  33, 5, 0.452, 0.534, -6.020, 22.438,
+  34, 5, 0.452, 0.514, -5.229, 22.782,
+  35, 7, 6.330, 0.520, -5.229, 23.133,
+  36, 7, 6.330, 0.518, -5.229, 23.484,
+  37, 7, 6.330, 0.507, -5.229, 23.828,
+  38, 19, 171.813, 0.447, -4.559, 24.173,
+  32000.0, 41,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.985, -8.240, 1.250,
+  2, 1, 0.090, 0.983, -8.240, 2.500,
+  3, 1, 0.029, 0.983, -8.240, 3.750,
+  4, 1, 0.009, 0.981, -8.240, 4.909,
+  5, 1, 0.009, 0.975, -8.240, 5.958,
+  6, 1, 0.009, 0.959, -8.240, 6.857,
+  7, 1, 0.009, 0.944, -8.240, 7.700,
+  8, 1, 0.009, 0.933, -8.240, 8.500,
+  9, 1, 0.009, 0.920, -8.240, 9.237,
+  10, 1, 0.009, 0.892, -7.447, 9.895,
+  11, 1, 0.009, 0.863, -7.447, 10.500,
+  12, 1, 0.009, 0.839, -7.447, 11.083,
+  13, 1, 0.009, 0.786, -7.447, 11.604,
+  14, 1, 0.009, 0.755, -7.447, 12.107,
+  15, 1, 0.009, 0.698, -7.447, 12.554,
+  16, 1, 0.009, 0.673, -7.447, 13.000,
+  17, 1, 0.009, 0.605, -7.447, 13.391,
+  18, 1, 0.009, 0.629, -7.447, 13.781,
+  19, 2, 0.018, 0.883, -7.447, 14.474,
+  20, 2, 0.018, 0.858, -6.990, 15.096,
+  21, 2, 0.018, 0.829, -6.990, 15.667,
+  22, 2, 0.018, 0.767, -6.990, 16.177,
+  23, 2, 0.018, 0.705, -6.990, 16.636,
+  24, 2, 0.018, 0.637, -6.990, 17.057,
+  25, 2, 0.018, 0.564, -6.990, 17.429,
+  26, 2, 0.018, 0.550, -6.990, 17.786,
+  27, 3, 0.027, 0.603, -6.990, 18.177,
+  28, 3, 0.027, 0.635, -6.990, 18.597,
+  29, 3, 0.027, 0.592, -6.990, 18.994,
+  30, 3, 0.027, 0.533, -6.020, 19.352,
+  31, 3, 0.027, 0.518, -6.020, 19.693,
+  32, 4, 0.072, 0.568, -6.020, 20.066,
+  33, 4, 0.072, 0.594, -6.020, 20.462,
+  34, 4, 0.072, 0.568, -5.229, 20.841,
+  35, 5, 0.143, 0.536, -5.229, 21.201,
+  36, 5, 0.143, 0.522, -5.229, 21.549,
+  37, 6, 0.172, 0.542, -5.229, 21.911,
+  38, 7, 0.633, 0.539, -4.559, 22.275,
+  39, 7, 0.633, 0.519, -4.559, 22.625,
+  40, 8, 0.723, 0.514, -3.980, 22.971,
+  41, 10, 9.043, 0.518, -3.980, 23.321,
+  24000, 44,
+  0, 1, 8.91250896, 0.971850038, 0.150000006, 0,
+  1, 1, 8.91250896, 0.874727964, 0.150000006, 0.946573138,
+  2, 1, 0.891250908, 0.85779953, 0.150000006, 1.88476217,
+  3, 1, 0.0891250968, 0.839743853, 0.150000006, 2.8056457,
+  4, 1, 0.028183829, 0.82260257, 0.150000006, 3.70133615,
+  5, 1, 0.00891250931, 0.80018574, 0.150000006, 4.56532001,
+  6, 1, 0.00891250931, 0.771475196, 0.150000006, 5.39263105,
+  7, 1, 0.00891250931, 0.737389982, 0.150000006, 6.17986727,
+  8, 1, 0.00891250931, 0.701111019, 0.150000006, 6.92507982,
+  9, 1, 0.00891250931, 0.65977633, 0.150000006, 7.62757969,
+  10, 1, 0.00891250931, 0.615037441, 0.150000006, 8.28770351,
+  11, 1, 0.00891250931, 0.568658054, 0.150000006, 8.90657234,
+  12, 1, 0.00891250931, 0.522260666, 0.180000007, 9.48587132,
+  13, 1, 0.00891250931, 0.478903115, 0.180000007, 10.0276566,
+  14, 1, 0.00891250931, 0.43808648, 0.180000007, 10.5341988,
+  15, 1, 0.00891250931, 0.412505627, 0.180000007, 11.0078659,
+  16, 1, 0.00891250931, 0.39070797, 0.180000007, 11.4510288,
+  17, 1, 0.00891250931, 0.371887118, 0.180000007, 11.866004,
+  18, 1, 0.00891250931, 0.367617637, 0.180000007, 12.2550087,
+  19, 1, 0.00891250931, 0.422220588, 0.180000007, 12.6201363,
+  20, 2, 0.0178250186, 0.564990044, 0.180000007, 13.2772083,
+  21, 2, 0.0178250186, 0.519700944, 0.180000007, 13.871047,
+  22, 2, 0.0178250186, 0.455360681, 0.200000003, 14.4024391,
+  23, 2, 0.0178250186, 0.408867925, 0.200000003, 14.8811684,
+  24, 2, 0.0178250186, 0.381538749, 0.200000003, 15.3153324,
+  25, 2, 0.0178250186, 0.362357527, 0.200000003, 15.7116165,
+  26, 2, 0.0178250186, 0.365735918, 0.200000003, 16.0755405,
+  27, 3, 0.0267375279, 0.38064, 0.200000003, 16.4882088,
+  28, 3, 0.0267375279, 0.379183382, 0.200000003, 16.9410992,
+  29, 3, 0.0267375279, 0.360672712, 0.200000003, 17.3513336,
+  30, 3, 0.0267375279, 0.343065977, 0.200000003, 17.7264423,
+  31, 3, 0.0267375279, 0.339290261, 0.200000003, 18.0722466,
+  32, 4, 0.0356500372, 0.342963994, 0.200000003, 18.4426575,
+  33, 4, 0.0356500372, 0.343128443, 0.200000003, 18.8344078,
+  34, 4, 0.0356500372, 0.343988508, 0.25, 19.1955795,
+  35, 5, 0.0445625484, 0.343928397, 0.25, 19.5697021,
+  36, 5, 0.0445625484, 0.339527696, 0.25, 19.9551182,
+  37, 5, 0.0889139697, 0.336541563, 0.280000001, 20.3115921,
+  38, 6, 0.106696762, 0.334955156, 0.280000001, 20.6737747,
+  39, 6, 0.169102982, 0.335601568, 0.300000012, 21.0404968,
+  40, 7, 0.1972868, 0.334716886, 0.300000012, 21.4060211,
+  41, 7, 0.1972868, 0.331676662, 0.300000012, 21.7696877,
+  42, 8, 0.713000774, 0.328550965, 0.400000006, 22.1267223,
+  43, 8, 0.713000774, 0.339241952, 0.400000006, 22.4769249,
+  44, 9, 0.802125871, 0.425207615, 0.400000006, 22.8164864,
+  22050, 44,
+  0, 1, 8.91250896, 0.954045713, 0.150000006, 0,
+  1, 1, 8.91250896, 0.833381653, 0.150000006, 0.869851649,
+  2, 1, 0.891250908, 0.815945923, 0.150000006, 1.73325908,
+  3, 1, 0.0891250968, 0.794244766, 0.150000006, 2.58322191,
+  4, 1, 0.028183829, 0.776486695, 0.150000006, 3.4134295,
+  5, 1, 0.00891250931, 0.755260408, 0.150000006, 4.21850443,
+  6, 1, 0.00891250931, 0.731070817, 0.150000006, 4.99414825,
+  7, 1, 0.00891250931, 0.701775849, 0.150000006, 5.73718691,
+  8, 1, 0.00891250931, 0.667876124, 0.150000006, 6.44553185,
+  9, 1, 0.00891250931, 0.630284071, 0.150000006, 7.11807632,
+  10, 1, 0.00891250931, 0.590170324, 0.150000006, 7.75455618,
+  11, 1, 0.00891250931, 0.548788548, 0.150000006, 8.3553915,
+  12, 1, 0.00891250931, 0.507795513, 0.150000006, 8.92152882,
+  13, 1, 0.00891250931, 0.469515711, 0.180000007, 9.45430183,
+  14, 1, 0.00891250931, 0.432291716, 0.180000007, 9.95530319,
+  15, 1, 0.00891250931, 0.411131173, 0.180000007, 10.4262848,
+  16, 1, 0.00891250931, 0.390771538, 0.180000007, 10.8690758,
+  17, 1, 0.00891250931, 0.373318017, 0.180000007, 11.2855215,
+  18, 1, 0.00891250931, 0.36956048, 0.180000007, 11.6774378,
+  19, 1, 0.00891250931, 0.42595759, 0.180000007, 12.0465794,
+  20, 2, 0.0178250186, 0.576900065, 0.180000007, 12.7141209,
+  21, 2, 0.0178250186, 0.533114731, 0.180000007, 13.3197365,
+  22, 2, 0.0178250186, 0.469967514, 0.180000007, 13.8634901,
+  23, 2, 0.0178250186, 0.417268544, 0.200000003, 14.3544445,
+  24, 2, 0.0178250186, 0.389299124, 0.200000003, 14.8002586,
+  25, 2, 0.0178250186, 0.362824857, 0.200000003, 15.2073727,
+  26, 2, 0.0178250186, 0.346801281, 0.200000003, 15.5811834,
+  27, 2, 0.0178250186, 0.349400043, 0.200000003, 15.926218,
+  28, 3, 0.0267375279, 0.364026934, 0.200000003, 16.3194923,
+  29, 3, 0.0267375279, 0.36560446, 0.200000003, 16.752903,
+  30, 3, 0.0267375279, 0.354275256, 0.200000003, 17.1470814,
+  31, 3, 0.0267375279, 0.351219416, 0.200000003, 17.5086212,
+  32, 4, 0.0356500372, 0.354364097, 0.200000003, 17.8938141,
+  33, 4, 0.0356500372, 0.348915905, 0.200000003, 18.2992878,
+  34, 4, 0.0356500372, 0.337649345, 0.200000003, 18.6713982,
+  35, 4, 0.0356500372, 0.332076877, 0.25, 19.015646,
+  36, 5, 0.0445625484, 0.330793113, 0.25, 19.3734016,
+  37, 5, 0.0445625484, 0.327528268, 0.25, 19.7430382,
+  38, 5, 0.0889139697, 0.32551071, 0.280000001, 20.0859604,
+  39, 6, 0.106696762, 0.324436843, 0.280000001, 20.4354992,
+  40, 6, 0.106696762, 0.325835049, 0.280000001, 20.7905579,
+  41, 7, 0.1972868, 0.326221824, 0.300000012, 21.1458054,
+  42, 7, 0.1972868, 0.325960994, 0.300000012, 21.5005951,
+  43, 8, 0.225470632, 0.339019388, 0.300000012, 21.8504524,
+  44, 8, 0.713000774, 0.426850349, 0.400000006, 22.1951065,
+  16000, 45,
+  0, 1, 8.91250896, 0.834739447, 0.150000006, 0,
+  1, 1, 8.91250896, 0.623757005, 0.150000006, 0.631518543,
+  2, 1, 0.891250908, 0.60420388, 0.150000006, 1.2606914,
+  3, 1, 0.891250908, 0.591974258, 0.150000006, 1.88476217,
+  4, 1, 0.0891250968, 0.575301588, 0.150000006, 2.50111985,
+  5, 1, 0.028183829, 0.561547697, 0.150000006, 3.1073606,
+  6, 1, 0.028183829, 0.546665847, 0.150000006, 3.70133615,
+  7, 1, 0.00891250931, 0.52986443, 0.150000006, 4.28118753,
+  8, 1, 0.00891250931, 0.511183441, 0.150000006, 4.84536505,
+  9, 1, 0.00891250931, 0.490902334, 0.150000006, 5.39263105,
+  10, 1, 0.00891250931, 0.46938166, 0.150000006, 5.92205667,
+  11, 1, 0.00891250931, 0.447003782, 0.150000006, 6.43299866,
+  12, 1, 0.00891250931, 0.428170592, 0.150000006, 6.92507982,
+  13, 1, 0.00891250931, 0.414536625, 0.150000006, 7.39815664,
+  14, 1, 0.00891250931, 0.401033074, 0.150000006, 7.85228777,
+  15, 1, 0.00891250931, 0.38779071, 0.150000006, 8.28770351,
+  16, 1, 0.00891250931, 0.374230444, 0.150000006, 8.704772,
+  17, 1, 0.00891250931, 0.360547513, 0.180000007, 9.10397339,
+  18, 1, 0.00891250931, 0.348256677, 0.180000007, 9.48587132,
+  19, 1, 0.00891250931, 0.350327015, 0.180000007, 9.85109234,
+  20, 1, 0.00891250931, 0.406330824, 0.180000007, 10.200304,
+  21, 2, 0.0178250186, 0.554098248, 0.180000007, 10.846529,
+  22, 2, 0.0178250186, 0.528312504, 0.180000007, 11.4447651,
+  23, 2, 0.0178250186, 0.476527005, 0.180000007, 11.9928398,
+  24, 2, 0.0178250186, 0.428205669, 0.180000007, 12.495945,
+  25, 2, 0.0178250186, 0.402271926, 0.180000007, 12.9588718,
+  26, 2, 0.0178250186, 0.378024429, 0.180000007, 13.3859692,
+  27, 2, 0.0178250186, 0.36254698, 0.180000007, 13.7811394,
+  28, 2, 0.0178250186, 0.368058592, 0.200000003, 14.1478529,
+  29, 3, 0.0267375279, 0.385963261, 0.200000003, 14.5674343,
+  30, 3, 0.0267375279, 0.38640517, 0.200000003, 15.0304852,
+  31, 3, 0.0267375279, 0.367834061, 0.200000003, 15.4513416,
+  32, 3, 0.0267375279, 0.349686563, 0.200000003, 15.836277,
+  33, 3, 0.0267375279, 0.345709383, 0.200000003, 16.1904697,
+  34, 4, 0.0356500372, 0.34871915, 0.200000003, 16.5683517,
+  35, 4, 0.0356500372, 0.347054332, 0.200000003, 16.9660263,
+  36, 4, 0.0356500372, 0.346329987, 0.200000003, 17.3304482,
+  37, 5, 0.0445625484, 0.344658494, 0.200000003, 17.7055588,
+  38, 5, 0.0445625484, 0.338779271, 0.200000003, 18.0899811,
+  39, 5, 0.0445625484, 0.334878683, 0.200000003, 18.4440536,
+  40, 6, 0.0534750558, 0.332811534, 0.200000003, 18.8030052,
+  41, 6, 0.0534750558, 0.333717585, 0.25, 19.1665268,
+  42, 7, 0.062387567, 0.333986402, 0.25, 19.5299358,
+  43, 7, 0.062387567, 0.334142625, 0.25, 19.8934898,
+  44, 8, 0.142262354, 0.34677428, 0.280000001, 20.2535706,
+  45, 8, 0.142262354, 0.436254472, 0.280000001, 20.610569,
+  48000.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.639,
+  5, 2, 17, 19, 0.361, 0.417,
+  6, 3, 19, 22, 0.583, 0.083,
+  7, 2, 22, 24, 0.917, 0.750,
+  8, 3, 24, 27, 0.250, 0.417,
+  9, 3, 27, 30, 0.583, 0.648,
+  10, 3, 30, 33, 0.352, 0.611,
+  11, 3, 33, 36, 0.389, 0.625,
+  12, 4, 36, 40, 0.375, 0.144,
+  13, 3, 40, 43, 0.856, 0.389,
+  14, 3, 43, 46, 0.611, 0.160,
+  15, 3, 46, 49, 0.840, 0.217,
+  16, 3, 49, 52, 0.783, 0.184,
+  17, 2, 52, 54, 0.816, 0.886,
+  18, 3, 54, 57, 0.114, 0.313,
+  19, 2, 57, 59, 0.687, 0.452,
+  20, 1, 59, 60, 0.548, 0.908,
+  44100.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.139,
+  5, 1, 17, 18, 0.861, 0.917,
+  6, 3, 18, 21, 0.083, 0.583,
+  7, 3, 21, 24, 0.417, 0.250,
+  8, 3, 24, 27, 0.750, 0.805,
+  9, 3, 27, 30, 0.194, 0.574,
+  10, 3, 30, 33, 0.426, 0.537,
+  11, 3, 33, 36, 0.463, 0.819,
+  12, 4, 36, 40, 0.180, 0.100,
+  13, 3, 40, 43, 0.900, 0.468,
+  14, 3, 43, 46, 0.532, 0.623,
+  15, 3, 46, 49, 0.376, 0.450,
+  16, 3, 49, 52, 0.550, 0.552,
+  17, 3, 52, 55, 0.448, 0.403,
+  18, 2, 55, 57, 0.597, 0.643,
+  19, 2, 57, 59, 0.357, 0.722,
+  20, 2, 59, 61, 0.278, 0.960,
+  32000, 20,
+  0, 1, 0, 2, 1.000, 0.528,
+  1, 2, 2, 4, 0.472, 0.305,
+  2, 2, 4, 6, 0.694, 0.083,
+  3, 1, 6, 7, 0.917, 0.861,
+  4, 2, 7, 9, 0.139, 0.639,
+  5, 2, 9, 11, 0.361, 0.417,
+  6, 3, 11, 14, 0.583, 0.083,
+  7, 2, 14, 16, 0.917, 0.750,
+  8, 3, 16, 19, 0.250, 0.870,
+  9, 3, 19, 22, 0.130, 0.833,
+  10, 4, 22, 26, 0.167, 0.389,
+  11, 4, 26, 30, 0.611, 0.478,
+  12, 4, 30, 34, 0.522, 0.033,
+  13, 3, 34, 37, 0.967, 0.917,
+  14, 4, 37, 41, 0.083, 0.617,
+  15, 3, 41, 44, 0.383, 0.995,
+  16, 4, 44, 48, 0.005, 0.274,
+  17, 3, 48, 51, 0.726, 0.480,
+  18, 3, 51, 54, 0.519, 0.261,
+  19, 2, 54, 56, 0.739, 0.884,
+  20, 2, 56, 58, 0.116, 1.000,
+  24000, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.537036896,
+  7, 3, 20, 23, 0.462963104, 0.5,
+  8, 4, 23, 27, 0.5, 0.0555559993,
+  9, 3, 27, 30, 0.944444001, 0.402778625,
+  10, 3, 30, 33, 0.597221375, 0.766667187,
+  11, 3, 33, 36, 0.233332828, 0.805555999,
+  12, 3, 36, 39, 0.194444016, 0.769841909,
+  13, 3, 39, 42, 0.23015812, 0.611111104,
+  14, 3, 42, 45, 0.388888896, 0.449494779,
+  15, 3, 45, 48, 0.550505221, 0.194444954,
+  16, 2, 48, 50, 0.805555046, 0.913194656,
+  17, 3, 50, 53, 0.0868053436, 0.580555737,
+  18, 3, 53, 56, 0.419444263, 0.113426208,
+  19, 2, 56, 58, 0.886573792, 0.533730626,
+  20, 2, 58, 60, 0.466269344, 0.691176474,
+  22050, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.203703582,
+  7, 3, 20, 23, 0.796296418, 0.166666687,
+  8, 3, 23, 26, 0.833333313, 0.722222686,
+  9, 4, 26, 30, 0.277777344, 0.152778625,
+  10, 3, 30, 33, 0.847221375, 0.566667199,
+  11, 3, 33, 36, 0.433332831, 0.93518573,
+  12, 4, 36, 40, 0.0648142472, 0.118056297,
+  13, 3, 40, 43, 0.881943703, 0.0925937295,
+  14, 2, 43, 45, 0.907406271, 0.934344172,
+  15, 3, 45, 48, 0.0656557977, 0.575398028,
+  16, 3, 48, 51, 0.424601972, 0.232026935,
+  17, 2, 51, 53, 0.767973065, 0.758334339,
+  18, 3, 53, 56, 0.241665646, 0.187501252,
+  19, 2, 56, 58, 0.812498748, 0.533731699,
+  20, 2, 58, 60, 0.466268271, 0.257577598,
+  16000, 20,
+  0, 1, 0, 2, 1, 0.944444478,
+  1, 2, 2, 4, 0.0555555038, 0.722222328,
+  2, 2, 4, 6, 0.277777672, 0.5,
+  3, 2, 6, 8, 0.5, 0.27777797,
+  4, 2, 8, 10, 0.72222203, 0.0555559993,
+  5, 1, 10, 11, 0.944444001, 0.833333313,
+  6, 3, 11, 14, 0.166666672, 0.203703582,
+  7, 3, 14, 17, 0.796296418, 0.166666687,
+  8, 3, 17, 20, 0.833333313, 0.54166698,
+  9, 3, 20, 23, 0.458333015, 0.652778625,
+  10, 4, 23, 27, 0.347221375, 0.166667163,
+  11, 3, 27, 30, 0.833332837, 0.722222924,
+  12, 4, 30, 34, 0.277777106, 0.277778625,
+  13, 3, 34, 37, 0.722221375, 0.604167938,
+  14, 3, 37, 40, 0.395832062, 0.627778649,
+  15, 3, 40, 43, 0.37222138, 0.542736351,
+  16, 3, 43, 46, 0.457263649, 0.371528625,
+  17, 3, 46, 49, 0.628471375, 0.00833433867,
+  18, 2, 49, 51, 0.991665661, 0.500001311,
+  19, 2, 51, 53, 0.499998659, 0.886832893,
+  20, 2, 53, 55, 0.113167092, 0.629034221,
+  48000.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 4, 15, 19, 0.833, 0.583,
+  6, 3, 19, 22, 0.417, 0.917,
+  7, 4, 22, 26, 0.083, 0.944,
+  8, 4, 26, 30, 0.055, 0.042,
+  9, 2, 30, 32, 0.958, 0.567,
+  10, 3, 32, 35, 0.433, 0.167,
+  11, 2, 35, 37, 0.833, 0.618,
+  44100.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 3, 20, 23, 0.750, 0.583,
+  7, 4, 23, 27, 0.417, 0.055,
+  8, 3, 27, 30, 0.944, 0.375,
+  9, 3, 30, 33, 0.625, 0.300,
+  10, 3, 33, 36, 0.700, 0.167,
+  11, 2, 36, 38, 0.833, 1.000,
+  32000, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 4, 20, 24, 0.750, 0.250,
+  7, 5, 24, 29, 0.750, 0.055,
+  8, 4, 29, 33, 0.944, 0.375,
+  9, 4, 33, 37, 0.625, 0.472,
+  10, 3, 37, 40, 0.528, 0.937,
+  11, 1, 40, 41, 0.062, 1.000,
+  24000, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 5, 13, 18, 0.5, 0.833333969,
+  5, 5, 18, 23, 0.166666031, 0.25,
+  6, 4, 23, 27, 0.75, 0.25,
+  7, 3, 27, 30, 0.75, 0.611111999,
+  8, 4, 30, 34, 0.388888031, 0.208333969,
+  9, 3, 34, 37, 0.791666031, 0.766667187,
+  10, 4, 37, 41, 0.233332828, 0.45238167,
+  11, 4, 41, 45, 0.54761833, 0.277778625,
+  22050, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 4, 13, 17, 0.5, 0.5,
+  5, 4, 17, 21, 0.5, 0.916666985,
+  6, 4, 21, 25, 0.0833330154, 0.25,
+  7, 4, 25, 29, 0.75, 0.611111999,
+  8, 4, 29, 33, 0.388888031, 0.458333969,
+  9, 4, 33, 37, 0.541666031, 0.633334339,
+  10, 4, 37, 41, 0.366665661, 0.583334565,
+  11, 4, 41, 45, 0.416665405, 0.437500954,
+  16000, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 5, 13, 18, 0.5, 0.833333969,
+  5, 5, 18, 23, 0.166666031, 0.75,
+  6, 4, 23, 27, 0.25, 0.75,
+  7, 4, 27, 31, 0.25, 0.611111999,
+  8, 4, 31, 35, 0.388888031, 0.458333969,
+  9, 4, 35, 39, 0.541666031, 0.166667163,
+  10, 3, 39, 42, 0.833332837, 0.805555999,
+  11, 4, 42, 46, 0.194444016, 0.4375};
+ 
+ double enwindow[] = 
+ {0.000000000, -0.000000477, -0.000000477, -0.000000477,
+  -0.000000477, -0.000000477, -0.000000477, -0.000000954,
+  -0.000000954, -0.000000954, -0.000000954, -0.000001431,
+  -0.000001431, -0.000001907, -0.000001907, -0.000002384,
+  -0.000002384, -0.000002861, -0.000003338, -0.000003338,
+  -0.000003815, -0.000004292, -0.000004768, -0.000005245,
+  -0.000006199, -0.000006676, -0.000007629, -0.000008106,
+  -0.000009060, -0.000010014, -0.000011444, -0.000012398,
+  -0.000013828, -0.000014782, -0.000016689, -0.000018120,
+  -0.000019550, -0.000021458, -0.000023365, -0.000025272,
+  -0.000027657, -0.000030041, -0.000032425, -0.000034809,
+  -0.000037670, -0.000040531, -0.000043392, -0.000046253,
+  -0.000049591, -0.000052929, -0.000055790, -0.000059605,
+  -0.000062943, -0.000066280, -0.000070095, -0.000073433,
+  -0.000076771, -0.000080585, -0.000083923, -0.000087261,
+  -0.000090599, -0.000093460, -0.000096321, -0.000099182,
+  0.000101566, 0.000103951, 0.000105858, 0.000107288,
+  0.000108242, 0.000108719, 0.000108719, 0.000108242,
+  0.000106812, 0.000105381, 0.000102520, 0.000099182,
+  0.000095367, 0.000090122, 0.000084400, 0.000077724,
+  0.000069618, 0.000060558, 0.000050545, 0.000039577,
+  0.000027180, 0.000013828, -0.000000954, -0.000017166,
+  -0.000034332, -0.000052929, -0.000072956, -0.000093937,
+  -0.000116348, -0.000140190, -0.000165462, -0.000191212,
+  -0.000218868, -0.000247478, -0.000277042, -0.000307560,
+  -0.000339031, -0.000371456, -0.000404358, -0.000438213,
+  -0.000472546, -0.000507355, -0.000542164, -0.000576973,
+  -0.000611782, -0.000646591, -0.000680923, -0.000714302,
+  -0.000747204, -0.000779152, -0.000809669, -0.000838757,
+  -0.000866413, -0.000891685, -0.000915051, -0.000935555,
+  -0.000954151, -0.000968933, -0.000980854, -0.000989437,
+  -0.000994205, -0.000995159, -0.000991821, -0.000983715,
+  0.000971317, 0.000953674, 0.000930786, 0.000902653,
+  0.000868797, 0.000829220, 0.000783920, 0.000731945,
+  0.000674248, 0.000610352, 0.000539303, 0.000462532,
+  0.000378609, 0.000288486, 0.000191689, 0.000088215,
+  -0.000021458, -0.000137329, -0.000259876, -0.000388145,
+  -0.000522137, -0.000661850, -0.000806808, -0.000956535,
+  -0.001111031, -0.001269817, -0.001432419, -0.001597881,
+  -0.001766682, -0.001937389, -0.002110004, -0.002283096,
+  -0.002457142, -0.002630711, -0.002803326, -0.002974033,
+  -0.003141880, -0.003306866, -0.003467083, -0.003622532,
+  -0.003771782, -0.003914356, -0.004048824, -0.004174709,
+  -0.004290581, -0.004395962, -0.004489899, -0.004570484,
+  -0.004638195, -0.004691124, -0.004728317, -0.004748821,
+  -0.004752159, -0.004737377, -0.004703045, -0.004649162,
+  -0.004573822, -0.004477024, -0.004357815, -0.004215240,
+  -0.004049301, -0.003858566, -0.003643036, -0.003401756,
+  0.003134727, 0.002841473, 0.002521515, 0.002174854,
+  0.001800537, 0.001399517, 0.000971317, 0.000515938,
+  0.000033379, -0.000475883, -0.001011848, -0.001573563,
+  -0.002161503, -0.002774239, -0.003411293, -0.004072189,
+  -0.004756451, -0.005462170, -0.006189346, -0.006937027,
+  -0.007703304, -0.008487225, -0.009287834, -0.010103703,
+  -0.010933399, -0.011775017, -0.012627602, -0.013489246,
+  -0.014358521, -0.015233517, -0.016112804, -0.016994476,
+  -0.017876148, -0.018756866, -0.019634247, -0.020506859,
+  -0.021372318, -0.022228718, -0.023074150, -0.023907185,
+  -0.024725437, -0.025527000, -0.026310921, -0.027073860,
+  -0.027815342, -0.028532982, -0.029224873, -0.029890060,
+  -0.030526638, -0.031132698, -0.031706810, -0.032248020,
+  -0.032754898, -0.033225536, -0.033659935, -0.034055710,
+  -0.034412861, -0.034730434, -0.035007000, -0.035242081,
+  -0.035435200, -0.035586357, -0.035694122, -0.035758972,
+  0.035780907, 0.035758972, 0.035694122, 0.035586357,
+  0.035435200, 0.035242081, 0.035007000, 0.034730434,
+  0.034412861, 0.034055710, 0.033659935, 0.033225536,
+  0.032754898, 0.032248020, 0.031706810, 0.031132698,
+  0.030526638, 0.029890060, 0.029224873, 0.028532982,
+  0.027815342, 0.027073860, 0.026310921, 0.025527000,
+  0.024725437, 0.023907185, 0.023074150, 0.022228718,
+  0.021372318, 0.020506859, 0.019634247, 0.018756866,
+  0.017876148, 0.016994476, 0.016112804, 0.015233517,
+  0.014358521, 0.013489246, 0.012627602, 0.011775017,
+  0.010933399, 0.010103703, 0.009287834, 0.008487225,
+  0.007703304, 0.006937027, 0.006189346, 0.005462170,
+  0.004756451, 0.004072189, 0.003411293, 0.002774239,
+  0.002161503, 0.001573563, 0.001011848, 0.000475883,
+  -0.000033379, -0.000515938, -0.000971317, -0.001399517,
+  -0.001800537, -0.002174854, -0.002521515, -0.002841473,
+  0.003134727, 0.003401756, 0.003643036, 0.003858566,
+  0.004049301, 0.004215240, 0.004357815, 0.004477024,
+  0.004573822, 0.004649162, 0.004703045, 0.004737377,
+  0.004752159, 0.004748821, 0.004728317, 0.004691124,
+  0.004638195, 0.004570484, 0.004489899, 0.004395962,
+  0.004290581, 0.004174709, 0.004048824, 0.003914356,
+  0.003771782, 0.003622532, 0.003467083, 0.003306866,
+  0.003141880, 0.002974033, 0.002803326, 0.002630711,
+  0.002457142, 0.002283096, 0.002110004, 0.001937389,
+  0.001766682, 0.001597881, 0.001432419, 0.001269817,
+  0.001111031, 0.000956535, 0.000806808, 0.000661850,
+  0.000522137, 0.000388145, 0.000259876, 0.000137329,
+  0.000021458, -0.000088215, -0.000191689, -0.000288486,
+  -0.000378609, -0.000462532, -0.000539303, -0.000610352,
+  -0.000674248, -0.000731945, -0.000783920, -0.000829220,
+  -0.000868797, -0.000902653, -0.000930786, -0.000953674,
+  0.000971317, 0.000983715, 0.000991821, 0.000995159,
+  0.000994205, 0.000989437, 0.000980854, 0.000968933,
+  0.000954151, 0.000935555, 0.000915051, 0.000891685,
+  0.000866413, 0.000838757, 0.000809669, 0.000779152,
+  0.000747204, 0.000714302, 0.000680923, 0.000646591,
+  0.000611782, 0.000576973, 0.000542164, 0.000507355,
+  0.000472546, 0.000438213, 0.000404358, 0.000371456,
+  0.000339031, 0.000307560, 0.000277042, 0.000247478,
+  0.000218868, 0.000191212, 0.000165462, 0.000140190,
+  0.000116348, 0.000093937, 0.000072956, 0.000052929,
+  0.000034332, 0.000017166, 0.000000954, -0.000013828,
+  -0.000027180, -0.000039577, -0.000050545, -0.000060558,
+  -0.000069618, -0.000077724, -0.000084400, -0.000090122,
+  -0.000095367, -0.000099182, -0.000102520, -0.000105381,
+  -0.000106812, -0.000108242, -0.000108719, -0.000108719,
+  -0.000108242, -0.000107288, -0.000105858, -0.000103951,
+  0.000101566, 0.000099182, 0.000096321, 0.000093460,
+  0.000090599, 0.000087261, 0.000083923, 0.000080585,
+  0.000076771, 0.000073433, 0.000070095, 0.000066280,
+  0.000062943, 0.000059605, 0.000055790, 0.000052929,
+  0.000049591, 0.000046253, 0.000043392, 0.000040531,
+  0.000037670, 0.000034809, 0.000032425, 0.000030041,
+  0.000027657, 0.000025272, 0.000023365, 0.000021458,
+  0.000019550, 0.000018120, 0.000016689, 0.000014782,
+  0.000013828, 0.000012398, 0.000011444, 0.000010014,
+  0.000009060, 0.000008106, 0.000007629, 0.000006676,
+  0.000006199, 0.000005245, 0.000004768, 0.000004292,
+  0.000003815, 0.000003338, 0.000003338, 0.000002861,
+  0.000002384, 0.000002384, 0.000001907, 0.000001907,
+  0.000001431, 0.000001431, 0.000000954, 0.000000954,
+  0.000000954, 0.000000954, 0.000000477, 0.000000477,
+  0.000000477, 0.000000477, 0.000000477, 0.000000477};
+ 
diff -r -c -N encoder/tonal.c lame3.13/tonal.c
*** encoder/tonal.c	Wed Jan 22 02:43:23 1997
--- lame3.13/tonal.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1051 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: tonal.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: tonal.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Douglas Wong        start of version 1.1 records          *
-  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
-  *                              updated I_psycho_one and II_psycho_one*
-  * 3/11/91  W. J. Carter        Added Douglas Wong's updates dated    *
-  *                              3/9/91 for I_Psycho_One() and for     *
-  *                              II_Psycho_One().                      *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 6/11/91  Davis Pan           corrected several bugs                *
-  *                              based on comments from H. Fuchs       *
-  * 01jul91  dpwe (Aware Inc.)   Made pow() args float                 *
-  *                              Removed logical bug in I_tonal_label: *
-  *                              Sometimes *tone returned == STOP      *
-  * 7/10/91  Earle Jennings      no change necessary in port to MsDos  *
-  * 11sep91  dpwe@aware.com      Subtracted 90.3dB from II_f_f_t peaks *
-  * 10/1/91  Peter W. Farrett    Updated II_Psycho_One(),I_Psycho_One()*
-  *                              to include comments.                  *
-  *11/29/91  Masahiro Iwadare    Bug fix regarding POWERNORM           *
-  *                              fixed several other miscellaneous bugs*
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 2/12/92  Masahiro Iwadare    Fixed some potential bugs in          *
-  *          Davis Pan           subsampling()                         *
-  * 2/25/92  Masahiro Iwadare    Fixed some more potential bugs        *
-  * 6/24/92  Tan Ah Peng         Modified window for FFT               * 
-  *                              (denominator N-1 to N)                *
-  *                              Updated all critical band rate &      *
-  *                              absolute threshold tables and critical*
-  *                              boundaries for use with Layer I & II  *  
-  *                              Corrected boundary limits for tonal   *
-  *                              component computation                 *
-  *                              Placement of non-tonal component at   *
-  *                              geometric mean of critical band       *
-  *                              (previous placement method commented  *
-  *                               out - can be used if desired)        *
-  * 3/01/93  Mike Li             Infinite looping fix in noise_label() *
-  * 3/19/93  Jens Spille         fixed integer overflow problem in     *
-  *                              psychoacoutic model 1                 *
-  * 3/19/93  Giorgio Dimino      modifications to better account for   *
-  *                              tonal and non-tonal components        *
-  * 5/28/93 Sriram Jayasimha     "London" mod. to psychoacoustic model1*
-  * 8/05/93 Masahiro Iwadare     noise_label modification "option"     *
-  * 1/21/94 Seymore Shlien       fixed another infinite looping problem*
-  * 7/12/95 Soeren H. Nielsen    Changes for LSF, new tables           *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- #define LONDON                  /* enable "LONDON" modification */
- #define MAKE_SENSE              /* enable "MAKE_SENSE" modification */
- #define MI_OPTION               /* enable "MI_OPTION" modification */
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer II. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- int crit_band;
- int FAR *cbound;
- int sub_size;
- 
- void read_cbound(lay,freq)  /* this function reads in critical */
- int lay, freq;              /* band boundaries                 */
- {
-  int i,j,k;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2cb1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){       /* check boundary values */
-     printf("Please check %s boundary table\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);               /* read input for critical bands */
-  sscanf(t,"%d\n",&crit_band);
-  cbound = (int FAR *) mem_alloc(sizeof(int) * crit_band, "cbound");
-  for(i=0;i<crit_band;i++){   /* continue to read input for */
-     fgets(t,80,fp);            /* critical band boundaries   */
-     sscanf(t,"%d %d\n",&j, &k);
-     if(i==j) cbound[j] = k;
-     else {                     /* error */
-        printf("Please check index %d in cbound table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }        
- 
- void read_freq_band(ltg,lay,freq)  /* this function reads in   */
- int lay, freq;                     /* frequency bands and bark */
- g_ptr FAR *ltg;                /* values                   */
- {
-  int i,j, k;
-  double b,c;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2th1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){   /* check freq. values  */
-     printf("Please check frequency and cband table %s\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);              /* read input for freq. subbands */
-  sscanf(t,"%d\n",&sub_size);
-  *ltg = (g_ptr FAR ) mem_alloc(sizeof(g_thres) * sub_size, "ltg");
-  (*ltg)[0].line = 0;          /* initialize global masking threshold */
-  (*ltg)[0].bark = 0;
-  (*ltg)[0].hear = 0;
-  for(i=1;i<sub_size;i++){    /* continue to read freq. subband */
-     fgets(t,80,fp);          /* and assign                     */
-     sscanf(t,"%d %d %lf %lf\n",&j, &k, &b, &c);
-     if(i == j){
-        (*ltg)[j].line = k;
-        (*ltg)[j].bark = b;
-        (*ltg)[j].hear = c;
-     }
-     else {                   /* error */
-        printf("Please check index %d in freq-cb table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }
- 
- void make_map(power, ltg)       /* this function calculates the */
- mask FAR power[HAN_SIZE];   /* global masking threshold     */
- g_thres FAR *ltg;
- {
-  int i,j;
- 
-  for(i=1;i<sub_size;i++) for(j=ltg[i-1].line;j<=ltg[i].line;j++)
-     power[j].map = i;
- }
- 
- double add_db(a,b)
- double a,b;
- {
-  a = pow(10.0,a/10.0);
-  b = pow(10.0,b/10.0);
-  return 10 * log10(a+b);
- }
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void II_f_f_t(sample, power)      /* this function calculates an */
- double FAR sample[FFT_SIZE];  /* FFT analysis for the freq.  */
- mask FAR power[HAN_SIZE];     /* domain                      */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT), "energy");
-  for(i=0;i<FFT_SIZE;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT), "rev");
-     w_r = (double *) mem_alloc(sizeof(D10), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D10), "w_i");
-     M = 10;
-     MM1 = 9;
-     N = FFT_SIZE;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE;rev[i] = l,i++) for(j=0,l=0;j<10;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(9-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE;i++){    /* calculate power density spectrum */
-     if (energy[i] < 1E-20) energy[i] = 1E-20;
-     power[i].x = 10 * log10(energy[i]) + POWERNORM;
-     power[i].next = STOP;
-     power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void II_hann_win(sample)          /* this function calculates a  */
- double FAR sample[FFT_SIZE];  /* Hann window for PCM (input) */
- {                                 /* samples for a 1024-pt. FFT  */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE;i++){
-        /* Hann window formula */
-        window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE)))/FFT_SIZE;
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double max;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = max, i+=16)      /* calculate the      */
-  for(j=0, max = DBMIN;j<16;j++)                    /* maximum spectral   */
-     max = (max>power[i+j].x) ? max : power[i+j].x; /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #else
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = 10.0*log10(sum), i+=16)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<16;j++)      /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #endif
- 
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void II_tonal_label(power, tone)  /* this function extracts (tonal) */
- mask FAR power[HAN_SIZE];     /* sinusoidals from the spectrum  */
- int *tone;
- {
-  int i,j, last = LAST, first, run, last_but_one = LAST; /* dpwe */
-  double max;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE-12;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){               /* the conditions for the tonal          */
-     if(first<3 || first>500) run = 0;/* otherwise k+/-j will be out of bounds */
-     else if(first<63) run = 2;       /* components in layer II, which         */
-     else if(first<127) run = 3;      /* are the boundaries for calc.          */
-     else if(first<255) run = 6;      /* the tonal components                  */
-     else run = 12;
-     max = power[first].x - 7;        /* after calculation of tonal   */
-     for(j=2;j<=run;j++)              /* components, set to local max */
-        if(max < power[first-j].x || max < power[first+j].x){
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){   /* extract tonal components */
-        int help=first;
-        if(*tone==LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<500){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP;
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST); /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function groups all the remaining non-tonal
- * spectral lines into critical band where they are replaced by
- * one single line.
- *
- ****************************************************************/
-         
- void noise_label(power, noise, ltg)
- g_thres FAR *ltg;
- mask FAR *power;
- int *noise;
- {
-  int i,j, centre, last = LAST;
-  double index, weight, sum;
-                               /* calculate the remaining spectral */
-  for(i=0;i<crit_band-1;i++){  /* lines for non-tonal components   */
-      for(j=cbound[i],weight = 0.0,sum = DBMIN;j<cbound[i+1];j++){
-         if(power[j].type != TONE){
-            if(power[j].x != DBMIN){
-               sum = add_db(power[j].x,sum);
- /* the line below and others under the "MAKE_SENSE" condition are an alternate
-    interpretation of "geometric mean". This approach may make more sense but
-    it has not been tested with hardware. */
- #ifdef MAKE_SENSE
- /* weight += pow(10.0, power[j].x/10.0) * (ltg[power[j].map].bark-i);
-    bad code [SS] 21-1-93
-  */
-     weight += pow(10.0,power[j].x/10.0) * (double) (j-cbound[i]) /
-      (double) (cbound[i+1]-cbound[i]);  /* correction */
- #endif
-               power[j].x = DBMIN;
-            }
-         }   /*  check to see if the spectral line is low dB, and if  */
-      }      /* so replace the center of the critical band, which is */
-             /* the center freq. of the noise component              */
- 
- #ifdef MAKE_SENSE
-      if(sum <= DBMIN)  centre = (cbound[i+1]+cbound[i]) /2;
-      else {
-         index = weight/pow(10.0,sum/10.0);
-         centre = cbound[i] + (int) (index * (double) (cbound[i+1]-cbound[i]) );
-      } 
- #else
-      index = (double)( ((double)cbound[i]) * ((double)(cbound[i+1]-1)) );
-      centre = (int)(pow(index,0.5)+0.5);
- #endif
- 
-     /* locate next non-tonal component until finished; */
-     /* add to list of non-tonal components             */
- #ifdef MI_OPTION
-      /* Masahiro Iwadare's fix for infinite looping problem? */
-      if(power[centre].type == TONE) 
-        if (power[centre+1].type == TONE) centre++; else centre--;
- #else
-      /* Mike Li's fix for infinite looping problem */
-      if(power[centre].type == FALSE) centre++;
- 
-      if(power[centre].type == NOISE){
-        if(power[centre].x >= ltg[power[i].map].hear){
-          if(sum >= ltg[power[i].map].hear) sum = add_db(power[j].x,sum);
-          else
-          sum = power[centre].x;
-        }
-      }
- #endif
-      if(last == LAST) *noise = centre;
-      else {
-         power[centre].next = LAST;
-         power[last].next = centre;
-      }
-      power[centre].x = sum;
-      power[centre].type = NOISE;        
-      last = centre;
-  }        
- }
- 
- /****************************************************************
- *
- *        This function reduces the number of noise and tonal
- * component for further threshold analysis.
- *
- ****************************************************************/
- 
- void subsampling(power, ltg, tone, noise)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise;
- {
-  int i, old;
- 
-  i = *tone; old = STOP;    /* calculate tonal components for */
-  while(i!=LAST){           /* reduction of spectral lines    */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *tone = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *noise; old = STOP;    /* calculate non-tonal components for */
-  while(i!=LAST){            /* reduction of spectral lines        */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *noise = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *tone; old = STOP;
-  while(i != LAST){                              /* if more than one */
-     if(power[i].next == LAST)break;             /* tonal component  */
-     if(ltg[power[power[i].next].map].bark -     /* is less than .5  */
-        ltg[power[i].map].bark < 0.5) {          /* bark, take the   */
-        if(power[power[i].next].x > power[i].x ){/* maximum          */
-           if(old == STOP) *tone = power[i].next;
-           else power[old].next = power[i].next;
-           power[i].type = FALSE;
-           power[i].x = DBMIN;
-           i = power[i].next;
-        }
-        else {
-           power[power[i].next].type = FALSE;
-           power[power[i].next].x = DBMIN;
-           power[i].next = power[power[i].next].next;
-           old = i;
-        }
-     }
-     else {
-       old = i;
-       i = power[i].next;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function calculates the individual threshold and
- * sum with the quiet threshold to find the global threshold.
- *
- ****************************************************************/
- 
- void threshold(power, ltg, tone, noise, bit_rate)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise, bit_rate;
- {
-  int k, t;
-  double dz, tmps, vf;
- 
-  for(k=1;k<sub_size;k++){
-     ltg[k].x = DBMIN;
-     t = *tone;          /* calculate individual masking threshold for */
-     while(t != LAST){   /* components in order to find the global     */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 && /*threshold (LTG)*/
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value*/
-           tmps = -1.525-0.275*ltg[power[t].map].bark - 4.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;        
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
- 
-     t = *noise;        /* calculate individual masking threshold  */
-     while(t != LAST){  /* for non-tonal components to find LTG    */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 &&
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value */
-           tmps = -1.525-0.175*ltg[power[t].map].bark -0.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
-     if(bit_rate<96)ltg[k].x = add_db(ltg[k].hear, ltg[k].x);
-     else ltg[k].x = add_db(ltg[k].hear-12.0, ltg[k].x);
-  }
- }
- 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void II_minimum_mask(ltg,ltmin,sblimit)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- int sblimit;
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<sblimit;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>4 == i && j < sub_size){
-        if(min>ltg[j].x)  min = ltg[j].x;
-        j++;
-     }
-     ltmin[i] = min;
-  }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void II_smr(ltmin, spike, scale, sblimit)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- int sblimit;
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<sblimit;i++){                     /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10; /* level for each subband */
-     if(spike[i]>max) max = spike[i];         /* for the maximum scale  */
-     max -= ltmin[i];                         /* factors                */
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void II_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  layer *info = fr_ps->header;
-  int   stereo = fr_ps->stereo;
-  int   sblimit = fr_ps->sblimit;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D1408 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-      /* call functions for critical boundaries, freq. */
-  if(!init){  /* bands, bark values, and mapping */
-     fft_buf = (D1408 *) mem_alloc((long) sizeof(D1408) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for (i=0;i<1408;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){  /* check pcm input for 3 blocks of 384 samples */
-     for(i=0;i<1152;i++) fft_buf[k][(i+off[k])%1408]= (double)buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE;i++) sample[i] = fft_buf[k][(i+1216+off[k])%1408];
-     off[k] += 1152;
-     off[k] %= 1408;
-                             /* call functions for windowing PCM samples,*/
-     II_hann_win(sample);    /* location of spectral components in each  */
-     for(i=0;i<HAN_SIZE;i++) power[i].x = DBMIN;  /*subband with labeling*/
-     II_f_f_t(sample, power);                     /*locate remaining non-*/
-     II_pick_max(power, &spike[k][0]);            /*tonal sinusoidals,   */
-     II_tonal_label(power, &tone);                /*reduce noise & tonal */
-     noise_label(power, &noise, ltg);             /*components, find     */
-     subsampling(power, ltg, &tone, &noise);      /*global & minimal     */
-     threshold(power, ltg, &tone, &noise,         /*threshold, and sgnl- */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo); /*to-mask ratio*/
-     II_minimum_mask(ltg, &ltmin[k][0], sblimit);
-     II_smr(&ltmin[k][0], &spike[k][0], &scale[k][0], sblimit);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
- 
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer I. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void I_f_f_t(sample, power)         /* this function calculates */
- double FAR sample[FFT_SIZE/2];  /* an FFT analysis for the  */
- mask FAR power[HAN_SIZE/2];     /* freq. domain             */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT2), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT2), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT2), "energy");
-  for(i=0;i<FFT_SIZE/2;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT2), "rev");
-     w_r = (double *) mem_alloc(sizeof(D9), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D9), "w_i");
-     M = 9;
-     MM1 = 8;
-     N = FFT_SIZE/2;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE/2;rev[i] = l,i++) for(j=0,l=0;j<9;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(8-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE/2);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE/2;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE/2;i++){                     /* calculate power  */
-     if(energy[i] < 1E-20) energy[i] = 1E-20;    /* density spectrum */
-        power[i].x = 10 * log10(energy[i]) + POWERNORM;
-        power[i].next = STOP;
-        power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void I_hann_win(sample)             /* this function calculates a  */
- double FAR sample[FFT_SIZE/2];  /* Hann window for PCM (input) */
- {                                   /* samples for a 512-pt. FFT   */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT2), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE/2;i++){
-       /* Hann window formula */
-       window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE/2)))/(FFT_SIZE/2);
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE/2;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE/2];
- {
-  double max;
-  int i,j;
- 
-  /* calculate the spectral component in each subband */
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = max, i+=8)
-     for(j=0, max = DBMIN;j<8;j++) max = (max>power[i+j].x) ? max : power[i+j].x;
- }
- #else
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = 10.0*log10(sum), i+=8)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<8;j++)       /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
- #endif
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void I_tonal_label(power, tone)     /* this function extracts   */
- mask FAR power[HAN_SIZE/2];     /* (tonal) sinusoidals from */
- int *tone;                          /* the spectrum             */
- {
-  int i,j, last = LAST, first, run;
-  double max;
-  int last_but_one= LAST;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE/2-6;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){                /* conditions for the tonal     */
-     if(first<3 || first>250) run = 0; /* otherwise k+/-j will be out of bounds*/
-     else if(first<63) run = 2;        /* components in layer I, which */
-     else if(first<127) run = 3;       /* are the boundaries for calc.   */
-     else run = 6;                     /* the tonal components          */
-     max = power[first].x - 7;
-     for(j=2;j<=run;j++)  /* after calc. of tonal components, set to loc.*/
-        if(max < power[first-j].x || max < power[first+j].x){   /* max   */
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){    /* extract tonal components */
-        int help=first;
-        if(*tone == LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<255){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP; /*dpwe: 2nd was .x*/
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST) ; /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }                        
-                                 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void I_minimum_mask(ltg,ltmin)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<SBLIMIT;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>3 == i && j < sub_size){
-           if (min>ltg[j].x)  min = ltg[j].x;
-           j++;
-        }
-        ltmin[i] = min;
-     }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void I_smr(ltmin, spike, scale)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<SBLIMIT;i++){                      /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10;  /* level for each subband */
-     if(spike[i]>max) max = spike[i];          /* for the scalefactor    */
-     max -= ltmin[i];
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void I_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  int stereo = fr_ps->stereo;
-  the_layer info = fr_ps->header;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D640 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT2), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-             /* call functions for critical boundaries, freq. */
-  if(!init){ /* bands, bark values, and mapping              */
-     fft_buf = (D640 *) mem_alloc(sizeof(D640) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE/2, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for(i=0;i<640;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){    /* check PCM input for a block of */
-     for(i=0;i<384;i++)     /* 384 samples for a 512-pt. FFT  */
-        fft_buf[k][(i+off[k])%640]= (double) buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE/2;i++)
-        sample[i] = fft_buf[k][(i+448+off[k])%640];
-     off[k] += 384;
-     off[k] %= 640;
-                         /* call functions for windowing PCM samples,   */
-     I_hann_win(sample); /* location of spectral components in each     */
-     for(i=0;i<HAN_SIZE/2;i++) power[i].x = DBMIN;   /* subband with    */
-     I_f_f_t(sample, power);              /* labeling, locate remaining */
-     I_pick_max(power, &spike[k][0]);     /* non-tonal sinusoidals,     */
-     I_tonal_label(power, &tone);         /* reduce noise & tonal com., */
-     noise_label(power, &noise, ltg);     /* find global & minimal      */
-     subsampling(power, ltg, &tone, &noise);  /* threshold, and sgnl-   */
-     threshold(power, ltg, &tone, &noise,     /* to-mask ratio          */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo);
-     I_minimum_mask(ltg, &ltmin[k][0]);
-     I_smr(&ltmin[k][0], &spike[k][0], &scale[k][0]);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
--- 0 ----
diff -r -c -N encoder/version.c lame3.13/version.c
*** encoder/version.c	Wed Dec 31 17:00:00 1969
--- lame3.13/version.c	Mon May 24 15:24:32 1999
***************
*** 0 ****
--- 1,57 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "version.h"
+ #include <stdio.h>
+ 
+ static char lpszVersion[80];
+ 
+ char* get_lame_version()
+ {
+ 	if (LAME_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_ALPHAVERSION);
+ 	else if (LAME_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",LAME_MAJOR_VERSION,LAME_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_psy_version()
+ {
+ 	if (PSY_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_ALPHAVERSION);
+ 	else if (PSY_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",PSY_MAJOR_VERSION,PSY_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_mp3x_version()
+ {
+ 	if (MP3X_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (alpha %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_ALPHAVERSION);
+ 	else if (MP3X_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (beta %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d:%02d",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION);
+ 	return lpszVersion;
+ }
diff -r -c -N encoder/version.h lame3.13/version.h
*** encoder/version.h	Wed Dec 31 17:00:00 1969
--- lame3.13/version.h	Thu Jun 24 18:30:20 1999
***************
*** 0 ****
--- 1,44 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #ifndef LAME_H_INCLUDED
+ #define LAME_H_INCLUDED
+ 
+ #define LAME_MAJOR_VERSION	3	/* Major version number */
+ #define LAME_MINOR_VERSION	13	/* Minor version number */
+ #define LAME_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define LAME_BETAVERSION        0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define PSY_MAJOR_VERSION	0	/* Major version number */
+ #define PSY_MINOR_VERSION	50	/* Minor version number */
+ #define PSY_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define PSY_BETAVERSION		0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define MP3X_MAJOR_VERSION	0	/* Major version number */
+ #define MP3X_MINOR_VERSION	50	/* Minor version number */
+ #define MP3X_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define MP3X_BETAVERSION	0	/* Set number if this is a beta version, otherwise zero */
+ 
+ 
+ char* get_lame_version();		/* returns lame version number string */
+ char* get_psy_version();		/* returns psy model version number string */
+ char* get_mp3x_version();		/* returns mp3x version number string */
+ 
+ #endif
diff -r -c -N encoder/wavheader.h lame3.13/wavheader.h
*** encoder/wavheader.h	Wed Dec 31 17:00:00 1969
--- lame3.13/wavheader.h	Mon Jun 21 12:21:44 1999
***************
*** 0 ****
--- 1,70 ----
+ /*
+  *	WavHeader for LAME.
+  *
+  *  Ripped for lame from Michael Beck's vplay sources (found in sndkit)
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #ifndef WAVHEADER_H_INCLUDED
+ #define WAVHEADER_H_INCLUDED
+ 
+ /* Definitions for Microsoft WAVE format */
+ 
+ #define RIFF            0x46464952
+ #define WAVE            0x45564157
+ #define FMT             0x20746D66
+ #define DATA            0x61746164
+ #define PCM_CODE        1
+ #define WAVE_MONO       1
+ #define WAVE_STEREO     2
+ 
+ #define u_int unsigned int
+ #define u_short unsigned short
+ #ifdef _WIN32
+ 	#pragma pack(push)
+ 	#pragma pack(1)
+ #endif
+ 
+ /* it's in chunks like .voc and AMIGA iff, but my source say there
+    are in only in this combination, so I combined them in one header;
+    it works on all WAVE-file I have
+ */
+ typedef struct _waveheader {
+   u_int main_chunk;     /* 'RIFF' */
+   u_int length;         /* filelen */
+   u_int chunk_type;     /* 'WAVE' */
+ 
+   u_int sub_chunk;      /* 'fmt ' */
+   u_int sc_len;         /* length of sub_chunk, =16 */
+   u_short       format;         /* should be 1 for PCM-code */
+   u_short       modus;          /* 1 Mono, 2 Stereo */
+   u_int sample_fq;      /* frequence of sample */
+   u_int byte_p_sec;
+   u_short       byte_p_spl;     /* samplesize; 1 or 2 bytes */
+   u_short       bit_p_spl;      /* 8, 12 or 16 bit */
+ 
+   u_int data_chunk;     /* 'data' */
+   u_int data_length;    /* samplecount */
+ } WaveHeader;
+ 
+ 
+ void endswap_wave_fmt (WaveHeader *wavfmt);
+ 
+ #ifdef _WIN32
+ 	#pragma pack(pop)
+ #endif
+ 
+ #endif

diff -r -c -N encoder/.cvsignore lame3.70/.cvsignore
*** encoder/.cvsignore	Wed Dec 31 17:00:00 1969
--- lame3.70/.cvsignore	Wed Jan 12 15:38:44 2000
***************
*** 0 ****
--- 1,14 ----
+ mp3x
+ lame
+ *.d
+ Debug
+ DebugGTK
+ Release
+ ReleaseGTK
+ WinGTK
+ *.ncb
+ *.plg
+ *.opt
+ *.dll
+ *.new.mp3
+ *.wav.mp3
\ No newline at end of file
diff -r -c -N encoder/API lame3.70/API
*** encoder/API	Wed Dec 31 17:00:00 1969
--- lame3.70/API	Thu Mar 23 15:12:26 2000
***************
*** 0 ****
--- 1,68 ----
+ The LAME API
+ 
+ This is the simple interface to the lightweight encoding library
+ obtained by compiling libmp3lame.a without defining any of
+ the following extra features:
+ 
+ #define HAVEMPGLIB   to use mpglib's mp3 *decoding* capibility
+ #define AMIGA_MPEGA  to use mpega.library (Amiga), don't use with HAVEMPGLIB
+ #define BRHIST       to allow the display of the VBR historgram
+ #define LIBSNDFILE   to use Erik de Castro Lopo's libsndfile
+ #define LAMESNDFILE  to use LAME's minimial internal sndfile I/O
+ #define LAMEPARSE    to use LAME's command line parsing/option setting routines
+ #define HAVEGTK      to compile in support for the GTK mp3 frame analyzer
+ 
+ To use any of the above features, see lame.h more for details.
+ For an example of a simple command line interface to lame, see
+ main.c
+ 
+ 
+ =========================================================================
+ 
+ 1. (optional) Get the version number of the encoder, if you are interested.  
+    lame_version(char *);
+ 
+ 2. Initialize the encoder.  sets default for all encoder parameters,
+ returns pointer to encoder parameters listed above 
+ 
+    #include "lame.h"
+    lame_global_flags gf;
+    lame_init(%gf);
+ 
+ Then override various default settings as necessary, for example:
+ 
+    gf.num_channels=2;
+    gf.in_samplerate = 44100;
+    gf.brate = 128;
+    gf.mode = 0,1 or 3      /* stereo, jstereo, mono */
+    gf.quality = 2,5 or 9       /* 2=high, 5=medium 9=low */
+ 
+ see lame.h for the complete list of options.
+ 
+ 
+ 3. sets more internal configuration based on data provided above:
+    lame_init_params(&gf);
+ 
+ 
+ 
+ 4. Encode some data.  input pcm data, output (maybe) mp3 frames.
+ This routine handles all buffering, resampling and filtering for you.
+ The required mp3buffer_size can be computed from num_samples, 
+ samplerate and encoding rate, but here is a worst case estimate:
+ mp3buffer_size (in bytes) = 1.25*num_samples + 7200
+ The return code = number of bytes output in mp3buffer.  This can be 0.
+ If it is -1, an error occured.  
+ 
+    int lame_encode_buffer(lame_global_flags *gfp,
+          short int leftpcm[], short int rightpcm[],
+          int num_samples,char *mp3buffer,int  mp3buffer_size);
+ 
+ 
+ 5. lame_encode_finish will flush the buffers and may return a 
+ final few mp3 frames.  mp3buffer should be at least 7200 bytes.
+ return code = number of bytes output to mp3buffer.  This can be 0.
+ 
+    int lame_encode_finish(lame_global_flags *gfp,char *mp3buffer);
+ 
+ 
+ 
diff -r -c -N encoder/COPYING lame3.70/COPYING
*** encoder/COPYING	Wed Dec 31 17:00:00 1969
--- lame3.70/COPYING	Wed Nov 24 01:40:26 1999
***************
*** 0 ****
--- 1,482 ----
+ 		  GNU LIBRARY GENERAL PUBLIC LICENSE
+ 		       Version 2, June 1991
+ 
+  Copyright (C) 1991 Free Software Foundation, Inc.
+     		    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  Everyone is permitted to copy and distribute verbatim copies
+  of this license document, but changing it is not allowed.
+ 
+ [This is the first released version of the library GPL.  It is
+  numbered 2 because it goes with version 2 of the ordinary GPL.]
+ 
+ 			    Preamble
+ 
+   The licenses for most software are designed to take away your
+ freedom to share and change it.  By contrast, the GNU General Public
+ Licenses are intended to guarantee your freedom to share and change
+ free software--to make sure the software is free for all its users.
+ 
+   This license, the Library General Public License, applies to some
+ specially designated Free Software Foundation software, and to any
+ other libraries whose authors decide to use it.  You can use it for
+ your libraries, too.
+ 
+   When we speak of free software, we are referring to freedom, not
+ price.  Our General Public Licenses are designed to make sure that you
+ have the freedom to distribute copies of free software (and charge for
+ this service if you wish), that you receive source code or can get it
+ if you want it, that you can change the software or use pieces of it
+ in new free programs; and that you know you can do these things.
+ 
+   To protect your rights, we need to make restrictions that forbid
+ anyone to deny you these rights or to ask you to surrender the rights.
+ These restrictions translate to certain responsibilities for you if
+ you distribute copies of the library, or if you modify it.
+ 
+   For example, if you distribute copies of the library, whether gratis
+ or for a fee, you must give the recipients all the rights that we gave
+ you.  You must make sure that they, too, receive or can get the source
+ code.  If you link a program with the library, you must provide
+ complete object files to the recipients so that they can relink them
+ with the library, after making changes to the library and recompiling
+ it.  And you must show them these terms so they know their rights.
+ 
+   Our method of protecting your rights has two steps: (1) copyright
+ the library, and (2) offer you this license which gives you legal
+ permission to copy, distribute and/or modify the library.
+ 
+   Also, for each distributor's protection, we want to make certain
+ that everyone understands that there is no warranty for this free
+ library.  If the library is modified by someone else and passed on, we
+ want its recipients to know that what they have is not the original
+ version, so that any problems introduced by others will not reflect on
+ the original authors' reputations.
+ 
+   Finally, any free program is threatened constantly by software
+ patents.  We wish to avoid the danger that companies distributing free
+ software will individually obtain patent licenses, thus in effect
+ transforming the program into proprietary software.  To prevent this,
+ we have made it clear that any patent must be licensed for everyone's
+ free use or not licensed at all.
+ 
+   Most GNU software, including some libraries, is covered by the ordinary
+ GNU General Public License, which was designed for utility programs.  This
+ license, the GNU Library General Public License, applies to certain
+ designated libraries.  This license is quite different from the ordinary
+ one; be sure to read it in full, and don't assume that anything in it is
+ the same as in the ordinary license.
+ 
+   The reason we have a separate public license for some libraries is that
+ they blur the distinction we usually make between modifying or adding to a
+ program and simply using it.  Linking a program with a library, without
+ changing the library, is in some sense simply using the library, and is
+ analogous to running a utility program or application program.  However, in
+ a textual and legal sense, the linked executable is a combined work, a
+ derivative of the original library, and the ordinary General Public License
+ treats it as such.
+ 
+   Because of this blurred distinction, using the ordinary General
+ Public License for libraries did not effectively promote software
+ sharing, because most developers did not use the libraries.  We
+ concluded that weaker conditions might promote sharing better.
+ 
+   However, unrestricted linking of non-free programs would deprive the
+ users of those programs of all benefit from the free status of the
+ libraries themselves.  This Library General Public License is intended to
+ permit developers of non-free programs to use free libraries, while
+ preserving your freedom as a user of such programs to change the free
+ libraries that are incorporated in them.  (We have not seen how to achieve
+ this as regards changes in header files, but we have achieved it as regards
+ changes in the actual functions of the Library.)  The hope is that this
+ will lead to faster development of free libraries.
+ 
+   The precise terms and conditions for copying, distribution and
+ modification follow.  Pay close attention to the difference between a
+ "work based on the library" and a "work that uses the library".  The
+ former contains code derived from the library, while the latter only
+ works together with the library.
+ 
+   Note that it is possible for a library to be covered by the ordinary
+ General Public License rather than by this special one.
+ 
+ 		  GNU LIBRARY GENERAL PUBLIC LICENSE
+    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+ 
+   0. This License Agreement applies to any software library which
+ contains a notice placed by the copyright holder or other authorized
+ party saying it may be distributed under the terms of this Library
+ General Public License (also called "this License").  Each licensee is
+ addressed as "you".
+ 
+   A "library" means a collection of software functions and/or data
+ prepared so as to be conveniently linked with application programs
+ (which use some of those functions and data) to form executables.
+ 
+   The "Library", below, refers to any such software library or work
+ which has been distributed under these terms.  A "work based on the
+ Library" means either the Library or any derivative work under
+ copyright law: that is to say, a work containing the Library or a
+ portion of it, either verbatim or with modifications and/or translated
+ straightforwardly into another language.  (Hereinafter, translation is
+ included without limitation in the term "modification".)
+ 
+   "Source code" for a work means the preferred form of the work for
+ making modifications to it.  For a library, complete source code means
+ all the source code for all modules it contains, plus any associated
+ interface definition files, plus the scripts used to control compilation
+ and installation of the library.
+ 
+   Activities other than copying, distribution and modification are not
+ covered by this License; they are outside its scope.  The act of
+ running a program using the Library is not restricted, and output from
+ such a program is covered only if its contents constitute a work based
+ on the Library (independent of the use of the Library in a tool for
+ writing it).  Whether that is true depends on what the Library does
+ and what the program that uses the Library does.
+   
+   1. You may copy and distribute verbatim copies of the Library's
+ complete source code as you receive it, in any medium, provided that
+ you conspicuously and appropriately publish on each copy an
+ appropriate copyright notice and disclaimer of warranty; keep intact
+ all the notices that refer to this License and to the absence of any
+ warranty; and distribute a copy of this License along with the
+ Library.
+ 
+   You may charge a fee for the physical act of transferring a copy,
+ and you may at your option offer warranty protection in exchange for a
+ fee.
+ 
+   2. You may modify your copy or copies of the Library or any portion
+ of it, thus forming a work based on the Library, and copy and
+ distribute such modifications or work under the terms of Section 1
+ above, provided that you also meet all of these conditions:
+ 
+     a) The modified work must itself be a software library.
+ 
+     b) You must cause the files modified to carry prominent notices
+     stating that you changed the files and the date of any change.
+ 
+     c) You must cause the whole of the work to be licensed at no
+     charge to all third parties under the terms of this License.
+ 
+     d) If a facility in the modified Library refers to a function or a
+     table of data to be supplied by an application program that uses
+     the facility, other than as an argument passed when the facility
+     is invoked, then you must make a good faith effort to ensure that,
+     in the event an application does not supply such function or
+     table, the facility still operates, and performs whatever part of
+     its purpose remains meaningful.
+ 
+     (For example, a function in a library to compute square roots has
+     a purpose that is entirely well-defined independent of the
+     application.  Therefore, Subsection 2d requires that any
+     application-supplied function or table used by this function must
+     be optional: if the application does not supply it, the square
+     root function must still compute square roots.)
+ 
+ These requirements apply to the modified work as a whole.  If
+ identifiable sections of that work are not derived from the Library,
+ and can be reasonably considered independent and separate works in
+ themselves, then this License, and its terms, do not apply to those
+ sections when you distribute them as separate works.  But when you
+ distribute the same sections as part of a whole which is a work based
+ on the Library, the distribution of the whole must be on the terms of
+ this License, whose permissions for other licensees extend to the
+ entire whole, and thus to each and every part regardless of who wrote
+ it.
+ 
+ Thus, it is not the intent of this section to claim rights or contest
+ your rights to work written entirely by you; rather, the intent is to
+ exercise the right to control the distribution of derivative or
+ collective works based on the Library.
+ 
+ In addition, mere aggregation of another work not based on the Library
+ with the Library (or with a work based on the Library) on a volume of
+ a storage or distribution medium does not bring the other work under
+ the scope of this License.
+ 
+   3. You may opt to apply the terms of the ordinary GNU General Public
+ License instead of this License to a given copy of the Library.  To do
+ this, you must alter all the notices that refer to this License, so
+ that they refer to the ordinary GNU General Public License, version 2,
+ instead of to this License.  (If a newer version than version 2 of the
+ ordinary GNU General Public License has appeared, then you can specify
+ that version instead if you wish.)  Do not make any other change in
+ these notices.
+ 
+   Once this change is made in a given copy, it is irreversible for
+ that copy, so the ordinary GNU General Public License applies to all
+ subsequent copies and derivative works made from that copy.
+ 
+   This option is useful when you wish to copy part of the code of
+ the Library into a program that is not a library.
+ 
+   4. You may copy and distribute the Library (or a portion or
+ derivative of it, under Section 2) in object code or executable form
+ under the terms of Sections 1 and 2 above provided that you accompany
+ it with the complete corresponding machine-readable source code, which
+ must be distributed under the terms of Sections 1 and 2 above on a
+ medium customarily used for software interchange.
+ 
+   If distribution of object code is made by offering access to copy
+ from a designated place, then offering equivalent access to copy the
+ source code from the same place satisfies the requirement to
+ distribute the source code, even though third parties are not
+ compelled to copy the source along with the object code.
+ 
+   5. A program that contains no derivative of any portion of the
+ Library, but is designed to work with the Library by being compiled or
+ linked with it, is called a "work that uses the Library".  Such a
+ work, in isolation, is not a derivative work of the Library, and
+ therefore falls outside the scope of this License.
+ 
+   However, linking a "work that uses the Library" with the Library
+ creates an executable that is a derivative of the Library (because it
+ contains portions of the Library), rather than a "work that uses the
+ library".  The executable is therefore covered by this License.
+ Section 6 states terms for distribution of such executables.
+ 
+   When a "work that uses the Library" uses material from a header file
+ that is part of the Library, the object code for the work may be a
+ derivative work of the Library even though the source code is not.
+ Whether this is true is especially significant if the work can be
+ linked without the Library, or if the work is itself a library.  The
+ threshold for this to be true is not precisely defined by law.
+ 
+   If such an object file uses only numerical parameters, data
+ structure layouts and accessors, and small macros and small inline
+ functions (ten lines or less in length), then the use of the object
+ file is unrestricted, regardless of whether it is legally a derivative
+ work.  (Executables containing this object code plus portions of the
+ Library will still fall under Section 6.)
+ 
+   Otherwise, if the work is a derivative of the Library, you may
+ distribute the object code for the work under the terms of Section 6.
+ Any executables containing that work also fall under Section 6,
+ whether or not they are linked directly with the Library itself.
+ 
+   6. As an exception to the Sections above, you may also compile or
+ link a "work that uses the Library" with the Library to produce a
+ work containing portions of the Library, and distribute that work
+ under terms of your choice, provided that the terms permit
+ modification of the work for the customer's own use and reverse
+ engineering for debugging such modifications.
+ 
+   You must give prominent notice with each copy of the work that the
+ Library is used in it and that the Library and its use are covered by
+ this License.  You must supply a copy of this License.  If the work
+ during execution displays copyright notices, you must include the
+ copyright notice for the Library among them, as well as a reference
+ directing the user to the copy of this License.  Also, you must do one
+ of these things:
+ 
+     a) Accompany the work with the complete corresponding
+     machine-readable source code for the Library including whatever
+     changes were used in the work (which must be distributed under
+     Sections 1 and 2 above); and, if the work is an executable linked
+     with the Library, with the complete machine-readable "work that
+     uses the Library", as object code and/or source code, so that the
+     user can modify the Library and then relink to produce a modified
+     executable containing the modified Library.  (It is understood
+     that the user who changes the contents of definitions files in the
+     Library will not necessarily be able to recompile the application
+     to use the modified definitions.)
+ 
+     b) Accompany the work with a written offer, valid for at
+     least three years, to give the same user the materials
+     specified in Subsection 6a, above, for a charge no more
+     than the cost of performing this distribution.
+ 
+     c) If distribution of the work is made by offering access to copy
+     from a designated place, offer equivalent access to copy the above
+     specified materials from the same place.
+ 
+     d) Verify that the user has already received a copy of these
+     materials or that you have already sent this user a copy.
+ 
+   For an executable, the required form of the "work that uses the
+ Library" must include any data and utility programs needed for
+ reproducing the executable from it.  However, as a special exception,
+ the source code distributed need not include anything that is normally
+ distributed (in either source or binary form) with the major
+ components (compiler, kernel, and so on) of the operating system on
+ which the executable runs, unless that component itself accompanies
+ the executable.
+ 
+   It may happen that this requirement contradicts the license
+ restrictions of other proprietary libraries that do not normally
+ accompany the operating system.  Such a contradiction means you cannot
+ use both them and the Library together in an executable that you
+ distribute.
+ 
+   7. You may place library facilities that are a work based on the
+ Library side-by-side in a single library together with other library
+ facilities not covered by this License, and distribute such a combined
+ library, provided that the separate distribution of the work based on
+ the Library and of the other library facilities is otherwise
+ permitted, and provided that you do these two things:
+ 
+     a) Accompany the combined library with a copy of the same work
+     based on the Library, uncombined with any other library
+     facilities.  This must be distributed under the terms of the
+     Sections above.
+ 
+     b) Give prominent notice with the combined library of the fact
+     that part of it is a work based on the Library, and explaining
+     where to find the accompanying uncombined form of the same work.
+ 
+   8. You may not copy, modify, sublicense, link with, or distribute
+ the Library except as expressly provided under this License.  Any
+ attempt otherwise to copy, modify, sublicense, link with, or
+ distribute the Library is void, and will automatically terminate your
+ rights under this License.  However, parties who have received copies,
+ or rights, from you under this License will not have their licenses
+ terminated so long as such parties remain in full compliance.
+ 
+   9. You are not required to accept this License, since you have not
+ signed it.  However, nothing else grants you permission to modify or
+ distribute the Library or its derivative works.  These actions are
+ prohibited by law if you do not accept this License.  Therefore, by
+ modifying or distributing the Library (or any work based on the
+ Library), you indicate your acceptance of this License to do so, and
+ all its terms and conditions for copying, distributing or modifying
+ the Library or works based on it.
+ 
+   10. Each time you redistribute the Library (or any work based on the
+ Library), the recipient automatically receives a license from the
+ original licensor to copy, distribute, link with or modify the Library
+ subject to these terms and conditions.  You may not impose any further
+ restrictions on the recipients' exercise of the rights granted herein.
+ You are not responsible for enforcing compliance by third parties to
+ this License.
+ 
+   11. If, as a consequence of a court judgment or allegation of patent
+ infringement or for any other reason (not limited to patent issues),
+ conditions are imposed on you (whether by court order, agreement or
+ otherwise) that contradict the conditions of this License, they do not
+ excuse you from the conditions of this License.  If you cannot
+ distribute so as to satisfy simultaneously your obligations under this
+ License and any other pertinent obligations, then as a consequence you
+ may not distribute the Library at all.  For example, if a patent
+ license would not permit royalty-free redistribution of the Library by
+ all those who receive copies directly or indirectly through you, then
+ the only way you could satisfy both it and this License would be to
+ refrain entirely from distribution of the Library.
+ 
+ If any portion of this section is held invalid or unenforceable under any
+ particular circumstance, the balance of the section is intended to apply,
+ and the section as a whole is intended to apply in other circumstances.
+ 
+ It is not the purpose of this section to induce you to infringe any
+ patents or other property right claims or to contest validity of any
+ such claims; this section has the sole purpose of protecting the
+ integrity of the free software distribution system which is
+ implemented by public license practices.  Many people have made
+ generous contributions to the wide range of software distributed
+ through that system in reliance on consistent application of that
+ system; it is up to the author/donor to decide if he or she is willing
+ to distribute software through any other system and a licensee cannot
+ impose that choice.
+ 
+ This section is intended to make thoroughly clear what is believed to
+ be a consequence of the rest of this License.
+ 
+   12. If the distribution and/or use of the Library is restricted in
+ certain countries either by patents or by copyrighted interfaces, the
+ original copyright holder who places the Library under this License may add
+ an explicit geographical distribution limitation excluding those countries,
+ so that distribution is permitted only in or among countries not thus
+ excluded.  In such case, this License incorporates the limitation as if
+ written in the body of this License.
+ 
+   13. The Free Software Foundation may publish revised and/or new
+ versions of the Library General Public License from time to time.
+ Such new versions will be similar in spirit to the present version,
+ but may differ in detail to address new problems or concerns.
+ 
+ Each version is given a distinguishing version number.  If the Library
+ specifies a version number of this License which applies to it and
+ "any later version", you have the option of following the terms and
+ conditions either of that version or of any later version published by
+ the Free Software Foundation.  If the Library does not specify a
+ license version number, you may choose any version ever published by
+ the Free Software Foundation.
+ 
+   14. If you wish to incorporate parts of the Library into other free
+ programs whose distribution conditions are incompatible with these,
+ write to the author to ask for permission.  For software which is
+ copyrighted by the Free Software Foundation, write to the Free
+ Software Foundation; we sometimes make exceptions for this.  Our
+ decision will be guided by the two goals of preserving the free status
+ of all derivatives of our free software and of promoting the sharing
+ and reuse of software generally.
+ 
+ 			    NO WARRANTY
+ 
+   15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
+ WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
+ EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
+ OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
+ KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
+ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
+ LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
+ THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+ 
+   16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
+ WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
+ AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
+ FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
+ CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
+ LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
+ RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
+ FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
+ SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+ DAMAGES.
+ 
+ 		     END OF TERMS AND CONDITIONS
+ 
+            How to Apply These Terms to Your New Libraries
+ 
+   If you develop a new library, and you want it to be of the greatest
+ possible use to the public, we recommend making it free software that
+ everyone can redistribute and change.  You can do so by permitting
+ redistribution under these terms (or, alternatively, under the terms of the
+ ordinary General Public License).
+ 
+   To apply these terms, attach the following notices to the library.  It is
+ safest to attach them to the start of each source file to most effectively
+ convey the exclusion of warranty; and each file should have at least the
+ "copyright" line and a pointer to where the full notice is found.
+ 
+     <one line to give the library's name and a brief idea of what it does.>
+     Copyright (C) <year>  <name of author>
+ 
+     This library is free software; you can redistribute it and/or
+     modify it under the terms of the GNU Library General Public
+     License as published by the Free Software Foundation; either
+     version 2 of the License, or (at your option) any later version.
+ 
+     This library is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+     Library General Public License for more details.
+ 
+     You should have received a copy of the GNU Library General Public
+     License along with this library; if not, write to the 
+     Free Software Foundation, Inc., 59 Temple Place - Suite 330, 
+     Boston, MA  02111-1307  USA.
+ 
+ Also add information on how to contact you by electronic and paper mail.
+ 
+ You should also get your employer (if you work as a programmer) or your
+ school, if any, to sign a "copyright disclaimer" for the library, if
+ necessary.  Here is a sample; alter the names:
+ 
+   Yoyodyne, Inc., hereby disclaims all copyright interest in the
+   library `Frob' (a library for tweaking knobs) written by James Random Hacker.
+ 
+   <signature of Ty Coon>, 1 April 1990
+   Ty Coon, President of Vice
+ 
+ That's all there is to it!
diff -r -c -N encoder/CVS/Entries lame3.70/CVS/Entries
*** encoder/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/CVS/Entries	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,80 ----
+ D/Dll////
+ D/doc////
+ D/i386////
+ D/libmp3lame////
+ D/mpglib////
+ /.cvsignore/1.5/Wed Jan 12 22:38:44 2000//Tlame3_70
+ /API/1.5/Thu Mar 23 22:12:26 2000//Tlame3_70
+ /COPYING/1.1.1.1/Wed Nov 24 08:40:26 1999//Tlame3_70
+ /HACKING/1.4/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /INSTALL/1.3/Thu Mar 30 09:37:28 2000//Tlame3_70
+ /LICENSE/1.1.1.1/Wed Nov 24 08:43:10 1999//Tlame3_70
+ /Makefile/1.44.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /Makefile.MSVC/1.4/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /PRESETS.draft/1.2/Sat Jan  8 17:52:52 2000//Tlame3_70
+ /README/1.2/Thu Mar 30 08:24:20 2000//Tlame3_70
+ /README.WINGTK/1.3/Thu Mar 30 08:04:11 2000//Tlame3_70
+ /TODO/1.6/Sun Jan 30 10:50:36 2000//Tlame3_70
+ /USAGE/1.7/Wed Mar 22 02:03:03 2000//Tlame3_70
+ /VbrTag.c/1.7.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /VbrTag.h/1.5/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /amiga_mpega.c/1.11.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /auenc/1.1.1.1/Wed Nov 24 08:41:13 1999//Tlame3_70
+ /brhist.c/1.6.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /brhist.h/1.4/Tue Mar 21 23:02:17 2000//Tlame3_70
+ /debugscalefac.c/1.1.1.1/Wed Nov 24 08:43:46 1999//Tlame3_70
+ /encoder.h/1.6/Wed Mar 15 20:37:16 2000//Tlame3_70
+ /fft.c/1.18.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /fft.h/1.7/Sun Feb 13 18:52:59 2000//Tlame3_70
+ /formatBitstream.c/1.4/Sun Feb 20 14:09:34 2000//Tlame3_70
+ /formatBitstream.h/1.2/Sat Feb 19 13:32:30 2000//Tlame3_70
+ /get_audio.c/1.36.4.1/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /get_audio.h/1.7/Thu Mar 16 19:05:26 2000//Tlame3_70
+ /gpkplotting.c/1.1.1.1/Wed Nov 24 08:42:07 1999//Tlame3_70
+ /gpkplotting.h/1.1.1.1/Wed Nov 24 08:42:08 1999//Tlame3_70
+ /gtkanal.c/1.26/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /gtkanal.h/1.10/Thu Mar 30 05:39:41 2000//Tlame3_70
+ /id3tag.c/1.3/Sun Mar  5 18:37:28 2000//Tlame3_70
+ /id3tag.h/1.4/Mon Mar  6 19:53:03 2000//Tlame3_70
+ /ieeefloat.c/1.3/Mon Feb 21 23:05:05 2000//Tlame3_70
+ /ieeefloat.h/1.1.1.1/Wed Nov 24 08:42:58 1999//Tlame3_70
+ /l3bitstream-pvt.h/1.4/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /l3bitstream.c/1.20.2.1.2.2/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /l3bitstream.h/1.5/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /l3side.h/1.10/Thu Apr  6 18:50:49 2000//Tlame3_70
+ /lame.c/1.99.2.3.4.4/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /lame.dsp/1.12/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /lame.dsw/1.1.1.1/Wed Nov 24 08:43:20 1999//Tlame3_70
+ /lame.h/1.39/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /machine.h/1.14.4.1/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /main.c/1.25/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /mlame/1.3/Mon Jan 31 05:49:48 2000//Tlame3_70
+ /mp3rtp.c/1.11/Thu Mar 16 19:05:26 2000//Tlame3_70
+ /mp3x.c/1.7/Thu Mar 16 19:05:26 2000//Tlame3_70
+ /newmdct.c/1.11.4.1/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /newmdct.h/1.4/Tue Mar 21 23:02:17 2000//Tlame3_70
+ /parse.c/1.25.4.1.4.2/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /portableio.c/1.1.1.1/Wed Nov 24 08:43:35 1999//Tlame3_70
+ /portableio.h/1.1.1.1/Wed Nov 24 08:43:37 1999//Tlame3_70
+ /psymodel.c/1.52.4.2/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /psymodel.h/1.10/Fri Mar 24 18:07:30 2000//Tlame3_70
+ /quantize-pvt.c/1.67.4.1/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /quantize-pvt.h/1.35/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /quantize.c/1.69.2.1.2.2/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /quantize.h/1.5/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /reservoir.c/1.11.4.1/Thu Apr  6 18:50:51 2000//Tlame3_70
+ /reservoir.h/1.4/Tue Mar 21 23:02:17 2000//Tlame3_70
+ /rtp.c/1.3/Thu Jan 27 04:35:48 2000//Tlame3_70
+ /rtp.h/1.2/Tue Jan 25 17:48:23 2000//Tlame3_70
+ /tables.c/1.4.2.1/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /tables.h/1.2/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /takehiro.c/1.33.2.1.2.2/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /testcase.mp3/1.11/Thu Apr  6 18:50:52 2000/-kb/Tlame3_70
+ /testcase.wav/1.1/Sun Jan  9 20:55:56 2000/-kb/Tlame3_70
+ /timestatus.c/1.4/Thu Mar 16 16:44:22 2000//Tlame3_70
+ /timestatus.h/1.3/Tue Mar 14 20:45:04 2000//Tlame3_70
+ /util.c/1.20.4.1/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /util.h/1.15/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /vbrquantize.c/1.20/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /version.c/1.3/Fri Mar 10 20:56:35 2000//Tlame3_70
+ /version.h/1.12.2.1.2.1.4.4/Thu Apr  6 18:50:52 2000//Tlame3_70
diff -r -c -N encoder/CVS/Repository lame3.70/CVS/Repository
*** encoder/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/CVS/Repository	Thu Apr  6 12:50:20 2000
***************
*** 0 ****
--- 1 ----
+ lame
diff -r -c -N encoder/CVS/Root lame3.70/CVS/Root
*** encoder/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/CVS/Root	Thu Apr  6 12:50:20 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/CVS/Tag lame3.70/CVS/Tag
*** encoder/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/CVS/Tag	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/Dll/.cvsignore lame3.70/Dll/.cvsignore
*** encoder/Dll/.cvsignore	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/.cvsignore	Tue Nov 30 12:30:46 1999
***************
*** 0 ****
--- 1,9 ----
+ *.d
+ Debug
+ DebugGTK
+ Release
+ ReleaseGTK
+ *.ncb
+ *.plg
+ *.opt
+ *.dll
diff -r -c -N encoder/Dll/BladeMP3EncDLL.c lame3.70/Dll/BladeMP3EncDLL.c
*** encoder/Dll/BladeMP3EncDLL.c	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/BladeMP3EncDLL.c	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,448 ----
+ /*
+  *	Blade DLL Interface for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ #include "BladeMP3EncDLL.h"
+ #include <assert.h>
+ #include "version.h"  
+ #include "VbrTag.h"   
+ #include "lame.h"
+ /*
+ #include "get_audio.h"
+ #include "globalflags.h"
+ #include "machine.h"
+ #include "util.h"
+ */
+ 
+ #ifdef _DEBUG
+ 	#define _DEBUGDLL 1
+ #endif
+ 
+ 
+ const int MAJORVERSION=1;
+ const int MINORVERSION=05;
+ const int CURRENT_STRUCT_VERSION=1;
+ const int CURRENT_STRUCT_SIZE=sizeof(BE_CONFIG);
+ 
+ 
+ 
+ 
+ 
+ // Local variables
+ static int		nPsychoModel=2;
+ static BOOL		bFirstFrame=TRUE;
+ static DWORD	dwSampleBufferSize=0;
+ 
+ 
+ #ifdef _DEBUGDLL
+ void dump_config( char *inPath, char *outPath);
+ #endif
+ 
+ lame_global_flags gf;
+ 
+ static void InitParams()
+ {
+     bFirstFrame=TRUE;
+     lame_init(&gf);
+ 
+ }
+ 
+ 
+ 
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream)
+ {
+ 	int			nDllArgC=0;
+ 	BE_CONFIG	lameConfig;
+ 
+ 	InitParams();
+ 
+ 	// clear out structure
+ 	memset(&lameConfig,0x00,CURRENT_STRUCT_SIZE);
+ 
+ 	// Check if this is a regular BLADE_ENCODER header
+ 	if (pbeConfig->dwConfig!=BE_CONFIG_LAME)
+ 	{
+ 		int	nCRC=pbeConfig->format.mp3.bCRC;
+ 		int nVBR=(nCRC>>12)&0x0F;
+ 
+ 		// Copy parameter from old Blade structure
+ 		lameConfig.format.LHV1.dwSampleRate	=pbeConfig->format.mp3.dwSampleRate;
+ 		//for low bitrates, LAME will automatically downsample for better
+ 		//sound quality.  Forcing output samplerate = input samplerate is not a good idea 
+ 		//unless the user specifically requests it:
+ 		//lameConfig.format.LHV1.dwReSampleRate=pbeConfig->format.mp3.dwSampleRate;
+ 		lameConfig.format.LHV1.nMode		=(pbeConfig->format.mp3.byMode&0x0F);
+ 		lameConfig.format.LHV1.dwBitrate	=pbeConfig->format.mp3.wBitrate;
+ 		lameConfig.format.LHV1.bPrivate		=pbeConfig->format.mp3.bPrivate;
+ 		lameConfig.format.LHV1.bOriginal	=pbeConfig->format.mp3.bOriginal;
+ 		lameConfig.format.LHV1.bCRC			=nCRC&0x01;
+ 		lameConfig.format.LHV1.bCopyright	=pbeConfig->format.mp3.bCopyright;
+ 	
+ 		// Fill out the unknowns
+ 		lameConfig.format.LHV1.dwStructSize=CURRENT_STRUCT_VERSION;
+ 		lameConfig.format.LHV1.dwStructVersion=CURRENT_STRUCT_SIZE;
+ 
+ 		// Get VBR setting from fourth nibble
+ 		if (nVBR>0)
+ 		{
+ 			lameConfig.format.LHV1.bWriteVBRHeader=TRUE;
+ 			lameConfig.format.LHV1.bEnableVBR=TRUE;
+ 			lameConfig.format.LHV1.nVBRQuality=nVBR-1;
+ 		}
+ 
+ 		// Get Quality from third nibble
+ 		lameConfig.format.LHV1.nQuality=(MPEG_QUALITY)((nCRC>>8)&0x0F);
+ 
+ 	}
+ 	else
+ 	{
+ 		// Copy the parameters
+ 		memcpy(&lameConfig,pbeConfig,pbeConfig->format.LHV1.dwStructSize);
+ 	}
+ 
+ 
+ 	// Not used, always assign stream 1
+ 	*phbeStream=1;
+ 
+ 
+ 
+ 	// --------------- Set arguments to LAME encoder -------------------------
+ 
+ 	// Set zero argument, the filename
+ 	//strcpy(DllArgV[nDllArgC++],"LameDLLEncoder");
+ 
+   	switch (lameConfig.format.LHV1.nMode)
+ 	{
+ 		case BE_MP3_MODE_STEREO:
+ 			gf.mode=0;
+ 			gf.mode_fixed=1;  /* dont allow LAME to change the mode */
+ 			gf.num_channels=2;
+ 		break;
+ 		case BE_MP3_MODE_JSTEREO:
+ 			gf.mode=1;
+ 			gf.mode_fixed=1;
+ 			gf.num_channels=2;
+ 		break;
+ 		case BE_MP3_MODE_MONO:
+ 			gf.mode=3;
+ 			gf.mode_fixed=1;
+ 			gf.num_channels=1;
+ 		break;
+ 		case BE_MP3_MODE_DUALCHANNEL:
+ 			gf.force_ms=1;
+ 			gf.mode=1;
+ 			gf.mode_fixed=1;
+ 			gf.num_channels=2;
+ 		break;
+ 		default:
+ 		{
+ 			char lpszError[255];
+ 			sprintf(lpszError,"Invalid lameConfig.format.LHV1.nMode, value is %d\n",lameConfig.format.LHV1.nMode);
+ 			OutputDebugString(lpszError);
+ 			return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ 		}
+ 	}
+ 
+ 	switch (lameConfig.format.LHV1.nQuality)
+ 	{
+ 		case NORMAL_QUALITY:	// Nothing special
+ 			break;
+ 		case LOW_QUALITY:		// -f flag
+ 			gf.quality=9;
+ 			break;
+ 		case HIGH_QUALITY:		// -h flag for high qualtiy
+ 			gf.quality=2;
+ 			break;
+ 		case VOICE_QUALITY:		// --voice flag for experimental voice mode
+ 			gf.lowpassfreq=12000;
+ 			gf.VBR_max_bitrate_kbps=160;
+ 			gf.no_short_blocks=1;
+ 		break;
+ 	}
+ 
+ 	if (lameConfig.format.LHV1.bEnableVBR)
+ 	{
+ 		// 0=no vbr 1..10 is VBR quality setting -1
+ 		gf.VBR=1;
+ 		gf.VBR_q=lameConfig.format.LHV1.nVBRQuality;
+ 	}
+ 
+ 	// Set frequency
+ 	gf.in_samplerate=lameConfig.format.LHV1.dwSampleRate;
+ 
+ 	// Set frequency resampling rate, if specified
+ 	if (lameConfig.format.LHV1.dwReSampleRate>0)
+ 		gf.out_samplerate=lameConfig.format.LHV1.dwReSampleRate;
+ 		
+ 	
+ 	// Set bitrate.  (CDex users always specify bitrate=Min bitrate when using VBR)
+ 	gf.brate=lameConfig.format.LHV1.dwBitrate;
+ 	gf.VBR_min_bitrate_kbps=gf.brate;
+ 			
+ 	// Set Maxbitrate, if specified
+ 	if (lameConfig.format.LHV1.dwMaxBitrate>0)
+ 		gf.VBR_max_bitrate_kbps=lameConfig.format.LHV1.dwMaxBitrate;
+ 	
+ 	// Set copyright flag?
+ 	if (lameConfig.format.LHV1.bCopyright)
+ 		gf.copyright=1;
+ 
+ 	// Do we have to tag  it as non original 
+ 	if (!lameConfig.format.LHV1.bOriginal)
+ 		gf.original=0;
+ 
+ 	// Add CRC?
+ 	if (lameConfig.format.LHV1.bCRC)
+ 		gf.error_protection=1;
+ 
+ 	gf.silent=1;  /* disable status ouput */
+ 
+ 	// Set private bit?
+ 	if (lameConfig.format.LHV1.bPrivate)
+ 	{
+ 		gf.extension = 0;
+ 	}
+ 	else
+ 	{
+ 		gf.extension = 1;
+ 	}
+ 	
+ 	lame_init_params(&gf);	
+ 
+ 	//LAME encoding call will accept any number of samples.  
+ 	*dwSamples=1152*gf.num_channels;
+ 
+ 	// Set the input sample buffer size, so we know what we can expect
+ 	dwSampleBufferSize=*dwSamples;
+ 
+ 	// Set MP3 buffer size
+ 	// conservative estimate
+ 	*dwBufferSize=1.25*(*dwSamples/gf.num_channels) + 7200;
+ 
+ 
+ #ifdef _DEBUGDLL
+ 	dump_config(gf.inPath,gf.outPath);
+ #endif
+ 
+ 	// Everything went OK, thus return SUCCESSFUL
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 
+ 	*pdwOutput = lame_encode_finish(&gf,pOutput,0);
+ 
+ 	if (*pdwOutput<0) {
+ 		*pdwOutput=0;
+ 		return BE_ERR_BUFFER_TOO_SMALL;
+ 	}
+ 
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream)
+ {
+ 	// DeInit encoder
+ //	return DeInitEncoder();
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion)
+ {
+ 	// DLL Release date
+ 	char lpszDate[20];
+ 	char lpszTemp[5];
+ 
+ 
+ 	// Set DLL interface version
+ 	pbeVersion->byDLLMajorVersion=MAJORVERSION;
+ 	pbeVersion->byDLLMinorVersion=MINORVERSION;
+ 
+ 	// Set Engine version number (Same as Lame version)
+ 	pbeVersion->byMajorVersion=LAME_MAJOR_VERSION;
+ 	pbeVersion->byMinorVersion=LAME_MINOR_VERSION;
+ 
+ 	// Get compilation date
+ 	strcpy(lpszDate,__DATE__);
+ 
+ 	// Get the first three character, which is the month
+ 	strncpy(lpszTemp,lpszDate,3);
+ 
+ 	// Set month
+ 	if (strcmp(lpszTemp,"Jan")==0)	pbeVersion->byMonth=1;
+ 	if (strcmp(lpszTemp,"Feb")==0)	pbeVersion->byMonth=2;
+ 	if (strcmp(lpszTemp,"Mar")==0)	pbeVersion->byMonth=3;
+ 	if (strcmp(lpszTemp,"Apr")==0)	pbeVersion->byMonth=4;
+ 	if (strcmp(lpszTemp,"May")==0)	pbeVersion->byMonth=5;
+ 	if (strcmp(lpszTemp,"Jun")==0)	pbeVersion->byMonth=6;
+ 	if (strcmp(lpszTemp,"Jul")==0)	pbeVersion->byMonth=7;
+ 	if (strcmp(lpszTemp,"Aug")==0)	pbeVersion->byMonth=8;
+ 	if (strcmp(lpszTemp,"Sep")==0)	pbeVersion->byMonth=9;
+ 	if (strcmp(lpszTemp,"Oct")==0)	pbeVersion->byMonth=10;
+ 	if (strcmp(lpszTemp,"Nov")==0)	pbeVersion->byMonth=11;
+ 	if (strcmp(lpszTemp,"Dec")==0)	pbeVersion->byMonth=12;
+ 
+ 	// Get day of month string (char [4..5])
+ 	pbeVersion->byDay=atoi(lpszDate+4);
+ 
+ 	// Get year of compilation date (char [7..10])
+ 	pbeVersion->wYear=atoi(lpszDate+7);
+ 
+ 	memset(pbeVersion->zHomepage,0x00,BE_MAX_HOMEPAGE);
+ 
+ 	strcpy(pbeVersion->zHomepage,"http://www.sulaco.org/mp3/");
+ }
+ 
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, 
+ 			 PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 
+ 	// Encode it
+         int dwSamples;
+ 	dwSamples=nSamples/gf.num_channels;
+ 
+ 	// old versions of lame_enc.dll required exactly 1152 samples
+ 	// and worked even if nSamples accidently set to 2304
+ 	// simulate this behavoir:
+ 	if (gf.num_channels==1 && nSamples == 2304)
+ 	  dwSamples/=2;
+ 
+ 	*pdwOutput=lame_encode_buffer_interleaved(&gf,pSamples,dwSamples,pOutput,0);
+ 
+ 
+ 	if (*pdwOutput<0) {
+ 		*pdwOutput=0;
+ 		return BE_ERR_BUFFER_TOO_SMALL;
+ 	}
+ 
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR beWriteVBRHeader(LPCSTR lpszFileName)
+ {
+ 	if (gf.bWriteVbrTag)
+ 	{
+ 		// Calculate relative quality of VBR stream 
+ 		// 0=best, 100=worst
+ 		int nQuality=gf.VBR_q*100/9;
+ 
+ 		// Write Xing header again
+ 		return PutVbrTag((LPSTR)lpszFileName,nQuality,1-gf.version);
+ 	}
+ 	return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ }
+ 
+ 
+ BOOL APIENTRY DllMain(HANDLE hModule, 
+                       DWORD  ul_reason_for_call, 
+                       LPVOID lpReserved)
+ {
+     switch( ul_reason_for_call )
+ 	{
+ 		case DLL_PROCESS_ATTACH:
+ #ifdef _DEBUGDLL
+ 			OutputDebugString("Attach Process \n");
+ #endif
+ 		break;
+ 		case DLL_THREAD_ATTACH:
+ #ifdef _DEBUGDLL
+ 			OutputDebugString("Attach Thread \n");
+ #endif
+ 		break;
+ 		case DLL_THREAD_DETACH:
+ #ifdef _DEBUGDLL
+ 			OutputDebugString("Detach Thread \n");
+ #endif
+ 		break;
+ 		case DLL_PROCESS_DETACH:
+ #ifdef _DEBUGDLL
+ 			OutputDebugString("Detach Process \n");
+ #endif
+ 		break;
+     }
+     return TRUE;
+ }
+ 
+ 
+ #ifdef _DEBUGDLL
+ void dump_config( char *inPath, char *outPath)
+ {
+   	char strTmp[255];
+ 
+ 	OutputDebugString("Encoding configuration:\n");
+ 
+ 
+ 	sprintf(strTmp,"Write VBR Header=%s\n",(gf.bWriteVbrTag)?"Yes":"No");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"version=%d\n",gf.version);
+ 	OutputDebugString(strTmp);
+ 
+ 
+ 	sprintf(strTmp,"Layer=3   mode=%d  \n",gf.mode);
+ 	OutputDebugString(strTmp);
+ 
+ 
+ 	sprintf(strTmp,"samp frq=%.1f kHz   total bitrate=%d kbps\n",gf.in_samplerate/1000.0);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",gf.emphasis, gf.copyright, gf.original,((gf.error_protection) ? "on" : "off"));
+ 	OutputDebugString(strTmp);
+ 
+ //	sprintf(strTmp,"16 Khz cut off is %s\n",(0)?"enabled":"disabled");
+ //	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Fast mode is %s\n",(gf.quality==9)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Force ms %s\n",(gf.force_ms)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ //	sprintf(strTmp,"GPsycho acoustic model is %s\n",(gpsycho)?"enabled":"disabled");
+ //	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"VRB is %s, VBR_q value is  %d\n",(gf.VBR)?"enabled":"disabled",gf.VBR_q);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"input file: '%s'   output file: '%s'\n", inPath, outPath);
+ 	OutputDebugString(strTmp);
+ 
+ //	sprintf(strTmp,"Voice mode %s\n",(voice_mode)?"enabled":"disabled");
+ //	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Encoding as %.1f kHz %d kbps %d MPEG-%d LayerIII file\n",gf.out_samplerate/1000.0,gf.brate,gf.mode,3 - gf.mode_gr);
+ 	OutputDebugString(strTmp);
+ }
+ 
+ 
+ void DispErr(LPSTR strErr)
+ {
+ 	MessageBox(NULL,strErr,"",MB_OK);
+ }
+ 
+ #endif
diff -r -c -N encoder/Dll/BladeMP3EncDLL.def lame3.70/Dll/BladeMP3EncDLL.def
*** encoder/Dll/BladeMP3EncDLL.def	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/BladeMP3EncDLL.def	Sun Nov 28 15:21:47 1999
***************
*** 0 ****
--- 1,9 ----
+ LIBRARY  lame_enc.DLL
+ EXPORTS
+ 
+ beInitStream		@1
+ beEncodeChunk		@2
+ beDeinitStream		@3
+ beCloseStream		@4
+ beVersion			@5
+ beWriteVBRHeader	@6
diff -r -c -N encoder/Dll/BladeMP3EncDLL.h lame3.70/Dll/BladeMP3EncDLL.h
*** encoder/Dll/BladeMP3EncDLL.h	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/BladeMP3EncDLL.h	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,196 ----
+ /*
+ 
+ 	bladedll.h
+ 
+     +++++++++++++++++++++++++++
+ 	+   Blade's Encoder DLL   +
+ 	+++++++++++++++++++++++++++
+ 
+     ------------------------------------------------------
+ 	- Version 1.00 (7 November 1998) - Jukka Poikolainen -
+ 	------------------------------------------------------
+ 
+ 	Initial version
+ 	
+ 	------------------------------------------------------
+ 	- Version x.xx (x xxxxxxxx xxxx) - xxxxx xxxxxxxxxxx -
+ 	------------------------------------------------------
+ 
+ */
+ 
+ #ifndef ___BLADEDLL_H_INCLUDED___
+ #define ___BLADEDLL_H_INCLUDED___
+ 
+ #pragma pack(push)
+ #pragma pack(1)
+ 
+ /* encoding formats */
+ 
+ #define		BE_CONFIG_MP3			0										
+ #define		BE_CONFIG_LAME			256		
+ 
+ /* type definitions */
+ 
+ typedef		unsigned long			HBE_STREAM;
+ typedef		HBE_STREAM				*PHBE_STREAM;
+ typedef		unsigned long			BE_ERR;
+ 
+ /* error codes */
+ 
+ #define		BE_ERR_SUCCESSFUL					0x00000000
+ #define		BE_ERR_INVALID_FORMAT				0x00000001
+ #define		BE_ERR_INVALID_FORMAT_PARAMETERS	0x00000002
+ #define		BE_ERR_NO_MORE_HANDLES				0x00000003
+ #define		BE_ERR_INVALID_HANDLE				0x00000004
+ #define		BE_ERR_BUFFER_TOO_SMALL				0x00000005
+ 
+ /* other constants */
+ 
+ #define		BE_MAX_HOMEPAGE			256
+ 
+ /* format specific variables */
+ 
+ #define		BE_MP3_MODE_STEREO		0
+ #define		BE_MP3_MODE_JSTEREO		1
+ #define		BE_MP3_MODE_DUALCHANNEL	2
+ #define		BE_MP3_MODE_MONO		3
+ 
+ #define		MPEG1	1
+ #define		MPEG2	0
+ 
+ #ifdef _BLADEDLL
+ #undef FLOAT
+ 	#include <Windows.h>
+ #endif
+ 
+ 
+ typedef enum 
+ {
+ 	NORMAL_QUALITY=0,
+ 	LOW_QUALITY,
+ 	HIGH_QUALITY,
+ 	VOICE_QUALITY
+ } MPEG_QUALITY;
+ 
+ typedef struct	{
+ 	DWORD	dwConfig;			// BE_CONFIG_XXXXX
+ 								// Currently only BE_CONFIG_MP3 is supported
+ 	union	{
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;	// 48000, 44100 and 32000 allowed
+ 			BYTE	byMode;			// BE_MP3_MODE_STEREO, BE_MP3_MODE_DUALCHANNEL, BE_MP3_MODE_MONO
+ 			WORD	wBitrate;		// 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256 and 320 allowed
+ 			BOOL	bPrivate;		
+ 			BOOL	bCRC;
+ 			BOOL	bCopyright;
+ 			BOOL	bOriginal;
+ 
+ 			} mp3;					// BE_CONFIG_MP3
+ 
+ 			struct
+ 			{
+ 			// STRUCTURE INFORMATION
+ 			DWORD			dwStructVersion;	
+ 			DWORD			dwStructSize;
+ 
+ 			// BASIC ENCODER SETTINGS
+ 			DWORD			dwSampleRate;	// ALLOWED SAMPLERATE VALUES DEPENDS ON dwMPEGVersion 
+ 			DWORD			dwReSampleRate;	// DOWNSAMPLERATE, 0=ENCODER DECIDES  
+ 			INT				nMode;			// BE_MP3_MODE_STEREO, BE_MP3_MODE_DUALCHANNEL, BE_MP3_MODE_MONO
+ 			DWORD			dwBitrate;		// CBR bitrate, VBR min bitrate
+ 			DWORD			dwMaxBitrate;	// CBR ignored, VBR Max bitrate
+ 			MPEG_QUALITY	nQuality;		// Quality setting (NORMAL,HIGH,LOW,VOICE)
+ 			DWORD			dwMpegVersion;	// MPEG-1 OR MPEG-2
+ 			DWORD			dwPsyModel;		// FUTURE USE, SET TO 0
+ 			DWORD			dwEmphasis;		// FUTURE USE, SET TO 0
+ 
+ 			// BIT STREAM SETTINGS
+ 			BOOL			bPrivate;		// Set Private Bit (TRUE/FALSE)
+ 			BOOL			bCRC;			// Insert CRC (TRUE/FALSE)
+ 			BOOL			bCopyright;		// Set Copyright Bit (TRUE/FALSE)
+ 			BOOL			bOriginal;		// Set Original Bit (TRUE/FALSE)
+ 			
+ 			// VBR STUFF
+ 			BOOL			bWriteVBRHeader;	// WRITE XING VBR HEADER (TRUE/FALSE)
+ 			BOOL			bEnableVBR;			// USE VBR ENCODING (TRUE/FALSE)
+ 			INT				nVBRQuality;		// VBR QUALITY 0..9
+ 
+ 			BYTE			btReserved[255];	// FUTURE USE, SET TO 0
+ 
+ 			} LHV1;					// LAME header version 1
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;
+ 			BYTE	byMode;
+ 			WORD	wBitrate;
+ 			BYTE	byEncodingMethod;
+ 
+ 		} aac;
+ 
+ 	} format;
+ 		
+ } BE_CONFIG, *PBE_CONFIG;
+ 
+ 
+ typedef struct	{
+ 
+ 	// BladeEnc DLL Version number
+ 
+ 	BYTE	byDLLMajorVersion;
+ 	BYTE	byDLLMinorVersion;
+ 
+ 	// BladeEnc Engine Version Number
+ 
+ 	BYTE	byMajorVersion;
+ 	BYTE	byMinorVersion;
+ 
+ 	// DLL Release date
+ 
+ 	BYTE	byDay;
+ 	BYTE	byMonth;
+ 	WORD	wYear;
+ 
+ 	// BladeEnc	Homepage URL
+ 
+ 	CHAR	zHomepage[BE_MAX_HOMEPAGE + 1];	
+ 
+ } BE_VERSION, *PBE_VERSION;			
+ 
+ #ifndef _BLADEDLL
+ 
+ typedef BE_ERR	(*BEINITSTREAM)		(PBE_CONFIG, PDWORD, PDWORD, PHBE_STREAM);
+ typedef BE_ERR	(*BEENCODECHUNK)	(HBE_STREAM, DWORD, PSHORT, PBYTE, PDWORD);
+ typedef BE_ERR	(*BEDEINITSTREAM)	(HBE_STREAM, PBYTE, PDWORD);
+ typedef BE_ERR	(*BECLOSESTREAM)	(HBE_STREAM);
+ typedef VOID	(*BEVERSION)		(PBE_VERSION);
+ 
+ #define	TEXT_BEINITSTREAM	"beInitStream"
+ #define	TEXT_BEENCODECHUNK	"beEncodeChunk"
+ #define	TEXT_BEDEINITSTREAM	"beDeinitStream"
+ #define	TEXT_BECLOSESTREAM	"beCloseStream"
+ #define	TEXT_BEVERSION		"beVersion"
+ 
+ /*	
+ 	BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ 	BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ 	VOID	beVersion(PBE_VERSION pbeVersion);		
+ */
+ 	
+ #else
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion);
+ 
+ #endif
+ 
+ #pragma pack(pop)
+ 
+ #endif
diff -r -c -N encoder/Dll/CVS/Entries lame3.70/Dll/CVS/Entries
*** encoder/Dll/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/CVS/Entries	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,7 ----
+ /.cvsignore/1.1/Tue Nov 30 19:30:46 1999//Tlame3_70
+ /BladeMP3EncDLL.c/1.16.4.8/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /BladeMP3EncDLL.def/1.2/Sun Nov 28 22:21:47 1999//Tlame3_70
+ /BladeMP3EncDLL.h/1.3.8.1/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /MP3EncDll.dsp/1.13/Thu Apr  6 18:50:52 2000//Tlame3_70
+ /MP3EncDll.dsw/1.4/Wed Mar 15 01:20:31 2000//Tlame3_70
+ D
diff -r -c -N encoder/Dll/CVS/Repository lame3.70/Dll/CVS/Repository
*** encoder/Dll/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/CVS/Repository	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ lame/Dll
diff -r -c -N encoder/Dll/CVS/Root lame3.70/Dll/CVS/Root
*** encoder/Dll/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/CVS/Root	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/Dll/CVS/Tag lame3.70/Dll/CVS/Tag
*** encoder/Dll/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/CVS/Tag	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/Dll/MP3EncDll.dsp lame3.70/Dll/MP3EncDll.dsp
*** encoder/Dll/MP3EncDll.dsp	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/MP3EncDll.dsp	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,298 ----
+ # Microsoft Developer Studio Project File - Name="MP3EncDll" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+ 
+ CFG=MP3EncDll - Win32 Debug
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak" CFG="MP3EncDll - Win32 Debug"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "MP3EncDll - Win32 Release" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE "MP3EncDll - Win32 Debug" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ MTL=midl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "MP3EncDll - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MT /W3 /GX /Ox /Ot /Og /Oy /Ob2 /I "..\\" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL"   /YX /FD -Qmem -Qip /c
+ # SUBTRACT CPP /Oa /Ow /Oi /Os
+ # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:"..\..\lame_enc.dll"
+ 
+ !ELSEIF  "$(CFG)" == "MP3EncDll - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MTd /W3 /Gm /GX /Zi /Od /I "..\\" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL"   /YX /FD /c
+ # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:"..\..\lame_enc.dll" /pdbtype:sept
+ # SUBTRACT LINK32 /map
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "MP3EncDll - Win32 Release"
+ # Name "MP3EncDll - Win32 Debug"
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.def
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\brhist.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\brhist.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fft.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fft.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gpkplotting.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gpkplotting.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gtkanal.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gtkanal.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\id3tag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\id3tag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\lame.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\lame.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\newmdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\newmdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\parse.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\psymodel.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\psymodel.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\quantize-pvt.c"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\quantize-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\quantize.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\quantize.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\sqrttab.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\tables.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\timestatus.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\timestatus.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\takehiro.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\util.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\util.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\version.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\wavheader.h
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/Dll/MP3EncDll.dsw lame3.70/Dll/MP3EncDll.dsw
*** encoder/Dll/MP3EncDll.dsw	Wed Dec 31 17:00:00 1969
--- lame3.70/Dll/MP3EncDll.dsw	Tue Mar 14 18:20:31 2000
***************
*** 0 ****
--- 1,29 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "MP3EncDll"=.\MP3EncDll.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/HACKING lame3.70/HACKING
*** encoder/HACKING	Wed Dec 31 17:00:00 1969
--- lame3.70/HACKING	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,106 ----
+ ************************************************************************
+ LAME API
+ 
+ For a general outline of the code, see the file API.  
+ Also, main.c is a simple front end to libmp3lame.a
+ 
+ The guts of the code are called from lame_encode_buffer().
+ 
+ lame_encode_buffer() handles buffering, resampling, filtering, and
+ then calls lame_encode_frame() for each frame:
+ 
+ lame_encode_frame():
+    l3psycho_anal()        compute masking thresholds
+    mdct_sub()             compute MDCT coefficients
+    iteration_loop()       choose scalefactors (via iteration)
+                           which determine noise shapping, and 
+                           choose best huffman tables for lossless compression
+ 
+    III_formatBitstream    format the bitstream and store in bit_buffer
+    copy_buffer()          make a copy of bit_buffer, to return to calling program
+    write_buffer()         optionally output bit_buffer to a file
+    empty_buffer()	  mark bit_buffer as empty
+ 
+ 
+ 
+ 
+ 
+ ************************************************************************
+ We are in the process of switching the whole code to FLOAT or FLOAT8,
+ which ever is faster (defined in machine.h).  
+ Avoid using float or double, and instead use:
+ 
+ FLOAT    4 byte floating point.  
+ FLOAT8   8 byte floating point (only when necessary)
+ 
+ 
+ ************************************************************************
+ Initialization:   LAME can be used as a library, and there are two
+ kinds of static data:  data that has to be initialized only once
+ when the library is called, and data that has to be initialized
+ every time you start encoding a new sample.
+ 
+ These routines should be coded something like:
+ 
+ #include "globalflags"
+ void subroutine(void)
+ {
+   static int firstcall=1;
+   if (firstcall) {
+     firstcall=0;
+     /* code that needs to be done only once when routine is loaded */
+   }
+   if (gf.frameNum==0) {
+     /* code that needs to be done before encoding each file/stream */
+   }
+ }
+ 
+ The frameNum==0 code only works for routines which are only called
+ once per frame.  More general code would be:
+ 
+ 
+ #include "globalflags"
+ void subroutine(void)
+ {
+   static int init=0;
+   if (gf.frameNum==0 && !init) {
+     /* code that needs to be done before encoding each file/stream */
+     init=1;
+   }
+   if (gf.frameNum>0) init=0;
+ }
+ 
+ 
+ 
+ 
+ 
+ ************************************************************************
+ Global flags
+ 
+ For better or worse, there are many global flags in lame, 
+ in the 'gf' structure.  
+ 
+ The rules for adding a global flag are:
+ 
+ 1. declair in struct gf in lame.h
+ 2. default values must be set in lame_init()
+ 3. include "globalflags.h" in routines that need access to these flags.
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/INSTALL lame3.70/INSTALL
*** encoder/INSTALL	Wed Jan 22 02:43:12 1997
--- lame3.70/INSTALL	Thu Mar 30 02:37:28 2000
***************
*** 1,36 ****
! Building the MPEG audio encoding software:
  
! If you have gnu make and are on a Unix-type system, you should only have to
! type:
  
! ./configure
! make
  
- This will create a Makefile customized to your environment, overwriting the
- previous Makefile, using Makefile.in as a template.
  
- For other systems you may have to modify the Makefile. Some flags of
- interest are:
  
- BS_FORMAT
-   Set to BINARY to work with most MPEG audio decoders (and save space). You
-   can set it to ASCII, but your bitstream will only work with musicout().
  
- HAVE_NINT
-   Define this if your math library already has nint().
  
! NDEBUG
!   Define this to turn off all the assertions. Don't define this if you
!   are developing code.
  
- DEBUG
-   Define this to get debugging messages printed to stdout.
  
- For non-Unix systems you may have to define other things. Be sure to look
- at common.h. If you build this on a Macintosh, be sure to use a fairly
- recent set of Universal Headers. I have built this code on SunOS 4.1 and
- Linux 1.3 (using gcc 2.6.3), and on the Power Macintosh (using Metrowerks
- CodeWarrior 6).
  
  
- <mc@fivebats.com> 1995/10/16
--- 1,69 ----
! LAME 3.xx    3/00 Mark Taylor (http://www.sulaco.org/mp3)
  
! =======================================================================
! Building the MPEG audio encoding software on Windows:
! =======================================================================
! There are MSVC project files, and a Makefile.MSVC included
! with the project.  For production use, be sure to compile
! a "release" version and compile with the "maximum speed" compile
! option, and #define NDEBUG.   
  
! Note that MSVC "professional" claims to produce faster executables
! then MSVC "standard".  It is possible to compile the GTK frame
! analyzer under windows, see README.WINGTK
  
  
  
  
  
! =======================================================================
! Building the MPEG audio encoding software on *NIX platforms:
! =======================================================================
! If you are reading this, you have already applied the patch to the
! dist10 ISO demonstration source (or downloaded a full source
! distrubtion).  If you do not have GTK 1.1.16 or higher, or do not want
! the graphical frame analyzer (it uses a lot of memory), edit the
! Makefile and dont define GTK and GTKLIBS.  If you have trouble with
! libncurses/libtermcap, you can also disable that in the Makefile.
! 
! Now just type:
! 
! % make
! 
! If it doesn't work, figure out why and send me the fix!  
! If you are using a newer version of EGCS, check the Makefile.
! There are some flags which may improve performance.
! 
! LAME has built in support for 16bit raw pcm, aiff and simple wav
! formats.  Some complex .wav headers will confuse LAME. If you have
! trouble with this, or want to encode from other sound formats, you can
! now compile LAME to use Erik de Castro Lopo's libsndfile.  To use
! libsndfile in LAME:
! 
!   1. install libsndfile (see http://www.zip.com.au/~erikd/libsndfile/).  
!   2. set SNDLIB and LIBSNDFILE as shown in the LAME Makefile.  
!   3. make clean ; make
! 
! Thanks to Albert Faber for adding the libsndfile support!
! 
! LAME can also be compiled into a BladeEnc compatiable MS Windows .dll 
! file.  See the Dll/ directory for details. 
! 
! 
! 
! =======================================================================
! To encode:
! =======================================================================
! see the file "USAGE" for some usage guidlines.
! 
! 
! 
! =======================================================================
! Portability
! =======================================================================
! LAME 3.x has been run on every modern OS.  see the Makefile.
! 
  
  
  
  
diff -r -c -N encoder/LICENSE lame3.70/LICENSE
*** encoder/LICENSE	Wed Dec 31 17:00:00 1969
--- lame3.70/LICENSE	Wed Nov 24 01:43:10 1999
***************
*** 0 ****
--- 1,44 ----
+ Can I use LAME in my commercial program?  
+ 
+ Yes, you can, under the restrictions of the LGPL.  In particular, you
+ can include a compiled version of the LAME library (for example,
+ lame.dll) with a commercial program.  Some notable requirements of
+ the LGPL:
+ 
+ 1. In your program, you cannot include any source code from LAME, with
+    the exception of files whose only purpose is to describe the library
+    interface (such as lame.h).  
+ 
+ 2. Any modifications of LAME must be released under the LGPL.  
+    The LAME project (www.sulaco.org/mp3) would appreciate being
+    notified of any modifications.  
+ 
+ 3. You must give prominent notice that your program is:
+       A. using LAME (including version number)
+       B. LAME is under the LGPL
+       C. Provide a copy of the LGPL.  (the file COPYING contains the LGPL)
+       D. Provide a copy of LAME source, or a pointer where the LAME
+          source can be obtained (such as www.sulaco.org/mp3)
+    An example of prominent notice would be an "About the LAME encoding engine"
+    button in some pull down menu within the executable of your program.  
+ 
+ 4. If you determine that distribution of LAME requires a patent license,
+    you must obtain such license.
+ 
+ 
+ ***IMPORTANT NOTE***
+ 
+ The decoding functions provided in LAME use the mpglib decoding 
+ engine which is under the GPL.  They may not be used by any
+ program not released under the GPL unless you obtain such 
+ permission from the MPG123 project.  (www.mpg123.de).
+ 
+ LAME has built in support to read raw pcm and some wav and aiff files.
+ More robust file I/O can be handled by compiling in LIBSNDFILE,
+ but LIBSNDFILE is also under the GPL and my not be used by other
+ programs not under the GPL.
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/Makefile lame3.70/Makefile
*** encoder/Makefile	Wed Jan 22 02:43:23 1997
--- lame3.70/Makefile	Thu Apr  6 12:50:49 2000
***************
*** 1,72 ****
! # Generated automatically from Makefile.in by configure.
! ############################################################################
! ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
! ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
! ##
! ## $Id: Makefile,v 1.2 1996/08/14 23:18:34 rowlands Exp $
! ##
! ## Makefile for encoder. Requies GNU make.
! ##
! ## $Log: Makefile,v $
! ## Revision 1.2  1996/08/14 23:18:34  rowlands
! ## Cleanups.
! ##
! ## Revision 1.2  1996/02/14 05:18:05  rowlands
! ## Cleanups.
! ##
! ## Revision 1.1  1996/02/14 04:04:23  rowlands
! ## Initial revision
! ##
! ## Received from Mike Coleman
! ############################################################################
  
  CC = gcc
  
  c_sources = \
! 	common.c \
! 	encode.c \
  	formatBitstream.c \
! 	huffman.c \
! 	ieeefloat.c \
  	l3bitstream.c \
! 	l3psy.c \
! 	loop.c \
! 	mdct.c \
! 	musicin.c \
  	portableio.c \
! 	psy.c \
  	reservoir.c \
! 	subs.c \
! 	tonal.c
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
- NINT_SWITCH = 
  
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
  
! PGM = encode
  
! LIBS =  -lm
  
  
! %.o: %.c 
! 	$(CC) $(CC_SWITCHES) -c $< -o $@
  
! %.d: %.c
! 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
  
  
! $(PGM):	$(OBJ) Makefile
! 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
  
  clean:
! 	-rm $(OBJ) $(DEP)
  
  tags: TAGS
  
  TAGS: ${c_sources}
  	etags -T ${c_sources}
  
! -include $(DEP)
--- 1,326 ----
! # Makefile for LAME 3.xx
! #
! # LAME is reported to work under:  
! # Linux (i86), NetBSD 1.3.2 (StrongARM), FreeBSD (i86)
! # Compaq Alpha(OSF, Linux, Tru64 Unix), Sun Solaris, SGI IRIX,
! # OS2 Warp, Macintosh PPC, BeOS, Amiga and even VC++ 
! # 
! UNAME = $(shell uname)
! ARCH = $(shell uname -m)
  
+ 
+ # defaults:
+ PGM = lame
  CC = gcc
+ CC_OPTS =  -O
+ GTK = 
+ GTKLIBS = 
+ SNDLIB = -DLAMESNDFILE
+ LIBSNDFILE =  
+ LIBS = -lm 
+ MAKEDEP = -M
+ BRHIST_SWITCH = 
+ LIBTERMCAP = 
+ RM = rm -f
+ CPP_OPTS = -DHAVEMPGLIB -DLAMEPARSE
+ 
+ 
+ 
+ ##########################################################################
+ # To remove support for mp3 *decoding*, 
+ # remove -DHAVEMPGLIB to CPP_OPTS
+ ##########################################################################
+ 
+ 
+ ##########################################################################
+ # Define these to compile in code for the optional VBR bitrate histogram.  
+ # Requires ncurses, but libtermcap also works.  
+ # If you have any trouble, just dont define these
+ ##########################################################################
+ #BRHIST_SWITCH = -DBRHIST
+ #LIBTERMCAP = -lncurses
+ #LIBTERMCAP = -ltermcap
+ 
+ 
+ ##########################################################################
+ # SNDLIB =         no file i/o 
+ # SNDLIB = -DLAMESNDFILE  to use internal LAME soundfile routines
+ # SNDLIB = -DLIBSNDFILE   to use Erik de Castro Lopo's libsndfile 
+ # http://www.zip.com.au/~erikd/libsndfile/
+ # otherwise LAME can only read 16bit wav, aiff and pcm inputfiles.
+ # Note: at present, libsndfile does not support input from stdin.  
+ ##########################################################################
+ #SNDLIB = -DLIBSNDFILE
+ #LIBSNDFILE=-lsndfile 
+ # if libsndfile is in a custom location, try:
+ #LIBSNDFILE=-L $(LIBSNDHOME) -lsndfile  -I $(LIBSNDHOME)
+ 
+ 
+ ##########################################################################
+ # define these to use compile in support for the GTK mp3 frame analyzer
+ # Requires  -DHAVEMPGLIB
+ # and SNDLIB = -DLAME or -DLIBSNDFILE
+ ##########################################################################
+ #GTK = -DHAVEGTK `gtk-config --cflags`
+ #GTKLIBS = `gtk-config --libs` 
+ 
+ 
+ ##########################################################################
+ # LINUX   
+ ##########################################################################
+ ifeq ($(UNAME),Linux)
+ #  remove these lines if you dont have GTK, or dont want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk-config --cflags`
+    GTKLIBS = `gtk-config --libs` 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -lncurses
+ 
+ 
+ # suggested for gcc-2.7.x
+    CC_OPTS =  -O3 -fomit-frame-pointer -funroll-loops -ffast-math  -finline-functions -Wall
+ #  CC_OPTS =  -O9 -fomit-frame-pointer -fno-strength-reduce -mpentiumpro -ffast-math -finline-functions -funroll-loops -Wall -malign-double -g -march=pentiumpro -mfancy-math-387 -pipe 
+ 
+ #  for debugging:
+ #   CC_OPTS =  -UNDEBUG -O -Wall -g -DABORTFP 
+ 
+ #  for lots of debugging:
+ #   CC_OPTS =  -DDEBUG -UNDEBUG  -O -Wall -g -DABORTFP 
+ 
+ 
+ 
+ # The following features are experimental code, 
+ # so don't use them if you don't know exactly what you do! (RH 2000-01-30)
+ #   FEATURES  = -DRH_QUALITY_CONTROL  # tuned VBR quality control
+ #   FEATURES += -DRH_SIDE_VBR         # turns side channel reduction off (VBR)
+ #   FEATURES += -DRH_SIDE_CBR         # turns side channel reduction off (CBR)
+ #   FEATURES += -DRH_ATH              # max noise instead of average noise
+ # these options for gcc-2.95.2 to produce fast code
+ #   CC_OPTS = $(FEATURES)\
+ #	-Wall -O9 -fomit-frame-pointer -march=pentium \
+ #	-finline-functions -fexpensive-optimizations \
+ #	-ffast-math -malign-double -mfancy-math-387 \
+ #	-funroll-loops -funroll-all-loops -pipe -fschedule-insns2 \
+ #	-fno-strength-reduce 
+ 
+ 
+ ##########################################################################
+ # LINUX on Digital/Compaq Alpha CPUs
+ ##########################################################################
+ ifeq ($(ARCH),alpha)
+ # double is faster than float on Alpha
+ CC_OPTS =       -O4 -Wall -fomit-frame-pointer -ffast-math -funroll-loops \
+                 -mfp-regs -fschedule-insns -fschedule-insns2 \
+                 -finline-functions \
+ #                -DFLOAT=double
+ # add "-mcpu=21164a -Wa,-m21164a" to optimize for 21164a (ev56) CPU
+ 
+ # Compaq's C Compiler
+ #CC = ccc
+ # Options for Compaq's C Compiler
+ #CC_OPTS = -fast -Wall
+ 
+ # standard Linux libm
+ #LIBS	=	-lm  
+ # optimized libffm (free fast math library)
+ #LIBS	=	-lffm  
+ # Compaq's fast math library
+ LIBS    =       -lcpml 
+ endif
+ endif
+ 
+ 
+ 
+ ##########################################################################
+ # FreeBSD
+ ##########################################################################
+ ifeq ($(UNAME),FreeBSD)
+ #  remove if you do not have GTK or do not want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk12-config --cflags`
+    GTKLIBS = `gtk12-config --libs` 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -lncurses
+ 
+ endif
+ 
+ 
+ ##########################################################################
+ # SunOS
+ ##########################################################################
+ ifeq ($(UNAME),SunOS) 
+    CC = cc
+    CC_OPTS = -O -xCC  	
+    MAKEDEP = -xM
+ endif
+ 
+ 
+ ##########################################################################
+ # SGI
+ ##########################################################################
+ ifeq ($(UNAME),IRIX64) 
+    CC = cc	
+ endif
+ 
+ 
+ ##########################################################################
+ # Compaq Alpha running Dec Unix (OSF)
+ ##########################################################################
+ ifeq ($(UNAME),OSF1)
+    CC = cc
+    CC_OPTS = -fast -O3 -std -g3 -non_shared
+ endif
+ 
+ ##########################################################################
+ # BeOS
+ ##########################################################################
+ ifeq ($(UNAME),BeOS)
+    CC = $(BE_C_COMPILER)
+    LIBS =
+ ifeq ($(ARCH),BePC)
+    CC_OPTS = -O9 -fomit-frame-pointer -march=pentium \
+    -mcpu=pentium -ffast-math -funroll-loops \
+    -fprofile-arcs -fbranch-probabilities
+ else
+    CC_OPTS = -opt all
+    MAKEDEP = -make
+ endif
+ endif
+ 
+ ###########################################################################
+ # MOSXS (Rhapsody PPC)
+ ###########################################################################
+ ifeq ($(UNAME),Rhapsody)
+    CC = cc
+    LIBS =
+    CC_OPTS = -O9 -ffast-math -funroll-loops -fomit-frame-pointer
+    MAKEDEP = -make 
+    
+ endif
+ ##########################################################################
+ # OS/2
+ ##########################################################################
+ # Properly installed EMX runtime & development package is a prerequisite.
+ # tools I used: make 3.76.1, uname 1.12, sed 2.05, PD-ksh 5.2.13
+ #
+ ##########################################################################
+ ifeq ($(UNAME),OS/2)
+    SHELL=sh	
+    CC = gcc
+    CC_OPTS = -O3
+    PGM = lame.exe
+    LIBS =
+ 
+ # I use the following for slightly better performance on my Pentium-II
+ # using pgcc-2.91.66:
+ #   CC_OPTS = -O6 -ffast-math -funroll-loops -mpentiumpro -march=pentiumpro
+ 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -ltermcap
+ 
+ # Uncomment & inspect the 2 GTK lines to use MP3x GTK frame analyzer.
+ # Properly installed XFree86/devlibs & GTK+ is a prerequisite.
+ # The following works for me using Xfree86/OS2 3.3.5 and GTK+ 1.2.3:
+ #   GTK = -DHAVEGTK -IC:/XFree86/include/gtk12 -Zmt -D__ST_MT_ERRNO__ -IC:/XFree86/include/glib12 -IC:/XFree86/include
+ #   GTKLIBS = -LC:/XFree86/lib -Zmtd -Zsysv-signals -Zbin-files -lgtk12 -lgdk12 -lgmodule -lglib12 -lXext -lX11 -lshm -lbsd -lsocket -lm
+ endif
+ 
+ 
+ 
  
+ # 10/99 added -D__NO_MATH_INLINES to fix a bug in *all* versions of
+ # gcc 2.8+ as of 10/99.  
+ 
+ CC_SWITCHES = -DNDEBUG -D__NO_MATH_INLINES $(CC_OPTS) $(SNDLIB) $(GTK) $(BRHIST_SWITCH)
  c_sources = \
!         brhist.c \
  	formatBitstream.c \
! 	fft.c \
! 	get_audio.c \
  	l3bitstream.c \
!         id3tag.c \
! 	ieeefloat.c \
!         lame.c \
!         newmdct.c \
!         parse.c \
  	portableio.c \
! 	psymodel.c \
! 	quantize.c \
! 	quantize-pvt.c \
! 	vbrquantize.c \
  	reservoir.c \
! 	tables.c \
! 	takehiro.c \
! 	timestatus.c \
! 	util.c \
!         VbrTag.c \
!         version.c \
!         gtkanal.c \
!         gpkplotting.c \
!         mpglib/common.c \
!         mpglib/dct64_i386.c \
!         mpglib/decode_i386.c \
!         mpglib/layer3.c \
!         mpglib/tabinit.c \
!         mpglib/interface.c \
!         mpglib/main.c 
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
  
  
! %.o: %.c 
! 	$(CC) $(CPP_OPTS) $(CC_SWITCHES) -c $< -o $@
  
! %.d: %.c
! 	$(SHELL) -ec '$(CC) $(MAKEDEP)  $(CPP_OPTS) $(CC_SWITCHES)  $< | sed '\''s;$*.o;& $@;g'\'' > $@'
  
+ #$(PGM):	main.o $(OBJ) Makefile 
+ #	$(CC) -o $(PGM)  main.o $(OBJ) $(LIBS) $(CPP_OPTS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
! $(PGM):	main.o libmp3lame.a 
! 	$(CC) -o $(PGM)  main.o -L. -lmp3lame $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
! mp3x:	mp3x.o libmp3lame.a
! 	$(CC) -o mp3x mp3x.o  $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
+ mp3rtp:	rtp.o mp3rtp.o libmp3lame.a
+ 	$(CC) -o mp3rtp mp3rtp.o rtp.o   $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
! libmp3lame.a:  $(OBJ) Makefile
! #	cd libmp3lame
! #	make libmp3lame
! 	ar cr libmp3lame.a  $(OBJ) 
  
  clean:
! 	-$(RM) $(OBJ) $(DEP) $(PGM) main.o rtp.o mp3rtp mp3rtp.o \
!          mp3x.o mp3x libmp3lame.a 
! 
  
  tags: TAGS
  
  TAGS: ${c_sources}
  	etags -T ${c_sources}
  
! ifneq ($(MAKECMDGOALS),clean)
!   -include $(DEP)
! endif
! 
! 
! #
! #  testcase.mp3 is a 2926 byte file.  The first number output by
! #  wc is the number of bytes which differ between new output
! #  and 'official' results.  
! #
! #  Because of compilier options and effects of roundoff, the 
! #  number of bytes which are different may not be zero, but
! #  should be at most 30.
! #
! test: $(PGM)
! 	./lame  --nores -h testcase.wav testcase.new.mp3
! 	cmp -l testcase.new.mp3 testcase.mp3 | wc
! 
! testg: $(PGM)
! 	./lame -g -h ../test/castanets.wav
diff -r -c -N encoder/Makefile.MSVC lame3.70/Makefile.MSVC
*** encoder/Makefile.MSVC	Wed Dec 31 17:00:00 1969
--- lame3.70/Makefile.MSVC	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,86 ----
+ # Makefile.MSVC: MSVC Makefile for LAME 3.57beta
+ 
+ PGM = lame
+ CC = cl
+ LN = link
+ 
+ # debugging options
+ # CC_OPTS = /nologo /Zi /Ge /GZ
+ # LN_OPTS = /nologo /debug:full /debugtype:cv /fixed:no
+ 
+ # profiling options
+ # CC_OPTS = /nologo /Zi /O2ab2gitwy /G6AFs /DNDEBUG 
+ # LN_OPTS = /nologo /debug:full /debugtype:cv /fixed:no /profile
+ 
+ # release options
+ CC_OPTS = /nologo /O2ab2gitwy /G6AFs /DNDEBUG 
+ LN_OPTS = /nologo
+ 
+ GTK =
+ GTKLIBS =
+ SNDLIB =
+ LIBSNDFILE =
+ LIBS =
+ MAKEDEP =
+ TIMER_SWITCH =
+ BRHIST_SWITCH =
+ LIBTERMCAP =
+ 
+ CC_SWITCHES = $(CC_OPTS) $(DISTRIB) $(SNDLIB) $(GTK) \
+               /DBS_FORMAT=BINARY $(TIMER_SWITCH) $(BRHIST_SWITCH)
+ LN_SWITCHES = $(LN_OPTS)
+ 
+ c_sources = \
+  main.c \
+  brhist.c \
+  formatBitstream.c \
+  fft.c \
+  get_audio.c \
+  l3bitstream.c \
+         id3tag.c \
+  ieeefloat.c \
+         lame.c \
+         newmdct.c \
+  parse.c \
+  portableio.c \
+  psymodel.c \
+  quantize.c \
+  quantize-pvt.c \
+  vbrquantize.c \
+  loopold.c \
+  reservoir.c \
+  tables.c \
+  takehiro.c \
+  timestatus.c \
+  util.c \
+         VbrTag.c \
+         version.c \
+         gtkanal.c \
+         gpkplotting.c \
+         mpglib/common.c \
+         mpglib/dct64_i386.c \
+         mpglib/decode_i386.c \
+         mpglib/layer3.c \
+         mpglib/tabinit.c \
+         mpglib/interface.c \
+         mpglib/main.c 
+ 
+ OBJ = $(c_sources:.c=.obj)
+ 
+ .c.obj:
+  @$(CC) $(CC_SWITCHES) /c $< /Fo$@
+ 
+ $(PGM).exe: $(OBJ) Makefile.MSVC
+  @echo $(PGM).exe
+  @$(LN) $(LN_SWITCHES) $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) \
+    $(LIBTERMCAP) /out:$(PGM).exe /map:$(PGM).map
+ 
+ clean:
+  @-del *.obj
+  @-del dll\*.obj
+  @-del mpglib\*.obj
+ 
+ rebuild: clean $(PGM).exe
+ 
+ 
+ 
diff -r -c -N encoder/Makefile.in lame3.70/Makefile.in
*** encoder/Makefile.in	Wed Jan 22 02:43:12 1997
--- lame3.70/Makefile.in	Wed Dec 31 17:00:00 1969
***************
*** 1,68 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
- ##
- ## $Id: Makefile.in,v 1.2 1996/02/14 05:18:05 rowlands Exp $
- ##
- ## Makefile for encoder. Requies GNU make.
- ##
- ## $Log: Makefile.in,v $
- ## Revision 1.2  1996/02/14 05:18:05  rowlands
- ## Cleanups.
- ##
- ## Revision 1.1  1996/02/14 04:04:23  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ############################################################################
- 
- CC = gcc
- 
- c_sources = \
- 	common.c \
- 	encode.c \
- 	formatBitstream.c \
- 	huffman.c \
- 	ieeefloat.c \
- 	l3bitstream.c \
- 	l3psy.c \
- 	loop.c \
- 	mdct.c \
- 	musicin.c \
- 	portableio.c \
- 	psy.c \
- 	reservoir.c \
- 	subs.c \
- 	tonal.c
- 
- OBJ = $(c_sources:.c=.o)
- DEP = $(c_sources:.c=.d)
- 
- NINT_SWITCH = @NINTSW@
- 
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
- 
- PGM = encode
- 
- LIBS = @LIBS@ @MATHLIBS@
- 
- 
- %.o: %.c 
- 	$(CC) $(CC_SWITCHES) -c $< -o $@
- 
- %.d: %.c
- 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
- 
- 
- $(PGM):	$(OBJ) Makefile
- 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
- 
- clean:
- 	-rm $(OBJ) $(DEP)
- 
- tags: TAGS
- 
- TAGS: ${c_sources}
- 	etags -T ${c_sources}
- 
- -include $(DEP)
--- 0 ----
diff -r -c -N encoder/PRESETS.draft lame3.70/PRESETS.draft
*** encoder/PRESETS.draft	Wed Dec 31 17:00:00 1969
--- lame3.70/PRESETS.draft	Sat Jan  8 10:52:52 2000
***************
*** 0 ****
--- 1,45 ----
+ --
+ 
+  Phone  300 -  3400 hz, mono:
+          --highpass  0.300 
+          --lowpass   3.400 
+          --noshort        (preechoes are a minor issue)
+          --resample 16    (8 would be better, needs MPEG2.5)
+          -m m -b 16       (8 is a litle bit to low :( 
+ 
+  Tape    20 - 18000 hz, stereo:
+          --highpass  0.020
+          --lowpass  18.000
+          --resample 44.1
+          -m j -b 128
+ 
+  HIFI    20 - 20000 hz, stereo:
+          --highpass  0.020
+          --lowpass  20.000
+          --resample 44.1
+          -m j -b 160
+ 
+  CD       0 - 22050 hz, stereo: (full 44.1kHz frequency range)
+          -m s -b 192
+ 
+  Studio   0 - 24000 hz, stereo: (full 48kHz frequency range)
+          -m s -b 256
+ 
+ 
+ 
+ -- thanks to Ross Levis:
+ 
+  FM    30 - 15000 hz, stereo:
+          --lowpass 15.000
+          --lowpass-width 0 (sharp cut-off)
+ 	 --resample 32
+          -m j -b 128
+ 
+  HQvoice (interviews) 100 - 12000 hz, mono:
+            --lowpass  12.000
+            --highpass  0.100
+ 	   --resample 24
+            -m m -b 64
+ 
+ 
+ -- feel free to extend this list further --
diff -r -c -N encoder/README lame3.70/README
*** encoder/README	Wed Dec 31 17:00:00 1969
--- lame3.70/README	Thu Mar 30 01:24:20 2000
***************
*** 0 ****
--- 1,52 ----
+                       LAME 3.xx   
+                LAME Ain't an MP3 Encoder
+                http://www.sulaco.org/mp3
+ 	           October 1999
+ 
+ Originally developed by Mike Cheng (www.uq.net.au/~zzmcheng).  Now 
+ maintained by Mark Taylor (www.sulaco.org/mp3).
+ 
+ This is a patch against the ISO MPEG2 dist10 demonstration source.  The
+ modifications are distributed under the GNU LESSER PUBLIC LICENSE
+ (LGPL, see www.gnu.org) with the following modification:
+ 
+ 1. If you determine that distribution of LAME requires a patent license,
+    and you obtain a patent license, you may distribute LAME even though
+    redistribution of LAME may also require a patent license.  
+ 
+ 2. You agree not to enforce any patent claims for any aspect of
+    MPEG audio compression, or any other techniques contained in 
+    the LAME source code. 
+ 
+ 
+ ============================================================================
+ 
+ see the file "INSTALL" for installation (compiling) instructions.  
+ see the file "USAGE" for the most up-to-date guide to the command line options.
+ see the file "LICENSE" for details on how to use LAME in non-GPL programs.
+ see the file "HACKING" for some general codeing guidelines
+ 
+ There is HTML documentation and a man page in the doc directory.
+ The HTML docs were contributed by Gabriel Bouvigne (www.mp3tech.org).
+ See www.mp3tech.org for more audio compression information and links.
+ 
+ ============================================================================
+ 
+ The graphical frame analyzer uses the MPGLIB decoding engine, from the
+ MPG123 package, written by: Michael Hipp (www.mpg123.de) MPGLIB is
+ released under the GPL, while MPG123 is released under a more
+ restrictive agreement.
+ 
+ Various components of the patch are:
+ 
+ Copyrights (c) 1999 by Mark Taylor: new psy-model, quantization and bit allocation 
+ Copyrights (c) 1998 by Michael Cheng:  new transforms and many other improvements
+ Copyrights (c) 1995,1996,1997 by Michael Hipp: mpglib
+ 
+ 
+ The ISO demonstration source (distributed separately) has its own
+ patent, copyright and distribution issues.  The code is freely
+ available, but any commercial use (including distributing free
+ encoders) may require a patent license from Thomson Multimedia.  (see
+ http://www.iis.fhg.de/amm/legal/)
+ 
diff -r -c -N encoder/README.WINGTK lame3.70/README.WINGTK
*** encoder/README.WINGTK	Wed Dec 31 17:00:00 1969
--- lame3.70/README.WINGTK	Thu Mar 30 01:04:11 2000
***************
*** 0 ****
--- 1,42 ----
+ March 30, 2000
+ 
+ Release notes MP3X (the LAME frame analyzer) for WIN32
+ 
+ ===========================================================================
+ How to compile Lame with MP3x support:
+ 
+ You first need the proper GTK and GLIB include files and lib files. 
+ You can get them from the WINGTK project 
+ http://user.sgic.fi/~tml/gimp/win32/ 
+ (or see http://www.gtk.org, and click on the WINGTK link).
+ 
+ Download:  glib-dev-VERSION.zip, gtk+-dev-VERSION.zip, extralibs-dev-VERSION.zip
+ where VERSION = something like 20000201
+ 
+ unzip the files.  this will make a "src" directory. (for example, c:\gtk\src)
+ Then, in MSVC, under Tools->options->directories, add 
+ to the "include files" and "library files" settings:
+   c:\gtk\src\glib
+   c:\gtk\src\gtk+\glib
+   c:\gtk\src\gtk+
+ 
+ 
+ ===========================================================================
+ To run MP3x.exe, or lame.exe with MP3x support, you need
+ the GTK DLL files:  Either instal them on your system,
+ or put them in the same directory as lame.exe.
+ 
+ glib-1.3.dll
+ gdk-1.3.dll
+ gtk-1.3.dll
+ gmodule-1.3.dll
+ gnu-intl.dll
+ 
+ lame -g myfile
+ 
+ myfile can be a mp3 file, or a wav file.
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/TODO lame3.70/TODO
*** encoder/TODO	Wed Dec 31 17:00:00 1969
--- lame3.70/TODO	Sun Jan 30 03:50:36 2000
***************
*** 0 ****
--- 1,44 ----
+ 0.   ./configure script
+ 
+ things to check for:  
+ 
+    -llibsndfile      (allow user to enable)
+    -lncurses         
+    -lGTK             (allow user to disable)
+    make depend option for CC
+ 
+ 
+ 
+ 
+ 1. Modularization:
+ 
+ BladeEnc.dll was written before lame was 'modularized'
+ this should be cleaned up to look like main.c:  It should be possible
+ to write the BladeEnc/lame dll so that it just uses
+ #include "lame.h" and then calls to various lame_*() routines
+ 
+ 
+ 2.
+ Does stdin work when LAME is compiled to use libsndfile? 
+ (new version of libsndfile will support this - try this out)
+ 
+ 3.
+ LAME uses a linear downsampling with simple lowpass filter
+ on the MDCT/polyphase coefficients.  Is this good enough, or
+ would a more expensive filter give better results?
+ 
+ 4.
+ make use of subblock_gain (crude algorithm enabled with -Z) 
+    One method:  loop over all possible subblock_gains and
+    see which combination gives best distortion?  But this puts a lot
+    of faith in the short block psycho acoustics
+ 
+ 5.
+ make use of scalefactor_select  (crude algorithm enabled with -Y)
+ 
+ 6.
+ 10Hz high-pass filter.  Probably wont help much.
+ 
+ 
+ 
+ 
diff -r -c -N encoder/USAGE lame3.70/USAGE
*** encoder/USAGE	Wed Dec 31 17:00:00 1969
--- lame3.70/USAGE	Tue Mar 21 19:03:03 2000
***************
*** 0 ****
--- 1,539 ----
+ 
+ % lame [options] inputfile [outputfile]
+ 
+ =======================================================================
+ Examples:
+ =======================================================================
+ fixed bit rate jstereo 128kbs encoding:
+ % lame sample.wav  sample.mp3      
+ 
+ fixed bit rate jstereo 128kbs encoding, highest quality:  (recommended)
+ % lame -h sample.wav  sample.mp3      
+ 
+ To disable joint stereo encoding (slightly faster, but less quality at bitrates<=128kbs)
+ % lame -m s sample.wav  sample.mp3     
+ 
+ Fast encode, low quality  (no psycho-acoustics)
+ % lame -f sample.wav  sample.mp3     
+ 
+ Variable Bitrate (VBR): (use -V n to adjust quality/filesize)
+ % lame -h -v sample.wav sample.mp3
+ 
+ Note: VBR is currently under heavy development.  Right now it can
+ often result in too much compression.  I would recommend using VBR
+ with a minimum bitrate of 112kbs.  This will let LAME increase
+ the bitrate for difficult-to-encode frames, but prevent LAME from
+ being too aggressive for simple frames:
+ 
+ % lame -h -v -b 112  sample.wav sample.mp3
+ 
+ 
+ =======================================================================
+ LOW BITRATES
+ =======================================================================
+ At lower bitrates, (like 24kbs per channel), it is recommended that
+ you use a 16kHz sampling rate combined with lowpass filtering.  LAME,
+ as well as commercial encoders (FhG, Xing) will do this automatically.
+ However, if you feel there is too much (or not enough) lowpass
+ filtering, you may need to try different values of the lowpass cutoff
+ and passband width (--lowpass and --lowpass-width options).
+ 
+ 
+ 
+ 
+ =======================================================================
+ STREAMING EXAMPLES
+ =======================================================================
+ Streaming mono 22.05kHz raw pcm, 24kbs output:
+ % cat inputfile | lame -r -m m -b 24 -s 22.05 - - > output
+ 
+ Streaming mono 22.05kHz raw pcm, with downsampling to 16kHz:
+ % cat inputfile | sox -t raw -x -w -s -c 1 -r 22050 -  -t raw -x -w -s -c 1 -r 16000 - resample 0.66 | lame -r -m m -b 24 -s 16 - - > output
+ 
+ You may or may not need one or both of the "-x" (swap bytes) option in Sox.  
+ 
+ 
+ 
+ 
+ =======================================================================
+ 
+ For more options, just type:
+ % lame --help
+ 
+ Scripts are included to run lame on multiple files:
+ 
+ bach script:  mlame     Run "mlame -h" for instructions.
+ sh script:    auenc     Run auenc for instructions
+ 
+ 
+ 
+ =======================================================================
+ options guide:
+ =======================================================================
+ These options are explained in detail below.
+ 
+ 
+ Quality related:
+ 
+ -m m/s/j/f     mode selection
+ -k             disable all filtering
+ -d             allow block types to differ between channels
+ --athonly      ignore psy-model output, only use masking from the ATH
+ --voice        experimental voice encoding mode
+ --noshort      disable short blocks
+ 
+ 
+ Constant Bit Rate (CBR)
+ -b  n          set bitrate (8,16,24,...,320)
+ -h             higher quality but slower
+ -f             disable psycho-acoustics.  Encoding much faster but lower quality
+ 
+ 
+ Variable Bit Rate (VBR)
+ -v             VBR
+ -V n           VBR quality setting  (0=highest quality, 9=lowest)
+ -b  n          specify a minimum allowed bitrate (8,16,24,...,320)
+ -B  n          specify a maximum allowed bitrate (8,16,24,...,320)
+ -t             disable Xing VBR informational tag 
+ --nohist       disable display of VBR bitrate histogram
+ 
+ 
+ Experimental (undocumented):  may work better or worse:
+ 
+ -X n           try different quality measures (when comparing quantizations)
+ -Y             try to use scalefac_select 
+ -Z             try to use subblock_gain
+ 
+ 
+ Operational:
+ 
+ -r             assume input file is raw PCM
+ -s  n          input sampling frequency in kHz (for raw PCM input files)
+ --resample n   output sampling frequency
+ --mp3input     input file is an MP3 file.  decode using mpglib/mpg123
+ -x             swap bytes of input file
+ -a             downmix stereo input file to mono .mp3
+ -e  n/5/c      de-emphasis
+ -p             add CRC error protection
+ -c             mark the encoded file as copyrighted
+ -o             mark the encoded file as a copy
+ -S             don't print progress report, VBR histogram
+ -g             run MP3x, the graphical frame analyzer
+ 
+ 
+ id3 tagging:
+ 
+ --tt "title"     title of song (max 30 chars)
+ --ta "artist"    artist who did the song (max 30 chars)
+ --tl "album"     album where it came from (max 30 chars)
+ --ty "year"      year in which the song/album was made (max 4 chars)
+ --tc "comment"   additional info (max 30 chars)
+ --tg "genre"     genre of song (name or number)
+ 
+ 
+ 
+ options not yet described:
+ --nores            disable bit reservoir
+ --noath            disable ATH
+ --cwlimit <freq>   specify range of tonality calculation
+ 
+ --lowpass
+ --lowpass-width
+ --highpass
+ --highpass-width
+ 
+ 
+ 
+ 
+ 
+ =======================================================================
+ Detailed description of all options in alphabetical order
+ =======================================================================
+ 
+ 
+ =======================================================================
+ downmix
+ =======================================================================
+ -a  
+ 
+ mix the stereo input file to mono and encode as mono.  
+ 
+ This option is only needed in the case of raw PCM stereo input 
+ (because LAME cannot determine the number of channels in the input file).
+ To encode a stereo PCM input file as mono, use "lame -m s -a"
+ 
+ For WAV and AIFF input files, using "-m m" will always produce a
+ mono .mp3 file from both mono and stereo input.
+ 
+ =======================================================================
+ ATH only
+ =======================================================================
+ --athonly
+ 
+ This option causes LAME to ignore the output of the psy-model and
+ only use masking from the ATH.  Might be useful at very high bitrates
+ or for testing the ATH.  
+ 
+ 
+ 
+ 
+ =======================================================================
+ bitrate
+ =======================================================================
+ -b  n
+ 
+ For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)
+ n =   32,40,48,56,64,80,96,112,128,160,192,224,256,320
+ 
+ For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)
+ n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160
+ 
+ 
+ The bitrate to be used.  Default is 128kbs MPEG1, 80kbs MPEG2.
+ 
+ When used with variable bitrate encodings (VBR), -b specifies the
+ minimum bitrate to use.  This is useful to prevent LAME VBR from
+ using some very aggressive compression which can cause some distortion
+ due to small flaws in the psycho-acoustic model.
+ 
+ =======================================================================
+ max bitrate
+ =======================================================================
+ -B  n
+ 
+ For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)
+ n =   32,40,48,56,64,80,96,112,128,160,192,224,256,320
+ 
+ For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)
+ n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160
+ 
+ Maximum allowed bitrate when using VBR.
+ 
+ 
+ =======================================================================
+ copyright
+ =======================================================================
+ -c   
+ 
+ mark the encoded file as copyrighted
+ 
+ 
+ 
+ =======================================================================
+ block type control
+ =======================================================================
+ -d 
+ 
+ Allows the left and right channels to use different block types.
+ Normally this is not allowed, only because the FhG encoder does
+ not seem to allow it either.  If anyone finds a sample where -d
+ produces better results, let me know.  (mt@sulaco.org)
+ 
+ 
+ 
+ =======================================================================
+ de-emphasis
+ =======================================================================
+ -e  n/5/c   
+ 
+   n = (none, default)
+   5 = 0/15 microseconds
+   c = citt j.17
+ 
+ All this does is set a flag in the bitstream.  If you have a PCM
+ input file where one of the above types of (obsolete) emphasis has
+ been applied, you can set this flag in LAME.  Then the mp3 decoder
+ should de-emphasize the output during playback, although most 
+ decoders ignore this flag.
+ 
+ A better solution would be to apply the de-emphasis with a standalone
+ utility before encoding, and then encode without -e.  
+ 
+ 
+ 
+ =======================================================================
+ fast mode
+ =======================================================================
+ -f   
+ 
+ disable psycho-acoustics.  Encoding much faster but lower quality
+ 
+ 
+ 
+ =======================================================================
+ graphical frame analyzer
+ =======================================================================
+ -g
+ 
+ run MP3x, the graphical frame analyzer analysis on the inputfile.  The
+ inputfile can be either an .mp3 file or uncompressed audio file.  MP3x
+ support must be compiled into LAME, and requires GTK 1.2.
+ Documentation is under the About pull down menu.
+ 
+ 
+ 
+ =======================================================================
+ high quality
+ =======================================================================
+ -h
+ 
+ use (maybe) some quality improvements
+ 
+ LAME 3.21 and up:  -h enables specialized mid/side masking thresholds to
+ be used in jstereo mode.  Will sound better in jstereo mode
+ but is 20% slower.  No effect for mono files.
+ 
+ LAME 3.58beta and up: -h also enables a more accurate but slightly
+ slower quantization formula.  
+ 
+ 
+ 
+ =======================================================================
+ sfb=21 cutoff
+ =======================================================================
+ -k   
+ 
+ keep all frequencies.  (Disable all filters)
+ 
+ Without -k, LAME will automatically apply various types of lowpass
+ filters.  This is because the high frequency coefficients can take up
+ a lot of bits that would be better used for lower, more important
+ frequencies.
+ 
+ 
+ 
+ 
+ =======================================================================
+ Modes:
+ =======================================================================
+ 
+ -m m           mono.  
+ -m s           stereo
+ -m j           jstereo
+ -m f           forced mid/side stereo
+ 
+ mono is the default mode for mono input files.  If "-m m" is specified
+ for a stereo input file, the two channels will be averaged into a mono
+ signal.  
+ 
+ jstereo is the default mode for stereo files with fixed bitrates of
+ 128kbs or less.  At higher fixed bitrates, the default is stereo.
+ For VBR encoding, jstereo is the default for VBR_q >4, and stereo
+ is the default for VBR_q <=4.  You can override all of these defaults
+ by specifing the mode on the command line.  
+ 
+ jstereo means the encoder can use (on a frame by frame bases) either
+ regular stereo (just encode left and right channels independently)
+ or mid/side stereo.  In mid/side stereo, the mid (L+R) and side (L-R)
+ channels are encoded, and more bits are allocated to the mid channel
+ than the side channel.  This will effectively increase the bandwidth
+ if the signal does not have too much stereo separation.  
+ 
+ Mid/side stereo is basically a trick to increase bandwidth.  At 128kbs,
+ it is clearly worth while.  At higher bitrates it is less usefull.  
+ 
+ Using mid/side stereo inappropriately can result in audible
+ compression artifacts.  To much switching between mid/side and regular
+ stereo can also sound bad.  To determine when to switch to mid/side
+ stereo, LAME uses a much more sophisticated algorithm than that
+ described in the ISO documentation.
+ 
+ -m f forces all frames to be encoded mid/side stereo.  It 
+ should only be used if you are sure every frame of the input file
+ has very little stereo seperation.  
+ 
+ 
+ 
+ =======================================================================
+ MP3 input file
+ =======================================================================
+ --mp3input
+ 
+ Assume the input file is a MP3 file.  Usefull for downsampling from
+ one mp3 to another.  If the filename ends in ".mp3" LAME will assume
+ it is an MP3.  For stdin or MP3 files which dont end in .mp3 you need
+ to use this switch.
+ 
+ 
+ =======================================================================
+ disable historgram display
+ =======================================================================
+ --nohist
+ 
+ By default, LAME will display a bitrate histogram while producing
+ VBR mp3 files.  This will disable that feature.
+ 
+ 
+ =======================================================================
+ disable short blocks
+ =======================================================================
+ --noshort
+ 
+ Encode all frames using long blocks.
+ 
+ 
+ 
+ =======================================================================
+ non-original
+ =======================================================================
+ -o   
+ 
+ mark the encoded file as a copy
+ 
+ 
+ =======================================================================
+ CRC error protection
+ =======================================================================
+ -p  
+ 
+ turn on CRC error protection.  
+ Yes this really does work correctly in LAME.  However, it takes 
+ 16 bits per frame that would otherwise be used for encoding.
+ 
+ 
+ 
+ =======================================================================
+ input file is raw pcm
+ =======================================================================
+ -r  
+ 
+ Assume the input file is raw pcm.  Sampling rate and mono/stereo/jstereo
+ must be specified on the command line.  Without -r, LAME will perform
+ several fseek()'s on the input file looking for WAV and AIFF headers.
+ 
+ Not supported if LAME is compiled to use LIBSNDFILE.
+ 
+ 
+ 
+ =======================================================================
+ output sampling frequency in kHZ
+ =======================================================================
+ --resample  n
+ 
+ where n = 16, 22.05, 24, 32, 44.1, 48
+ 
+ Output sampling frequency.  Resample the input if necessary.  
+ 
+ If not specified, LAME may sometimes resample automatically 
+ when faced with extreme compression conditions (like encoding
+ a 44.1khz input file at 16kbs).  
+ 
+ 
+ 
+ =======================================================================
+ sampling frequency in kHZ
+ =======================================================================
+ -s  n
+ 
+ where n = sampling rate in kHz.
+ 
+ Required for raw PCM input files.  Otherwise it will be determined
+ from the header information in the input file.
+ 
+ LAME will automatically resample the input file to one of the
+ supported MP3 samplerates if necessary.
+ 
+ 
+ =======================================================================
+ silent operation
+ =======================================================================
+ -S
+ 
+ don't print progress report
+ 
+ 
+ 
+ =======================================================================
+ disable Xing VBR tag
+ =======================================================================
+ -t              
+ 
+ Disable writing of the Xing VBR Tag (only valid if -v flag is
+ specified) This tag in embedded in frame 0 of the MP3 file.  It lets
+ VBR aware players correctly seek and compute playing times of VBR
+ files.
+ 
+ 
+ 
+ =======================================================================
+ variable bit rate  (VBR)
+ =======================================================================
+ -v
+ 
+ Turn on VBR.  There are several ways you can use VBR.  I personally
+ like using VBR to get files slightly bigger than 128kbs files, where
+ the extra bits are used for the occasional difficult-to-encode frame.
+ For this, try specifying a minimum bitrate to use with VBR:
+ 
+ lame -v -b 112  input.wav output.mp3
+ 
+ If the file is too big, use -V n, where n=0..9
+ 
+ lame -v -V n   -b 112  input.wav output.mp3
+ 
+ 
+ If you wan to use VBR to get the maximum compression possible,
+ and for this, you can try:  
+ 
+ lame -v  input.wav output.mp3
+ lame -v -V n input.wav output.mp3         (to very quality/filesize)
+ 
+ 
+ 
+ 
+ =======================================================================
+ VBR quality setting
+ =======================================================================
+ -V n       
+ 
+ n=0..9.  Specifies the value of VBR_q.  default=4.  0=highest quality.
+ 
+ 
+ 
+ How is VBR_q used?
+ 
+ OVER = number of scalefactor bands with distortion that exceeds the
+ allowed distortion given by the masking thresholds.  OVER is computed
+ by outer_loop, and the masking thresholds are computed by the
+ psycho-acoustic model. 
+ 
+ VBR_q = the minimum value of OVER which is to be allowed.
+ LAME will choose the smallest bitrate for which OVER <= VBR_q.  
+ (a minimum allowed bitrate can be set with -b.  default=64kbs)
+ 
+ If the frame contains short blocks, then the minimum bitrate is made
+ much larger since the OVER does not adequately measure distortion
+ caused by pre-echo.  LAME uses bitrates of at least 160kbs for short
+ blocks to make sure they sound good.
+ 
+ *NOTE* No psy-model is perfect, so there can often be distortion which
+ is audible even though the psy-model claims it is not!  Thus using a
+ small minimum bitrate can result in some aggressive compression and
+ audible distortion even with -V 0.  Thus using -V 0 does not sound
+ better than a fixed 256kbs encoding.  For example: suppose in the 1kHz
+ frequency band the psy-model claims 20db of distortion will not be
+ detectable by the human ear, so LAME VBR-0 will compress that
+ frequency band as much as possible and introduce at most 20db of
+ distortion.  Using a fixed 256kbit framesize, LAME could end up
+ introducing only 2db of distortion.  If the psy-model was correct,
+ they will both sound the same.  If the psy-model was wrong, the VBR-0
+ result can sound worse.
+ 
+ 
+ =======================================================================
+ voice encoding mode
+ =======================================================================
+ --voice
+ 
+ An experimental voice encoding mode.  Tuned for 44.1kHz input files.
+ 
+ 
+ =======================================================================
+ swapbytes   
+ =======================================================================
+ -x
+ 
+ swap bytes in the input file.  for sorting out little endian/big endian
+ type problems.  If your encodings sound like static, try this first.
+ 
+ 
diff -r -c -N encoder/VbrTag.c lame3.70/VbrTag.c
*** encoder/VbrTag.c	Wed Dec 31 17:00:00 1969
--- lame3.70/VbrTag.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,494 ----
+ /*
+  *	Xing VBR tagging for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ #include "machine.h"
+ #include <math.h>
+ #include "VbrTag.h"
+ #include "version.h"
+ 
+ #ifdef _DEBUG
+ /*  #define DEBUG_VBRTAG */
+ #endif
+ 
+ 
+ int SizeOfEmptyFrame[2][2]=
+ {
+ 	{32,17},
+ 	{17,9},
+ };
+ 
+ static u_char pbtStreamBuffer[216];   
+ static long g_Position[NUMTOCENTRIES];
+ static int nZeroStreamSize=0;
+ static int TotalFrameSize=0;
+ static char	VBRTag[]={"Xing"};
+ 
+ 
+ int* pVbrFrames=NULL;
+ int nVbrNumFrames=0;
+ int nVbrFrameBufferSize=0;
+ 
+ /****************************************************************************
+  * AddVbrFrame: Add VBR entry, used to fill the VBR the TOC entries
+  * Paramters:
+  *	nStreamPos: how many bytes did we write to the bitstream so far
+  *				(in Bytes NOT Bits)
+  ****************************************************************************
+ */
+ void AddVbrFrame(int nStreamPos)
+ {
+         /* Simple exponential growing buffer */
+ 	if (pVbrFrames==NULL || nVbrFrameBufferSize==0)
+ 	{
+                 /* Start with 100 frames */
+ 		nVbrFrameBufferSize=100;
+ 
+ 		/* Allocate them */
+ 		pVbrFrames=(int*)malloc((size_t)(nVbrFrameBufferSize*sizeof(int)));
+ 	}
+ 
+ 	/* Is buffer big enough to store this new frame */
+ 	if (nVbrNumFrames==nVbrFrameBufferSize)
+ 	{
+                 /* Guess not, double th e buffer size */
+ 		nVbrFrameBufferSize*=2;
+ 
+ 		/* Allocate new buffer */
+ 		pVbrFrames=(int*)realloc(pVbrFrames,(size_t)(nVbrFrameBufferSize*sizeof(int)));
+ 	}
+ 
+ 	/* Store values */
+ 	pVbrFrames[nVbrNumFrames++]=nStreamPos;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ static int ExtractI4(unsigned char *buf)
+ {
+ 	int x;
+ 	/* big endian extract */
+ 	x = buf[0];
+ 	x <<= 8;
+ 	x |= buf[1];
+ 	x <<= 8;
+ 	x |= buf[2];
+ 	x <<= 8;
+ 	x |= buf[3];
+ 	return x;
+ }
+ 
+ void CreateI4(unsigned char *buf, int nValue)
+ {
+         /* big endian create */
+ 	buf[0]=(nValue>>24)&0xff;
+ 	buf[1]=(nValue>>16)&0xff;
+ 	buf[2]=(nValue>> 8)&0xff;
+ 	buf[3]=(nValue    )&0xff;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ /* Same as GetVbrTag below, but only checks for the Xing tag.
+    requires buf to contain only 40 bytes */
+ /*-------------------------------------------------------------*/
+ int CheckVbrTag(unsigned char *buf)
+ {
+ 	int			h_id, h_mode, h_sr_index;
+ 
+ 	/* get selected MPEG header data */
+ 	h_id       = (buf[1] >> 3) & 1;
+ 	h_sr_index = (buf[2] >> 2) & 3;
+ 	h_mode     = (buf[3] >> 6) & 3;
+ 
+ 	/*  determine offset of header */
+ 	if( h_id ) 
+ 	{
+                 /* mpeg1 */
+ 		if( h_mode != 3 )	buf+=(32+4);
+ 		else				buf+=(17+4);
+ 	}
+ 	else
+ 	{
+                 /* mpeg2 */
+ 		if( h_mode != 3 ) buf+=(17+4);
+ 		else              buf+=(9+4);
+ 	}
+ 
+ 	if( buf[0] != VBRTag[0] ) return 0;    /* fail */
+ 	if( buf[1] != VBRTag[1] ) return 0;    /* header not found*/
+ 	if( buf[2] != VBRTag[2] ) return 0;
+ 	if( buf[3] != VBRTag[3] ) return 0;
+ 	return 1;
+ }
+ 
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf)
+ {
+ 	int			i, head_flags;
+ 	int			h_id, h_mode, h_sr_index;
+ 	static int	sr_table[4] = { 44100, 48000, 32000, 99999 };
+ 
+ 	/* get Vbr header data */
+ 	pTagData->flags = 0;     
+ 
+ 	/* get selected MPEG header data */
+ 	h_id       = (buf[1] >> 3) & 1;
+ 	h_sr_index = (buf[2] >> 2) & 3;
+ 	h_mode     = (buf[3] >> 6) & 3;
+ 
+ 	/*  determine offset of header */
+ 	if( h_id ) 
+ 	{
+                 /* mpeg1 */
+ 		if( h_mode != 3 )	buf+=(32+4);
+ 		else				buf+=(17+4);
+ 	}
+ 	else
+ 	{
+                 /* mpeg2 */
+ 		if( h_mode != 3 ) buf+=(17+4);
+ 		else              buf+=(9+4);
+ 	}
+ 
+ 	if( buf[0] != VBRTag[0] ) return 0;    /* fail */
+ 	if( buf[1] != VBRTag[1] ) return 0;    /* header not found*/
+ 	if( buf[2] != VBRTag[2] ) return 0;
+ 	if( buf[3] != VBRTag[3] ) return 0;
+ 
+ 	buf+=4;
+ 
+ 	pTagData->h_id = h_id;
+ 
+ 	pTagData->samprate = sr_table[h_sr_index];
+ 
+ 	if( h_id == 0 )
+ 		pTagData->samprate >>= 1;
+ 
+ 	head_flags = pTagData->flags = ExtractI4(buf); buf+=4;      /* get flags */
+ 
+ 	if( head_flags & FRAMES_FLAG )
+ 	{
+ 		pTagData->frames   = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & BYTES_FLAG )
+ 	{
+ 		pTagData->bytes = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & TOC_FLAG )
+ 	{
+ 		if( pTagData->toc != NULL )
+ 		{
+ 			for(i=0;i<NUMTOCENTRIES;i++)
+ 				pTagData->toc[i] = buf[i];
+ 		}
+ 		buf+=NUMTOCENTRIES;
+ 	}
+ 
+ 	pTagData->vbr_scale = -1;
+ 
+ 	if( head_flags & VBR_SCALE_FLAG )
+ 	{
+ 		pTagData->vbr_scale = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ #ifdef DEBUG_VBRTAG
+ 	printf("\n\n********************* VBR TAG INFO *****************\n");
+ 	printf("tag         :%s\n",VBRTag);
+ 	printf("head_flags  :%d\n",head_flags);
+ 	printf("bytes       :%d\n",pTagData->bytes);
+ 	printf("frames      :%d\n",pTagData->frames);
+ 	printf("VBR Scale   :%d\n",pTagData->vbr_scale);
+ 	printf("toc:\n");
+ 	if( pTagData->toc != NULL )
+ 	{
+ 		for(i=0;i<NUMTOCENTRIES;i++)
+ 		{
+ 			if( (i%10) == 0 ) printf("\n");
+ 			printf(" %3d", (int)(pTagData->toc[i]));
+ 		}
+ 	}
+ 	printf("\n***************** END OF VBR TAG INFO ***************\n");
+ #endif
+ 	return 1;       /* success */
+ }
+ 
+ 
+ /****************************************************************************
+  * InitVbrTag: Initializes the header, and write empty frame to stream
+  * Paramters:
+  *				fpStream: pointer to output file stream
+  *				nVersion: 0= MPEG1 1=MPEG2
+  *				nMode	: Channel Mode: 0=STEREO 1=JS 2=DS 3=MONO
+  ****************************************************************************
+ */
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion, int nMode, int SampIndex)
+ {
+ 	int i;
+ 
+ 	/* Clear Frame position array variables */
+ 	pVbrFrames=NULL;
+ 	nVbrNumFrames=0;
+ 	nVbrFrameBufferSize=0;
+ 
+ 	/* Clear struct */
+ 	memset(g_Position,0x00,sizeof(g_Position));
+ 
+ 	/* Clear stream buffer */
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	/* Set TOC values to 255 */
+ 	for (i=0;i<NUMTOCENTRIES;i++)
+ 	{
+ 		g_Position[i]=-1;
+ 	}
+ 
+ 
+ 
+ 	/* Reserve the proper amount of bytes */
+ 	if (nMode==3)
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][1]+4;
+ 	}
+ 	else
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][0]+4;
+ 	}
+ 
+ 	/*
+ 	// Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).
+         // (at 48kHz they use 56kbs since 48kbs frame not big enough for 
+         // table of contents)
+ 	// let's always embed Xing header inside a 64kbs layer III frame.  
+ 	// this gives us enough room for a LAME version string too.
+ 	// size determined by sampling frequency (MPEG1)
+ 	// 32kHz:    216 bytes@48kbs    288bytes@ 64kbs    
+ 	// 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)
+ 	// 48kHz:    144 bytes          192
+ 	// 
+ 	// MPEG 2 values are the since the framesize and samplerate
+         // are each reduced by a factor of 2.
+ 	*/
+ 	{
+ 	int tot;
+ 	static const int framesize[3]={208,192,288};  /* 64kbs MPEG1 or MPEG2  framesize */
+ 	/* static int framesize[3]={156,144,216}; */ /* 48kbs framesize */
+ 	
+ 	if (SampIndex>2) {
+ 	  fprintf(stderr,"illegal sampling frequency index\n");
+ 	  exit(-1);
+ 	}
+ 	TotalFrameSize= framesize[SampIndex];
+ 	tot = (nZeroStreamSize+VBRHEADERSIZE);
+ 	tot += 20;  /* extra 20 bytes for LAME & version string */
+ 	
+ 	if (TotalFrameSize < tot ) {
+ 	  fprintf(stderr,"Xing VBR header problem...use -t\n");
+ 	  exit(-1);
+ 	}
+ 	}
+ 
+ 
+ 	/* Put empty bytes into the bitstream */
+ 	for (i=0;i<TotalFrameSize;i++)
+ 	{
+                 /* Write a byte to the bitstream */
+ 		putbits(pBs,0,8);
+ 	}
+ 
+ 	/* Success */
+ 	return 0;
+ }
+ 
+ 
+ 
+ /****************************************************************************
+  * PutVbrTag: Write final VBR tag to the file
+  * Paramters:
+  *				lpszFileName: filename of MP3 bit stream
+  *				nVersion: 0= MPEG1 1=MPEG2
+  *				nVbrScale	: encoder quality indicator (0..100)
+  ****************************************************************************
+ */
+ int PutVbrTag(char* lpszFileName,int nVbrScale,int nVersion)
+ {
+ 	int			i;
+ 	long lFileSize;
+ 	int nStreamIndex;
+ 	char abyte;
+ 	u_char		btToc[NUMTOCENTRIES];
+ 	FILE *fpStream;
+ 	char str1[80];
+ 
+ 
+ 	if (nVbrNumFrames==0 || pVbrFrames==NULL)
+ 		return -1;
+ 
+ 	/* Open the bitstream again */
+ 	fpStream=fopen(lpszFileName,"rb+");
+ 
+ 	/* Assert stream is valid */
+ 	if (fpStream==NULL)
+ 		return -1;
+ 
+ 	/* Clear stream buffer */
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	/* Seek to end of file*/
+ 	fseek(fpStream,0,SEEK_END);
+ 
+ 	/* Get file size */
+ 	lFileSize=ftell(fpStream);
+ 	
+ 	/* Abort if file has zero length. Yes, it can happen :) */
+ 	if (lFileSize==0)
+ 		return -1;
+ 
+ 	/* Seek to first real frame */
+ 	fseek(fpStream,(long)TotalFrameSize,SEEK_SET);
+ 
+ 	/* Read the header (first valid frame) */
+ 	fread(pbtStreamBuffer,4,1,fpStream);
+ 
+ 	/* the default VBR header.  48kbs layer III, no padding, no crc */
+ 	/* but sampling freq, mode andy copyright/copy protection taken */
+ 	/* from first valid frame */
+ 	pbtStreamBuffer[0]=(u_char) 0xff;    
+ 	if (nVersion==0) {
+ 	  pbtStreamBuffer[1]=(u_char) 0xfb;    
+ 	  abyte = pbtStreamBuffer[2] & (char) 0x0c;   
+ 	  pbtStreamBuffer[2]=(char) 0x50 | abyte;     /* 64kbs MPEG1 frame */
+ 	}else{
+ 	  pbtStreamBuffer[1]=(u_char) 0xf3;    
+ 	  abyte = pbtStreamBuffer[2] & (char) 0x0c;   
+ 	  pbtStreamBuffer[2]=(char) 0x80 | abyte;     /* 64kbs MPEG2 frame */
+ 	}
+ 
+ 
+ 	/*Seek to the beginning of the stream */
+ 	fseek(fpStream,0,SEEK_SET);
+ 
+ 	/* Clear all TOC entries */
+ 	memset(btToc,0,sizeof(btToc));
+ 
+         for (i=1;i<NUMTOCENTRIES;i++) /* Don't touch zero point... */
+         {
+                 /* Calculate frame from given percentage */
+                 int frameNum=(int)(floor(0.01*i*nVbrNumFrames));
+ 
+                 /*  Calculate relative file postion, normalized to 0..256!(?) */
+                 float fRelStreamPos=(float)256.0*(float)pVbrFrames[frameNum]/(float)lFileSize;
+ 
+                 /* Just to be safe */
+                 if (fRelStreamPos>255) fRelStreamPos=255;
+ 
+                 /* Assign toc entry value */
+                 btToc[i]=(u_char) fRelStreamPos;
+         }
+ 
+ 
+ 
+ 	/* Start writing the tag after the zero frame */
+ 	nStreamIndex=nZeroStreamSize;
+ 
+ 	/* Put Vbr tag */
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[0];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[1];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[2];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[3];
+ 
+ 	/* Put header flags */
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],FRAMES_FLAG+BYTES_FLAG+TOC_FLAG+VBR_SCALE_FLAG);
+ 	nStreamIndex+=4;
+ 
+ 	/* Put Total Number of frames */
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrNumFrames);
+ 	nStreamIndex+=4;
+ 
+ 	/* Put Total file size */
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],(int)lFileSize);
+ 	nStreamIndex+=4;
+ 
+ 	/* Put TOC */
+ 	memcpy(&pbtStreamBuffer[nStreamIndex],btToc,sizeof(btToc));
+ 	nStreamIndex+=sizeof(btToc);
+ 
+ 	/* Put VBR SCALE */
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrScale);
+ 	nStreamIndex+=4;
+ 
+ 	/* Put LAME id */
+ 	sprintf(str1,"LAME%s",get_lame_version());
+ 	strncpy((char *)&pbtStreamBuffer[nStreamIndex],str1,(size_t) 20);
+ 	nStreamIndex+=20;
+ 
+ 
+ #ifdef DEBUG_VBRTAG
+ {
+ 	VBRTAGDATA TestHeader;
+ 	GetVbrTag(&TestHeader,pbtStreamBuffer);
+ }
+ #endif
+ 
+         /* Put it all to disk again */
+ 	if (fwrite(pbtStreamBuffer,TotalFrameSize,1,fpStream)!=1)
+ 	{
+ 		return -1;
+ 	}
+ 	fclose(fpStream);
+ 
+ 	/* Save to delete the frame buffer */
+ 	free(pVbrFrames);
+ 	pVbrFrames=NULL;
+ 
+ 	return 0;       /* success */
+ }
+ 
+ /*-------------------------------------------------------------*/
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent)
+ {
+ /* interpolate in TOC to get file seek point in bytes */
+ int a, seekpoint;
+ float fa, fb, fx;
+ 
+ 
+ if( percent < (float)0.0 )   percent = (float)0.0;
+ if( percent > (float)100.0 ) percent = (float)100.0;
+ 
+ a = (int)percent;
+ if( a > 99 ) a = 99;
+ fa = TOC[a];
+ if( a < 99 ) {
+     fb = TOC[a+1];
+ }
+ else {
+     fb = (float)256.0;
+ }
+ 
+ 
+ fx = fa + (fb-fa)*(percent-a);
+ 
+ seekpoint = (int)(((float)(1.0/256.0))*fx*file_bytes); 
+ 
+ 
+ return seekpoint;
+ }
+ /*-------------------------------------------------------------*/
diff -r -c -N encoder/VbrTag.h lame3.70/VbrTag.h
*** encoder/VbrTag.h	Wed Dec 31 17:00:00 1969
--- lame3.70/VbrTag.h	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,86 ----
+ /*
+  *	Xing VBR tagging for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ #ifndef VRBTAG_H_INCLUDED
+ #define VRBTAG_H_INCLUDED
+ 
+ /* -----------------------------------------------------------
+  * A Vbr header may be present in the ancillary
+  * data field of the first frame of an mp3 bitstream
+  * The Vbr header (optionally) contains
+  *      frames      total number of audio frames in the bitstream
+  *      bytes       total number of bytes in the bitstream
+  *      toc         table of contents
+ 
+  * toc (table of contents) gives seek points
+  * for random access
+  * the ith entry determines the seek point for
+  * i-percent duration
+  * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes
+  * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes
+  */
+ 
+ #include "l3bitstream.h"
+ 
+ #define FRAMES_FLAG     0x0001
+ #define BYTES_FLAG      0x0002
+ #define TOC_FLAG        0x0004
+ #define VBR_SCALE_FLAG  0x0008
+ 
+ #define NUMTOCENTRIES 100
+ 
+ #define FRAMES_AND_BYTES (FRAMES_FLAG | BYTES_FLAG)
+ 
+ /*structure to receive extracted header */
+ /* toc may be NULL*/
+ typedef struct
+ {
+   int		h_id;			/* from MPEG header, 0=MPEG2, 1=MPEG1 */
+   int		samprate;		/* determined from MPEG header */
+   int		flags;			/* from Vbr header data */
+   int		frames;			/* total bit stream frames from Vbr header data */
+   int		bytes;			/* total bit stream bytes from Vbr header data*/
+   int		vbr_scale;		/* encoded vbr scale from Vbr header data*/
+   u_char	toc[NUMTOCENTRIES];	/* may be NULL if toc not desired*/
+ }   VBRTAGDATA;
+ /*
+ //    4 bytes for Header Tag
+ //    4 bytes for Header Flags
+ //  100 bytes for entry (NUMTOCENTRIES)
+ //    4 bytes for FRAME SIZE
+ //    4 bytes for STREAM_SIZE
+ //    4 bytes for VBR SCALE. a VBR quality indicator: 0=best 100=worst
+ //   20 bytes for LAME tag.  for example, "LAME3.12 (beta 6)"
+ // ___________
+ //  140 bytes
+ */
+ 
+ #define VBRHEADERSIZE (NUMTOCENTRIES+4+4+4+4+4)
+ 
+ int CheckVbrTag(unsigned char *buf);
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf);
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent);
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion,int nMode, int SampIndex);
+ int PutVbrTag(char* lpszFileName,int nVbrScale,int nVersion);
+ void AddVbrFrame(int nStreamPos);
+ 
+ 
+ #endif
diff -r -c -N encoder/amiga_mpega.c lame3.70/amiga_mpega.c
*** encoder/amiga_mpega.c	Wed Dec 31 17:00:00 1969
--- lame3.70/amiga_mpega.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,96 ----
+ /* MPGLIB replacement using mpega.library (AmigaOS)
+  * Written by Thomas Wenzel and Sigbjrn (CISC) Skjret.
+  *
+  * Big thanks to Stphane Tavernard for mpega.library.
+  *
+  */
+ 
+ #ifdef AMIGA_MPEGA
+ 
+ #include "lame.h"
+ #include "util.h"
+ #include <stdio.h>
+ #include <stdlib.h>
+ #include <proto/exec.h>
+ #include <dos.h>
+ #include <proto/mpega.h>
+ 
+ struct Library  *MPEGABase;
+ MPEGA_STREAM    *mstream=NULL;
+ MPEGA_CTRL      mctrl;
+ 
+ 
+ static int break_cleanup(void)
+ {
+ 	/* Dummy break function to make atexit() work. :P */
+ 	return 1;
+ }
+ 
+ static void exit_cleanup(void)
+ {
+ 	if(mstream) {
+ 		MPEGA_close(mstream);
+ 		mstream = NULL;
+ 	}
+ 	if(MPEGABase) {
+ 		CloseLibrary(MPEGABase);
+ 		MPEGABase = NULL;
+ 	}
+ }
+ 
+ 
+ int lame_decode_initfile(const char *fullname, int *stereo, int *samp, int *bitrate, unsigned long *nsamp)
+ {
+ 	mctrl.bs_access = NULL;
+ 
+ 	mctrl.layer_1_2.mono.quality    = 2;
+ 	mctrl.layer_1_2.stereo.quality  = 2;
+ 	mctrl.layer_1_2.mono.freq_div   = 1;
+ 	mctrl.layer_1_2.stereo.freq_div = 1;
+ 	mctrl.layer_1_2.mono.freq_max   = 48000;
+ 	mctrl.layer_1_2.stereo.freq_max = 48000;
+ 	mctrl.layer_3.mono.quality      = 2;
+ 	mctrl.layer_3.stereo.quality    = 2;
+ 	mctrl.layer_3.mono.freq_div     = 1;
+ 	mctrl.layer_3.stereo.freq_div   = 1;
+ 	mctrl.layer_3.mono.freq_max     = 48000;
+ 	mctrl.layer_3.stereo.freq_max   = 48000;
+ 	mctrl.layer_1_2.force_mono      = 0;
+ 	mctrl.layer_3.force_mono        = 0;
+ 
+ 	MPEGABase = OpenLibrary("mpega.library", 2);
+ 	if(!MPEGABase) {
+ 		fprintf(stderr, "Unable to open mpega.library v2\n");
+ 		exit(1);
+ 	}
+ 	onbreak(break_cleanup);
+ 	atexit(exit_cleanup);
+ 
+ 	mstream=MPEGA_open(fullname, &mctrl);
+ 	if(!mstream) { return (-1); }
+ 
+ 	*stereo  = mstream->dec_channels;
+ 	*samp    = mstream->dec_frequency;
+ 	*bitrate = mstream->bitrate;
+ /*	*nsamp   = MAX_U_32_NUM; */
+ 	*nsamp   = (FLOAT)mstream->ms_duration/1000 * mstream->dec_frequency;
+ 
+ 	return 0;
+ }
+ 
+ int lame_decode_fromfile(FILE *fd, short pcm_l[],short pcm_r[])
+ {
+ 	int outsize=0;
+ 	WORD *b[MPEGA_MAX_CHANNELS];
+ 
+ 	b[0]=pcm_l;
+ 	b[1]=pcm_r;
+ 
+ 	while (outsize == 0)
+ 		outsize = MPEGA_decode_frame(mstream, b);
+ 
+ 	if (outsize < 0) { return (-1); }
+ 	else { return outsize; }
+ }
+ 
+ #endif /* AMIGA_MPEGA */
diff -r -c -N encoder/auenc lame3.70/auenc
*** encoder/auenc	Wed Dec 31 17:00:00 1969
--- lame3.70/auenc	Wed Nov 24 01:41:13 1999
***************
*** 0 ****
--- 1,39 ----
+ #!/bin/sh
+ # 
+ # auenc -- version 0.1
+ #
+ # A wrapper for lame to encode multiple files.  By default, a .wav
+ # extension is removed and replaced by .mp3 .
+ #
+ # (C) 1999 Gerhard Wesp <gwesp@cosy.sbg.ac.at> under the GPL.
+ 
+ # set the variables below according to your taste
+ LAME=/usr/bin/lame
+ LAME_OPTS="-S -h -v -V 0 -b 256" # high quality, silent operation
+ 
+ if [ $# -lt 1 ] ; then
+   exec 1>&2
+   cat << _EOF_
+ usage: $0 [options] file...
+ options:
+   -d --delete: delete original file after successful encoding
+ _EOF_
+   exit 1
+ fi
+ 
+ unset DELETE
+ case "$1" in ( -d | --delete )
+   DELETE=1
+   shift ;;
+ esac
+ 
+ for f in $* ; do
+   if ! $LAME $LAME_OPTS "$f" `basename "$f" .wav`.mp3 ; then
+     exec 1>&2
+     echo "encoding of $f failed, aborting..."
+     exit 1
+   fi
+   if [ -n "$DELETE" ] ; then
+     rm -f "$f"
+   fi
+ done
diff -r -c -N encoder/brhist.c lame3.70/brhist.c
*** encoder/brhist.c	Wed Dec 31 17:00:00 1969
--- lame3.70/brhist.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,135 ----
+ #ifdef BRHIST
+ #include <string.h>
+ #include "brhist.h"
+ #include "util.h"
+ #include <termcap.h>
+ 
+ 
+ #define BRHIST_BARMAX 50
+ int disp_brhist = 1;
+ long brhist_count[15];
+ long brhist_temp[15];
+ int brhist_vbrmin;
+ int brhist_vbrmax;
+ long brhist_max;
+ char brhist_bps[15][5];
+ char brhist_backcur[200];
+ char brhist_bar[BRHIST_BARMAX+10];
+ char brhist_spc[BRHIST_BARMAX+1];
+ 
+ char stderr_buff[BUFSIZ];
+ 
+ 
+ void brhist_init(lame_global_flags *gfp,int br_min, int br_max)
+ {
+   int i;
+   char term_buff[1024];
+   char *termname;
+   char *tp;
+   char tc[10];
+ 
+   for(i = 0; i < 15; i++)
+     {
+       sprintf(brhist_bps[i], "%3d:", bitrate_table[gfp->version][i]);
+       brhist_count[i] = 0;
+       brhist_temp[i] = 0;
+     }
+ 
+   brhist_vbrmin = br_min;
+   brhist_vbrmax = br_max;
+ 
+   brhist_max = 0;
+ 
+   memset(&brhist_bar[0], '*', BRHIST_BARMAX);
+   brhist_bar[BRHIST_BARMAX] = '\0';
+   memset(&brhist_spc[0], ' ', BRHIST_BARMAX);
+   brhist_spc[BRHIST_BARMAX] = '\0';
+   brhist_backcur[0] = '\0';
+ 
+   if ((termname = getenv("TERM")) == NULL)
+     {
+       fprintf(stderr, "can't get TERM environment string.\n");
+       disp_brhist = 0;
+       return;
+     }
+ 
+   if (tgetent(term_buff, termname) != 1)
+     {
+       fprintf(stderr, "can't find termcap entry: %s\n", termname);
+       disp_brhist = 0;
+       return;
+     }
+ 
+   tc[0] = '\0';
+   tp = &tc[0];
+   tp=tgetstr("up", &tp);
+   brhist_backcur[0] = '\0';
+   for(i = br_min-1; i <= br_max; i++)
+     strcat(brhist_backcur, tp);
+   setbuf(stderr, stderr_buff);
+ }
+ 
+ void brhist_add_count(void)
+ {
+   int i;
+ 
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       brhist_count[i] += brhist_temp[i];
+       if (brhist_count[i] > brhist_max)
+ 	brhist_max = brhist_count[i];
+       brhist_temp[i] = 0;
+     }
+ }
+ 
+ void brhist_disp(void)
+ {
+   int i;
+   long full;
+   int barlen;
+ 
+   full = (brhist_max < BRHIST_BARMAX) ? BRHIST_BARMAX : brhist_max;
+   fputc('\n', stderr);
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       barlen = (brhist_count[i]*BRHIST_BARMAX+full-1) / full;
+       fputs(brhist_bps[i], stderr);
+       fputs(&brhist_bar[BRHIST_BARMAX - barlen], stderr);
+       fputs(&brhist_spc[barlen], stderr);
+       fputc('\n', stderr);
+     }
+   fputs(brhist_backcur, stderr);
+   fflush(stderr);
+ }
+ 
+ void brhist_disp_total(lame_global_flags *gfp)
+ {
+   int i;
+   FLOAT ave;
+ 
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     fputc('\n', stderr);
+ 
+   ave=0;
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     ave += bitrate_table[gfp->version][i]*
+       (FLOAT)brhist_count[i] / gfp->totalframes;
+   fprintf(stderr, "\naverage: %2.0f kbs\n",ave);
+     
+ #if 0
+   fprintf(stderr, "----- bitrate statistics -----\n");
+   fprintf(stderr, " [kbps]      frames\n");
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       fprintf(stderr, "   %3d  %8ld (%.1f%%)\n",
+ 	      bitrate_table[gfp->version][i],
+ 	      brhist_count[i],
+ 	      (FLOAT)brhist_count[i] / gfp->totalframes * 100.0);
+     }
+ #endif
+   fflush(stderr);
+ }
+ 
+ #endif /* BRHIST */
+ 
+ 
diff -r -c -N encoder/brhist.h lame3.70/brhist.h
*** encoder/brhist.h	Wed Dec 31 17:00:00 1969
--- lame3.70/brhist.h	Tue Mar 21 16:02:17 2000
***************
*** 0 ****
--- 1,15 ----
+ #ifdef BRHIST
+ #ifndef BRHIST_H_INCLUDED
+ #define BRHIST_H_INCLUDED
+ 
+ extern int disp_brhist;
+ 
+ #include "lame.h"
+ void brhist_init(lame_global_flags *gfp,int br_min, int br_max);
+ void brhist_add_count(void);
+ void brhist_disp(void);
+ void brhist_disp_total(lame_global_flags *gfp);
+ extern long brhist_temp[15];
+ #endif
+ 
+ #endif
diff -r -c -N encoder/common.c lame3.70/common.c
*** encoder/common.c	Wed Jan 22 02:43:13 1997
--- lame3.70/common.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1439 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: common.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: common.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
-  *          Davis Pan                                                 *
-  * 5/10/91  W. Joseph Carter    Created this file for all common      *
-  *                              functions and global variables.       *
-  *                              Ported to Macintosh and Unix.         *
-  *                              Added Jean-Georges Fritsch's          *
-  *                              "bitstream.c" package.                *
-  *                              Added routines to handle AIFF PCM     *
-  *                              sound files.                          *
-  *                              Added "mem_alloc()" and "mem_free()"  *
-  *                              routines for memory allocation        *
-  *                              portability.                          *
-  *                              Added routines to convert between     *
-  *                              Apple SANE extended floating point    *
-  *                              format and IEEE double precision      *
-  *                              floating point format.  For AIFF.     *
-  * 02jul91 dpwe (Aware Inc)     Moved allocation table input here;    *
-  *                              Tables read from subdir TABLES_PATH.  *
-  *                              Added some debug printout fns (Write*)*
-  * 7/10/91 Earle Jennings       replacement of the one float by FLOAT *
-  *                              port to MsDos from MacIntosh version  *
-  * 8/ 5/91 Jean-Georges Fritsch fixed bug in open_bit_stream_r()      *
-  *10/ 1/91 S.I. Sudharsanan,    Ported to IBM AIX platform.           *
-  *         Don H. Lee,                                                *
-  *         Peter W. Farrett                                           *
-  *10/3/91  Don H. Lee           implemented CRC-16 error protection   *
-  *                              newly introduced functions are        *
-  *                              I_CRC_calc, II_CRC_calc and           *
-  *                              update_CRC. Additions and revisions   *
-  *                              are marked with dhl for clarity       *
-  *10/18/91 Jean-Georges Fritsch fixed bug in update_CRC(),            *
-  *                              II_CRC_calc() and I_CRC_calc()        *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 3/20/92 Jean-Georges Fritsch  fixed bug in start-of-frame search   *
-  * 6/15/92 Juan Pineda          added refill_buffer(bs) "n"           *
-  *                              initialization                        *
-  * 7/08/92 Susanne Ritscher     MS-DOS, MSC6.0 port fixes             *
-  * 7/27/92 Mike Li               (re-)Port to MS-DOS                  *
-  * 8/19/92 Soren H. Nielsen     Fixed bug in I_CRC_calc and in        *
-  *                              II_CRC_calc.  Added function: new_ext *
-  *                              for better MS-DOS compatability       *
-  * 3/10/93 Kevin Peterson       changed aiff_read_headers to handle   *
-  *                              chunks in any order.  now returns     *
-  *                              position of sound data in file.       *
-  * 3/31/93 Jens Spille          changed IFF_* string compares to use  *
-  *                              strcmp()                              *
-  * 5/30/93 Masahiro Iwadare     removed the previous modification     *
-  *                              for UNIX.                             *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  *--------------------------------------------------------------------*
-  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
-  *                              Changed for 1 pass decoding.          *
-  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
-  *--------------------------------------------------------------------*
-  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      rewind of bitbuffer added             *
-  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
-  *  7/11/95 Soeren H. Nielsen   Changes for MPEG-2 LSF Layer I and II *
-  *--------------------------------------------------------------------*
-  * 8/02/95  mc@fivebats.com     Added code to determine byte-order,   *
-  *                              fixes to AIFF routines. Modified Mac  *
-  *                              code to work with new Apple headers   *
-  **********************************************************************/
- 
- /***********************************************************************
- *
- *  Global Include Files
- *
- ***********************************************************************/
- 
- #include    "common.h"
- #include	<string.h> /* 1995-07-11 shn */
- #include	<ctype.h>
- #include <stdlib.h>
- 
- /***********************************************************************
- *
- *  Global Variable Definitions
- *
- ***********************************************************************/
- 
- char *mode_names[4] = { "stereo", "j-stereo", "dual-ch", "single-ch" };
- char *layer_names[3] = { "I", "II", "III" };
- char *version_names[2] = { "MPEG-2 LSF", "MPEG-1" };
- 
- /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
- double  s_freq[2][4] = {{22.05, 24, 16, 0}, {44.1, 48, 32, 0}};
- 
- /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
- int     bitrate[2][3][15] = {
-           {{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256},
-            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
-            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160}},
- 	  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
-            {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
-            {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}}
-         };
- 
- double FAR multiple[64] = {
- 2.00000000000000, 1.58740105196820, 1.25992104989487,
- 1.00000000000000, 0.79370052598410, 0.62996052494744, 0.50000000000000,
- 0.39685026299205, 0.31498026247372, 0.25000000000000, 0.19842513149602,
- 0.15749013123686, 0.12500000000000, 0.09921256574801, 0.07874506561843,
- 0.06250000000000, 0.04960628287401, 0.03937253280921, 0.03125000000000,
- 0.02480314143700, 0.01968626640461, 0.01562500000000, 0.01240157071850,
- 0.00984313320230, 0.00781250000000, 0.00620078535925, 0.00492156660115,
- 0.00390625000000, 0.00310039267963, 0.00246078330058, 0.00195312500000,
- 0.00155019633981, 0.00123039165029, 0.00097656250000, 0.00077509816991,
- 0.00061519582514, 0.00048828125000, 0.00038754908495, 0.00030759791257,
- 0.00024414062500, 0.00019377454248, 0.00015379895629, 0.00012207031250,
- 0.00009688727124, 0.00007689947814, 0.00006103515625, 0.00004844363562,
- 0.00003844973907, 0.00003051757813, 0.00002422181781, 0.00001922486954,
- 0.00001525878906, 0.00001211090890, 0.00000961243477, 0.00000762939453,
- 0.00000605545445, 0.00000480621738, 0.00000381469727, 0.00000302772723,
- 0.00000240310869, 0.00000190734863, 0.00000151386361, 0.00000120155435,
- 1E-20
- };
- 
- enum byte_order NativeByteOrder = order_unknown;
- 
- /***********************************************************************
- *
- *  Global Function Definitions
- *
- ***********************************************************************/
- 
- /* The system uses a variety of data files.  By opening them via this
-    function, we can accommodate various locations. */
- 
- FILE *OpenTableFile(name)
- char *name;
- {
-     char fulname[80];
-     char *envdir;
-     FILE *f;
-     
-     fulname[0] = '\0';
-     
- #ifdef TABLES_PATH
-     strcpy(fulname, TABLES_PATH);   /* default relative path for tables */
- #endif /* TABLES_PATH */          /* (includes terminal path seperator */
-     
- #ifdef UNIX                       /* envir. variables for UNIX only */
- {
-     char *getenv();
-     
-     envdir = getenv(MPEGTABENV);   /* check for environment */
-     if(envdir != NULL)
- 	strcpy(fulname, envdir);
-     strcat(fulname, PATH_SEPARATOR);  /* add a "/" on the end */
- }
- #endif /* UNIX */
- 
- strcat(fulname, name);
- if( (f=fopen(fulname,"r"))==NULL ) {
-     fprintf(stderr,"OpenTable: could not find %s\n", fulname);
-     
- #ifdef UNIX
-     if(envdir != NULL)
- 	fprintf(stderr,"Check %s directory '%s'\n",MPEGTABENV, envdir);
-           else
-             fprintf(stderr,"Check local directory './%s' or setenv %s\n",
-                     TABLES_PATH, MPEGTABENV);
- #else /* not unix : no environment variables */
- 
- #ifdef TABLES_PATH
-             fprintf(stderr,"Check local directory './%s'\n",TABLES_PATH);
- #endif /* TABLES_PATH */
- 
- #endif /* UNIX */
- 
-     }
-     return f;
- }
- 
- /***********************************************************************
- *
- * Read one of the data files ("alloc_*") specifying the bit allocation/
- * quatization parameters for each subband in layer II encoding
- *
- **********************************************************************/
- 
- int read_bit_alloc(table, alloc)        /* read in table, return # subbands */
- int table;
- al_table *alloc;
- {
-         unsigned int a, b, c, d, i, j;
-         FILE *fp;
-         char name[16], t[80];
-         int sblim;
- 
-         strcpy(name, "alloc_0");
- 
-         switch (table) {
-                 case 0 : name[6] = '0';         break;
-                 case 1 : name[6] = '1';         break;
-                 case 2 : name[6] = '2';         break;
-                 case 3 : name[6] = '3';         break;
- 		case 4 : name[6] = '4';		break; /* LSF, added 1995-07-11 shn */
-                 default : name[6] = '0';
-         }
- 
-         if (!(fp = OpenTableFile(name))) {
-                 printf("Please check bit allocation table %s\n", name);
-                 exit(1);
-         }
- 
-         printf("using bit allocation table %s\n", name);
- 
-         fgets(t, 80, fp);
-         sscanf(t, "%d\n", &sblim);
-         while (!feof(fp)) {
-                 fgets(t, 80, fp);
-                 sscanf(t, "%d %d %d %d %d %d\n", &i, &j, &a, &b, &c, &d);
-                         (*alloc)[i][j].steps = a;
-                         (*alloc)[i][j].bits  = b;
-                         (*alloc)[i][j].group = c;
-                         (*alloc)[i][j].quant = d;
-         }
-         fclose(fp);
-         return sblim;
- }
- 
- /***********************************************************************
- *
- * Using the decoded info the appropriate possible quantization per
- * subband table is loaded
- *
- **********************************************************************/
- 
- int pick_table(fr_ps)   /* choose table, load if necess, return # sb's */
- frame_params *fr_ps;
- {
-         int table, lay, ws, bsp, br_per_ch, sfrq;
-         int sblim = fr_ps->sblimit;     /* return current value if no load */
- 
-         lay = fr_ps->header->lay - 1;
-         bsp = fr_ps->header->bitrate_index;
-         br_per_ch = bitrate[fr_ps->header->version][lay][bsp] / fr_ps->stereo;
-         ws = fr_ps->header->sampling_frequency;
-         sfrq = s_freq[fr_ps->header->version][ws];
-         /* decision rules refer to per-channel bitrates (kbits/sec/chan) */
- 	if (fr_ps->header->version == MPEG_AUDIO_ID) { /* MPEG-1 */
- 	    if ((sfrq == 48 && br_per_ch >= 56) ||
- 		(br_per_ch >= 56 && br_per_ch <= 80)) table = 0;
- 	    else if (sfrq != 48 && br_per_ch >= 96) table = 1;
- 	    else if (sfrq != 32 && br_per_ch <= 48) table = 2;
- 	    else table = 3;
- 	}
- 	else { /* MPEG-2 LSF */
- 	    table = 4;
- 	}
-         if (fr_ps->tab_num != table) {
-            if (fr_ps->tab_num >= 0)
-               mem_free((void **)&(fr_ps->alloc));
-            fr_ps->alloc = (al_table FAR *) mem_alloc(sizeof(al_table),
-                                                          "alloc");
-            sblim = read_bit_alloc(fr_ps->tab_num = table, fr_ps->alloc);
-         }
-         return sblim;
- }
- 
- int js_bound(lay, m_ext)
- int lay, m_ext;
- {
- static int jsb_table[3][4] =  { { 4, 8, 12, 16 }, { 4, 8, 12, 16},
-                                 { 0, 4, 8, 16} };  /* lay+m_e -> jsbound */
- 
-     if(lay<1 || lay >3 || m_ext<0 || m_ext>3) {
-         fprintf(stderr, "js_bound bad layer/modext (%d/%d)\n", lay, m_ext);
-         exit(1);
-     }
-     return(jsb_table[lay-1][m_ext]);
- }
- 
- void hdr_to_frps(fr_ps) /* interpret data in hdr str to fields in fr_ps */
- frame_params *fr_ps;
- {
- layer *hdr = fr_ps->header;     /* (or pass in as arg?) */
- 
-     fr_ps->actual_mode = hdr->mode;
-     fr_ps->stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
-     if (hdr->lay == 2)          fr_ps->sblimit = pick_table(fr_ps);
-     else                        fr_ps->sblimit = SBLIMIT;
-     if(hdr->mode == MPG_MD_JOINT_STEREO)
-         fr_ps->jsbound = js_bound(hdr->lay, hdr->mode_ext);
-     else
-         fr_ps->jsbound = fr_ps->sblimit;
-     /* alloc, tab_num set in pick_table */
- }
- 
- void WriteHdr(fr_ps, s)
- frame_params *fr_ps;
- FILE *s;
- {
- layer *info = fr_ps->header;
- 
-    fprintf(s, "HDR: s=FFF, id=%X, l=%X, ep=%s, br=%X, sf=%X, pd=%X, ",
-            info->version, info->lay, ((info->error_protection) ? "on" : "off"),
-            info->bitrate_index, info->sampling_frequency, info->padding);
-    fprintf(s, "pr=%X, m=%X, js=%X, c=%X, o=%X, e=%X\n",
-            info->extension, info->mode, info->mode_ext,
-            info->copyright, info->original, info->emphasis);
-    fprintf(s, "alg.=%s, layer=%s, tot bitrate=%d, sfrq=%.1f\n",
-            version_names[info->version], layer_names[info->lay-1],
- 	   bitrate[info->version][info->lay-1][info->bitrate_index],
-            s_freq[info->version][info->sampling_frequency]);
-    fprintf(s, "mode=%s, sblim=%d, jsbd=%d, ch=%d\n",
-            mode_names[info->mode], fr_ps->sblimit, fr_ps->jsbound, fr_ps->stereo);
-    fflush(s);
- }
- 
- void WriteBitAlloc(bit_alloc, f_p, s)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *f_p;
- FILE *s;
- {
- int i,j;
- int st = f_p->stereo;
- int sbl = f_p->sblimit;
- int jsb = f_p->jsbound;
- 
-     fprintf(s, "BITA ");
-     for(i=0; i<sbl; ++i) {
-         if(i == jsb) fprintf(s,"-");
-         for(j=0; j<st; ++j)
-             fprintf(s, "%1x", bit_alloc[j][i]);
-     }
-     fprintf(s, "\n");   fflush(s);
- }
- 
- void WriteScale(bit_alloc, scfsi, scalar, fr_ps, s)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT], scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int stereo  = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- int lay     = fr_ps->header->lay;
- int i,j,k;
- 
-         if(lay == 2) {
-             fprintf(s, "SFSI ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%d",scfsi[k][i]);
-             fprintf(s, "\nSCFs ");
-             for (k=0;k<stereo;k++) {
-                 for (i=0;i<sblimit;i++)
-                     if (bit_alloc[k][i])
-                         switch (scfsi[k][i]) {
-                           case 0: for (j=0;j<3;j++)
-                                   fprintf(s,"%2d%c",scalar[k][j][i],
-                                           (j==2)?';':'-');
-                                   break;
-                           case 1:
-                           case 3: fprintf(s,"%2d-",scalar[k][0][i]);
-                                   fprintf(s,"%2d;",scalar[k][2][i]);
-                                   break;
-                           case 2: fprintf(s,"%2d;",scalar[k][0][i]);
-                         }
-                 fprintf(s, "\n");
-             }
-         }
-         else{   /* lay == 1 */
-             fprintf(s, "SCFs ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%2d;",scalar[k][0][i]);
-             fprintf(s, "\n");
-         }
- }
- 
- void WriteSamples(ch, sample, bit_alloc, fr_ps, s)
- int ch;
- unsigned int FAR sample[SBLIMIT];
- unsigned int bit_alloc[SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int i;
- int stereo = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- 
-         fprintf(s, "SMPL ");
-         for (i=0;i<sblimit;i++)
-                 if ( bit_alloc[i] != 0)
-                     fprintf(s, "%d:", sample[i]);
-         if(ch==(stereo-1) )     fprintf(s, "\n");
-         else                    fprintf(s, "\t");
- }
- 
- int NumericQ(s) /* see if a string lookd like a numeric argument */
- char *s;
- {
- char    c;
- 
-     while( (c = *s++)!='\0' && isspace((int)c)) /* strip leading ws */
-         ;
-     if( c == '+' || c == '-' )
-         c = *s++;               /* perhaps skip leading + or - */
-     return isdigit((int)c);
- }
- 
- int BitrateIndex(layr, bRate, version)   /* convert bitrate in kbps to index */
- int     layr;           /* 1 or 2 */
- int     bRate;          /* legal rates from 32 to 448 */
- int	version;	/* MPEG-1 or MPEG-2 LSF */
- {
- int     index = 0;
- int     found = 0;
- 
-     while(!found && index<15)   {
-         if(bitrate[version][layr-1][index] == bRate)
-             found = 1;
-         else
-             ++index;
-     }
-     if(found)
-         return(index);
-     else {
-         fprintf(stderr, "BitrateIndex: %d (layer %d) is not a legal bitrate\n",
-                 bRate, layr);
-         return(-1);     /* Error! */
-     }
- }
- 
- int SmpFrqIndex(sRate, version)  /* convert samp frq in Hz to index */
- long sRate;             /* legal rates 16000, 22050, 24000, 32000, 44100, 48000 */
- int  *version;
- {
-     if (sRate == 44100L) {
-         *version = MPEG_AUDIO_ID; return(0);
-     }
-     else if (sRate == 48000L) {
-         *version = MPEG_AUDIO_ID; return(1);
-     }
-     else if (sRate == 32000L) {
-         *version = MPEG_AUDIO_ID; return(2);
-     }
-     else if (sRate == 24000L) {
-         *version = MPEG_PHASE2_LSF; return(1);
-     }
-     else if (sRate == 22050L) {
-         *version = MPEG_PHASE2_LSF; return(0);
-     }
-     else if (sRate == 16000L) {
-         *version = MPEG_PHASE2_LSF; return(2);
-     }
-     else {
-         fprintf(stderr, "SmpFrqIndex: %ld is not a legal sample rate\n", sRate);
-         return(-1);     /* Error! */
-     }
- }
- 
- /*******************************************************************************
- *
- *  Allocate number of bytes of memory equal to "block".
- *
- *******************************************************************************/
- 
- void  FAR *mem_alloc(block, item)
- unsigned long   block;
- char            *item;
- {
- 
-     void    *ptr;
- 
- #ifdef  MACINTOSH
-     ptr = NewPtr(block);
- #endif
- 
- #ifdef MSC60
-     /*ptr = (void FAR *) _fmalloc((unsigned int)block);*/ /* far memory, 92-07-08 sr */
-     ptr = (void FAR *) malloc((unsigned int)block); /* far memory, 93-08-24 ss */
- #endif
- 
- #if ! defined (MACINTOSH) && ! defined (MSC60)
-     ptr = (void FAR *) malloc(block);
- #endif
- 
-     if (ptr != NULL){
- #ifdef  MSC60
-         _fmemset(ptr, 0, (unsigned int)block); /* far memory, 92-07-08 sr */
- #else
-         memset(ptr, 0, block);
- #endif
-     }
-     else{
-         printf("Unable to allocate %s\n", item);
-         exit(0);
-     }
-     return(ptr);
- }
- 
- 
- /****************************************************************************
- *
- *  Free memory pointed to by "*ptr_addr".
- *
- *****************************************************************************/
- 
- void    mem_free(ptr_addr)
- void    **ptr_addr;
- {
- 
-     if (*ptr_addr != NULL){
- #ifdef  MACINTOSH
-         DisposPtr(*ptr_addr);
- #else
-         free(*ptr_addr);
- #endif
-         *ptr_addr = NULL;
-     }
- 
- }
- 
- /*******************************************************************************
- *
- *  Check block of memory all equal to a single byte, else return FALSE
- *
- *******************************************************************************/
- 
- int memcheck(array, test, num)
- char *array;
- int test;       /* but only tested as a char (bottom 8 bits) */
- int num;
- {
-  int i=0;
- 
-    while (array[i] == test && i<num) i++;
-    if (i==num) return TRUE;
-    else return FALSE;
- }
- 
- /*****************************************************************************
- *
- *  Routines to determine byte order and swap bytes
- *
- *****************************************************************************/
- 
- enum byte_order DetermineByteOrder()
- {
-     char s[ sizeof(long) + 1 ];
-     union
-     {
-         long longval;
-         char charval[ sizeof(long) ];
-     } probe;
-     probe.longval = 0x41424344L;  /* ABCD in ASCII */
-     strncpy( s, probe.charval, sizeof(long) );
-     s[ sizeof(long) ] = '\0';
-     /* fprintf( stderr, "byte order is %s\n", s ); */
-     if ( strcmp(s, "ABCD") == 0 )
-         return order_bigEndian;
-     else
-         if ( strcmp(s, "DCBA") == 0 )
-             return order_littleEndian;
-         else
-             return order_unknown;
- }
- 
- void SwapBytesInWords( short *loc, int words )
- {
-     int i;
-     short thisval;
-     char *dst, *src;
-     src = (char *) &thisval;
-     for ( i = 0; i < words; i++ )
-     {
-         thisval = *loc;
-         dst = (char *) loc++;
-         dst[0] = src[1];
-         dst[1] = src[0];
-     }
- }
- 
- /*****************************************************************************
-  *
-  *  Read Audio Interchange File Format (AIFF) headers.
-  *
-  *****************************************************************************/
- 
- int aiff_read_headers( FILE *file_ptr, IFF_AIFF *aiff_ptr )
- {
-     int chunkSize, subSize, sound_position;
-     
-     if ( fseek(file_ptr, 0, SEEK_SET) != 0 )
-         return -1;
-     
-     if ( Read32BitsHighLow(file_ptr) != IFF_ID_FORM )
-         return -1;
-     
-     chunkSize = Read32BitsHighLow( file_ptr );
-     
-     if ( Read32BitsHighLow(file_ptr) != IFF_ID_AIFF )
-         return -1;
-     
-     sound_position = 0;
-     while ( chunkSize > 0 )
-     {
-         chunkSize -= 4;
-         switch ( Read32BitsHighLow(file_ptr) )
- 	{
-             
-           case IFF_ID_COMM:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             aiff_ptr->numChannels = Read16BitsHighLow( file_ptr );
-             subSize -= 2;
-             aiff_ptr->numSampleFrames = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             aiff_ptr->sampleSize = Read16BitsHighLow( file_ptr );
-             subSize -= 2;
-             aiff_ptr->sampleRate  = ReadIeeeExtendedHighLow( file_ptr );
-             subSize -= 10;
-             while ( subSize > 0 )
- 	    {
-                 getc( file_ptr );
-                 subSize -= 1;
- 	    }
-             break;
-             
-           case IFF_ID_SSND:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             aiff_ptr->blkAlgn.offset = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             aiff_ptr->blkAlgn.blockSize = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             sound_position = ftell( file_ptr ) + aiff_ptr->blkAlgn.offset;
-             if ( fseek(file_ptr, (long) subSize, SEEK_CUR) != 0 )
-                 return -1;
-             aiff_ptr->sampleType = IFF_ID_SSND;
-             break;
-             
-           default:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             while ( subSize > 0 )
- 	    {
-                 getc( file_ptr );
-                 subSize -= 1;
- 	    }
-             break;
- 	}
-     }
-     return sound_position;
- }
- 
- /*****************************************************************************
-  *
-  *  Seek past some Audio Interchange File Format (AIFF) headers to sound data.
-  *
-  *****************************************************************************/
- 
- int aiff_seek_to_sound_data( FILE *file_ptr )
- {
- 	if ( fseek(file_ptr, AIFF_FORM_HEADER_SIZE + AIFF_SSND_HEADER_SIZE, SEEK_SET) != 0 )
-         return(-1);
-     return(0);
- }
- 
- /*******************************************************************************
-  *
-  *  Write Audio Interchange File Format (AIFF) headers.
-  *
-  *******************************************************************************/
- 
- int aiff_write_headers( FILE *file_ptr, IFF_AIFF *aiff_ptr )
- {
-     int chunkSize;
-     int sampleBytes = (aiff_ptr->sampleSize / 8) + (aiff_ptr->sampleSize % 8 ? 1 : 0);
-     
-     if ( fseek(file_ptr, 0L, SEEK_SET) != 0 )
-         return -1;
-     
-     /* write FORM chunk */
-     chunkSize = 8 + 18 + 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
-     Write32BitsHighLow( file_ptr, IFF_ID_FORM );
-     Write32BitsHighLow( file_ptr, chunkSize );
-     Write32BitsHighLow( file_ptr, IFF_ID_AIFF );
-     /* write COMM chunk */
-     Write32BitsHighLow( file_ptr, IFF_ID_COMM );
-     Write32BitsHighLow( file_ptr, 18 ); /* chunk size */
-     Write16BitsHighLow( file_ptr, aiff_ptr->numChannels );
-     Write32BitsHighLow( file_ptr, aiff_ptr->numSampleFrames );
-     Write16BitsHighLow( file_ptr, aiff_ptr->sampleSize );
-     WriteIeeeExtendedHighLow( file_ptr, aiff_ptr->sampleRate );
-     /* write SSND chunk header */
-     chunkSize = 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
-     Write32BitsHighLow( file_ptr, IFF_ID_SSND );
-     Write32BitsHighLow( file_ptr, chunkSize );
-     Write32BitsHighLow( file_ptr, 0 ); /* offset */
-     Write32BitsHighLow( file_ptr, 0 ); /* block size */
-     return 0;
- }
- 
- /*****************************************************************************
- *
- *  bit_stream.c package
- *  Author:  Jean-Georges Fritsch, C-Cube Microsystems
- *
- *****************************************************************************/
- 
- /********************************************************************
-   This package provides functions to write (exclusive or read)
-   information from (exclusive or to) the bit stream.
- 
-   If the bit stream is opened in read mode only the get functions are
-   available. If the bit stream is opened in write mode only the put
-   functions are available.
- ********************************************************************/
- 
- /*open_bit_stream_w(); open the device to write the bit stream into it    */
- /*open_bit_stream_r(); open the device to read the bit stream from it     */
- /*close_bit_stream();  close the device containing the bit stream         */
- /*alloc_buffer();      open and initialize the buffer;                    */
- /*desalloc_buffer();   empty and close the buffer                         */
- /*back_track_buffer();     goes back N bits in the buffer                 */
- /*unsigned int get1bit();  read 1 bit from the bit stream                 */
- /*unsigned long getbits(); read N bits from the bit stream                */
- /*unsigned long byte_ali_getbits();   read the next byte aligned N bits from*/
- /*                                    the bit stream                        */
- /*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
- /*                            changing the buffer pointer                   */
- /*put1bit(); write 1 bit from the bit stream  */
- /*put1bit(); write 1 bit from the bit stream  */
- /*putbits(); write N bits from the bit stream */
- /*byte_ali_putbits(); write byte aligned the next N bits into the bit stream*/
- /*unsigned long sstell(); return the current bit stream length (in bits)    */
- /*int end_bs(); return 1 if the end of bit stream reached otherwise 0       */
- /*int seek_sync(); return 1 if a sync word was found in the bit stream      */
- /*                 otherwise returns 0                                      */
- 
- /* refill the buffer from the input device when the buffer becomes empty    */
- int refill_buffer(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    register int i=bs->buf_size-2-bs->buf_byte_idx;
-    register unsigned long n=1;
-    register int index=0;
-    char val[2];
- 
-    while ((i>=0) && (!bs->eob)) {
- 
-       if (bs->format == BINARY)
-          n = fread(&bs->buf[i--], sizeof(unsigned char), 1, bs->pt);
- 
-       else {
-          while((index < 2) && n) {
-             n = fread(&val[index], sizeof(char), 1, bs->pt);
-             switch (val[index]) {
-                   case 0x30:
-                   case 0x31:
-                   case 0x32:
-                   case 0x33:
-                   case 0x34:
-                   case 0x35:
-                   case 0x36:
-                   case 0x37:
-                   case 0x38:
-                   case 0x39:
-                   case 0x41:
-                   case 0x42:
-                   case 0x43:
-                   case 0x44:
-                   case 0x45:
-                   case 0x46:
-                   index++;
-                   break;
-                   default: break;
-             }
-          }
- 
-          if (val[0] <= 0x39)   bs->buf[i] = (val[0] - 0x30) << 4;
-                  else  bs->buf[i] = (val[0] - 0x37) << 4;
-          if (val[1] <= 0x39)   bs->buf[i--] |= (val[1] - 0x30);
-                  else  bs->buf[i--] |= (val[1] - 0x37);
-          index = 0;
-       }
- 
-       if (!n) {
-          bs->eob= i+1;
-       }
- 
-     }
-    return 0;
- }
- 
- static char *he = "0123456789ABCDEF";
- 
- /* empty the buffer to the output device when the buffer becomes full */
- void empty_buffer(bs, minimum)
- Bit_stream_struc *bs;   /* bit stream structure */
- int minimum;            /* end of the buffer to empty */
- {
-    register int i;
- 
- #if BS_FORMAT == BINARY
-    for (i=bs->buf_size-1;i>=minimum;i--)
-       fwrite(&bs->buf[i], sizeof(unsigned char), 1, bs->pt);
- #else
-    for (i=bs->buf_size-1;i>=minimum;i--) {
-        char val[2];
-        val[0] = he[((bs->buf[i] >> 4) & 0x0F)];
-        val[1] = he[(bs->buf[i] & 0x0F)];
-        fwrite(val, sizeof(char), 2, bs->pt);
-    }
- #endif
- fflush(bs->pt); /* NEW SS to assist in debugging*/
- 
-    for (i=minimum-1; i>=0; i--)
-        bs->buf[bs->buf_size - minimum + i] = bs->buf[i];
- 
-    bs->buf_byte_idx = bs->buf_size -1 - minimum;
-    bs->buf_bit_idx = 8;
- }
- 
- /* open the device to write the bit stream into it */
- void open_bit_stream_w(bs, bs_filenam, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- char *bs_filenam;       /* name of the bit stream file */
- int size;               /* size of the buffer */
- {
-    if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
-       printf("Could not create \"%s\".\n", bs_filenam);
-       exit(1);
-    }
-    alloc_buffer(bs, size);
-    bs->buf_byte_idx = size-1;
-    bs->buf_bit_idx=8;
-    bs->totbit=0;
-    bs->mode = WRITE_MODE;
-    bs->eob = FALSE;
-    bs->eobs = FALSE;
- }
- 
- /* open the device to read the bit stream from it */
- void open_bit_stream_r(bs, bs_filenam, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- char *bs_filenam;       /* name of the bit stream file */
- int size;               /* size of the buffer */
- {
-    register unsigned long n;
-    register unsigned char flag = 1;
-    unsigned char val;
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    do {
-      n = fread(&val, sizeof(unsigned char), 1, bs->pt);
-      switch (val) {
-       case 0x30:
-       case 0x31:
-       case 0x32:
-       case 0x33:
-       case 0x34:
-       case 0x35:
-       case 0x36:
-       case 0x37:
-       case 0x38:
-       case 0x39:
-       case 0x41:
-       case 0x42:
-       case 0x43:
-       case 0x44:
-       case 0x45:
-       case 0x46:
-       case 0xa:  /* \n */
-       case 0xd:  /* cr */
-       case 0x1a:  /* sub */
-           break;
- 
-       default: /* detection of an binary character */
-           flag--;
-           break;
-      }
- 
-    } while (flag & n);
- 
-    if (flag) {
-       printf ("the bit stream file %s is an ASCII file\n", bs_filenam);
-       bs->format = ASCII;
-    }
-    else {
-       bs->format = BINARY;
-       printf ("the bit stream file %s is a BINARY file\n", bs_filenam);
-    }
- 
-    fclose(bs->pt);
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    alloc_buffer(bs, size);
-    bs->buf_byte_idx=0;
-    bs->buf_bit_idx=0;
-    bs->totbit=0;
-    bs->mode = READ_MODE;
-    bs->eob = FALSE;
-    bs->eobs = FALSE;
- }
- 
- /*close the device containing the bit stream after a read process*/
- void close_bit_stream_r(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    fclose(bs->pt);
-    desalloc_buffer(bs);
- }
- 
- /*close the device containing the bit stream after a write process*/
- void close_bit_stream_w(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    empty_buffer(bs, bs->buf_byte_idx);
-    fclose(bs->pt);
-    desalloc_buffer(bs);
- }
- 
- /*open and initialize the buffer; */
- void alloc_buffer(bs, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- int size;
- {
-    bs->buf = (unsigned char FAR *) mem_alloc(size*sizeof(unsigned
-               char), "buffer");
-    bs->buf_size = size;
- }
- 
- /*empty and close the buffer */
- void desalloc_buffer(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    free(bs->buf);
- }
- 
- int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
- int clearmask[9]={0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0};
- 
- void back_track_buffer(bs, N) /* goes back N bits in the buffer */
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;
- {
-    int tmp = N - (N/8)*8;
-    register int i;
- 
-    bs->totbit -= N;
-    for (i=bs->buf_byte_idx;i< bs->buf_byte_idx+N/8-1;i++) bs->buf[i] = 0;
-    bs->buf_byte_idx += N/8;
-    if ( (tmp + bs->buf_bit_idx) <= 8) {
-       bs->buf_bit_idx += tmp;
-    }
-    else {
-       bs->buf_byte_idx ++;
-       bs->buf_bit_idx += (tmp - 8);
-    }
-    bs->buf[bs->buf_byte_idx] &= clearmask[bs->buf_bit_idx];
- }
- 
- int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
- 
- /*read 1 bit from the bit stream */
- unsigned int get1bit(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    unsigned int bit;
-    register int i;
- 
-    bs->totbit++;
- 
-    if (!bs->buf_bit_idx) {
-         bs->buf_bit_idx = 8;
-         bs->buf_byte_idx--;
-         if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
-              if (bs->eob)
-                 bs->eobs = TRUE;
-              else {
-                 for (i=bs->buf_byte_idx; i>=0;i--)
-                   bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
-                 refill_buffer(bs);
-                 bs->buf_byte_idx = bs->buf_size-1;
-              }
-         }
-    }
-    bit = bs->buf[bs->buf_byte_idx]&mask[bs->buf_bit_idx-1];
-    bit = bit >> (bs->buf_bit_idx-1);
-    bs->buf_bit_idx--;
-    return(bit);
- }
- 
- /*write 1 bit from the bit stream */
- void put1bit(bs, bit)
- Bit_stream_struc *bs;   /* bit stream structure */
- int bit;                /* bit to write into the buffer */
- {
-    bs->totbit++;
- 
-    bs->buf[bs->buf_byte_idx] |= (bit&0x1) << (bs->buf_bit_idx-1);
-    bs->buf_bit_idx--;
-    if (!bs->buf_bit_idx) {
-        bs->buf_bit_idx = 8;
-        bs->buf_byte_idx--;
-        if (bs->buf_byte_idx < 0)
-           empty_buffer(bs, MINIMUM);
-        bs->buf[bs->buf_byte_idx] = 0;
-    }
- }
- 
- /*look ahead for the next N bits from the bit stream */
- unsigned long look_ahead(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
-  register int bit_idx = bs->buf_bit_idx;
-  register int byte_idx = bs->buf_byte_idx;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  while (j > 0) {
-     if (!bit_idx) {
-         bit_idx = 8;
-         byte_idx--;
-     }
-     k = MIN (j, bit_idx);
-     tmp = bs->buf[byte_idx]&putmask[bit_idx];
-     tmp = tmp >> (bit_idx-k);
-     val |= tmp << (j-k);
-     bit_idx -= k;
-     j -= k;
-  }
-  return(val);
- }
- 
- /*read N bit from the bit stream */
- unsigned long getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int i;
-  register int j = N;
-  register int k, tmp;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  bs->totbit += N;
-  while (j > 0) {
-    if (!bs->buf_bit_idx) {
-         bs->buf_bit_idx = 8;
-         bs->buf_byte_idx--;
-         if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
-              if (bs->eob)
-                 bs->eobs = TRUE;
-              else {
-                 for (i=bs->buf_byte_idx; i>=0;i--)
-                    bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
-                 refill_buffer(bs);
-                 bs->buf_byte_idx = bs->buf_size-1;
-              }
-         }
-    }
-    k = MIN (j, bs->buf_bit_idx);
-    tmp = bs->buf[bs->buf_byte_idx]&putmask[bs->buf_bit_idx];
-    tmp = tmp >> (bs->buf_bit_idx-k);
-    val |= tmp << (j-k);
-    bs->buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
- 
- /*write N bits into the bit stream */
- void putbits(bs, val, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-  register int j = N;
-  register int k, tmp;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  bs->totbit += N;
-  while (j > 0) {
-    k = MIN(j, bs->buf_bit_idx);
-    tmp = val >> (j-k);
-    bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
-    bs->buf_bit_idx -= k;
-    if (!bs->buf_bit_idx) {
-        bs->buf_bit_idx = 8;
-        bs->buf_byte_idx--;
-        if (bs->buf_byte_idx < 0)
-           empty_buffer(bs, MINIMUM);
-        bs->buf[bs->buf_byte_idx] = 0;
-    }
-    j -= k;
-  }
- }
- 
- /*write N bits byte aligned into the bit stream */
- void byte_ali_putbits(bs, val, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-      putbits(bs, (unsigned int)0, (int)(8-aligning)); 
- 
-  putbits(bs, val, N);
- }
- 
- /*read the next bute aligned N bits from the bit stream */
- unsigned long byte_ali_getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-     getbits(bs, (int)(8-aligning));
- 
-  return(getbits(bs, N));
- }
- 
- /*return the current bit stream length (in bits)*/
- unsigned long sstell(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-   return(bs->totbit);
- }
- 
- /*return the status of the bit stream*/
- /* returns 1 if end of bit stream was reached */
- /* returns 0 if end of bit stream was not reached */
- int end_bs(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-   return(bs->eobs);
- }
- 
- /*this function seeks for a byte aligned sync word in the bit stream and
-   places the bit stream pointer right after the sync.
-   This function returns 1 if the sync was found otherwise it returns 0  */
- int seek_sync(bs, sync, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- long sync;      /* sync word maximum 32 bits */
- int N;          /* sync word length */
- {
- #if defined(MACINTOSH) && !defined(__powerc)
-  double pow();
- #endif
-  unsigned long aligning, stell();
-  unsigned long val;
-  long maxi = (int)pow(2.0, (FLOAT)N) - 1;
- 
-  aligning = sstell(bs)%ALIGNING;
-  if (aligning)
-     getbits(bs, (int)(ALIGNING-aligning));
- 
-   val = getbits(bs, N);
-   while (((val&maxi) != sync) && (!end_bs(bs))) {
-         val <<= ALIGNING;
-         val |= getbits(bs, ALIGNING);
-   }
- 
-  if (end_bs(bs)) return(0);
-  else return(1);
- }
- /*****************************************************************************
- *
- *  End of bit_stream.c package
- *
- *****************************************************************************/
- 
- /*****************************************************************************
- *
- *  CRC error protection package
- *
- *****************************************************************************/
- 
- void I_CRC_calc(fr_ps, bit_alloc, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int jsbound = fr_ps->jsbound;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<SBLIMIT;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], 4, crc);
- }
- 
- void II_CRC_calc(fr_ps, bit_alloc, scfsi, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int sblimit = fr_ps->sblimit;
-         int jsbound = fr_ps->jsbound;
-         al_table *alloc = fr_ps->alloc;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], (*alloc)[i][0].bits, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<stereo;k++)
-                         if (bit_alloc[k][i])
-                                 update_CRC(scfsi[k][i], 2, crc);
- }
- 
- void update_CRC(data, length, crc)
- unsigned int data, length, *crc;
- {
-         unsigned int  masking, carry;
- 
-         masking = 1 << length;
- 
-         while((masking >>= 1)){
-                 carry = *crc & 0x8000;
-                 *crc <<= 1;
-                 if (!carry ^ !(data & masking))
-                         *crc ^= CRC16_POLYNOMIAL;
-         }
-         *crc &= 0xffff;
- }
- 
- /*****************************************************************************
- *
- *  End of CRC error protection package
- *
- *****************************************************************************/
- 
- #ifdef  MACINTOSH
- /*****************************************************************************
- *
- *  Set Macintosh file attributes.
- *
- *****************************************************************************/
- void set_mac_file_attr( char fileName[MAX_NAME_SIZE], short vRefNum, OSType creator, OSType fileType)
- {
-     char pascal_fileName[MAX_NAME_SIZE];
-     FInfo fndrInfo;
-     OSErr anErr;
-     long dirID = 0L;
-     
-     CtoPstr(strcpy(pascal_fileName, fileName));
-     anErr = HGetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
-     if ( anErr != noErr )
-         return;
-     fndrInfo.fdCreator = creator;
-     fndrInfo.fdType = fileType;
-     anErr = HSetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
- }
- 
- #endif
- 
- 
- #ifdef  MS_DOS
- /* ------------------------------------------------------------------------
- new_ext()
- Puts a new extension name on a file name <filename>.
- Removes the last extension name, if any.
- 1992-08-19, 1995-06-12 shn
- ------------------------------------------------------------------------ */
- void
- new_ext(char *filename, char *extname, char *newname)
- {
-   int found, dotpos;
- 
-   /* First, strip the extension */
-   dotpos=strlen(filename); found=0;
-   do
-   {
-     switch (filename[dotpos])
-     {
-       case '.' : found=1; break;
-       case '\\':
-       case '/' :
-       case ':' : found=-1; break;
-       default  : dotpos--; if (dotpos<0) found=-1; break;
-     }
-   } while (found==0);
-   if (found==-1) strcpy(newname,filename);
-   if (found== 1) { strncpy(newname,filename,dotpos); newname[dotpos]='\0'; }
-   strcat(newname,extname);
- }
- #endif
- 
- 
- 
- #define BUFSIZE 4096
- static unsigned long offset,totbit=0, buf_byte_idx=0;
- static unsigned int buf[BUFSIZE];
- static unsigned int buf_bit_idx=8;
- 
- /*return the current bit stream length (in bits)*/
- unsigned long hsstell()
- {
-   return(totbit);
- }
- 
- /* int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff}; */
- extern int putmask[9];
- 
- /*read N bit from the bit stream */
- unsigned long hgetbits(N)
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
- 
- /*
-  if (N > MAX_LENGTH)
-      printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- */
-  totbit += N;
-  while (j > 0) {
-    if (!buf_bit_idx) {
-         buf_bit_idx = 8;
-         buf_byte_idx++;
- 	if (buf_byte_idx > offset)
- 	  { printf("Buffer overflow !!\n");exit(3); }
-    }
-    k = MIN (j, buf_bit_idx);
-    tmp = buf[buf_byte_idx%BUFSIZE]&putmask[buf_bit_idx];
-    tmp = tmp >> (buf_bit_idx-k);
-    val |= tmp << (j-k);
-    buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
- 
- unsigned int hget1bit()
- {
- return(hgetbits(1));
- }
- 
- /*write N bits into the bit stream */
- void hputbuf(val, N)
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-   if (N != 8) { printf("Not Supported yet!!\n"); exit(-3); }
-   buf[offset % BUFSIZE] = val;
-   offset++;
- }
- 
- void rewindNbits( N )
- int N;
- {
-    totbit -= N;
-    buf_bit_idx += N;
-    while( buf_bit_idx >= 8 )
-    {  buf_bit_idx -= 8;
-       buf_byte_idx--;
-    }
- }
- 
- void rewindNbytes( N )
- int N;
- {
-    totbit -= N*8;
-    buf_byte_idx -= N;
- }
--- 0 ----
diff -r -c -N encoder/common.h lame3.70/common.h
*** encoder/common.h	Wed Jan 22 02:43:13 1997
--- lame3.70/common.h	Wed Dec 31 17:00:00 1969
***************
*** 1,491 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: common.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: common.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
-  *          Davis Pan                                                 *
-  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
-  *                              into "common.h" and "encoder.h".      *
-  *                              Ported to Macintosh and Unix.         *
-  *                              Added additional type definitions for *
-  *                              AIFF, double/SANE and "bitstream.c".  *
-  *                              Added function prototypes for more    *
-  *                              rigorous type checking.               *
-  * 27jun91  dpwe (Aware)        Added "alloc_*" defs & prototypes     *
-  *                              Defined new struct 'frame_params'.    *
-  *                              Changed info.stereo to info.mode_ext  *
-  *                              #define constants for mode types      *
-  *                              Prototype arguments if PROTO_ARGS     *
-  * 5/28/91  Earle Jennings      added MS_DOS definition               *
-  *                              MsDos function prototype declarations *
-  * 7/10/91  Earle Jennings      added FLOAT definition as double      *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  *                              Modified some function prototypes.    *
-  *                              Changed BUFFER_SIZE back to 4096.     *
-  * 7/27/92  Michael Li          (re-)Ported to MS-DOS                 *
-  * 7/27/92  Masahiro Iwadare    Ported to Convex                      *
-  * 8/07/92  mc@tv.tek.com                                             *
-  * 8/10/92  Amit Gulati         Ported to the AIX Platform (RS6000)   *
-  *                              AIFF string constants redefined       *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  *--------------------------------------------------------------------*
-  * 4/23/92  J. Pineda           Added code for Layer III.             *
-  * 11/9/92  Amit Gulati         Added defines for layerIII stereo     *
-  *                              modes.                                *
-  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
-  *                              Changed for 1 pass decoding.          *
-  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
-  *--------------------------------------------------------------------*
-  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      Fix for HPUX an IRIX in AIFF-Strings  *
-  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
-  *  7/11/95 Soeren H. Nielsen   Added defs. for MPEG-2 LSF            *
-  *--------------------------------------------------------------------*
-  * 8/02/95  mc@fivebats.com     Changes to AIFF stuff for portability *
-  *                              to little-endian machines             *
-  **********************************************************************/
- #ifndef COMMON_DOT_H
- #define COMMON_DOT_H
- /***********************************************************************
- *
- *  Global Conditional Compile Switches
- *
- ***********************************************************************/
- 
- #if 0
- #define      UNIX            /* Unix conditional compile switch */
- #define      MACINTOSH       /* Macintosh conditional compile switch */
- #define      MS_DOS          /* IBM PC conditional compile switch */
- #define      MSC60           /* Compiled for MS_DOS with MSC v6.0 */
- #define      AIX             /* AIX conditional compile switch    */
- #define      CONVEX          /* CONVEX conditional compile switch */
- #endif
- 
- #if defined(MSC60) 
- #ifndef MS_DOS
- #define MS_DOS
- #endif
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
- #ifdef  UNIX
- #define         TABLES_PATH     "tables"  /* to find data files */
- /* name of environment variable holding path of table files */
- #define         MPEGTABENV      "MPEGTABLES"
- #define         PATH_SEPARATOR  "/"        /* how to build paths */
- #endif  /* UNIX */
- 
- #ifdef  MACINTOSH
- #define      TABLES_PATH ":tables:"  /* where to find data files */
- #endif  /* MACINTOSH */
- 
- /* 
-  * Don't define FAR to far unless you're willing to clean up the 
-  * prototypes
-  */
- #define FAR /*far*/
- 
- #ifdef __STDC__
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
- #ifdef CONVEX
- #define SEEK_SET        0
- #define SEEK_CUR        1
- #define SEEK_END        2
- #endif
- 
- /* MS_DOS and VMS do not define TABLES_PATH, so OpenTableFile will default
-    to finding the data files in the default directory */
- 
- /***********************************************************************
- *
- *  Global Include Files
- *
- ***********************************************************************/
- 
- #include        <stdio.h>
- #include        <string.h>
- #include        <math.h>
- #include "portableio.h"
- #include "ieeefloat.h"
- 
- #ifdef  UNIX
- #include        <unistd.h>
- #endif  /* UNIX */
- 
- #ifdef __sgi
- #include	<stdlib.h>
- #endif
- 
- #ifdef  MACINTOSH
- #include        <stdlib.h>
- #include        <console.h>
- #endif  /* MACINTOSH */
- 
- #ifdef  MS_DOS
- #include        <stdlib.h>
- #ifdef MSC60
- #include        <memory.h>
- #else
- #include        <alloc.h>
- #include        <mem.h>
- #endif  /* MSC60 */
- #endif  /* MS_DOS */
- 
- #ifndef EXIT_SUCCESS
- #define EXIT_SUCCESS 0
- #endif
- 
- #ifndef EXIT_FAILURE
- #define EXIT_FAILURE 1
- #endif
- 
- /***********************************************************************
- *
- *  Global Definitions
- *
- ***********************************************************************/
- 
- /* General Definitions */
- 
- #ifdef  MS_DOS
- #define         FLOAT                   double
- #else
- #define         FLOAT                   float
- #endif
- #ifndef FALSE
- #define         FALSE                   0
- #endif
- 
- #ifndef TRUE
- #define         TRUE                    1
- #endif
- 
- #define         NULL_CHAR               '\0'
- 
- #define         MAX_U_32_NUM            0xFFFFFFFF
- #ifndef PI
- #define         PI                      3.14159265358979
- #endif
- #define         PI4                     PI/4
- #define         PI64                    PI/64
- #define         LN_TO_LOG10             0.2302585093
- 
- #define         VOL_REF_NUM             0
- #define         MPEG_AUDIO_ID           1
- #define		MPEG_PHASE2_LSF		0	/* 1995-07-11 SHN */
- #define         MAC_WINDOW_SIZE         24
- 
- #define         MONO                    1
- #define         STEREO                  2
- #define         BITS_IN_A_BYTE          8
- #define         WORD                    16
- #define         MAX_NAME_SIZE           81
- #define         SBLIMIT                 32
- #define         SSLIMIT                 18
- #define         FFT_SIZE                1024
- #define         HAN_SIZE                512
- #define         SCALE_BLOCK             12
- #define         SCALE_RANGE             64
- #define         SCALE                   32768
- #define         CRC16_POLYNOMIAL        0x8005
- 
- /* MPEG Header Definitions - Mode Values */
- 
- #define         MPG_MD_STEREO           0
- #define         MPG_MD_JOINT_STEREO     1
- #define         MPG_MD_DUAL_CHANNEL     2
- #define         MPG_MD_MONO             3
- 
- /* Mode Extention */
- 
- #define         MPG_MD_LR_LR             0
- #define         MPG_MD_LR_I              1
- #define         MPG_MD_MS_LR             2
- #define         MPG_MD_MS_I              3
- 
- 
- /* "bit_stream.h" Definitions */
- 
- #define         MINIMUM         4    /* Minimum size of the buffer in bytes */
- #define         MAX_LENGTH      32   /* Maximum length of word written or
-                                         read from bit stream */
- #define         READ_MODE       0
- #define         WRITE_MODE      1
- #define         ALIGNING        8
- #define         BINARY          0
- #define         ASCII           1
- 
- #ifndef BS_FORMAT
- #define         BS_FORMAT       ASCII /* BINARY or ASCII = 2x bytes */
- #endif
- 
- #define         BUFFER_SIZE     4096
- 
- #define         MIN(A, B)       ((A) < (B) ? (A) : (B))
- #define         MAX(A, B)       ((A) > (B) ? (A) : (B))
- 
- /***********************************************************************
- *
- *  Global Type Definitions
- *
- ***********************************************************************/
- 
- /* Structure for Reading Layer II Allocation Tables from File */
- 
- typedef struct {
-     unsigned int    steps;
-     unsigned int    bits;
-     unsigned int    group;
-     unsigned int    quant;
- } sb_alloc, *alloc_ptr;
- 
- typedef sb_alloc        al_table[SBLIMIT][16];
- 
- /* Header Information Structure */
- 
- typedef struct {
-     int version;
-     int lay;
-     int error_protection;
-     int bitrate_index;
-     int sampling_frequency;
-     int padding;
-     int extension;
-     int mode;
-     int mode_ext;
-     int copyright;
-     int original;
-     int emphasis;
- } layer, *the_layer;
- 
- /* Parent Structure Interpreting some Frame Parameters in Header */
- 
- typedef struct {
-     layer       *header;        /* raw header information */
-     int         actual_mode;    /* when writing IS, may forget if 0 chs */
-     al_table    *alloc;         /* bit allocation table read in */
-     int         tab_num;        /* number of table as loaded */
-     int         stereo;         /* 1 for mono, 2 for stereo */
-     int         jsbound;        /* first band of joint stereo coding */
-     int         sblimit;        /* total number of sub bands */
- } frame_params;
- 
- 
- /* AIFF Definitions */
- 
- #define IFF_ID_FORM 0x464f524d /* "FORM" */
- #define IFF_ID_AIFF 0x41494646 /* "AIFF" */
- #define IFF_ID_COMM 0x434f4d4d /* "COMM" */
- #define IFF_ID_SSND 0x53534e44 /* "SSND" */
- #define IFF_ID_MPEG 0x4d504547 /* "MPEG" */
- 
- #define AIFF_FORM_HEADER_SIZE 12
- #define AIFF_SSND_HEADER_SIZE 16
- 
- 
- typedef struct  blockAlign_struct {
-     unsigned long   offset;
-     unsigned long   blockSize;
- } blockAlign;
- 
- typedef struct  IFF_AIFF_struct {
-     short           numChannels;
-     unsigned long   numSampleFrames;
-     short           sampleSize;
-     double          sampleRate;
-     unsigned long   sampleType;
-     blockAlign      blkAlgn;
- } IFF_AIFF;
- 
- enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
- extern enum byte_order NativeByteOrder;
- 
- /* "bit_stream.h" Type Definitions */
- 
- typedef struct  bit_stream_struc {
-     FILE        *pt;            /* pointer to bit stream device */
-     unsigned char *buf;         /* bit stream buffer */
-     int         buf_size;       /* size of buffer (in number of bytes) */
-     long        totbit;         /* bit counter of bit stream */
-     int         buf_byte_idx;   /* pointer to top byte in buffer */
-     int         buf_bit_idx;    /* pointer to top bit of top byte in buffer */
-     int         mode;           /* bit stream open in read or write mode */
-     int         eob;            /* end of buffer index */
-     int         eobs;           /* end of bit stream flag */
-     char        format;
-     
-     /* format of file in rd mode (BINARY/ASCII) */
- } Bit_stream_struc;
- 
- #include "l3side.h"
- 
- /***********************************************************************
- *
- *  Global Variable External Declarations
- *
- ***********************************************************************/
- 
- extern char     *mode_names[4];
- extern char     *layer_names[3];
- extern char	*version_names[2];
- extern double   s_freq[2][4];
- extern int      bitrate[2][3][15];
- extern double FAR multiple[64];
- 
- /***********************************************************************
- *
- *  Global Function Prototype Declarations
- *
- ***********************************************************************/
- 
- /* The following functions are in the file "common.c" */
- 
- #ifdef  PROTO_ARGS
- extern FILE           *OpenTableFile(char*);
- extern int            read_bit_alloc(int, al_table*);
- extern int            pick_table(frame_params*);
- extern int            js_bound(int, int);
- extern void           hdr_to_frps(frame_params*);
- extern void           WriteHdr(frame_params*, FILE*);
- extern void           WriteBitAlloc(unsigned int[2][SBLIMIT], frame_params*,
-                         FILE*);
- extern void           WriteScale(unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int[2][3][SBLIMIT],
-                         frame_params*, FILE*);
- extern void           WriteSamples(int, unsigned int FAR [SBLIMIT],
-                         unsigned int[SBLIMIT], frame_params*, FILE*);
- extern int            NumericQ(char*);
- extern int            BitrateIndex(int, int, int);
- extern int            SmpFrqIndex(long, int*);
- extern int            memcheck(char*, int, int);
- extern void           FAR *mem_alloc(unsigned long, char*);
- extern void           mem_free(void**);
- extern void           double_to_extended(double*, char[10]);
- extern void           extended_to_double(char[10], double*);
- extern int            aiff_read_headers(FILE*, IFF_AIFF*);
- extern int            aiff_seek_to_sound_data(FILE*);
- extern int            aiff_write_headers(FILE*, IFF_AIFF*);
- extern int            refill_buffer(Bit_stream_struc*);
- extern void           empty_buffer(Bit_stream_struc*, int);
- extern void           open_bit_stream_w(Bit_stream_struc*, char*, int);
- extern void           open_bit_stream_r(Bit_stream_struc*, char*, int);
- extern void           close_bit_stream_r(Bit_stream_struc*);
- extern void           close_bit_stream_w(Bit_stream_struc*);
- extern void           alloc_buffer(Bit_stream_struc*, int);
- extern void           desalloc_buffer(Bit_stream_struc*);
- extern void           back_track_buffer(Bit_stream_struc*, int);
- extern unsigned int   get1bit(Bit_stream_struc*);
- extern void           put1bit(Bit_stream_struc*, int);
- extern unsigned long  look_ahead(Bit_stream_struc*, int);
- extern unsigned long  getbits(Bit_stream_struc*, int);
- extern void           putbits(Bit_stream_struc*, unsigned int, int);
- extern void           byte_ali_putbits(Bit_stream_struc*, unsigned int, int);
- extern unsigned long  byte_ali_getbits(Bit_stream_struc*, int);
- extern unsigned long  sstell(Bit_stream_struc*);
- extern int            end_bs(Bit_stream_struc*);
- extern int            seek_sync(Bit_stream_struc*, long, int);
- extern void           I_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int*);
- extern void           II_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int*);
- extern void           update_CRC(unsigned int, unsigned int, unsigned int*);
- extern void           read_absthr(FLOAT*, int);
- extern unsigned int   hget1bit(); /* MI */
- extern unsigned long  hgetbits(int);
- extern unsigned long  hsstell();
- extern void           hputbuf(unsigned int,int);
- extern enum byte_order DetermineByteOrder();
- extern void SwapBytesInWords( short *loc, int words );
- 
- 
- #ifdef  MACINTOSH
- extern void           set_mac_file_attr(char[MAX_NAME_SIZE], short, OSType,
-                         OSType);
- #endif
- #ifdef MS_DOS
- extern void           new_ext(char *filename, char *extname, char *newname); 
- #endif
- 
- #else
- extern FILE           *OpenTableFile();
- extern int            read_bit_alloc();
- extern int            pick_table();
- extern int            js_bound();
- extern void           hdr_to_frps();
- extern void           WriteHdr();
- extern void           WriteBitAlloc();
- extern void           WriteScale();
- extern void           WriteSamples();
- extern int            NumericQ();
- extern int            BitrateIndex();
- extern int            SmpFrqIndex();
- extern int            memcheck();
- extern void           FAR *mem_alloc();
- extern void           mem_free();
- extern void           double_to_extended();
- extern void           extended_to_double();
- extern int            aiff_read_headers();
- extern int            aiff_seek_to_sound_data();
- extern int            aiff_write_headers();
- extern int            refill_buffer();
- extern void           empty_buffer();
- extern void           open_bit_stream_w();
- extern void           open_bit_stream_r();
- extern void           close_bit_stream_r();
- extern void           close_bit_stream_w();
- extern void           alloc_buffer();
- extern void           desalloc_buffer();
- extern void           back_track_buffer();
- extern unsigned int   get1bit();
- extern void           put1bit();
- extern unsigned long  look_ahead();
- extern unsigned long  getbits();
- extern void           putbits();
- extern void           byte_ali_putbits();
- extern unsigned long  byte_ali_getbits();
- extern unsigned long  sstell();
- extern int            end_bs();
- extern int            seek_sync();
- extern void           I_CRC_calc();
- extern void           II_CRC_calc();
- extern void           update_CRC();
- extern void           read_absthr();
- 
- extern unsigned int   hget1bit();
- extern unsigned long  hgetbits();
- extern unsigned long  hsstell();
- extern void           hputbuf();
- 
- #ifdef MS_DOS
- extern void           new_ext(); 
- #endif
- #endif
- #endif
--- 0 ----
diff -r -c -N encoder/configure lame3.70/configure
*** encoder/configure	Wed Jan 22 02:43:13 1997
--- lame3.70/configure	Wed Dec 31 17:00:00 1969
***************
*** 1,742 ****
- #!/bin/sh
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: configure,v 1.1 1996/02/14 04:06:24 rowlands Exp $
- ##
- ## $Log: configure,v $
- ## Revision 1.1  1996/02/14 04:06:24  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ##
- ############################################################################
- 
- # Guess values for system-dependent variables and create Makefiles.
- # Generated automatically using autoconf version 2.3 
- # Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.
- #
- # This configure script is free software; the Free Software Foundation
- # gives unlimited permission to copy, distribute and modify it.
- 
- # Defaults:
- ac_help=
- ac_default_prefix=/usr/local
- # Any additions from configure.in:
- 
- # Initialize some variables set by options.
- # The variables have the same names as the options, with
- # dashes changed to underlines.
- build=NONE
- cache_file=./config.cache
- exec_prefix=NONE
- host=NONE
- no_create=
- nonopt=NONE
- no_recursion=
- prefix=NONE
- program_prefix=NONE
- program_suffix=NONE
- program_transform_name=s,x,x,
- silent=
- site=
- srcdir=
- target=NONE
- verbose=
- x_includes=NONE
- x_libraries=NONE
- 
- # Initialize some other variables.
- subdirs=
- 
- ac_prev=
- for ac_option
- do
- 
-   # If the previous option needs an argument, assign it.
-   if test -n "$ac_prev"; then
-     eval "$ac_prev=\$ac_option"
-     ac_prev=
-     continue
-   fi
- 
-   case "$ac_option" in
-   -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
-   *) ac_optarg= ;;
-   esac
- 
-   # Accept the important Cygnus configure options, so we can diagnose typos.
- 
-   case "$ac_option" in
- 
-   -build | --build | --buil | --bui | --bu | --b)
-     ac_prev=build ;;
-   -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)
-     build="$ac_optarg" ;;
- 
-   -cache-file | --cache-file | --cache-fil | --cache-fi \
-   | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-     ac_prev=cache_file ;;
-   -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-   | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-     cache_file="$ac_optarg" ;;
- 
-   -disable-* | --disable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     eval "enable_${ac_feature}=no" ;;
- 
-   -enable-* | --enable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "enable_${ac_feature}='$ac_optarg'" ;;
- 
-   -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-   | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-   | --exec | --exe | --ex)
-     ac_prev=exec_prefix ;;
-   -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-   | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-   | --exec=* | --exe=* | --ex=*)
-     exec_prefix="$ac_optarg" ;;
- 
-   -gas | --gas | --ga | --g)
-     # Obsolete; use --with-gas.
-     with_gas=yes ;;
- 
-   -help | --help | --hel | --he)
-     # Omit some internal or obsolete options to make the list less imposing.
-     # This message is too long to be a string in the A/UX 3.1 sh.
-     cat << EOF
- Usage: configure [options] [host]
- Options: [defaults in brackets after descriptions]
- Configuration:
-   --cache-file=FILE       cache test results in FILE
-   --help                  print this message
-   --no-create             do not create output files
-   --quiet, --silent       do not print \`checking...' messages
-   --version               print the version of autoconf that created configure
- Directory and file names:
-   --prefix=PREFIX         install architecture-independent files in PREFIX
-                           [$ac_default_prefix]
-   --exec-prefix=PREFIX    install architecture-dependent files in PREFIX
-                           [same as prefix]
-   --srcdir=DIR            find the sources in DIR [configure dir or ..]
-   --program-prefix=PREFIX prepend PREFIX to installed program names
-   --program-suffix=SUFFIX append SUFFIX to installed program names
-   --program-transform-name=PROGRAM run sed PROGRAM on installed program names
- Host type:
-   --build=BUILD           configure for building on BUILD [BUILD=HOST]
-   --host=HOST             configure for HOST [guessed]
-   --target=TARGET         configure for TARGET [TARGET=HOST]
- Features and packages:
-   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-   --x-includes=DIR        X include files are in DIR
-   --x-libraries=DIR       X library files are in DIR
- --enable and --with options recognized:$ac_help
- EOF
-     exit 0 ;;
- 
-   -host | --host | --hos | --ho)
-     ac_prev=host ;;
-   -host=* | --host=* | --hos=* | --ho=*)
-     host="$ac_optarg" ;;
- 
-   -nfp | --nfp | --nf)
-     # Obsolete; use --without-fp.
-     with_fp=no ;;
- 
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c)
-     no_create=yes ;;
- 
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-     no_recursion=yes ;;
- 
-   -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-     ac_prev=prefix ;;
-   -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-     prefix="$ac_optarg" ;;
- 
-   -program-prefix | --program-prefix | --program-prefi | --program-pref \
-   | --program-pre | --program-pr | --program-p)
-     ac_prev=program_prefix ;;
-   -program-prefix=* | --program-prefix=* | --program-prefi=* \
-   | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-     program_prefix="$ac_optarg" ;;
- 
-   -program-suffix | --program-suffix | --program-suffi | --program-suff \
-   | --program-suf | --program-su | --program-s)
-     ac_prev=program_suffix ;;
-   -program-suffix=* | --program-suffix=* | --program-suffi=* \
-   | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-     program_suffix="$ac_optarg" ;;
- 
-   -program-transform-name | --program-transform-name \
-   | --program-transform-nam | --program-transform-na \
-   | --program-transform-n | --program-transform- \
-   | --program-transform | --program-transfor \
-   | --program-transfo | --program-transf \
-   | --program-trans | --program-tran \
-   | --progr-tra | --program-tr | --program-t)
-     ac_prev=program_transform_name ;;
-   -program-transform-name=* | --program-transform-name=* \
-   | --program-transform-nam=* | --program-transform-na=* \
-   | --program-transform-n=* | --program-transform-=* \
-   | --program-transform=* | --program-transfor=* \
-   | --program-transfo=* | --program-transf=* \
-   | --program-trans=* | --program-tran=* \
-   | --progr-tra=* | --program-tr=* | --program-t=*)
-     program_transform_name="$ac_optarg" ;;
- 
-   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-   | -silent | --silent | --silen | --sile | --sil)
-     silent=yes ;;
- 
-   -site | --site | --sit)
-     ac_prev=site ;;
-   -site=* | --site=* | --sit=*)
-     site="$ac_optarg" ;;
- 
-   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-     ac_prev=srcdir ;;
-   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-     srcdir="$ac_optarg" ;;
- 
-   -target | --target | --targe | --targ | --tar | --ta | --t)
-     ac_prev=target ;;
-   -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-     target="$ac_optarg" ;;
- 
-   -v | -verbose | --verbose | --verbos | --verbo | --verb)
-     verbose=yes ;;
- 
-   -version | --version | --versio | --versi | --vers)
-     echo "configure generated by autoconf version 2.3"
-     exit 0 ;;
- 
-   -with-* | --with-*)
-     ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "with_${ac_package}='$ac_optarg'" ;;
- 
-   -without-* | --without-*)
-     ac_package=`echo $ac_option|sed -e 's/-*without-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     eval "with_${ac_package}=no" ;;
- 
-   --x)
-     # Obsolete; use --with-x.
-     with_x=yes ;;
- 
-   -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-   | --x-incl | --x-inc | --x-in | --x-i)
-     ac_prev=x_includes ;;
-   -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-   | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-     x_includes="$ac_optarg" ;;
- 
-   -x-libraries | --x-libraries | --x-librarie | --x-librari \
-   | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-     ac_prev=x_libraries ;;
-   -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-     x_libraries="$ac_optarg" ;;
- 
-   -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
-     ;;
- 
-   *) 
-     if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
-       echo "configure: warning: $ac_option: invalid host type" 1>&2
-     fi
-     if test "x$nonopt" != xNONE; then
-       { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
-     fi
-     nonopt="$ac_option"
-     ;;
- 
-   esac
- done
- 
- if test -n "$ac_prev"; then
-   { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
- fi
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- # File descriptor usage:
- # 0 standard input
- # 1 file creation
- # 2 errors and warnings
- # 3 some systems may open it to /dev/tty
- # 4 used on the Kubota Titan
- # 6 checking for... messages and results
- # 5 compiler messages saved in config.log
- if test "$silent" = yes; then
-   exec 6>/dev/null
- else
-   exec 6>&1
- fi
- exec 5>./config.log
- 
- echo "\
- This file contains any messages produced by compilers while
- running configure, to aid debugging if configure makes a mistake.
- " 1>&5
- 
- # Strip out --no-create and --no-recursion so they do not pile up.
- # Also quote any args containing shell metacharacters.
- ac_configure_args=
- for ac_arg
- do
-   case "$ac_arg" in
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c) ;;
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
-   ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-   *) ac_configure_args="$ac_configure_args $ac_arg" ;;
-   esac
- done
- 
- # NLS nuisances.
- # Only set LANG and LC_ALL to C if already set.
- # These must not be set unconditionally because not all systems understand
- # e.g. LANG=C (notably SCO).
- if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
- if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
- 
- # confdefs.h avoids OS command line length limits that DEFS can exceed.
- rm -rf conftest* confdefs.h
- # AIX cpp loses on an empty file, so make sure it contains at least a newline.
- echo > confdefs.h
- 
- # A filename unique to this package, relative to the directory that
- # configure is in, which we can look for to find out if srcdir is correct.
- ac_unique_file=musicin.c
- 
- # Find the source files, if location was not specified.
- if test -z "$srcdir"; then
-   ac_srcdir_defaulted=yes
-   # Try the directory containing this script, then its parent.
-   ac_prog=$0
-   ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
-   test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
-   srcdir=$ac_confdir
-   if test ! -r $srcdir/$ac_unique_file; then
-     srcdir=..
-   fi
- else
-   ac_srcdir_defaulted=no
- fi
- if test ! -r $srcdir/$ac_unique_file; then
-   if test "$ac_srcdir_defaulted" = yes; then
-     { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
-   else
-     { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
-   fi
- fi
- srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
- 
- # Prefer explicitly selected file to automatically selected ones.
- if test -z "$CONFIG_SITE"; then
-   if test "x$prefix" != xNONE; then
-     CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-   else
-     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-   fi
- fi
- for ac_site_file in $CONFIG_SITE; do
-   if test -r "$ac_site_file"; then
-     echo "loading site script $ac_site_file"
-     . "$ac_site_file"
-   fi
- done
- 
- if test -r "$cache_file"; then
-   echo "loading cache $cache_file"
-   . $cache_file
- else
-   echo "creating cache $cache_file"
-   > $cache_file
- fi
- 
- ac_ext=c
- # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
- ac_cpp='$CPP $CPPFLAGS'
- ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5 2>&5'
- ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5 2>&5'
- 
- if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
-   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
-   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
-     ac_n= ac_c='
- ' ac_t='	'
-   else
-     ac_n=-n ac_c= ac_t=
-   fi
- else
-   ac_n= ac_c='\c' ac_t=
- fi
- 
- 
- 
- # Extract the first word of "gcc", so it can be a program name with args.
- set dummy gcc; ac_word=$2
- echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test -n "$CC"; then
-   ac_cv_prog_CC="$CC" # Let the user override the test.
- else
-   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
-   for ac_dir in $PATH; do
-     test -z "$ac_dir" && ac_dir=.
-     if test -f $ac_dir/$ac_word; then
-       ac_cv_prog_CC="gcc"
-       break
-     fi
-   done
-   IFS="$ac_save_ifs"
-   test -z "$ac_cv_prog_CC" && ac_cv_prog_CC="cc"
- fi
- fi
- CC="$ac_cv_prog_CC"
- if test -n "$CC"; then
-   echo "$ac_t""$CC" 1>&6
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.c <<EOF
- #ifdef __GNUC__
-   yes;
- #endif
- EOF
- if ${CC-cc} -E conftest.c 2>&5 | egrep yes >/dev/null 2>&1; then
-   ac_cv_prog_gcc=yes
- else
-   ac_cv_prog_gcc=no
- fi
- fi
- echo "$ac_t""$ac_cv_prog_gcc" 1>&6
- if test $ac_cv_prog_gcc = yes; then
-   GCC=yes
-   if test "${CFLAGS+set}" != set; then
-     echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc_g'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   echo 'void f(){}' > conftest.c
- if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-   ac_cv_prog_gcc_g=yes
- else
-   ac_cv_prog_gcc_g=no
- fi
- rm -f conftest*
- 
- fi
-     echo "$ac_t""$ac_cv_prog_gcc_g" 1>&6
-     if test $ac_cv_prog_gcc_g = yes; then
-       CFLAGS="-g -O"
-     else
-       CFLAGS="-O"
-     fi
-   fi
- else
-   GCC=
-   test "${CFLAGS+set}" = set || CFLAGS="-g"
- fi
- 
- 
- MATHLIBS="-lm"
- echo $ac_n "checking for -lieee""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_ieee'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lieee  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 485 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- main()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'ieee`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   MATHLIBS="$MATHLIBS -lieee"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- NINTSW=""
- echo $ac_n "checking for nint() in -lm""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_m'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lm  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 521 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- nint()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_m=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_m=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'m`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   NINTSW="-DHAVE_NINT"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- 
- trap '' 1 2 15
- cat > confcache <<\EOF
- # This file is a shell script that caches the results of configure
- # tests run on this system so they can be shared between configure
- # scripts and configure runs.  It is not useful on other systems.
- # If it contains results you don't want to keep, you may remove or edit it.
- #
- # By default, configure uses ./config.cache as the cache file,
- # creating it if it does not exist already.  You can give configure
- # the --cache-file=FILE option to use a different cache file; that is
- # what configure does when it calls configure scripts in
- # subdirectories, so they share the cache.
- # Giving --cache-file=/dev/null disables caching, for debugging configure.
- # config.status only pays attention to the cache file if you give it the
- # --recheck option to rerun configure.
- #
- EOF
- # Ultrix sh set writes to stderr and can't be redirected directly,
- # and sets the high bit in the cache file unless we assign to the vars.
- (set) 2>&1 |
-   sed -n "s/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=\${\1='\2'}/p" \
-   >> confcache
- if cmp -s $cache_file confcache; then
-   :
- else
-   if test -w $cache_file; then
-     echo "updating cache $cache_file"
-     cat confcache > $cache_file
-   else
-     echo "not updating unwritable cache $cache_file"
-   fi
- fi
- rm -f confcache
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- test "x$prefix" = xNONE && prefix=$ac_default_prefix
- # Let make expand exec_prefix.
- test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
- 
- # Any assignment to VPATH causes Sun make to only execute
- # the first set of double-colon rules, so remove it if not needed.
- # If there is a colon in the path, we need to keep it.
- if test "x$srcdir" = x.; then
-   ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
- fi
- 
- trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
- 
- # Transform confdefs.h into DEFS.
- # Protect against shell expansion while executing Makefile rules.
- # Protect against Makefile macro expansion.
- cat > conftest.defs <<\EOF
- s%#define \([A-Za-z_][A-Za-z0-9_]*\) \(.*\)%-D\1=\2%g
- s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
- s%\[%\\&%g
- s%\]%\\&%g
- s%\$%$$%g
- EOF
- DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
- rm -f conftest.defs
- 
- 
- # Without the "./", some shells look in PATH for config.status.
- : ${CONFIG_STATUS=./config.status}
- 
- echo creating $CONFIG_STATUS
- rm -f $CONFIG_STATUS
- cat > $CONFIG_STATUS <<EOF
- #! /bin/sh
- # Generated automatically by configure.
- # Run this file to recreate the current configuration.
- # This directory was configured as follows,
- # on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
- #
- # $0 $ac_configure_args
- #
- # Compiler output produced by configure, useful for debugging
- # configure, is in ./config.log if it exists.
- 
- ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
- for ac_option
- do
-   case "\$ac_option" in
-   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
-     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
-   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-     echo "$CONFIG_STATUS generated by autoconf version 2.3"
-     exit 0 ;;
-   -help | --help | --hel | --he | --h)
-     echo "\$ac_cs_usage"; exit 0 ;;
-   *) echo "\$ac_cs_usage"; exit 1 ;;
-   esac
- done
- 
- ac_given_srcdir=$srcdir
- 
- trap 'rm -fr `echo "Makefile" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
- 
- # Protect against being on the right side of a sed subst in config.status. 
- sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\\\&%]/\\\\&/g; 
-  s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
- $ac_vpsub
- $extrasub
- s%@CFLAGS@%$CFLAGS%g
- s%@CPPFLAGS@%$CPPFLAGS%g
- s%@CXXFLAGS@%$CXXFLAGS%g
- s%@DEFS@%$DEFS%g
- s%@LDFLAGS@%$LDFLAGS%g
- s%@LIBS@%$LIBS%g
- s%@exec_prefix@%$exec_prefix%g
- s%@prefix@%$prefix%g
- s%@program_transform_name@%$program_transform_name%g
- s%@CC@%$CC%g
- s%@MATHLIBS@%$MATHLIBS%g
- s%@NINTSW@%$NINTSW%g
- 
- CEOF
- EOF
- cat >> $CONFIG_STATUS <<EOF
- 
- CONFIG_FILES=\${CONFIG_FILES-"Makefile"}
- EOF
- cat >> $CONFIG_STATUS <<\EOF
- for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
-   # Support "outfile[:infile]", defaulting infile="outfile.in".
-   case "$ac_file" in
-   *:*) ac_file_in=`echo "$ac_file"|sed 's%.*:%%'`
-        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-   *) ac_file_in="${ac_file}.in" ;;
-   esac
- 
-   # Adjust relative srcdir, etc. for subdirectories.
- 
-   # Remove last slash and all that follows it.  Not all systems have dirname.
-   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-     # The file is in a subdirectory.
-     test ! -d "$ac_dir" && mkdir "$ac_dir"
-     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
-     # A "../" for each directory in $ac_dir_suffix.
-     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
-   else
-     ac_dir_suffix= ac_dots=
-   fi
- 
-   case "$ac_given_srcdir" in
-   .)  srcdir=.
-       if test -z "$ac_dots"; then top_srcdir=.
-       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
-   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
-   *) # Relative path.
-     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
-     top_srcdir="$ac_dots$ac_given_srcdir" ;;
-   esac
- 
-   echo creating "$ac_file"
-   rm -f "$ac_file"
-   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
-   case "$ac_file" in
-   *Makefile*) ac_comsub="1i\\
- # $configure_input" ;;
-   *) ac_comsub= ;;
-   esac
-   sed -e "$ac_comsub
- s%@configure_input@%$configure_input%g
- s%@srcdir@%$srcdir%g
- s%@top_srcdir@%$top_srcdir%g
- " -f conftest.subs $ac_given_srcdir/$ac_file_in > $ac_file
- fi; done
- rm -f conftest.subs
- 
- 
- 
- exit 0
- EOF
- chmod +x $CONFIG_STATUS
- rm -fr confdefs* $ac_clean_files
- test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
- 
--- 0 ----
diff -r -c -N encoder/debugscalefac.c lame3.70/debugscalefac.c
*** encoder/debugscalefac.c	Wed Dec 31 17:00:00 1969
--- lame3.70/debugscalefac.c	Wed Nov 24 01:43:46 1999
***************
*** 0 ****
--- 1,139 ----
+      {
+ /*******************************************************************
+ 
+ DEBUG INFORMATION 
+ criticalbands (scalefactor bands)
+ partition bands
+ FFT bands
+ MDCT bands 
+ 
+ *******************************************************************/
+ 
+ #include "tables.h"
+  int *scalefac_band_long; 
+  int *scalefac_band_short;
+  FLOAT fstart,fstop;
+  FLOAT mstart,mstop;
+  
+ 
+  scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
+  scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
+ 
+  printf("\n\n long block partiton  bands \n");
+  for (b = 0; b<CBANDS; b++) {
+    /* look for FFT partition band bu_l[b]*/
+    for (i=0;i<HBLKSIZE;i++, fstart=i) {
+      if (partition_l[i]==b) break;
+    }
+    fstop=0;
+    for (i=HBLKSIZE-1;i>=0;i--, fstart=i) {
+      if (partition_l[i]==b) break;
+    }
+ 
+    if(fstart>0) fstart -= .5;
+    fstop += .5;
+    printf("pb=%2i  FFT=(%4.1f,%4.1f)  numlines=%i  norm=%f  \n",
+          b,fstart,fstop,numlines_l[b],norm_l[b]);
+ 
+  }
+ 
+ 
+  
+  printf("\n\n long block critial bands \n");
+  printf("crit band,part_band, part_band range  FFT range MDCT range \n");
+  for ( b = 0;b < SBPSY_l; b++ ) {
+ 
+    /* look for FFT partition band bu_l[b]*/
+    for (i=0;i<HBLKSIZE;i++, fstart=i) {
+      if (partition_l[i]==bu_l[b]) break;
+    }
+    for (i=HBLKSIZE-1;i>=0;i--, fstop=i) {
+      if (partition_l[i]==bo_l[b]) break;
+    }
+ 
+ 
+    /* numlines_l[pb] = number of FFT lines in partition band pb */
+    /* w1 = 1, then all FFT lines belong to this partition band */
+    fstart += ( (1-w1_l[b])*numlines_l[ bu_l[b] ] ) ;
+ 
+    /* w2 = 1, then all FFT lines belong to this partition band */
+    fstop -= ( (1-w2_l[b])*numlines_l[ bo_l[b] ] ) ;
+ 
+ 
+    if (fstart>0) fstart -= .5;  /* contribution extends to center of freq band */
+    fstop += .5;
+ 
+    mstart = scalefac_band_long[b];
+    mstop  = scalefac_band_long[b+1]-1;
+    if (mstart>0) mstart -= .5;
+    mstop += .5;
+ 
+    printf("cb=%2i(%2i)(%2i,%2i)(%3.2f,%3.2f)  FFT:(%4.1f,%4.1f)(%5.0f,%5.0f)Hz   MDCT:(%5.1f,%5.1f)(%5.0f,%5.0f)Hz \n",
+            b,npart_l_orig,bu_l[b],bo_l[b],w1_l[b],w2_l[b],
+ 	  fstart,fstop,sfreq*fstart/BLKSIZE,sfreq*fstop/BLKSIZE,
+ 	  mstart,mstop,mstart*.5*sfreq/576,mstop*.5*sfreq/576
+            );
+  }
+ 
+ 
+ 
+ 
+ 
+  printf("\n\n short block partition bands \n");
+  for (b = 0; b<CBANDS; b++) {
+    /* look for FFT partition band bu_s[b]*/
+    for (i=0;i<HBLKSIZE_s;i++,fstart=i) {
+      if (partition_s[i]==b) break;
+    }
+    for (i=HBLKSIZE_s-1; i>=0; i--,fstop=i) {
+      if (partition_s[i]==b) break;
+    }
+ 
+    if(fstart>0) fstart -= .5;
+    fstop += .5;
+    printf("pb=%2i  FFT=(%4.1f,%4.1f)  numlines=%i norm=%f \n",
+ 	  b,fstart,fstop,numlines_s[b],norm_s[b]);
+ 
+  }
+ 
+ 
+  
+  printf("\n\n short block critial bands \n");
+  printf("crit band,part_band, part_band range  FFT range MDCT range \n");
+  for ( b = 0;b < SBPSY_s; b++ ) {
+ 
+    /* look for FFT partition band bu_s[b]*/
+    for (i=0;i<HBLKSIZE_s;i++)  
+      if (partition_s[i]==bu_s[b]) {fstart=i;break;}
+    for (i=HBLKSIZE_s-1;i>=0;i--) 
+      if (partition_s[i]==bo_s[b]) {fstop=i; break;}
+ 
+ 
+    /* numlines_s[pb] = number of FFT lines in partition band pb */
+    /* w1 = 1, then all FFT lines belong to this partition band */
+    fstart += ( (1-w1_s[b])*numlines_s[ bu_s[b] ] ) ;
+ 
+    /* w2 = 1, then all FFT lines belong to this partition band */
+    fstop -= ( (1-w2_s[b])*numlines_s[ bo_s[b] ] ) ;
+ 
+ 
+    if (fstart>0) fstart -= .5;  /* contribution extends to center of freq band */
+    fstop += .5;
+ 
+    mstart = scalefac_band_short[b];
+    mstop  = scalefac_band_short[b+1]-1;
+    if (mstart>0) mstart -= .5;
+    mstop += .5;
+ 
+    printf("cb=%2i(%2i)(%2i,%2i)(%3.2f,%3.2f)  FFT:(%4.1f,%4.1f)(%5.0f,%5.0f)Hz   MDCT:(%5.1f,%5.1f)(%5.0f,%5.0f)Hz \n",
+            b,npart_s_orig,bu_s[b],bo_s[b],w1_s[b],w2_s[b],
+ 	  fstart,fstop,sfreq*fstart/BLKSIZE_s,sfreq*fstop/BLKSIZE_s,
+ 	  mstart,mstop,mstart*.5*sfreq/192,mstop*.5*sfreq/192
+            );
+  }
+ 
+ 
+ /*******************************************************************
+ END DEBUG INFORMATION 
+ *******************************************************************/
+      }
diff -r -c -N encoder/doc/CVS/Entries lame3.70/doc/CVS/Entries
*** encoder/doc/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/CVS/Entries	Thu Apr  6 12:50:48 2000
***************
*** 0 ****
--- 1,2 ----
+ D/html////
+ D/man////
diff -r -c -N encoder/doc/CVS/Repository lame3.70/doc/CVS/Repository
*** encoder/doc/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/CVS/Repository	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ lame/doc
diff -r -c -N encoder/doc/CVS/Root lame3.70/doc/CVS/Root
*** encoder/doc/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/CVS/Root	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/doc/CVS/Tag lame3.70/doc/CVS/Tag
*** encoder/doc/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/CVS/Tag	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/doc/html/CVS/Entries lame3.70/doc/html/CVS/Entries
*** encoder/doc/html/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/CVS/Entries	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,11 ----
+ /contributors.html/1.5/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /examples.html/1.3/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /history.html/1.11.4.2/Thu Apr  6 18:50:53 2000//Tlame3_70
+ /id3.html/1.4/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /index.html/1.6/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /lame.css/1.3/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /node5.html/1.1.1.1/Wed Nov 24 08:44:08 1999//Tlame3_70
+ /node6.html/1.4/Wed Mar 29 20:49:02 2000//Tlame3_70
+ /node7.html/1.3/Mon Jan  3 05:15:41 2000//Tlame3_70
+ /switchs.html/1.6/Wed Mar 29 20:49:02 2000//Tlame3_70
+ D
diff -r -c -N encoder/doc/html/CVS/Repository lame3.70/doc/html/CVS/Repository
*** encoder/doc/html/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/CVS/Repository	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ lame/doc/html
diff -r -c -N encoder/doc/html/CVS/Root lame3.70/doc/html/CVS/Root
*** encoder/doc/html/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/CVS/Root	Thu Apr  6 12:50:35 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/doc/html/CVS/Tag lame3.70/doc/html/CVS/Tag
*** encoder/doc/html/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/CVS/Tag	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/doc/html/contributors.html lame3.70/doc/html/contributors.html
*** encoder/doc/html/contributors.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/contributors.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,132 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <!-- saved from url=(0051)http://internet.roadrunner.com/~mt/mp3/history.html -->
+ <HTML><HEAD><TITLE>Contributors</TITLE>
+ <META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
+ <META content="MSHTML 5.00.2014.210" name=GENERATOR><link rel="stylesheet" href="lame.css"></HEAD>
+ <BODY aLink=#bbbbbb bgColor=#ffffff link=#888888 text=#000000 vLink=#555555>
+ <CENTER>
+   <H1>Contributors</H1>
+ </CENTER>
+ <HR>
+ <H4>The following people contributed to the LAME development:</H4>
+ <p> Lauri Ahonen<br>
+   Sakari Ailus<br>
+   Tero Auvinen<br>
+   Alex Ballegooy<br>
+   Wilfried Behne<br>
+   Bob Bell<br>
+   Segher Boessenkool<br>
+   Lionel Bonnet<br>
+   Gabriel Bouvigne<br>
+   Erik de Castro Lopo<br>
+   Michael Cheng<br>
+   Goran Dokic<br>
+   James Droppo<br>
+   Sergey Dubov <br>
+   Alvaro Martinez Echevarria<br>
+   Joakim Enerstam <br>
+   Albert Faber<br>
+   Nils Faerber<br>
+   Sami Farin<br>
+   Mikhail M. Fedotov<br>
+   Joseph Fourier<br>
+   Jani Frilander<br>
+   Richard Gorton<br>
+   Steffan Haeuser<br>
+   Jeremy Hall<br>
+   Paul Hartman<br>
+   John Hayward-Warburton<br>
+   Robert Hegemann<br>
+   Mathew Hendry<br>
+   Ben "Jacobs"<br>
+   Mo Katz<br>
+   Iwasa Kazmi<br>
+   Joachim Kuebart <br>
+   Leonid Kulakov<br>
+   An van Lam<br>
+   Juha Laukala<br>
+   Felix von Leitner <br>
+   Rafael Luebbert<br>
+   Macik<br>
+   Lars Magne Ingebrigtsen<br>
+   Scott Manley<br>
+   Vladimir Marek<br>
+   Sergey A. Maslyakov<br>
+   Chris Matrakidis<br>
+   Greg Maxwell<br>
+   Scott Miller<br>
+   Kimmo Mustonen <br>
+   Dan Nelson<br>
+   Anton Oleynikov<br>
+   Mike Oliphant<br>
+   Andr&eacute; Osterhues<br>
+   Johannes Overmann<br>
+   Jan Peman<br>
+   Jan Rafaj<br>
+   Gertjan van Ratingen<br>
+   Miguel Revilla Rodriguez<br>
+   Tim Ruddick<br>
+   Ingo Saitz<br>
+   Conrad Sanderson<br>
+   Sergey Sapelin<br>
+   William Schelter<br>
+   Sigbjrn Skjret<br>
+   Nathan Slingerland<br>
+   Patrick De Smet<br>
+   Acy Stapp<br>
+   Mark Stephens<br>
+   Stephane Tavenard<br>
+   Mark Taylor<br>
+   Brad Threatt<br>
+   Takehiro Tominaga<br>
+   Warren Toomey<br>
+   Martin Weghofer<br>
+   Gerhard Wesp<br>
+   Alfred Weyers<br>
+   Ethan Yeo<br>
+   Chuck Zenkus </p>
+ <p>&nbsp;</p>
+ <h4>Original ISO contributors:</h4>
+ <p>Bill Aspromonte<br>
+   Shaun Astarabadi<br>
+   R. Bittner<br>
+   Karlheinz Brandenburg<br>
+   W. Joseph Carter<br>
+   Jack Chang<br>
+   Mike Coleman<br>
+   Johnathan Devine<br>
+   Ernst Eberlein<br>
+   Dan Ellis<br>
+   Peter Farrett<br>
+   Jean-Georges Fritsch<br>
+   Vlad Fruchter<br>
+   Hendrik Fuchs<br>
+   Bernhard Grill<br>
+   Amit Gulati<br>
+   Munsi Haque<br>
+   Chuck Hsiao<br>
+   Toshiyuki Ishino<br>
+   Masahiro Iwadare<br>
+   Earl Jennings<br>
+   James Johnston<br>
+   Leon v.d. Kerkhof<br>
+   Don Lee<br>
+   Mike Li<br>
+   Yu-Tang Lin<br>
+   Soren Neilsen<br>
+   Simao F. Campos Neto<br>
+   Mark Paley<br>
+   Davis Pan<br>
+   Tan Ah Peng<br>
+   Kevin Peterson<br>
+   Juan Pineda<br>
+   Ernst F. Schroeder<br>
+   Peter Siebert<br>
+   Jens Spille<br>
+   Sam Stewart<br>
+   Al Tabayoyon<br>
+   Kathy Wang<br>
+   Franz-Otto Witte<br>
+   Douglas Wong</p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/examples.html lame3.70/doc/html/examples.html
*** encoder/doc/html/examples.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/examples.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,52 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <HTML>
+ <HEAD>
+    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
+    <META NAME="description" CONTENT="Some examples">
+    <META NAME="keywords" CONTENT="lame">
+    <META NAME="resource-type" CONTENT="document">
+    <META NAME="distribution" CONTENT="global">
+    <META NAME="GENERATOR" CONTENT="Mozilla/4.08 [en] (X11; I; Linux 2.0.36 i686) [Netscape]">
+    <TITLE>Some command line examples</TITLE>
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node8.html">
+ <LINK REL="previous" HREF="node6.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node8.html">
+ </HEAD>
+ <BODY TEXT="#000000" BGCOLOR="#F9FBFB" LINK="#006666" VLINK="#4C4C4C" ALINK="#995500">
+ <H1><FONT FACE="Helvetica">Some command line examples</FONT></H1>
+ <UL>
+   <LI> Fixed bit rate jstereo 128kbs encoding:<br>
+     <kbd>lame sample.wav sample.mp3</kbd><br>
+     <br>
+   </LI>
+   <LI> Fixed bit rate jstereo 128kbs encoding, highest quality (recommended):<br>
+     <kbd>lame -h sample.wav sample.mp3</kbd><br>
+     <br>
+   </LI>
+   <LI> Fixed bit rate jstereo 112kbs encoding:<br>
+     <kbd>lame -b 112 sample.wav sample.mp3</kbd><br>
+     <br>
+   </LI>
+   <LI>To disable joint stereo encoding (slightly faster, but less quality at bitrates<=128kbs):<br>
+     <kbd>lame -m s sample.wav sample.mp3<br>
+     <br>
+     </kbd></LI>
+   <LI>Fast encode, low quality (no psycho-acoustics):<br>
+     <kbd>lame -f sample.wav sample.mp3<br>
+     <br>
+     </kbd></LI>
+   <LI>Variable bitrate (use -V n to adjust quality/filesize):<br>
+     <kbd>lame -h -V 6 sample.wav sample.mp3<br>
+     <br>
+     </kbd></LI>
+   <LI>Streaming mono 22.05kHz raw pcm, 24kbs output:<br>
+     <kbd>cat inputfile | lame -r -m m -b 24 -s 22.05 -- > output<br>
+     <br>
+     </kbd></LI>
+   <LI>Streaming mono 44.1kHz raw pcm, with downsampling to 22.05 kHz:<br>
+     <kbd>cat inputfile | lame -r -m m -b 24 --resample 22.05 -- > output</kbd></LI>
+ </UL>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/history.html lame3.70/doc/html/history.html
*** encoder/doc/html/history.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/history.html	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,1632 ----
+ <!doctype html public "-//w3c//dtd html 4.0 transitional//en">
+ <html>
+ <head>
+    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
+    <meta name="GENERATOR" content="Mozilla/4.7 [en] (X11; I; Linux 2.2.12-20 i686) [Netscape]">
+    <title> LAME Changelog</title>
+ </head>
+ <body text="#000000" bgcolor="#FFFFFF" link="#888888" vlink="#555555" alink="#BBBBBB">
+ 
+ <center>
+ <h1>
+ History</h1></center>
+ Starting with LAME 3.0:
+ <br><font color="#FF0000">red = features and bug fixes which effect quality</font>
+ <br><font color="#3366FF">blue = features and bug fixes which effect speed</font>
+ <br>black = usability, portability, other
+ <h3>
+ 
+ <hr></h3>
+ 
+ <h3>
+ LAME 3.80beta&nbsp; (CVS)</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; more efficient and faster
+ huffman encoding!</font></li>
+ 
+ <li>
+ <font color="#000000">Tomasz Motylewski and Mark Taylor:&nbsp; MPEG2.5
+ now supported!</font></li>
+ 
+ <li>
+ <font color="#000000">Mark Taylor: incorporated Takehiro's bitstream.c!&nbsp;
+ This replaces the last of the ISO code.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Scott&nbsp; Manley and Mark Taylor:&nbsp; good resampling
+ routine finaly in LAME.&nbsp; uses a 19 point FIR filter with Blackman
+ window.&nbsp; Very slow for non integer resampling ratios.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.70&nbsp;&nbsp; April 6 2000</h3>
+ 
+ <ul>
+ <li>
+ "spahm":&nbsp; default mode selection bug fixed.&nbsp; In some cases, lame
+ was defaulting to regular stereo instead of jstereo when the user did not
+ specify a mode.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.68beta&nbsp; April 4 2000</h3>
+ 
+ <ul>
+ <li>
+ Mark Taylor: mono encoding bug in DLL fixed.</li>
+ 
+ <li>
+ Ingo Saitz: bug in --cwlimit argument parsing fixed.</li>
+ 
+ <li>
+ <font color="#FF0000">Scott Manly: bug in 4-point resample code fixed.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.67beta&nbsp; March 27 2000</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Robert Hegemann:&nbsp; jstereo now enabled for MPEG2
+ encodings</font></li>
+ 
+ <li>
+ Mark Taylor: old M/S stereo mode which used L/R maskings has been removed.</li>
+ 
+ <li>
+ Mark Taylor: Xing MPEG2 VBR headers now working.</li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor:&nbsp; When quantized coefficients are
+ all 0 in a band, set scalefactors to 0 also to save a few bits.</font></li>
+ 
+ <li>
+ <font color="#000000">Ingo Saitz:&nbsp; Problems with framesize calculation
+ when using -f fast-math option fixed.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.66beta March 21 2000</h3>
+ 
+ <ul>
+ <li>
+ Bug fixes in BladeEnc DLL, possible click in last mp3 frame, VBR historgram
+ display, byteswapping option, ASM quantize routines work for both float
+ and double.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.65beta&nbsp;&nbsp; March 17 2000</h3>
+ 
+ <ul>
+ <li>
+ Enabled ASM version of quantize_xrpow() - accidently disabled in lame3.64.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.64beta&nbsp; March 16 2000</h3>
+ 
+ <ul>
+ <li>
+ Don Melton:&nbsp; id3v1.1 tags &amp; id3 bugfixes</li>
+ 
+ <li>
+ <font color="#FF0000">Gabriel Bouvigne:&nbsp; L/R matching block type fix</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug fixed which was allowing quantized values to
+ exceed the maximum when not using -h</font></li>
+ 
+ <li>
+ <font color="#3366FF">Mark Taylor: Fitlers based on polyphase filterbank.&nbsp;
+ should be slightly better since the responce is independent of the blocktype,
+ and they are slightly faster.</font></li>
+ 
+ <li>
+ Mark Taylor: API:&nbsp; the API changed slightly - and this should be the
+ final version. There is a new routine: lame_encode_buffer() which takes
+ an arbritray sized input buffer, resamples &amp; filters if necessary,
+ encodes, and returns the mp3buffer.&nbsp; There are also several new #defines,
+ so it is possible to compile a simple encoding library with no decoding
+ or file I/O or command line parsing.&nbsp; see the file API for details.</li>
+ 
+ <li>
+ Mark Taylor: MSVC stuff:&nbsp; lame.exe (with and without the frame analyzer)
+ and the CDex lame_enc.dll</li>
+ 
+ <br>should compile under MSVC.&nbsp; The MSVC5 project files may need some
+ tweaking.&nbsp; In particular,
+ <br>you need to make sure LAMEPARSE, LAMESNDFILE and HAVEMPGLIB
+ <br>are defined.&nbsp; (and HAVEGTK for the GTK stuff).</ul>
+ 
+ <h3>
+ LAME 3.63beta&nbsp; February 20&nbsp; 2000</h3>
+ 
+ <ul>
+ <li>
+ Robert Hegemann:&nbsp; FPE with -h fixed?</li>
+ 
+ <li>
+ Mathey Hendry:&nbsp; FPE error catching for Cygwin, FPE fix for vbr mode
+ and output to /dev/null</li>
+ 
+ <li>
+ Jeremy Hall:&nbsp; Fixed problems with input files where the number of
+ samples is not known.</li>
+ 
+ <li>
+ <font color="#3366FF">Mathew Hendry:&nbsp; ASM quantize_xrpow() for GNU
+ i386</font></li>
+ 
+ <li>
+ <font color="#3366FF">Wilfried Behne&nbsp; quantize_xrpow ()for PowerPC
+ and non-ASM</font></li>
+ 
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; GOGO FFTs&nbsp; (not yet
+ used?)</font></li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.62beta&nbsp;&nbsp; February 9 2000</h3>
+ 
+ <ul>
+ <li>
+ <font color="#000000">Iwasa Kazmi:&nbsp; frame analyzer short block display
+ of single subblocks (press 1,2&nbsp; or 3)</font></li>
+ 
+ <li>
+ <font color="#000000">Ingo Saitz:&nbsp; --help option added, with output
+ to stdout</font></li>
+ 
+ <li>
+ <font color="#FF0000">Alfred Weyers: short block AAC spreading function
+ bug fixed</font></li>
+ 
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; new scalefac data structure
+ - improves performance!</font></li>
+ 
+ <li>
+ <font color="#FF0000">Lionel Bonnet:&nbsp; Bug fixed in MPEG2 scalefactor
+ routine: scalefactors were being severly limited.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; faster FFT routines from.&nbsp;
+ These routines are also compatible with the GOGO routines, in case someone
+ is interested in porting them back to LAME.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Sigbj&oslash;rn Skj&aelig;ret, Takehiro Tominaga:&nbsp;
+ faster pow() code.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Joachim Kuebart:&nbsp; Found some unitialized variables
+ that were effecting quality for encodings which did not use the -h option
+ (now fixed).</font></li>
+ 
+ <li>
+ Mark Taylor: More modularization work.&nbsp;&nbsp; It is now possible to
+ use LAME as a library where you can set the encoding parameters directly
+ and do your own file i/o.&nbsp;&nbsp; The calling program is now it's own
+ mp3 output.&nbsp; For an example of the LAME API, see main.c, or mp3rtp.c
+ or mp3x.c.&nbsp; These can all be compiled as stand alone programs which
+ link with libmp3lame.a.</li>
+ 
+ <li>
+ Felix vos Leitner:&nbsp; mp3rtp fixes.&nbsp; mp3rtp is a standalone program
+ which will encode and stream with RTP.</li>
+ 
+ <li>
+ Robert Hegemann:&nbsp; Information written to stderr displaying exactly
+ which type of lowpass filter (if any) is being used.</li>
+ 
+ <li>
+ Iwasa Kazmi:&nbsp; mpglib (the mpg123 decoder) scsfi decoding fixes.</li>
+ 
+ <li>
+ Takehiro Tominaga:&nbsp; More mpglib scsfi decoding fixes.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.61beta&nbsp; January 14 2000</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Mark Taylor: Fixed bug with lowpass filters when
+ using VBR with a 64kbs or lower min bitrate setting.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; more efficient huffman encoding
+ splitting.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.60beta&nbsp;&nbsp; January 9 2000</h3>
+ 
+ <ul>
+ <li>
+ Mark Taylor: Distribution now comes with self test.&nbsp; Needs work to
+ be automated, see 'make test' in Makefile.</li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor: AAC spreading function now the default</font></li>
+ 
+ <li>
+ Gabriel Bouvigne: updated HTML docs</li>
+ 
+ <li>
+ Felix von Leitner: compute correct file length from Xing header (if present)
+ when input file is a mp3 file</li>
+ 
+ <li>
+ Felix von Leitner: mp3rtp (standalone) program now included.&nbsp; Not
+ yet tested.&nbsp; mp3rtp ip:port:ttl&nbsp; &lt;infile>&nbsp;&nbsp; /dev/null
+ will stream directly to ip:port using&nbsp; RTP.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.59beta&nbsp; January 4 2000</h3>
+ 
+ <ul>
+ <li>
+ Takehiro Tominaga:&nbsp; --noath option.&nbsp; Disables ATH maskings.</li>
+ 
+ <li>
+ Gabriel Bouvigne:&nbsp; updated HTML docs.</li>
+ 
+ <li>
+ Iwasa Kazmi:&nbsp; makefile fixes</li>
+ 
+ <li>
+ Mark Taylor:&nbsp; Fixed bug where first frame of data was always overwritten
+ with 0's.&nbsp; Thanks to 'gol'</li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor:&nbsp; bug fixes in mid/side masking
+ ratios (thanks to Menno Bakker)</font></li>
+ 
+ <li>
+ Mark Taylor:&nbsp; replaced norm_l, norm_s table data with formulas.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.58beta&nbsp; December 13 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Segher Boessenkool:&nbsp; More accurate quantization
+ procedure!&nbsp; Enabled with -h.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Mathew Hendry, Acy Stapp and Takehiro Tominaga: ASM
+ optimizations for quantize_xrpow and quantize_xrpow_ISO.</font></li>
+ 
+ <li>
+ Chuck Zenkus:&nbsp; "encoder inside" logo on web page</li>
+ 
+ <li>
+ Mark Taylor:&nbsp;&nbsp; a couple people have asked for this.&nbsp;&nbsp;
+ Allow LAME to overide VBR_min_bitrate if analog_silence detected.&nbsp;&nbsp;
+ Analog_silence defined a la Robert:&nbsp;&nbsp; energy&nbsp; &lt; ATH.</li>
+ 
+ <li>
+ An Van Lam: Valid bitrates were being printed for layer 2, not layer 3!</li>
+ 
+ <li>
+ Ethan Yeo:&nbsp; Makefile.MSVC updated</li>
+ 
+ <li>
+ Mark Stephens:&nbsp; updated all MSVC project files</li>
+ 
+ <li>
+ Robert Hegemann:&nbsp; lowpass and highpass filters can be enabled with
+ --lowpass, --highpass</li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor:&nbsp; MS switching is now smoother:
+ ms_ratio average over 4 granules</font></li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; Scalefactor pre-emphasis
+ fixed (and now turned back on)</font></li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; Bug in M/S maskings:&nbsp;
+ switch to turn on stereo demasking code was buggy.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.57beta&nbsp; November 22 1999</h3>
+ 
+ <ul>
+ <li>
+ Sigbj&oslash;rn Skj&aelig;ret, patch to allow encoding from 8bit input
+ files when using LIBSNDFILE</li>
+ 
+ <li>
+ Mark Taylor: Automatic downsampling to nearest valid samplerate.</li>
+ 
+ <li>
+ Mark Taylor: Scalefactor bands demarked on MDCT plot in frameanalyzer</li>
+ 
+ <li>
+ Mark Taylor: Scalefactor preemphasis disabled for now.&nbsp;&nbsp; The
+ algorithm was often doing more harm than good.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.56beta&nbsp; November 19 1999</h3>
+ 
+ <ul>
+ <li>
+ Kimmo Mustonen: portabilty code cleanup.</li>
+ 
+ <li>
+ Vladimir Marek: id3 genre patch.</li>
+ 
+ <li>
+ Conrad Sanderson: new applypatch script.</li>
+ 
+ <li>
+ Mark Taylor: Initial window type now "STOP_TYPE" to reduce initial attenuation.&nbsp;
+ This is needed because the new encoder delay is so short.&nbsp; With a
+ NORM_TYPE, the first 240 samples would be attenuated.</li>
+ 
+ <li>
+ Mark Taylor: Padding at end of file now adjusted (hopefully!) to produce
+ as little padding as possible while still guarantee all input samples are
+ encoded.</li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; Reduced shortblock extra
+ bit allocation formulas by 10% since new huffman coding is at least 10%
+ more efficient.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.55beta&nbsp; November 11 1999</h3>
+ 
+ <ul>
+ <li>
+ Albert Faber:&nbsp; updated BladeEnc.dll</li>
+ 
+ <li>
+ Mark Taylor: Simple lowpass filter added to linear downsampling routine.</li>
+ 
+ <li>
+ Nils Faerber: updated man page.</li>
+ 
+ <li>
+ Mark Taylor: All floating point variables are delcared FLOAT or&nbsp; FLOAT8.&nbsp;
+ Change the definition of FLOAT8 in machine.h to run at 32bit preceision.</li>
+ 
+ <li>
+ Mark Taylor: Bug (introduced in 3.54beta) in stereo->mono downsampling
+ fixed.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.54beta&nbsp; November 8 1999</h3>
+ 
+ <ul>
+ <li>
+ Mark Taylor: Encoder delay is now 48 samples.&nbsp; Can be adjusted to
+ 1160 to sync with FhG (see ENCDELAY in encoder.h)&nbsp; This is kind of
+ amazing, since if Takehiro put his MDCT/filterbank routine in a decoder,
+ we could have a total&nbsp; delay of only 96 samples.</li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor: More inconstancies found and fixed in
+ MPEG2 tables.</font></li>
+ 
+ <li>
+ Mark Taylor: Resampling from an MP3 input file now works.&nbsp; But we
+ still dont have a lowpass filter so dont expect good results.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.53beta&nbsp; November 8 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; Fixed MPEG2 problem in new
+ MDCT routines.&nbsp; Takehiro's combined filterbank/MDCT routine is now
+ the default.&nbsp; Removes all buffering from psymodel.c and the filterbanks/MDCT
+ routines.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.52beta&nbsp; November 8 1999</h3>
+ 
+ <ul>
+ <li>
+ By permission of copyright holders of all GPL code in LAME,&nbsp; all GPL
+ code is now released under a modified version of the LGPL (see the README
+ file)</li>
+ 
+ <li>
+ By popular demand, all C++ comments changed to C style comments</li>
+ 
+ <li>
+ Mark Taylor: Linear resampling now works.&nbsp; Use --resample to set an
+ output samplerate different from the input samplerate.&nbsp; (doesn't seem
+ to work with mp3 input files, and there is no lowpass filter, so dont expect
+ good results just yet)</li>
+ 
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; Faster Huffman encoding
+ routines</font></li>
+ </ul>
+ <font color="#3366FF">The following changes are disabled because of MPEG2
+ problems.&nbsp; But to try them, set MDCTDELAY=48 in encoder.h, instead
+ of MDCTDELAY=528.:</font>
+ <ul>
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; New MDCT routines with shorter
+ delay (48 samples instead of 528) and even faster than the old routines.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; Removed extra buffering
+ in psymodel.c</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.51&nbsp; November 7 1999</h3>
+ 
+ <ul>
+ <li>
+ Takehiro Tominaga: Bug in quantize.c absolute threshold of hearing calculation
+ for non-44.1kHz input files.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.50&nbsp; November 1 1999</h3>
+ 
+ <ul>
+ <li>
+ LAME 3.37beta becomes official LAME 3.50 release</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.37beta&nbsp; November 1 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Lionel Bonnet:&nbsp; Found severe bug in MPEG2 Short
+ block SNR.</font></li>
+ 
+ <li>
+ Sergey Sapelin:&nbsp; VBR Toc improvement.</li>
+ 
+ <li>
+ Sergey Dubov: fskip() routine</li>
+ 
+ <li>
+ Conrad Sanderson: replacement for filterbank.c.&nbsp;&nbsp; Not much faster
+ but amazingly simpler.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.36beta&nbsp; October 25 1999</h3>
+ 
+ <ul>
+ <li>
+ Albert Faber:&nbsp; more MSVC and BladeDLL updates</li>
+ 
+ <li>
+ Kimmo Mustonen:&nbsp; Much code cleanup and Amiga updates</li>
+ 
+ <li>
+ Anton Oleynikov: Borland C updates</li>
+ 
+ <li>
+ Mark Taylor: More stdin fixes:&nbsp; For some reason, forward fseek()'s
+ would fail when used on pipes even though it is okay with redirection from
+ "&lt;". So I changed all the forward fseek()'s to use fread().&nbsp; This
+ should improve stdin support for wav/aiff files.&nbsp; If you know the
+ input file is raw pcm, you can still use the '-r' option to avoid *all*
+ seeking of any kind.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.35beta&nbsp; October 21 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Leonid Kulakov:&nbsp; Serious bug in MPEG2 scalefactor
+ band tables fixed.</font></li>
+ 
+ <li>
+ Portability patches from:&nbsp; Anton Oleynikov, Sigbj&oslash;rn Skj&aelig;ret,
+ Mathew Hendry, Richard Gorton</li>
+ 
+ <li>
+ Alfred Weyers: compiler options, updated timestatus.</li>
+ 
+ <li>
+ Albert Faber:&nbsp; BladeDll and other updates (new machine.h).</li>
+ 
+ <li>
+ Monty:&nbsp; updated Makefile to fix gcc inline math bug.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.34beta&nbsp; October 12 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Mark Taylor: Bug fixed:&nbsp; minimum bitrate in
+ VBR mode could be ignored for a few frames.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Mark Taylor: New (minor) VBR tunings.</font></li>
+ 
+ <li>
+ Tim Ruddick: New wav/aiff header parsing routines.&nbsp; Better parsing
+ and fewer fseek()'s.</li>
+ 
+ <li>
+ Anton Oleynikov:&nbsp; patches to work with Borland C</li>
+ 
+ <li>
+ <font color="#FF0000">Gabriel Bouvigne:&nbsp; Experimental voice option
+ enabled with --voice</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.33beta&nbsp; October 11 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Robert Hegemann: RH VBR mode now the default and
+ only VBR mode.&nbsp; The new code will always quantize to 0 distortion
+ and the quality is increased by reducing the masking from the psy-model.&nbsp;
+ -X0 is still the default for now.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Robert Hegemann: new -X5 mode</font></li>
+ 
+ <li>
+ Mathew Hendry: New timing code, removes the need for HAVETIMES</li>
+ 
+ <li>
+ <font color="#3366FF">Mathew Hendry:&nbsp; assembler quantize_xrpow for
+ Windows</font></li>
+ 
+ <li>
+ Iwasa Kazmi:&nbsp; stdin/stdout patch for Windows</li>
+ 
+ <li>
+ Mark Taylor: New option: "--athonly" will ignore the psy-model output and
+ use only the absolute threshold of hearing for the masking.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.32beta&nbsp; October 8 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#3366FF">Takehiro Tominaga:&nbsp; faster long block spreading
+ function convolution for non 44.1kHz sampling frequencies, and faster short
+ block spreading function convolution for all sampling frequencies.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; Completly rewritten huffman
+ table selection and count_bits().&nbsp; More efficient table selection
+ results in many more bits per frame.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Takehiro Tominaga:&nbsp; More efficient scalefac
+ compress setting.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Mike Cheng: new calc_noise2()</font></li>
+ 
+ <li>
+ Alfred Weyers: patch for timestatus() seconds rollover</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.31beta&nbsp; September 28 1999</h3>
+ 
+ <ul>
+ <li>
+ Albert Faber:&nbsp; updated his BladeDLL code.&nbsp; This allows LAME to
+ be compiled into a BladeEnc compatiable .dll.</li>
+ 
+ <li>
+ <font color="#3366FF">Mike Cheng: faster l3psycho_ener() routine.</font></li>
+ 
+ <li>
+ Sigbj&oslash;rn Skj&aelig;ret: more code cleanup.</li>
+ </ul>
+ 
+ <h3>
+ LAME&nbsp; 3.30beta&nbsp; September 27 1999</h3>
+ 
+ <ul>
+ <li>
+ Conrad Sanderson:&nbsp; ID3 tag code added (type 'lame' for instructions)</li>
+ 
+ <li>
+ new mdct.c from Mike Cheng (no faster, but much cleaner code)</li>
+ 
+ <li>
+ Mathew Hendry: Microsoft nmake makefile and a couple other changes for
+ MSVC</li>
+ 
+ <li>
+ More modulization work:&nbsp; One input sound file interface handles mp3's,
+ uncompressed audio, with or without LIBSNDFILE.&nbsp; Fixes (hopefully)
+ a bunch of file I/O bugs introduced in 3.29 (Mark Taylor)</li>
+ 
+ <li>
+ LAME will now print valid samplerate/bitrate combinations (Mark Taylor)</li>
+ 
+ <li>
+ stdin/stdout fix for OS/2 (Paul Hartman)</li>
+ 
+ <li>
+ For mp3 input files, totalframes estimated based on filesize and first
+ frame bitrate. (Mark Taylor)</li>
+ 
+ <li>
+ Updated all functions with new style prototypes.&nbsp; (Sigbj&oslash;rn
+ Skj&aelig;ret)</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.29beta&nbsp; September 21 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Bug in bigv_bitcount fixed.&nbsp; Loop.c was overestimating
+ the number of bits needed, resulting in wasted bits every frame.&nbsp;
+ (Leonid A. Kulakov)</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in *_choose_table() fixed&nbsp;&nbsp; These routines
+ would not sellect the optimal Huffman table in some cases.&nbsp;&nbsp;
+ (Leonid A. Kulakov)</font></li>
+ 
+ <li>
+ <font color="#FF0000">Tuning of ATH normalization (macik)</font></li>
+ 
+ <li>
+ Removed unused variables and fixed function prototypes (Sigbj&oslash;rn
+ Skj&aelig;ret)</li>
+ 
+ <li>
+ Sami Farin sent a&nbsp; .wav&nbsp; file that&nbsp; LAME built in support
+ choked on.&nbsp;&nbsp; I added a slightly more sophisticated wav header
+ parsing to handle this, but if you have trouble, use libsndfile.</li>
+ 
+ <li>
+ Resampling hooks and options added.&nbsp; Buffering and resampling routines
+ need to be written.</li>
+ 
+ <li>
+ LAME will now take an mp3 file as input.&nbsp; When resampling code is
+ working, LAME will be able to (for example) convert a high bitrate stereo
+ mp3 to a low bitrate mono mp3 for streaming.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.28beta&nbsp; September 15 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Serious bug fixed in high frequency MDCT coefficients.&nbsp;
+ Huffman coding was reversing the order of the count1 block quadruples.&nbsp;&nbsp;
+ (Leonid A. Kulakov)</font></li>
+ 
+ <li>
+ nint() problems under Tru64 unix fixed and preprocessor variable HAVE_NINT
+ removed.&nbsp; (Bob Bell)</li>
+ 
+ <li>
+ Compiler warning fixes and code cleanup&nbsp;&nbsp; (Sigbj&oslash;rn Skj&aelig;ret,
+ Lionel Bonnet)</li>
+ 
+ <li>
+ USAGE file now includes suggestions for downsampling.&nbsp; For low bitrate
+ encodings, proper downsampling can give dramatically better results.&nbsp;
+ (John Hayward-Warburton)</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.27beta&nbsp; September 12 1999</h3>
+ 
+ <ul>
+ <li>
+ Several bugs in encode.c and l3bitstream.c fixed by Lionel Bonnet.</li>
+ 
+ <li>
+ Bugs in new VBR (#define RH) formula for mono input file and mid/side encoding
+ fixed.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.26beta&nbsp; September 10 1999</h3>
+ 
+ <ul>
+ <li>
+ The "-m m" option (mono .mp3 file) will automatically mix left and right
+ channels if the input file is stereo.&nbsp; (Alfred Weyers)</li>
+ 
+ <li>
+ <font color="#FF0000">New quant_compare algorithm (method for deciding
+ which of two quantizations is better) enabled with -X4 (Greg Maxwell)</font></li>
+ 
+ <li>
+ <font color="#FF0000">New mid/side VBR bit allocation formula.&nbsp; Mid
+ channel bits are set by the quality requirements, and then the side channel
+ uses a reduced number of bits (in a proportion coming from the fixed bitrate
+ code).&nbsp; This might not be optimal, but it should be pretty good and
+ no one knows what the optimal solution should be.&nbsp; (Greg Maxwell)</font></li>
+ 
+ <li>
+ <font color="#FF0000">New VBR (#define RH) tunings based on detailed listening
+ tests by Macik and Greg Maxwell.</font></li>
+ 
+ <li>
+ Sigbj&oslash;rn Skj&aelig;ret fixed several compiler warnings (which turned
+ out to be potential bugs)</li>
+ 
+ <li>
+ Takehiro Tominaga fixed a low bitrate bug in reduce_side()</li>
+ 
+ <li>
+ Alfred Weyers fixed some buffer overflows.</li>
+ 
+ <li>
+ <font color="#FF0000">New ATH (absolute threshold of hearing) formula replaces
+ buggy ISO code, and adds&nbsp; analog silence treatment&nbsp; (removal
+ of coefficients below below ATH).&nbsp;&nbsp; These are turned on by default
+ but have not been fully tested.&nbsp; (Robert Hegemann)</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in short block spreading function fixed.&nbsp;
+ (Robert Hegemann)</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.25beta&nbsp; August 22 1999</h3>
+ 
+ <ul>
+ <li>
+ Sigbj&oslash;rn Skj&aelig;ret fixed a zero byte malloc call.&nbsp; This
+ bug&nbsp; was introduced in 3.24 and causes problems on non Linux systems.</li>
+ 
+ <li>
+ Bit allocation routines would sometimes allocate more than 4095 bits to
+ one channel of one granule.&nbsp; A couple of people reported problems
+ that might be caused by this, especially at higher bitrates.</li>
+ 
+ <li>
+ Nils Faerber updated the man page and fixed many of the compiler warnings.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.24beta&nbsp;&nbsp; August 15 1999</h3>
+ 
+ <ul>
+ <li>
+ This release contains the following new code (for developers) which is
+ disabled by default:</li>
+ 
+ <li>
+ Robert Hegemann:&nbsp; Completely overhauled VBR code.&nbsp; Now computes
+ exact number of bits required for the given qualty and then quantized with
+ the appropriate bitrate.</li>
+ 
+ <li>
+ Several new quantization quality measures.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.23beta&nbsp; August 8 1999</h3>
+ 
+ <ul>
+ <li>
+ Very nice continuously updated VBR histogram display from Iwasa Kazmi.&nbsp;
+ (disabled with --nohist).</li>
+ 
+ <li>
+ More modulerization work.&nbsp; The encoding engine can now be compiled
+ into libmp3lame, but the interface is awkward.</li>
+ 
+ <li>
+ <font color="#FF0000">Bug fixed in FFT Hann window formula (Leonid A. Kulakov).</font></li>
+ 
+ <li>
+ New LAME logo on the download page.&nbsp; Created by Chris Michalisles.</li>
+ 
+ <li>
+ <font color="#FF0000">Several VBR algorithm improvements from Robert Hegemann.&nbsp;
+ New quantization noise metrics and VBR quality measure takes into account
+ mid/side encoding.&nbsp; Should produce smaller files with the same quality,
+ especially when using jstereo.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.22beta&nbsp; July 27 1999</h3>
+ 
+ <ul>
+ <li>
+ Downsampling (stereo to mono) bug with MPEG2 fixed.&nbsp; (Mike Oliphant)</li>
+ 
+ <li>
+ Downsampling now merges L &amp; R channels - before it only took the L
+ channel.</li>
+ 
+ <li>
+ More modularization and code cleanup from Albert Faber and myself.</li>
+ 
+ <li>
+ Input filesize limit removed for raw pcm input files.&nbsp; For other file
+ types, LAME will still only read the first 2^32 samples, (27 hours of playing
+ time at 44.1kHz).</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.21beta&nbsp; July 26 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Correct Mid/Side masking thresholds for JSTEREO mode!&nbsp;
+ This is enabled with -h.&nbsp; It&nbsp; makes LAME about 20% slower since
+ it computes psycho-acoustics for L,R Mid and Side channels.</font></li>
+ 
+ <li>
+ <font color="#FF0000">"Analog silence" threshold added.&nbsp; Keeps VBR
+ from upping the bitrate during very quite passages.&nbsp; (Robert.Hegemann)</font></li>
+ 
+ <li>
+ <font color="#FF0000">New VBR quality setting from Robert Hegemann.&nbsp;
+ It is based on the idea that distortion at lower bit rates sounds worse
+ than at higher bitrates, and so the allowed distortion (VBR quality setting)
+ is proportional to the bitrate.&nbsp; Because of this, default minimum
+ bitrate is now 32kbs.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Expermental subblock gain code enabled with -Z.</font></li>
+ 
+ <li>
+ New "-r" option for raw pcm input files.&nbsp; With -r, LAME will not do
+ any fseek()'s or look for wav and aiff headers on the input file.</li>
+ 
+ <li>
+ Bug fixes in mp3x (frame analyzer) for viewing frames near end of the file.</li>
+ 
+ <li>
+ Bug fixed to allow setting the sampling rate of raw pcm input files.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.20beta&nbsp; July 19 1999</h3>
+ 
+ <ul>
+ <li>
+ Bug in get_audio.c fixed.&nbsp; Libsndfile wrappers would not compile (Miguel
+ Revilla&nbsp; Rodriguez)</li>
+ 
+ <li>
+ Nils Faerber found some unitialized variables and some wierd extranous
+ computations in filter_subband, now fixed.&nbsp; This was causing seg faults
+ on some machines.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.19beta&nbsp; July 18 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Oops!&nbsp; Robert Hegemann immediatly found a bug
+ in the new&nbsp; (old -Z option) quantization code.&nbsp; calc_noise1 was
+ not returning tot_noise, so non ms-stereo frames were buggy.</font></li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.18beta&nbsp; July 17 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Many psycho-acoustic bug fixes.&nbsp; Dan Nelson
+ discovered a bug in MPEG2: For short blocks, the code assumes 42 partition
+ bands.&nbsp; MPEG1 sometimes has less, MPEG2 can have more.&nbsp; In MPEG1,
+ this bug would not have effected the output if your compiler initializes
+ static variables to 0 on creation.&nbsp; In MPEG2 it leads to array out-of-bounds
+ access errors. Finally, there was a related bug in MPEG1/MPEG2, short &amp;
+ long blocks where the energy above 16kHz was all added to partition band
+ 0. (the lowest frequeny partition band!)</font></li>
+ 
+ <li>
+ <font color="#FF0000">The -Z option (Gabriel Bouvigne's idea of using total
+ quantization noise to choose between two quantizations with the same value
+ of "over") is now the default.&nbsp; I believe this helps remove the trilling
+ sound in Jan's testsignal4.wav.&nbsp; The quality of testsignal2.wav and
+ testsignal4.wav are now better than Xing and getting closer to FhG.</font></li>
+ 
+ <li>
+ Bug fixes in frame &amp; sample count for downsampling mode. (ben "jacobs")</li>
+ 
+ <li>
+ Patches to improve modulization.&nbsp; (ben "jacobs")</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.17beta&nbsp; July 11 1999</h3>
+ 
+ <ul>
+ <li>
+ substantial code cleanup towards goal of making LAME more modular.</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.16beta&nbsp; July 11 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">New tunings of window switching, and better bit allocation
+ based on pe.&nbsp; (Jan Rafaj.&nbsp; improves both testsignal2.wav and
+ testsignal4.wav).</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in mid/side quantization when side channel was
+ zero fixed.&nbsp; (Albert Faber)</font></li>
+ 
+ <li>
+ Removed some extranous computations in l3psy.c (Robert Hegemann)</li>
+ 
+ <li>
+ More detailed timing status info, including hours display. (Sakari Ailus)
+ and percentage indicator (Conrad Sanderson).</li>
+ 
+ <li>
+ <font color="#3366FF">Window_subband and calc_noise1,calc_noise2 speedups.&nbsp;
+ Quantize_xrpow speedup should be significant on non GNU/intel systems.
+ (Mike Cheng)</font></li>
+ 
+ <li>
+ <font color="#3366FF">Better initial guess for VBR bitrate.&nbsp; Should
+ speed up VBR encoding.&nbsp; (Gabriel Bouvigne)</font></li>
+ 
+ <li>
+ More advanced .wav header parsing.&nbsp; fixes bugs involving click in
+ first frame. (Robert.Hegemann)</li>
+ 
+ <li>
+ Correct filesize and total frame computation when using LIBSNDFILE (ben
+ "jacobs")</li>
+ 
+ <li>
+ Click in last frame (buffering problem) when using libsndfile fixed.</li>
+ 
+ <li>
+ Audio I/O code overhauled.&nbsp; There is now a uniform audio i/o interface
+ to libsndfile or the LAME built in wav/aiff routines.&nbsp; All audio i/o
+ code localized to get_audio.c.</li>
+ 
+ <br>&nbsp;</ul>
+ 
+ <h3>
+ LAME 3.15beta</h3>
+ 
+ <ul>
+ <li>
+ times()/clock() problem fixed for non-unix OS.&nbsp; (Ben "Jacobs")</li>
+ 
+ <li>
+ Fixed uninitialized pe[] when using fast mode.&nbsp; (Ben "Jacobs")</li>
+ </ul>
+ 
+ <h3>
+ LAME 3.13&nbsp; June 24 1999</h3>
+ 
+ <ul>
+ <li>
+ Patches for BeOS from Gertjan van Ratingen.</li>
+ 
+ <li>
+ Makefile info for OS/2 Warp 4.0&nbsp; (from dink.org).</li>
+ 
+ <li>
+ Status display now based on wall clock time, not cpu time.</li>
+ 
+ <li>
+ mem_alloc no longer allocates twice as much memory as needed (Jan Peman).</li>
+ </ul>
+ 
+ <h3>
+ 3.12pre9</h3>
+ 
+ <ul>
+ <li>
+ Updated BLADEDLL code to handle recent changes (Albert Faber).</li>
+ 
+ <li>
+ Bug fixed in parsing options when not using GTK (Albert Faber).</li>
+ 
+ <li>
+ <font color="#FF0000">MPEG2 Layer III psycho acoustics now working.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Improved huffman encoding Chris Matrakidis. (10%
+ faster).&nbsp; I dont know how he finds these improvements!&nbsp; LAME
+ with full quality now encodes faster than real time on my PII 266.</font></li>
+ 
+ <li>
+ Fixed time display when encoding takes more than 60 minutes.</li>
+ </ul>
+ 
+ <h3>
+ 3.12pre8</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">New <a href="gpsycho/ms_stereo.html">mid/side stereo</a>
+ criterion.&nbsp; LAME will use mid/side stereo only when the difference
+ between L &amp; R masking thresholds (averaged over all scalefactors) is
+ less then 5db.&nbsp; In several test samples it does a very good job mimicking
+ the FhG encoder.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in mid/side stereo fixed:&nbsp; independent variation
+ of mid &amp; side channel scalefactors disabled.&nbsp; Because of the way
+ outer_loop is currently coded, when encoding mid/side coefficietns using
+ left/right thresholds, you have to vary the scalefactors simultaneously.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in side/mid energy ratio calculation fixed. (Thanks
+ to Robert Hegemann)</font></li>
+ 
+ <li>
+ Default mode is stereo (not jstereo) if bitrate is chosen as 192kbs or
+ higher.&nbsp; Tero Auvinen first pointed out that FhG seems to think at
+ 160kbs, their encoder is so good it doesn't need jstereo tricks. Since
+ LAME is not as good as FhG, I am going to claim that 192kbs LAME is so
+ good it doens't need jstereo tricks, and thus it is disabled by default.</li>
+ 
+ <li>
+ WAV header parsing for big-endian machines, and automatic detection of
+ big-endian machines.&nbsp; (Thanks to&nbsp; Sigbj&oslash;rn Skj&aelig;ret).</li>
+ 
+ <li>
+ added 56 sample delay to sync LAME with FhG.</li>
+ 
+ <li>
+ MP3x (frame analyzer) can now handle MPEG2 streams.</li>
+ </ul>
+ 
+ <h3>
+ 3.12pre7</h3>
+ 
+ <ul>
+ <li>
+ MPEG2 layer III now working!&nbsp; lower bit rates (down to 8kbs) and 3
+ more sampling frequencies:&nbsp; 16000, 22050, 24000Hz. Quality is poor
+ - the psy-model does not yet work with these sampling frequencies.</li>
+ 
+ <li>
+ Fixed "ERROR: outer_loop(): huff_bits &lt; 0." bug when using VBR.</li>
+ 
+ <li>
+ bash and sh scripts to run LAME on multiple files now included.&nbsp; (from
+ Robert Hegemann and Gerhard Wesp respectively)</li>
+ 
+ <li>
+ bug fix in encoding times for longer files from&nbsp; (Alvaro Martinez
+ Echevarria)</li>
+ 
+ <li>
+ yet another segfault in the frame analyzer fixed.</li>
+ 
+ <li>
+ ISO psy-model/bit allocation routines removed.&nbsp; This allowed makeframe()
+ to be made much simpler, and most of the complicated buffering is now gone.
+ Eventually I would like the encoding engine to be a stand alone library.</li>
+ </ul>
+ 
+ <h3>
+ 3.12pre6</h3>
+ 
+ <ul>
+ <li>
+ <font color="#FF0000">Better VBR tuning.&nbsp; Find minimum bitrate with
+ distortion less than the allows maximum.&nbsp; A minimum bit rate is imposed
+ on frames with short blocks (where the measured distortion can not be trusted).&nbsp;&nbsp;
+ A minimum frame bitrate can be specified with -b, default=64kbs.</font></li>
+ 
+ <li>
+ <a href="http://www.zip.com.au/~erikd/libsndfile">LIBSNDFILE</a> support.&nbsp;
+ With libsndfile, LAME can encode almost all sound formats.&nbsp; Albert
+ Faber did the work for this, including getting libsndfile running under
+ win32.</li>
+ 
+ <li>
+ CRC checksum now working!&nbsp;&nbsp; (Thanks to Johannes Overmann )</li>
+ 
+ <li>
+ frame analyzer will now work with mono .mp3 files</li>
+ 
+ <li>
+ <font color="#3366FF">more code tweeks from Jan Peman.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Compaq-Alpha(Linux) fixes and speedups from Nils
+ Faerber.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Faster bin_search_StepSize from Juha Laukala.</font></li>
+ 
+ <li>
+ <font color="#3366FF">Faster quantize() from Mike Cheng</font></li>
+ 
+ <li>
+ <font color="#3366FF">Faster quantize_xrpow() from Chris Matrakidis.&nbsp;
+ xrpow_flag removed since this option is now on by default.</font></li>
+ 
+ <li>
+ Fixed .wav header parsing from Nils Faerber.</li>
+ 
+ <li>
+ Xing VBR frame info header code from Albert Faber.&nbsp;&nbsp; "Xing" and
+ "LAME 3.12" embedded in first frame.</li>
+ 
+ <li>
+ <font color="#FF0000">Bug in VBR bit allocation based on "over" value fixed.</font></li>
+ </ul>
+ 
+ <h3>
+ LAME 3.11&nbsp; June 3 1999</h3>
+ 
+ <blockquote>
+ <li>
+ Almost all warnings (-Wall) now fixed!&nbsp; (Thanks to Jan Peman)</li>
+ 
+ <li>
+ More coding improvements from Gabriel Bouvigne and Warren Toomey.</li>
+ 
+ <li>
+ <font color="#FF0000">VBR&nbsp; (variable bit rate).&nbsp;&nbsp; Increases
+ bit rate for short blocks and for frames where the number of bands containing
+ audible distortion is greater than a given value.&nbsp; Much tuning needs
+ to be done.</font></li>
+ 
+ <li>
+ Patch to remove all atan() calls from James Droppo.</li>
+ </blockquote>
+ 
+ <h3>
+ LAME 3.10 May 30 1999</h3>
+ 
+ <ul>
+ <li>
+ <font color="#3366FF">Fast mode (-f)&nbsp; disables psycho-acoustic model
+ for real time encoding on older machines.&nbsp; Thanks to Lauri Ahonen
+ who first sent a patch for this.</font></li>
+ 
+ <li>
+ <font color="#FF0000">New bit reservoir usage scheme to accommodate the
+ new pre-echo detection formulas.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Tuning of AWS and ENER_AWS pre-echo formulas by Gabriel
+ Bouvigne and myself.&nbsp; They work great!&nbsp; now on by default.</font></li>
+ 
+ <li>
+ In jstereo, force blocktypes for left &amp; right channels to be identical.&nbsp;
+ FhG seems to do this.&nbsp; It can be disabled with "-d".</li>
+ 
+ <li>
+ Patches to compile MP3x under win32 (Thanks to Albert Faber).</li>
+ 
+ <li>
+ <font color="#3366FF">bin_serach_stepsize limited to a quantizationStepSize
+ of&nbsp; -210 through 45.</font></li>
+ 
+ <li>
+ <font color="#FF0000">outer_loop()&nbsp; will now vary Mid &amp; Side scalefactors
+ independently.&nbsp; Can lead to better quantizations, but it is slower
+ (twice as many quantizations to look at).&nbsp; Running with "-m f" does
+ not need this and will run at the old speed</font></li>
+ 
+ <li>
+ <font color="#FF0000">Bug in inner_loop would allow quantizations larger
+ than allowed.&nbsp; (introduced in lame3.04, now fixed.)</font></li>
+ 
+ <li>
+ Updated HTML documentation from Gabriel Bouvigne.</li>
+ 
+ <li>
+ Unix&nbsp; man page from William Schelter.</li>
+ 
+ <li>
+ <font color="#FF0000">numlines[] bug fixed.&nbsp; (Thanks to Rafael Luebbert,
+ MPecker author).</font></li>
+ 
+ <li>
+ <font color="#3366FF">Quantization speed improvements from Chirs Matrakidis.</font></li>
+ 
+ <li>
+ <font color="#FF0000">When comparing quantizations with the same number
+ of bands with audible distortion, use the one with the largest scalefactors,
+ not the first one outer_loop happened to find.</font></li>
+ 
+ <li>
+ Improved defination of best quantization when using -f (fast mode).</li>
+ 
+ <li>
+ subblock code now working.&nbsp; But no algorithm to choose subblock gains
+ yet.</li>
+ 
+ <li>
+ Linux now segfaults on floating point exceptions.&nbsp; Should prevent
+ me from releasing binaries that crash on other operating systems.</li>
+ </ul>
+ 
+ <h4>
+ May 22 1999</h4>
+ 
+ <ul>
+ <li>
+ Version 3.04 released.</li>
+ 
+ <li>
+ Preliminary documentation from Gabriel Bouvigne.</li>
+ 
+ <li>
+ <font color="#3366FF">I wouldn't have thought it was possible, but now
+ there are even more speed improvements from Chris Matrakidis!&nbsp; Removed
+ one FFT when using joint stereo, and many improvements in loop.c.</font></li>
+ 
+ <li>
+ "Fake" ms_stereo mode renamed "Force" ms_stereo since it forces mid/side
+ stereo on all frames.&nbsp; For some music this is said to be a problem,
+ but for most music mode is probably better than the default jstereo because
+ it uses specialized mid/side channel masking thresholds.</li>
+ 
+ <li>
+ Small bugs in Force ms_stereo mode fixed.</li>
+ 
+ <li>
+ Compaq Alpha fixes from Nathan Slingerland.</li>
+ 
+ <li>
+ <font color="#FF0000">Some new experimental pre-echo detection formulas
+ in l3psy.c (#ifdef AWS and #ifdef ENER_AWS, both off by default.&nbsp;
+ Thanks to Gabriel Bouvigne and Andre Osterhues)</font></li>
+ 
+ <li>
+ Several bugs in the syncing of data displayed by mp3x (the frame analyzer)
+ were fixed.</li>
+ 
+ <li>
+ highq (-h) option added.&nbsp; This turns on things (just one so far) that
+ should sound better but slow down LAME.</li>
+ </ul>
+ <b>May 18 1999</b>
+ <ul>
+ <li>
+ Version 3.03 released.</li>
+ 
+ <li>
+ <font color="#3366FF">Faster (20%) &amp; cleaner FFT (Thanks to Chris Matrakidis&nbsp;
+ http://www.geocities.com/ResearchTriangle/8869/fft_summary.html)</font></li>
+ 
+ <li>
+ mods so it works with VC++ (Thanks to Gabriel Bouvigne, www.mp3tech.org)</li>
+ 
+ <li>
+ MP3s marked "original" by default&nbsp; (Thanks to Gabriel Bouvigne, www.mp3tech.org)</li>
+ 
+ <li>
+ Can now be compiled into a BladeEnc compatible .DLL&nbsp;&nbsp; (Thanks
+ to&nbsp; Albert Faber, CDex author)</li>
+ 
+ <li>
+ Patches for "silent mode" and stdin/stdout&nbsp; (Thanks to Lars Magne
+ Ingebrigtsen)</li>
+ 
+ <li>
+ <font color="#FF0000">Fixed rare bug: if a long_block is sandwiched between
+ two short_blocks, it must be changed to a short_block, but the short_block
+ ratios have not been computed in l3psy.c.&nbsp; Now always compute short_block
+ ratios just in case.</font></li>
+ 
+ <li>
+ <font color="#FF0000">Fixed bug with initial quantize step size when many
+ coefficients are zero.&nbsp; (Thanks to Martin Weghofer).</font></li>
+ 
+ <li>
+ Bug fixed in MP3x display of audible distortion.</li>
+ 
+ <li>
+ improved status display (Thanks to Lauri Ahonen).</li>
+ </ul>
+ 
+ <h4>
+ May 12 1999</h4>
+ 
+ <ul>
+ <li>
+ Version 3.02 released.</li>
+ 
+ <li>
+ <font color="#FF0000">encoder could use ms_stereo even if channel 0 and
+ 1 block types were different.&nbsp; (Thanks to Jan Rafaj)</font></li>
+ 
+ <li>
+ <font color="#FF0000">added -k option to disable the 16kHz cutoff at 128kbs.&nbsp;
+ This cutoff is never used at higher bitrates. (Thanks to Jan Rafaj)</font></li>
+ 
+ <li>
+ <font color="#FF0000">modified pe bit allocation formula to make sense
+ at bit rates other than 128kbs.</font></li>
+ 
+ <li>
+ fixed l3_xmin initialization problem which showed up under FreeBSD.&nbsp;
+ (Thanks to Warren Toomey)</li>
+ </ul>
+ <b>May 11 1999</b>
+ <ul>
+ <li>
+ Version 3.01 released</li>
+ 
+ <li>
+ max_name_size increased to 300&nbsp; (Thanks to Mike Oliphant)</li>
+ 
+ <li>
+ patch to allow seeks on input file (Thanks to Scott Manley)</li>
+ 
+ <li>
+ fixes for mono modes (Thanks to everyone who pointed this out)</li>
+ 
+ <li>
+ overflow in calc_noise2 fixed</li>
+ 
+ <li>
+ bit reservoir overflow when encoding lots of frames with all zeros&nbsp;
+ (Thanks to Jani Frilander)</li>
+ </ul>
+ 
+ <p><br><b>May 10 1999</b>
+ <ul>
+ <li>
+ Version 3.0 released</li>
+ 
+ <li>
+ <font color="#FF0000">added GPSYCHO (developed by Mark Taylor)</font></li>
+ 
+ <li>
+ <font color="#000000">added MP3x (developed by Mark Taylor)</font></li>
+ 
+ <li>
+ LAME now maintained by Mark Taylor</li>
+ </ul>
+ <b>November 8 1998</b>
+ <ul>
+ <li>
+ Version 2.1f released</li>
+ 
+ <li>
+ 50% faster filter_subband() routine in encode.c contributed by James Droppo</li>
+ </ul>
+ <b>November 2 1998</b>
+ <ul>
+ <li>
+ Version 2.1e released.</li>
+ 
+ <li>
+ New command line switch <b>-a</b> auto-resamples a stereo input file to
+ mono.</li>
+ 
+ <li>
+ New command line switch <b>-r</b> resamples from 44.1khz to 32khz [this
+ switch doesn't work really well. Very tinny sounding output files. Has
+ to do with the way I do the resampling probably]</li>
+ 
+ <li>
+ Both of these were put into the ISO code in the encode.c file, and are
+ simply different ways of filling the input buffers from a file.</li>
+ </ul>
+ <b>October 31 1998</b>
+ <ul>
+ <li>
+ Version 2.1d released</li>
+ 
+ <li>
+ Fixed memory alloc in musicin.c (for l3_sb_sample)</li>
+ 
+ <li>
+ Added new command line switch (-x) to force swapping of byte order</li>
+ 
+ <li>
+ Cleaned up memory routines in l3psy.c. All the mem_alloc() and free() routines
+ where changed so that it was only done <i>once</i> and not every single
+ time the routine was called.</li>
+ 
+ <li>
+ Added a compile time switch -DTIMER that includes all timing info. It's
+ a switch for the time being until some other people have tested on their
+ system. Timing code has a tendency to do different things on different
+ platforms.</li>
+ </ul>
+ <b>October 18 1998</b>
+ <ul>
+ <li>
+ Version 2.1b released.</li>
+ 
+ <li>
+ Fixed up bug: all PCM files were being read as WAV.</li>
+ 
+ <li>
+ Played with the mem_alloc routine to fix crash under amigaos (just allocating
+ twice as much memory as needed). Might see if we can totally do without
+ this routine. Individual malloc()s where they are needed instead</li>
+ 
+ <li>
+ Put Jan Peman's quality switch back in. This reduces quality via the '-q&nbsp;<int>'
+ switch. Fun speedup which is mostly harmless if you're not concerned with
+ quality.</li>
+ 
+ <li>
+ Compiling with amiga-gcc works fine</li>
+ </ul>
+ <b>October 16 1998</b>
+ <ul>
+ <li>
+ Version 2.1a released. User input/output has been cleaned up a bit. WAV
+ file reading is there in a very rudimentary sense ie the program will recognize
+ the header and skip it, but not read it. The WAV file is assumed to be
+ 16bit stereo 44.1khz.</li>
+ </ul>
+ <b>October 6 1998</b>
+ <ul>
+ <li>
+ Version 2.1 released with all tables now incorporated into the exe. Thanks
+ to <b>Lars Magne Ingebrigtseni</b>(larsi@ifi.uio.no)</li>
+ </ul>
+ <b>October 4 1998</b>In response to some concerns about the quality of
+ the encoder, I have rebuilt the encoder from scratch and carefully compared
+ output at all stages with the output of the unmodified ISO encoder. <a href="http://www.uq.net.au/~zzmcheng/lame/download.html">Version2.0</a>
+ of LAME is built from the ISO source code (dist10), and incorporates modifications
+ from myself and the 8hz effort. The output file from LAME v2.0 is <i>identical</i>
+ to the output of the ISO encoder for my test file.Since I do not have heaps
+ of time, I left the ISO AIFF file reader in the code, and did not incorporate
+ a WAV file reader.Added section on <a href="http://www.uq.net.au/~zzmcheng/lame/quality.html">quality</a><b>October
+ 1 1998</b>
+ <ul>
+ <li>
+ Updated web page and released LAME v1.0</li>
+ </ul>
+ <b>Up to September 1998</b>
+ <ul>Working on the 8hz source code...
+ <ul>
+ <li>
+ Patched the <a href="http://www.8hz.com/">8hz</a> source code</li>
+ 
+ <li>
+ 45% faster than original source (on my freebsd p166).</li>
+ 
+ <ul>
+ <li>
+ m1 - sped up the mdct.c and quantize() functions [MDCTD, MDCTD2, LOOPD]</li>
+ 
+ <li>
+ m2 - sped up the filter_subband routine using <b>Stephane Tavenard</b>'s
+ work from musicin [FILTST]</li>
+ 
+ <li>
+ m2 - minor cleanup of window_subband [WINDST2]</li>
+ 
+ <li>
+ m2 - Cleaned up a few bits in l3psy.c. Replaced a sparse matrix multiply
+ with a hand configured unrolling [PSYD]</li>
+ 
+ <li>
+ m3 - (amiga only) Added in the asm FFT for m68k (based on sources from
+ <b>Henryk
+ Richter</b> and <b>Stephane Tavenard</b>)</li>
+ 
+ <li>
+ m4 - raw pcm support back in</li>
+ 
+ <li>
+ m5 - put in a byte-ordering switch for raw PCM reading (just in case)</li>
+ 
+ <li>
+ m6 - reworked the whole fft.c file. fft now 10-15% faster.</li>
+ 
+ <li>
+ m7 - totally new fft routine. exploits fact that this is a real->complex
+ fft. About twice as fast as previous fastest fft (in m6). (C fft routine
+ is faster than the asm one on an m68k!)</li>
+ 
+ <li>
+ m8</li>
+ 
+ <ul>
+ <li>
+ - Now encodes from stdin. Use '-' as the input filename. Thanks to <b>Brad
+ Threatt</b></li>
+ 
+ <li>
+ - Worked out that the 1024point FFT only ever uses the first 6 phi values,
+ and the first 465 energy values. Saves a bunch of calculations.</li>
+ 
+ <li>
+ - Added a speed-up/quality switch. Speed is increased but quality is decreased
+ <i>slightly</i>.
+ My ears are bad enough not to be able to notice the difference in quality
+ at low settings :). Setting '-q 1' improves speed by about 10%. '-q 100'
+ improves speed by about 26%. Enoding of my test track goes from 111s (at
+ default '-q 0') to 82s (at -q 100). Thanks to <b>Jan Peman</b> for this
+ tip.</li>
+ </ul>
+ 
+ <li>
+ m9 - fixed an error in l3psy.c. numlines[] is overwritten with incorrect
+ data. Added a new variable numlines_s[] to fix this. Thanks again to <b>Jan
+ Peman</b>.</li>
+ 
+ <li>
+ m10 - Down to 106 seconds by selecting a few more compiler options. Also
+ added a pow20() function in l3loop.c to speed up (ever so slightly) calls
+ to pow(2.0, x)</li>
+ 
+ <li>
+ m11</li>
+ 
+ <ul>
+ <li>
+ No speedups. Just cleaned up some bits of the code.</li>
+ 
+ <li>
+ Changed K&amp;R prototyping to 'normal' format. Thanks to <b>Steffan Haeuser</b>
+ for his help here.</li>
+ 
+ <li>
+ Changed some C++ style comments to normal C comments in huffman.c</li>
+ 
+ <li>
+ Removed the #warning from psy_data.h (it was getting annoying!)</li>
+ 
+ <li>
+ Removed reference in bitstream.c to malloc.h. Is there a system left where
+ malloc.h hasn't been superceded by stdlib.h?</li>
+ </ul>
+ 
+ <li>
+ In Progess:</li>
+ 
+ <ul>
+ <li>
+ my PSYD hack for the spreading functions is only valid for 44.1khz - Should
+ really put in a "if freq = 44.1khz" switch for it. Someone might want to
+ extend the speedup for 48 and 32khz.</li>
+ 
+ <li>
+ Putting in Jan Peman's quantanf_init speedup.</li>
+ </ul>
+ </ul>
+ </ul>
+ </ul>
+ 
+ </body>
+ </html>
diff -r -c -N encoder/doc/html/id3.html lame3.70/doc/html/id3.html
*** encoder/doc/html/id3.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/id3.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,221 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>ID3 tags</TITLE>
+ <META NAME="description" CONTENT="Command line switch reference">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node9.html">
+ <LINK REL="previous" HREF="node7.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node9.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <H1>ID3 tags</H1>
+ <p>&nbsp;</p>
+ <p>LAME is able to embed ID3 v1 or v1.1 tags inside the encoded MP3 file. This 
+   allows to have some usefull information about the music track included inside 
+   the file. Those data can be read by most MP3 players.</p>
+ <P> 
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><b>switch</b></TD>
+     <TD ALIGN="LEFT" nowrap><b>parameter</b></TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--tt "title"</kbd></td>
+     <td align="LEFT" nowrap>title of song (max 30 chars)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--ta "artist"</kbd></td>
+     <td align="LEFT" nowrap>artist who did the song (max 30 chars)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--tl "album"</kbd></td>
+     <td align="LEFT" nowrap>album where it came from (max 30 chars)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--ty "year"</kbd></td>
+     <td align="LEFT" nowrap>year in which the song/album was made (max 4 chars)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--tc "comment"</kbd></td>
+     <td align="LEFT" nowrap>additional info (max 30 chars or max 28 chars if using 
+       the "track" option)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--tn "track&quot;</kbd></td>
+     <td align="LEFT" nowrap>track number of the song on the CD (1 to 99)<br>
+       using this option will add an ID3v1.1 tag</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>--tg "genre"</kbd></td>
+     <td align="LEFT" nowrap> genre of song (name or number)</td>
+   </tr>
+ </TABLE>
+ <p><br>
+   The following genres are supported:<br>
+   <br>
+ </p>
+ <table width="80%" border="0">
+   <tr valign="top" align="left"> 
+     <td>00 - Blues<br>
+       01 - Classic Rock<br>
+       02 - Country<br>
+       03 - Dance<br>
+       04 - Disco<br>
+       05 - Funk<br>
+       06 - Grunge<br>
+       07 - Hip-Hop<br>
+       08 - Jazz<br>
+       09 - Metal<br>
+       10 - New Age<br>
+       11 - Oldies<br>
+       12 - Other<br>
+       13 - Pop<br>
+       14 - R&B<br>
+       15 - Rap<br>
+       16 - Reggae<br>
+       17 - Rock<br>
+       18 - Techno<br>
+       19 - Industrial<br>
+       20 - Alternative<br>
+       21 - Ska<br>
+       22 - Death Metal<br>
+       23 - Pranks<br>
+       24 - Soundtrack<br>
+       25 - Euro-Techno<br>
+       26 - Ambient<br>
+       27 - Trip-Hop<br>
+       28 - Vocal<br>
+       29 - Jazz+Funk<br>
+       30 - Fusion<br>
+       31 - Trance<br>
+       32 - Classical<br>
+       33 - Instrumental<br>
+       34 - Acid<br>
+       35 - House<br>
+       36 - Game<br>
+       37 - Sound Clip<br>
+       38 - Gospel<br>
+       39 - Noise<br>
+       40 - Alternative Rock<br>
+       41 - Bass<br>
+       43 - Punk<br>
+       44 - Space<br>
+       45 - Meditative<br>
+       46 - Instrumental Pop<br>
+       47 - Instrumental Rock<br>
+       48 - Ethnic<br>
+       49 - Gothic<br>
+       50 - Darkwave<br>
+       51 - Techno-Industrial<br>
+       52 - Electronic<br>
+       53 - Pop-Folk<br>
+       54 - Eurodance<br>
+       55 - Dream<br>
+       56 - Southern Rock<br>
+       57 - Comedy<br>
+       58 - Cult<br>
+       59 - Gangsta<br>
+       60 - Top 40<br>
+       61 - Christian Rap<br>
+       62 - Pop/Funk<br>
+       63 - Jungle<br>
+       64 - Native US<br>
+       65 - Cabaret<br>
+       66 - New Wave<br>
+       67 - Psychadelic<br>
+       68 - Rave<br>
+       69 - Showtunes<br>
+       70 - Trailer<br>
+       71 - Lo-Fi<br>
+       72 - Tribal<br>
+       73 - Acid Punk<br>
+       74 - Acid Jazz<br>
+       75 - Polka<br>
+       76 - Retro<br>
+       77 - Musical<br>
+       78 - Rock & Roll<br>
+       79 - Hard Rock<br>
+       80 - Folk<br>
+       81 - Folk-Rock<br>
+       82 - National Folk<br>
+       83 - Swing<br>
+       84 - Fast Fusion<br>
+       85 - Bebob<br>
+       86 - Latin<br>
+       87 - Revival<br>
+       88 - Celtic<br>
+       89 - Bluegrass<br>
+       90 - Avantgarde<br>
+       91 - Gothic Rock<br>
+       92 - Progressive Rock<br>
+       93 - Psychedelic Rock<br>
+       94 - Symphonic Rock<br>
+       95 - Slow Rock<br>
+       96 - Big Band<br>
+       97 - Chorus<br>
+       98 - Easy Listening<br>
+       99 - Acoustic </td>
+     <td>100 - Humour<br>
+       101 - Speech<br>
+       102 - Chanson<br>
+       103 - Opera<br>
+       104 - Chamber Music<br>
+       105 - Sonata<br>
+       106 - Symphony<br>
+       107 - Booty Bass<br>
+       108 - Primus<br>
+       109 - Porn Groove<br>
+       110 - Satire<br>
+       111 - Slow Jam<br>
+       112 - Club<br>
+       113 - Tango<br>
+       114 - Samba<br>
+       115 - Folklore<br>
+       116 - Ballad<br>
+       117 - Power Ballad<br>
+       118 - Rhytmic Soul<br>
+       119 - Freestyle<br>
+       120 - Duet<br>
+       121 - Punk Rock<br>
+       122 - Drum Solo<br>
+       123 - Acapella<br>
+       124 - Euro-House<br>
+       125 - Dance Hall<br>
+       126 - Goa<br>
+       127 - Drum & Bass<br>
+       128 - Club-House<br>
+       129 - Hardcore<br>
+       130 - Terror<br>
+       131 - Indie<br>
+       132 - BritPop<br>
+       133 - Negerpunk<br>
+       134 - Polsk Punk<br>
+       135 - Beat<br>
+       136 - Christian Gangsta<br>
+       137 - Heavy Metal<br>
+       138 - Black Metal<br>
+       139 - Crossover<br>
+       140 - Contemporary C<br>
+       141 - Christian Rock<br>
+       142 - Merengue<br>
+       143 - Salsa<br>
+       144 - Thrash Metal<br>
+       145 - Anime<br>
+       146 - JPop<br>
+       147 - SynthPop</td>
+   </tr>
+ </table>
+ <p><br>
+   <br>
+   <br>
+ </p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/index.html lame3.70/doc/html/index.html
*** encoder/doc/html/index.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/index.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,53 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>LAME V3 Next Generation High-End MPEG Layer III Encoding</TITLE>
+ <META NAME="description" CONTENT="MP3EncV3.1 Next Generation High-End MPEG Layer-3 Encoding">
+ <META NAME="keywords" CONTENT="mp3enc">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node1.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <P> 
+ <H1 ALIGN="CENTER"><FONT SIZE="+4"><i><font face="Arial, Helvetica, sans-serif">LAME</font></i><font face="Arial, Helvetica, sans-serif"> 
+   V3.70<BR>
+   </font></FONT> 
+   <P><font size="+4" face="Arial, Helvetica, sans-serif"> <BR>
+     </font> <font face="Arial, Helvetica, sans-serif"><BIG>L<font color="#3366FF">ame</font> 
+     A<font color="#3366FF">in't an</font> M<font color="#3366FF">P3</font> E<font color="#3366FF">ncoder</font></BIG></font> 
+   <P><BIG> <BR>
+     </BIG> 
+ </H1>
+ <P ALIGN="CENTER"><STRONG>Open Source Project <BR>
+   <A HREF="http://www.sulaco.org/mp3">http://www.sulaco.org/mp3</A> </STRONG></P>
+ <P ALIGN="LEFT"></P>
+ <P> 
+ <DIV ALIGN="LEFT"> 
+   <P> 
+ </DIV>
+ <BR>
+ <HR>
+ <br>
+ <LI><A HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+   <UL>
+     <LI><A HREF="node6.html#SECTION00311000000000000000"> The purpose of audio 
+       compression</A> 
+     <LI><A HREF="node6.html#SECTION00312000000000000000"> The two parts of audio 
+       compression</A> 
+     <LI><A HREF="node6.html#SECTION00313000000000000000"> Compression ratios, 
+       bitrate and quality</A> 
+   </UL>
+ <LI><A HREF="examples.html"> Some command line examples</A> 
+ <LI><a href="switchs.html">Full command line switch reference</a> 
+ <LI><a href="id3.html">ID3 tags</a> 
+ <LI><a href="history.html">History</a> 
+ <LI><a href="contributors.html">Contributors</a><BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/lame.css lame3.70/doc/html/lame.css
*** encoder/doc/html/lame.css	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/lame.css	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,24 ----
+ BODY {
+         font-family: Arial, Helvetica, sans-serif;
+         position: absolute;
+         padding-left: 1cm;
+         margin-left: 1cm;
+      }
+ 
+ h1, h2, h3 {
+         margin-left: -1cm; text-align: left
+         }
+ 
+ TABLE { text-align: left; font-family: Arial, Helvetica, sans-serif;}
+ TH {background-color: #C0C0C0}
+ TD {font-family: Arial, Helvetica, sans-serif;}
+ 
+ SMALL.TINY		{ font-size : xx-small }
+ SMALL.SCRIPTSIZE	{ font-size : xx-small }
+ SMALL.FOOTNOTESIZE	{ font-size : x-small  }
+ SMALL.SMALL		{ font-size : small    }
+ BIG.LARGE		{ font-size : large    }
+ BIG.XLARGE		{ font-size : x-large  }
+ BIG.XXLARGE		{ font-size : xx-large }
+ BIG.HUGE		{ font-size : xx-large }
+ BIG.XHUGE		{ font-size : xx-large }
diff -r -c -N encoder/doc/html/node5.html lame3.70/doc/html/node5.html
*** encoder/doc/html/node5.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/node5.html	Wed Nov 24 01:44:08 1999
***************
*** 0 ****
--- 1,51 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>For the impatient</TITLE>
+ <META NAME="description" CONTENT="For the impatient">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node10.html">
+ <LINK REL="previous" HREF="node2.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node6.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1><A NAME="SECTION00300000000000000000"> For the impatient</A> </H1>
+ If you are new to audio compression, you should read section <A HREF="node6.html#chap-intro">1.1</A> 
+ for an introduction about audio compression and MPEG Layer-3. 
+ <P> If, however, you want to jump right into the business of sound compression, 
+   then Section <A HREF="node7.html#cmdl-examples">1.2</A> will show you some prefabricated 
+   command lines that will give you compressed audio streams right away. 
+ <P> If you are an expert in audio coding already, the command line switch reference 
+   page might come in handy. 
+ <P> <BR>
+ <HR>
+ <!--Table of Child-Links--> <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A NAME="tex2html127"
+  HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+     <UL>
+       <LI><A NAME="tex2html128"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+       <LI><A NAME="tex2html129"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+       <LI><A NAME="tex2html130"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+         quality</A> 
+     </UL>
+   <LI><A NAME="tex2html131"
+  HREF="node7.html#SECTION00320000000000000000"> Some examples</A> 
+   <LI><A NAME="tex2html132"
+  HREF="switchs.html"> Command line switch reference</A> 
+ </UL>
+ <!--End of Table of Child-Links--> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node6.html lame3.70/doc/html/node6.html
*** encoder/doc/html/node6.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/node6.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,133 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Introduction</TITLE>
+ <META NAME="description" CONTENT="Introduction">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node7.html">
+ <LINK REL="previous" HREF="node5.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node7.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Table of Child-Links--> <A NAME="CHILD_LINKS"><strong>Subsections</strong></A> 
+ <UL>
+   <LI><A NAME="tex2html146"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+   <LI><A NAME="tex2html147"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+   <LI><A NAME="tex2html148"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+     quality</A> 
+ </UL>
+ <!--End of Table of Child-Links--> 
+ <HR>
+ <H1><A NAME="SECTION00310000000000000000"> Introduction</A> </H1>
+ <A NAME="chap-intro">&#160;</A> There is a lot of confusion surrounding the terms 
+ <A NAME="352">&#160;</A><I>audio compression</I>, <A NAME="354">&#160;</A><I>audio 
+ encoding</I>, and <A NAME="356">&#160;</A><I>audio decoding</I>. This section 
+ will give you an overview what audio coding (another one of these terms...) is 
+ all about. 
+ <P> 
+ <H2><A NAME="SECTION00311000000000000000"> The purpose of audio compression</A> 
+ </H2>
+ <P> Up to the advent of audio compression, high-quality digital audio data took 
+   a lot of hard disk space to store. Let us go through a short example. 
+ <P> You want to, say, sample your favorite 1-minute song and store it on your 
+   harddisk. Because you want CD quality, you sample at 44.1&nbsp;kHz, stereo, 
+   with 16 bits per sample. 
+ <P> 44100 Hz means that you have 44100 values per second coming in from your sound 
+   card (or input file). Multiply that by two because you have two channels. Multiply 
+   by another factor of two because you have two bytes per value (that's what 16 
+   bit means). The song will take up <NOBR>44100 samples/s &middot; 2 channels 
+   &middot; 2 bytes/sample &middot; 60 s/min ~ 10 MBytes</NOBR> of storage space 
+   on your harddisk. 
+ <P> If you wanted to download that over the internet, given an average 56k&nbsp;modem 
+   connected at 44k (which is a typical case), it would take you (at least) <NOBR>10000000 
+   bytes &middot; 8 bits/byte / (44000 bits/s) &middot; / (60 s/min) ~ 30 minutes</NOBR> 
+ <DIV ALIGN="CENTER"> <B>Just to download one minute of music!</B> </DIV>
+ <P> Digital audio coding, which - in this context - is synonymously called digital 
+   audio compression as well, is the art of minimizing storage space (or channel 
+   bandwidth) requirements for audio data. Modern perceptual audio coding techniques 
+   (like MPEG Layer III) exploit the properties of the human ear (the perception 
+   of sound) to achieve a size reduction by a factor of 11 with little or no perceptible 
+   loss of quality. 
+ <P> Therefore, such schemes are the key technology for high quality low bit-rate 
+   applications, like soundtracks for CD-ROM games, solid-state sound memories, 
+   Internet audio, digital audio broadcasting systems, and the like. 
+ <P> 
+ <H2><A NAME="SECTION00312000000000000000"> The two parts of audio compression</A> 
+ </H2>
+ <P> Audio compression really consists of two parts. The first part, called <A NAME="358">&#160;</A><I>encoding</I>, 
+   transforms the digital audio data that resides, say, in a WAVE file, into a 
+   highly compressed form called <A NAME="360">&#160;</A><I>bitstream</I>. To play 
+   the bitstream on your soundcard, you need the second part, called <A NAME="362">&#160;</A><I>decoding</I>. 
+   Decoding takes the bitstream and re-expands it to a WAVE file. 
+ <P> The program that effects the first part is called an audio <I>encoder</I>. 
+   <i>LAME</i> is such an encoder . The program that does the second part is called 
+   an audio <I>decoder</I>. One well-known MPEG&nbsp;Layer III decoder is <tt>Xmms</tt>, 
+   another <TT>mpg123</TT>. Both can be found on <A NAME="tex2html1"
+  HREF="http://mp3tech.tsx.org">www.mp3tech.org</A> .
+ <H2><A NAME="SECTION00313000000000000000"> Compression ratios, bitrate and quality</A> 
+ </H2>
+ <P> It has not been explicitly mentioned up to now: What you end up with after 
+   encoding and decoding is not the same sound file anymore: All superflous information 
+   has been squeezed out, so to say. It is not the same <I>file</I>, but it will 
+   <I>sound</I> the same - more or less, depending on how much compression had 
+   been performed on it. 
+ <P> Generally speaking, the lower the compression ratio achieved, the better the 
+   sound quality will be in the end - and <I>vice versa</I>. Table <A HREF="node6.html#table-soundq">1.1</A> 
+   gives you an overview about quality achievable. 
+ <P> Because compression ratio is a somewhat unwieldy measure, experts use the 
+   term <A NAME="365">&#160;</A><I>bitrate</I> when speaking of the strength of 
+   compression. Bitrate denotes the average number of bits that one second of audio 
+   data will take up in your compressed bitstream. Usually the units used will 
+   be kbps, which is <SUP>kbits</SUP>/<SUB>s</SUB>, or 1000&nbsp;<SUP>bits</SUP>/<SUB>s</SUB>. 
+   To calculate the number of bytes per second of audio data, simply divide the 
+   number of bits per second by eight. 
+ <P> <BR>
+ <DIV ALIGN="CENTER"><A NAME="table-soundq">&#160;</A> <A NAME="95">&#160;</A> 
+   <TABLE CELLPADDING=3 BORDER="1">
+     <CAPTION><STRONG>Table 1.1:</STRONG> Bitrate versus sound quality</CAPTION>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>Bitrate</TD>
+       <TD ALIGN="RIGHT" nowrap>Bandwidth</TD>
+       <TD ALIGN="LEFT" nowrap>Quality comparable to or better than</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>8 kbps</TD>
+       <TD ALIGN="RIGHT" nowrap>2.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>POTS (telephone sound)</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>16 kbps</TD>
+       <TD ALIGN="RIGHT" nowrap>4.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>shortwave radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>32 kbps</TD>
+       <TD ALIGN="RIGHT" nowrap>7.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>AM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>64 kbps</TD>
+       <TD ALIGN="RIGHT" nowrap>11 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>FM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>128 kbps</TD>
+       <TD ALIGN="RIGHT" nowrap>16 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>CD</TD>
+     </TR>
+   </TABLE>
+ </DIV>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node7.html lame3.70/doc/html/node7.html
*** encoder/doc/html/node7.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/node7.html	Sun Jan  2 22:15:41 2000
***************
*** 0 ****
--- 1,33 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <HTML>
+ <HEAD>
+    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
+    <META NAME="description" CONTENT="Some examples">
+    <META NAME="keywords" CONTENT="lame">
+    <META NAME="resource-type" CONTENT="document">
+    <META NAME="distribution" CONTENT="global">
+    <META NAME="GENERATOR" CONTENT="Mozilla/4.08 [en] (X11; I; Linux 2.0.36 i686) [Netscape]">
+    <TITLE>Some examples</TITLE>
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node8.html">
+ <LINK REL="previous" HREF="node6.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node8.html">
+ </HEAD>
+ <BODY TEXT="#000000" BGCOLOR="#F9FBFB" LINK="#006666" VLINK="#4C4C4C" ALINK="#995500">
+ <H1> <A NAME="SECTION00320000000000000000"></A><FONT FACE="Helvetica">Some examples</FONT></H1>
+ <A NAME="cmdl-examples"></A> 
+ <UL>
+   <LI> <FONT FACE="Helvetica">Recommended usage: Encode a WAVE-file <TT>myfile.wav</TT> 
+     to a bitrate of 128000 bits/s, writing to a plain bitstream <TT>myfile.mp3</TT> 
+     and using high quality mode:</FONT></LI>
+   <BR>
+   <TT><FONT FACE="Helvetica">lame -h myfile.wav myfile.mp3</FONT></TT> <br>
+   <br>
+   <LI> <FONT FACE="Helvetica">Encode a plain PCM stream (2-channel, 44.1 kHz) 
+     to a plain 56 kBit/s Layer-3 stream, using the encoder as filter</FONT></LI>
+   <BR>
+   <TT><FONT FACE="Helvetica">lame -r -s 44.1 -b 56 - -</FONT></TT>
+ </UL>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/switchs.html lame3.70/doc/html/switchs.html
*** encoder/doc/html/switchs.html	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/html/switchs.html	Wed Mar 29 13:49:02 2000
***************
*** 0 ****
--- 1,521 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Full command line switch reference</TITLE>
+ <META NAME="description" CONTENT="Command line switch reference">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node9.html">
+ <LINK REL="previous" HREF="node7.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node9.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <H1>Full command line switch reference</H1>
+ <P> 
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><b>switch</b></TD>
+     <TD ALIGN="LEFT" nowrap><b>parameter</b></TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#a">-a</a></kbd></td>
+     <td align="LEFT" nowrap>downmix stereo file to mono</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-athonly">--athonly</a></kbd></td>
+     <td align="LEFT" nowrap>ATH only</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#b">-b</a></kbd></td>
+     <td align="LEFT" nowrap>bitrate (8...320)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#Bmax">-B</a></kbd></td>
+     <td align="LEFT" nowrap>max VBR bitrate (8...320)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#c">-c</a></kbd></td>
+     <td align="LEFT" nowrap>copyright</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#d">-d</a></kbd></td>
+     <td align="LEFT" nowrap>block type control</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#e">-e</a></kbd></td>
+     <td align="LEFT" nowrap>de-emphasis (<b>n</b>, 5, c)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#f">-f</a></kbd></td>
+     <td align="LEFT" nowrap> fast mode</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd>-g</kbd></td>
+     <td align="LEFT" nowrap>turn on MP3x graphical frame analyser (may not be 
+       available on your release)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#h">-h</a></kbd></td>
+     <td align="LEFT" nowrap>high quality</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-help">--help</a></kbd></td>
+     <td align="LEFT" nowrap> help</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-highpass">--highpass</a></kbd></td>
+     <td align="LEFT" nowrap> highpass filtering frequency in kHz</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-highpass">--highpass-width</a></kbd></td>
+     <td align="LEFT" nowrap> width of highpass filtering in kHz</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#k">-k</a></kbd></td>
+     <td align="LEFT" nowrap> full bandwidth</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-lowpass">--lowpass</a></kbd></td>
+     <td align="LEFT" nowrap> lowpass filtering frequency in kHz</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-lowpass-width">--lowpass-width</a></kbd></td>
+     <td align="LEFT" nowrap> width of lowpass filtering in kHz</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#m">-m</a></kbd></td>
+     <td align="LEFT" nowrap>stereo mode (s, <b>j</b>, f, m)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-mp3input">--mp3input</a></kbd></td>
+     <td align="LEFT" nowrap>mp3 input file</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-noath">--noath</a></kbd></td>
+     <td align="LEFT" nowrap>no ATH</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-nohist">--nohist</a></kbd></td>
+     <td align="LEFT" nowrap>disable histogram display</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-nores">--nores</a></kbd></td>
+     <td align="LEFT" nowrap>disable bit reservoir</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-noshort">--noshort</a></kbd></td>
+     <td align="LEFT" nowrap>disable short blocks frames</td>
+   </tr>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><kbd><a href="#o">-o</a></kbd></TD>
+     <TD ALIGN="LEFT" nowrap>non-original</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#p">-p</a></kbd></td>
+     <td align="LEFT" nowrap>error protection</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-preset">--preset</a></kbd></td>
+     <td align="LEFT" nowrap>use built-in preset (phone, voice, fm, tape, hifi, 
+       cd, studio)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#r">-r</a></kbd></td>
+     <td align="LEFT" nowrap>input file is raw pcm</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-resample">--resample</a></kbd></td>
+     <td align="LEFT" nowrap>output sampling frequency in kHz</td>
+   </tr>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><kbd><a href="#s">-s</a></kbd></TD>
+     <TD ALIGN="LEFT" nowrap>sampling frequency in kHz</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#S">-S</a></kbd></td>
+     <td align="LEFT" nowrap>silent operation</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#t">-t</a></kbd></td>
+     <td align="LEFT" nowrap>disable VBR tag</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#V">-V</a></kbd></td>
+     <td align="LEFT" nowrap>VBR quality setting (0...9)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#-voice">--voice</a></kbd></td>
+     <td align="LEFT" nowrap>voice encoding mode</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><kbd><a href="#x">-x</a></kbd></td>
+     <td align="LEFT" nowrap>swapbytes</td>
+   </tr>
+ </TABLE>
+ <BR>
+ <dl> 
+   <dt><strong>* <kbd>-a</kbd><a name="a">&nbsp;&nbsp;&nbsp;&nbsp;downmix&#160;</a></strong> 
+   <dd>Mix the stereo input file to mono and encode as mono. This option is only 
+     needed in the case of raw PCM stereo input (because LAME cannot determine 
+     the number of channels in the input file).<br>
+     To encode a stereo PCM input file as mono, use "lame -m s -a".<br>
+     For WAV and AIFF input files, using "-m m" will always produce a mono .mp3 
+     file from both mono and stereo input.<br>
+     The downmix is calculated as the sum of the left and right channel, attenuated 
+     by 6 dB. 
+   <dt><br>
+     <br>
+   </dt>
+   <dt><strong>* <kbd>--athonly</kbd><a name="-athonly">&nbsp;&nbsp;&nbsp;&nbsp;ATH 
+     only</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd>This option causes LAME to ignore the output of the psy-model and only use 
+     masking from the ATH. Might be useful at very high bitrates or for testing 
+     the ATH. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-b</kbd><a name="b">&nbsp;&nbsp;&nbsp;&nbsp;bitrate</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd>For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)<br>
+     n = 32,40,48,56,64,80,96,112,128,160,192,224,256,320<br>
+     <br>
+     For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)<br>
+     n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160<br>
+     <br>
+     Default is 128kbs for MPEG1 and 80kbs for MPEG2. <br>
+     <br>
+     When used with variable bitrate encoding (VBR), -b specifies the minimum bitrate 
+     to be used. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-B</kbd><a name="Bmax">&nbsp;&nbsp;&nbsp;&nbsp;maximum VBR 
+     bitrate&nbsp;</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd>For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)<br>
+     n = 32,40,48,56,64,80,96,112,128,160,192,224,256,320<br>
+     <br>
+     For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)<br>
+     n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160<br>
+     <br>
+     Specifies the maximum allowed bitrate when using VBR.<br>
+     <br>
+     <i>note: If you own an mp3 hardware player build upon a MAS 3503 chip, you 
+     must set maximum bitrate to no more than 224 kpbs.</i> <br>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-c</kbd><a name="c">&nbsp;&nbsp;&nbsp;&nbsp;copyright</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd>Mark the encoded file as being copyrighted. 
+   <dt><br>
+     <br>
+   <dt><strong>* <kbd>-d</kbd><a name="d">&nbsp;&nbsp;&nbsp;&nbsp;block type control</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd>Allows the left and right channels to use different block size types. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-e n/5/c</kbd><a name="e">&nbsp;&nbsp;&nbsp;&nbsp;de-emphasis</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> <br>
+     n = (none, default)<br>
+     5 = 0/15 microseconds<br>
+     c = citt j.17<br>
+     <br>
+     All this does is set a flag in the bitstream. If you have a PCM input file 
+     where one of the above types of (obsolete) emphasis has been applied, you 
+     can set this flag in LAME. Then the mp3 decoder should de-emphasize the output 
+     during playback, although most decoders ignore this flag.<br>
+     A better solution would be to apply the de-emphasis with a standalone utility 
+     before encoding. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-f</kbd><a name="f">&nbsp;&nbsp;&nbsp;&nbsp;fast mode</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> This switch forces the encoder to use the fast encoding mode. It will reduce 
+     a lot the quality of the output. This might be useful for real-time processing 
+     or streaming on slowest computers. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-h</kbd><a name="h">&nbsp;&nbsp;&nbsp;&nbsp;high quality</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Enables specialized mid/side masking thresholds to be used in jstereo mode 
+     and also enables a more accurate but slightly slower quantization formula. 
+     It will sound better but is about 20% slower.<br>
+     Recommended setting.<br>
+     <br>
+     In the future there may be more quality settings, ranging from 0 (highest) 
+     to 9 (lowest) but right now there are just 3: 2,5 or 9. They are enabled with:<br>
+     <br>
+     <table border="0" width="213">
+       <tr> 
+         <td>-f 'fast mode'</td>
+         <td>quality 9</td>
+       </tr>
+       <tr> 
+         <td>default</td>
+         <td>quality 5</td>
+       </tr>
+       <tr> 
+         <td> -h 'high quality'</td>
+         <td>quality 2</td>
+       </tr>
+     </table>
+     
+   <dt><br>
+     <br>
+     <strong>* <kbd>--help</kbd><a name="-help">&nbsp;&nbsp;&nbsp;&nbsp;help</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Display a list of all available options. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>--highpass</kbd><a name="-highpass">&nbsp;&nbsp;&nbsp;&nbsp;highpass 
+     filtering frequency in kHz</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Set an highpass filtering frequency. Frequencies below the specified one 
+     will be cutoff. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>--highpass-width</kbd><a name="-highpass-width">&nbsp;&nbsp;&nbsp;&nbsp;width 
+     of highpass filtering in kHz</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Set the width of the highpass filter. The default value is 15% of highpass 
+     frequency. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-k</kbd><a name="k">&nbsp;&nbsp;&nbsp;&nbsp;full bandwidth</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Tells the encoder to use full bandwidth. By default, the encoder uses some 
+     highpass filtering at low bitrates, in order to keep a good quality. Increasing 
+     the bandwidth from the default setting might produces ringing artefacts at 
+     low bitrates. Use with care! 
+   <dt><br>
+     <br>
+     <strong>* <kbd>--lowpass</kbd><a name="-lowpass">&nbsp;&nbsp;&nbsp;&nbsp;lowpass 
+     filtering frequency in kHz</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Set a lowpass filtering frequency. Frequencies above the specified one 
+     will be cutoff. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>--lowpass-width</kbd><a name="-lowpass-width">&nbsp;&nbsp;&nbsp;&nbsp;width 
+     of lowpass filtering in kHz</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Set the width of the lowpass filter. The default value is 15% of lowpass 
+     frequency. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-m s/<b>j/</b>f/m</kbd><a name="m">&nbsp;&nbsp;&nbsp;&nbsp;stereo 
+     mode</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Joint-stereo is the default mode for stereo files with VBR or fixed bitrates 
+     of 160kbs or less. At higher fixed bitrates, the default is stereo. <b><i><br>
+     <br>
+     stereo</i></b> <br>
+     In this mode, the encoder makes no use of potentially existing correlations 
+     between the two input channels. It can, however, negotiate the bit demand 
+     between both channel, i.e. give one channel more bits if the other contains 
+     silence.<br>
+     <br>
+     <i><b>joint stereo</b></i><br>
+     In this mode, the encoder will make use of a correlation between both channels. 
+     The signal will be matrixed into a sum ("mid") and difference ("side") signal. 
+     For quasi-mono signals, this will give a significant gain in encoding quality.<br>
+     This mode does not destroy phase information like IS stereo that may be used 
+     by other encoders and thus can be used to encode DOLBY ProLogic surround signals. 
+     <br>
+     <br>
+     <b><i>forced joint stereo </i></b><br>
+     This mode will force MS joint stereo on all frames. It's slightly faster than 
+     joint stereo, but it should be used only if you are sure that every frame 
+     of the input file has very little stereo separation.<br>
+     <br>
+     <b><i>mono</i></b><br>
+     The input will be encoded as a mono signal. If it was a stereo signal, it 
+     will be downsampled to mono. The downmix is calculated as the sum of the left 
+     and right channel, attenuated by 6 dB. 
+   <dt><br>
+     <br>
+   </dt>
+   <dt><strong>* <kbd>--mp3input</kbd><a name="-mp3input">&nbsp;&nbsp;&nbsp;&nbsp;mp3 
+     input file</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Assume the input file is a MP3 file. Usefull for downsampling from one 
+     mp3 to another. As an example, it can be usefull for streaming through an 
+     IceCast server.<br>
+     If the filename ends in ".mp3" LAME will assume it is an MP3. For stdin or 
+     MP3 files which dont end in .mp3 you need to use this switch. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>--noath</kbd><a name="-noath">&nbsp;&nbsp;&nbsp;&nbsp;no 
+     ATH</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Disable any use of the ATH for masking. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>--nohist</kbd><a name="-nohist">&nbsp;&nbsp;&nbsp;&nbsp;disable 
+     histogram display</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> By default, LAME will display a bitrate histogram while producing VBR mp3 
+     files. This will disable that feature.<br>
+     Histogram display might not be available on your release. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>--nores</kbd><a name="-nores">&nbsp;&nbsp;&nbsp;&nbsp;disable 
+     bit reservoir</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Disable the bit reservoir. Each frame will then become independent from 
+     previous ones, but the quality will be lower. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>--noshort</kbd><a name="-noshort">&nbsp;&nbsp;&nbsp;&nbsp;disable 
+     short blocks frames</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Encode all frames using long blocks only. This could increase quality when 
+     encoding at very low bitrates, but can produce serious pre-echo artefacts. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-o</kbd><a name="o">&nbsp;&nbsp;&nbsp;&nbsp;non-original</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Mark the encoded file as a copy. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-p</kbd><a name="p">&nbsp;&nbsp;&nbsp;&nbsp;error protection</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Turn on CRC error protection. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>--preset phone/voice/fm/tape/hifi/cd/studio</kbd> <a name="-preset">&nbsp;&nbsp;&nbsp;&nbsp;use 
+     built-in preset</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Use one of the built-in presets. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-r</kbd><a name="r">&nbsp;&nbsp;&nbsp;&nbsp;input file is raw 
+     pcm</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Assume the input file is raw pcm. Sampling rate and mono/stereo/jstereo 
+     must be specified on the command line. Without -r, LAME will perform several 
+     fseek()'s on the input file looking for WAV and AIFF headers.<br>
+     Might not be available on your release. 
+   <dt><br>
+     <br>
+   </dt>
+   <dt><strong>* <kbd>--resample</kbd><a name="-resample">&nbsp;&nbsp;&nbsp;&nbsp;output 
+     sampling frequency in kHz</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> n = 16, 22.05, 24, 32, 44.1, 48<br>
+     <br>
+     Resample the input to the specified frequency. If not specified, LAME will 
+     automatically resample the input when using high compression ratios. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-s 16/22.05/24/32/44.1/48</kbd><a name="s">&nbsp;&nbsp;&nbsp;&nbsp;sampling 
+     frequency</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Required only for raw PCM input files. Otherwise it will be determined 
+     from the header. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-S</kbd><a name="S">&nbsp;&nbsp;&nbsp;&nbsp;silent operation</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Don't print progress report. 
+   <dt><br>
+     <br>
+     <strong>* <kbd>-t</kbd><a name="t">&nbsp;&nbsp;&nbsp;&nbsp;disable VBR tag</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Disable writing of the VBR Tag (only valid in VBR mode).<br>
+     This tag in embedded in frame 0 of the MP3 file. It lets VBR aware players 
+     correctly seek and compute playing times of VBR files. 
+   <dt><br>
+     <br>
+   </dt>
+   <dt><strong>* <kbd>-V 0...9</kbd><a name="V">&nbsp;&nbsp;&nbsp;&nbsp;VBR quality 
+     setting</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Enable VBR (Variable BitRate) and specifies the value of VBR quality.<br>
+     default=4<br>
+     0=highest quality. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>--voice</kbd><a name="-voice">&nbsp;&nbsp;&nbsp;&nbsp;voice 
+     encoding mode</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Use voice encoding mode. In the case of voice encoding, it will increase 
+     the quality a low bitrates, or reduce the file size when using VBR.<br>
+     However, be carefull to only use it on 44.1kHz files. 
+   <dt><br>
+   </dt>
+ </dl>
+ <dl> 
+   <dt><strong>* <kbd>-x</kbd><a name="x">&nbsp;&nbsp;&nbsp;&nbsp;swapbytes</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Swap bytes in the input file. For sorting out little endian/big endian 
+     type problems. If your encodings sounds like static, try this first. 
+ </dl>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/man/CVS/Entries lame3.70/doc/man/CVS/Entries
*** encoder/doc/man/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/man/CVS/Entries	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,2 ----
+ /lame.1/1.1.1.1/Wed Nov 24 08:44:31 1999//Tlame3_70
+ D
diff -r -c -N encoder/doc/man/CVS/Repository lame3.70/doc/man/CVS/Repository
*** encoder/doc/man/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/man/CVS/Repository	Thu Apr  6 12:50:36 2000
***************
*** 0 ****
--- 1 ----
+ lame/doc/man
diff -r -c -N encoder/doc/man/CVS/Root lame3.70/doc/man/CVS/Root
*** encoder/doc/man/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/man/CVS/Root	Thu Apr  6 12:50:36 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/doc/man/CVS/Tag lame3.70/doc/man/CVS/Tag
*** encoder/doc/man/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/man/CVS/Tag	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/doc/man/lame.1 lame3.70/doc/man/lame.1
*** encoder/doc/man/lame.1	Wed Dec 31 17:00:00 1969
--- lame3.70/doc/man/lame.1	Wed Nov 24 01:44:31 1999
***************
*** 0 ****
--- 1,353 ----
+ .TH lame 1 "November 8, 1999" " " "LAME audio compressor MP3 "
+ .SH NAME
+ lame \- create mp3 audio files
+ .SH SYNOPSIS
+ .nf
+ lame [options] <infile> <outfile>
+ .fi
+ .SH DESCRIPTION
+ .PP
+ Lame is a program which can be used to create compressed audio files.
+ (Lame aint MP3 encoder).   These audio files can be played back by popular 
+ mp3 players such as mpg123.  To read from stdin, use "-" for <infile>.
+ To write to stdout, use a "-" for <outfile>.
+ 
+ .SH OPTIONS
+ .TP
+ .BI -m  " mode"
+  (s)tereo, (j)oint, (f)orce or (m)ono  (default j)
+ force = force mid/side stereo on all frames.  Faster if you know mid/side
+ stereo is appropriate for the input file.
+ .TP
+ .BI -b  " bitrate"
+ set the bitrate, default 128kbps
+ .TP
+ .BI -s " sample-freq"
+ frequency of input file (khz) - default 44.1
+ .TP
+ .BI --resamp " sfreq"
+ sampling frequency of output file(kHz)- default=input sfreq
+ .TP
+ .BI --mp3input
+ input file is a MP3 file
+ .TP
+ .BI --voice
+ experimental voice mode
+ .TP
+ .BI -v
+ use variable bitrate (VBR)
+ .TP
+ .BI -V " n"
+ quality setting for VBR. Default n=4, 0=high quality,bigger files.
+ 9=smaller files
+ .TP
+ .BI -b " <bitrate>"
+ specify minimum allowed bitrate for VBR, default 32kbs
+ .TP
+ .BI -B " <bitrate>"
+ specify miximum allowed bitrate for VBR, default 256kbs
+ .TP
+ .BI -t
+ disable Xing VBR informational tag
+ .TP
+ .BI --nohist
+ disable VBR histogram display
+ 
+ .TP
+ .BI -h
+ slower, but (maybe) higher quality
+ .TP
+ .BI -f
+ fast mode (low quality)
+ .TP
+ .BI -k
+ disable sfb=21 cutoff
+ .TP
+ .BI -d
+ allow channels to have different blocktypes
+ .TP
+ .BI --athonly
+ only use the ATH for masking
+ .TP
+ .BI -r
+ input is raw pcm
+ .TP
+ .BI -x
+ force byte-swapping of input
+ .TP
+ .BI -a
+ autoconvert from stereo to mono file for mono encoding
+ .TP
+ .BI -e " emp"
+ de-emphasis n/5/c  (default: n)
+ .TP
+ .BI -p
+ add CRC error protection (adds additional 16bits per frame to stream)
+ .TP
+ .BI -c
+ mark as copyright
+ .TP
+ .BI -o
+ mark as non-original (i.e. do not set the original bit)
+ .TP
+ .BI -S
+ don't print progress report, VBR histograms
+ .TP
+ .BI -g
+ run graphical analysis on <infile>.  <infile> can also be a .mp3 file.
+ (This feature is a compile time option. Your binary may for speed reasons be
+ compiled without this.)
+ 
+ 
+ 
+ .SH EXAMPLES
+ .LP
+ Recommended way to create a fixed 128kbs mp3 file from a wav file
+ .IP
+ .B lame -h
+ .I foo.wav foo.mp3
+ .LP
+ Copy track 7 from a regular audio CD, using cdparanoia
+ 
+ .IP
+ .B cdparanoia 7 foo.wav  ;
+ .B  lame -h foo.wav foo.mp3
+ 
+ .LP
+ Copy track 7 from a regular audio CD with cdda2wav, where the cdrom device is
+ device /dev/cdrom to an mp3 file foo.mp3
+ 
+ .IP
+ .B cdda2wav \-O
+ .I wav
+ .B \-t 7 \-D
+ .I /dev/cdrom
+ .I \-
+ .B  | lame 
+ .I \- foo.mp3
+ 
+ .IP
+ 
+ .LP
+ Streaming from mono 22.05kHz raw pcm data and using sox to 
+ downsample to 16kHz:
+ .IP
+ cat inputfile | sox -t raw -x -w -s -c 1 -r 22050 -  
+ -t raw -x -w -s -c 1 -r 16000 - | lame -r -m m -b 24 -s 16 - - > output
+ .IP
+ 
+ 
+ 
+ .SH BUGS
+ .PP
+ Quality is much better than encoders based on the ISO routines,
+ but still not as good as the FhG encoder.
+ .SH SEE ALSO
+ .BR mpg123 (1) ,
+ .BR cdparanoia (1) ,
+ .BR cdda2wav (1) ,
+ .BR sox (1)
+ .SH AUTHORS
+ .nf
+ LAME originally developed by Mike Cheng
+ (www.uq.net.au/~zzmcheng)
+ GPSYCHO psycho-acoustic model by Mark Taylor 
+ (www.sulaco.org/mp3).
+ mpglib by Michael Hipp
+ Manual page by William Schelter, Nils Faerber
+ .f
+  -=- MIME -=- 
+ 
+ --jI8keyz6grp/JLjh
+ Content-Type: text/plain; charset=us-ascii
+ 
+ Hi Mark!
+ I have just updated the man page for lame 3.53beta to the latest options
+ with some minor cosmetic changes. Find the new version as attachment...
+ CU
+   nils
+ 
+ -- 
+ Nils Faerber (Linux Nils)        eMail: nils@unix-ag.org
+ Student of computer science      http://www.si.unix-ag.org/~nils/
+ Unix user group, University of Siegen, Germany
+ 
+ Siegen ... the arctic rain forest!
+ --
+ --jI8keyz6grp/JLjh
+ Content-Type: text/plain; charset=us-ascii
+ Content-Disposition: attachment; filename="lame.1"
+ 
+ .TH lame 1 "November 8, 1999" " " "LAME audio compressor MP3 "
+ .SH NAME
+ lame \- create mp3 audio files
+ .SH SYNOPSIS
+ .nf
+ lame [options] <infile> <outfile>
+ .fi
+ .SH DESCRIPTION
+ .PP
+ Lame is a program which can be used to create compressed audio files.
+ (Lame aint MP3 encoder).   These audio files can be played back by popular 
+ mp3 players such as mpg123.  To read from stdin, use "-" for <infile>.
+ To write to stdout, use a "-" for <outfile>.
+ 
+ .SH OPTIONS
+ .TP
+ .BI -m  " mode"
+  (s)tereo, (j)oint, (f)orce or (m)ono  (default j)
+ force = force mid/side stereo on all frames.  Faster if you know mid/side
+ stereo is appropriate for the input file.
+ .TP
+ .BI -b  " bitrate"
+ set the bitrate, default 128kbps
+ .TP
+ .BI -s " sample-freq"
+ frequency of input file (khz) - default 44.1
+ .TP
+ .BI --resamp " sfreq"
+ sampling frequency of output file(kHz)- default=input sfreq
+ .TP
+ .BI --mp3input
+ input file is a MP3 file
+ .TP
+ .BI --voice
+ experimental voice mode
+ .TP
+ .BI -v
+ use variable bitrate (VBR)
+ .TP
+ .BI -V " n"
+ quality setting for VBR. Default n=4, 0=high quality,bigger files.
+ 9=smaller files
+ .TP
+ .BI -b " <bitrate>"
+ specify minimum allowed bitrate for VBR, default 32kbs
+ .TP
+ .BI -B " <bitrate>"
+ specify miximum allowed bitrate for VBR, default 256kbs
+ .TP
+ .BI -t
+ disable Xing VBR informational tag
+ .TP
+ .BI --nohist
+ disable VBR histogram display
+ 
+ .TP
+ .BI -h
+ slower, but (maybe) higher quality
+ .TP
+ .BI -f
+ fast mode (low quality)
+ .TP
+ .BI -k
+ disable sfb=21 cutoff
+ .TP
+ .BI -d
+ allow channels to have different blocktypes
+ .TP
+ .BI --athonly
+ only use the ATH for masking
+ .TP
+ .BI -r
+ input is raw pcm
+ .TP
+ .BI -x
+ force byte-swapping of input
+ .TP
+ .BI -a
+ autoconvert from stereo to mono file for mono encoding
+ .TP
+ .BI -e " emp"
+ de-emphasis n/5/c  (default: n)
+ .TP
+ .BI -p
+ add CRC error protection (adds additional 16bits per frame to stream)
+ .TP
+ .BI -c
+ mark as copyright
+ .TP
+ .BI -o
+ mark as non-original (i.e. do not set the original bit)
+ .TP
+ .BI -S
+ don't print progress report, VBR histograms
+ .TP
+ .BI -g
+ run graphical analysis on <infile>.  <infile> can also be a .mp3 file.
+ (This feature is a compile time option. Your binary may for speed reasons be
+ compiled without this.)
+ 
+ 
+ 
+ .SH EXAMPLES
+ .LP
+ Recommended way to create a fixed 128kbs mp3 file from a wav file
+ .IP
+ .B lame -h
+ .I foo.wav foo.mp3
+ .LP
+ Copy track 7 from a regular audio CD, using cdparanoia
+ 
+ .IP
+ .B cdparanoia 7 foo.wav  ;
+ .B  lame -h foo.wav foo.mp3
+ 
+ .LP
+ Copy track 7 from a regular audio CD with cdda2wav, where the cdrom device is
+ device /dev/cdrom to an mp3 file foo.mp3
+ 
+ .IP
+ .B cdda2wav \-O
+ .I wav
+ .B \-t 7 \-D
+ .I /dev/cdrom
+ .I \-
+ .B  | lame 
+ .I \- foo.mp3
+ 
+ .IP
+ 
+ .LP
+ Streaming from mono 22.05kHz raw pcm data and using sox to 
+ downsample to 16kHz:
+ .IP
+ cat inputfile | sox -t raw -x -w -s -c 1 -r 22050 -  
+ -t raw -x -w -s -c 1 -r 16000 - | lame -r -m m -b 24 -s 16 - - > output
+ .IP
+ 
+ 
+ 
+ .SH BUGS
+ .PP
+ Quality is much better than encoders based on the ISO routines,
+ but still not as good as the FhG encoder.
+ .SH SEE ALSO
+ .BR mpg123 (1) ,
+ .BR cdparanoia (1) ,
+ .BR cdda2wav (1) ,
+ .BR sox (1)
+ .SH AUTHORS
+ .nf
+ LAME originally developed by Mike Cheng
+ (www.uq.net.au/~zzmcheng)
+ GPSYCHO psycho-acoustic model by Mark Taylor 
+ (www.sulaco.org/mp3).
+ mpglib by Michael Hipp
+ Manual page by William Schelter, Nils Faerber
+ .f
+ 
+ --jI8keyz6grp/JLjh--
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/encode.c lame3.70/encode.c
*** encoder/encode.c	Wed Jan 22 02:43:14 1997
--- lame3.70/encode.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1456 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: encode.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: encode.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
-  *          Davis Pan                                                 *
-  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
-  *                                      efilter to enfilter           *
-  *                                      ewindow to enwindow           *
-  *                              integrated "quantizer", "scalefactor",*
-  *                              and "transmission" files              *
-  *                              update routine "window_subband"       *
-  * 3/31/91  Bill Aspromonte     replaced read_filter by               *
-  *                              create_an_filter                      *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Incorporated Jean-Georges Fritsch's   *
-  *                              "bitstream.c" package.                *
-  *                              Incorporated Bill Aspromonte's        *
-  *                              filterbank coefficient matrix         *
-  *                              calculation routines and added        *
-  *                              roundoff to coincide with specs.      *
-  *                              Modified to strictly adhere to        *
-  *                              encoded bitstream specs, including    *
-  *                              "Berlin changes".                     *
-  *                              Modified PCM sound file handling to   *
-  *                              process all incoming samples and fill *
-  *                              out last encoded frame with zeros     *
-  *                              (silence) if needed.                  *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 19jun91  dpwe (Aware)        moved "alloc_*" reader to common.c    *
-  *                              Globals sblimit, alloc replaced by new*
-  *                              struct 'frame_params' passed as arg.  *
-  *                              Added JOINT STEREO coding, layers I,II*
-  *                              Affects: *_bit_allocation,            *
-  *                              subband_quantization, encode_bit_alloc*
-  *                              sample_encoding                       *
-  * 6/10/91  Earle Jennings      modified II_subband_quantization to   *
-  *                              resolve type cast problem for MS_DOS  *
-  * 6/11/91  Earle Jennings      modified to avoid overflow on MS_DOS  *
-  *                              in routine filter_subband             *
-  * 7/10/91  Earle Jennings      port to MsDos from MacIntosh version  *
-  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
-  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
-  *          Don H. Lee,                                               *
-  *          Peter W. Farrett                                          *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  *                              newly introduced function encode_CRC  *
-  *11/ 8/91  Kathy Wang          Documentation of code                 *
-  *                              All variablenames are referred to     *
-  *                              with surrounding pound (#) signs      *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 6/16/92  Shaun Astarabadi    Changed I_scale_factor_calc() and     *
-  *                              II_scale_factor_calc() to use scale   *
-  *                              factor 0 thru 62 only and not to      *
-  *                              encode index 63 into the bit stream.  *
-  * 7/27/92  Mike Li             (re-)Port to MS-DOS                   *
-  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() defs       *
-  * 3/31/93  Giogio Dimino       changed II_a_bit_allocation() from:   *
-  *                              if( ad > ...) to if(ad >= ...)        *
-  * 8/05/93  TEST                changed I_a_bit_allocation() from:    *
-  *                              if( ad > ...) to if(ad >= ...)        *
-  * 8/02/95  mc@fivebats.com     Changed audio file reading code to    *
-  *                              read samples big-endian               *
-  *10/15/95  mc@fivebats.com     Modified get_audio() for layer3-LSF   *
-  **********************************************************************/
-  
- #include "common.h"
- #include "encoder.h"
- 
- #ifdef MS_DOS
- extern unsigned _stklen = 16384;
- #endif
- 
- 
- /*=======================================================================\
- |                                                                       |
- | This segment contains all the core routines of the encoder,           |
- | except for the psychoacoustic models.                                 |
- |                                                                       |
- | The user can select either one of the two psychoacoustic              |
- | models. Model I is a simple tonal and noise masking threshold         |
- | generator, and Model II is a more sophisticated cochlear masking      |
- | threshold generator. Model I is recommended for lower complexity      |
- | applications whereas Model II gives better subjective quality at low  |
- | bit rates.                                                            |
- |                                                                       |
- | Layers I and II of mono, stereo, and joint stereo modes are supported.|
- | Routines associated with a given layer are prefixed by "I_" for layer |
- | 1 and "II_" for layer 2.                                              |
- \=======================================================================*/
-  
- /************************************************************************
- *
- * read_samples()
- *
- * PURPOSE:  reads the PCM samples from a file to the buffer
- *
- *  SEMANTICS:
- * Reads #samples_read# number of shorts from #musicin# filepointer
- * into #sample_buffer[]#.  Returns the number of samples read.
- *
- ************************************************************************/
- 
- unsigned long read_samples(musicin, sample_buffer, num_samples, frame_size)
- FILE *musicin;
- short sample_buffer[2304];
- unsigned long num_samples, frame_size;
- {
-     unsigned long samples_read;
-     static unsigned long samples_to_read;
-     static char init = TRUE;
- 
-     if (init) {
-         samples_to_read = num_samples;
-         init = FALSE;
-     }
-     if (samples_to_read >= frame_size)
-         samples_read = frame_size;
-     else
-         samples_read = samples_to_read;
-     if ((samples_read =
-          fread(sample_buffer, sizeof(short), (int)samples_read, musicin)) == 0)
-         printf("Hit end of audio data\n");
-     /*
-        Samples are big-endian. If this is a little-endian machine
-        we must swap
-      */
-     if ( NativeByteOrder == order_unknown )
-       {
- 	NativeByteOrder = DetermineByteOrder();
- 	if ( NativeByteOrder == order_unknown )
- 	  {
- 	    fprintf( stderr, "byte order not determined\n" );
- 	    exit( 1 );
- 	  }
-       }
-     if ( NativeByteOrder == order_littleEndian )
-       SwapBytesInWords( sample_buffer, samples_read );
- 
-     samples_to_read -= samples_read;
-     if (samples_read < frame_size && samples_read > 0) {
-         printf("Insufficient PCM input for one frame - fillout with zeros\n");
-         for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
-         samples_to_read = 0;
-     }
-     return(samples_read);
- }
- 
- /************************************************************************
- *
- * get_audio()
- *
- * PURPOSE:  reads a frame of audio data from a file to the buffer,
- *   aligns the data for future processing, and separates the
- *   left and right channels
- *
- *
- ************************************************************************/
-  
- unsigned long get_audio( musicin, buffer, num_samples, stereo, info )
- FILE *musicin;
- short FAR buffer[2][1152];
- unsigned long num_samples;
- int stereo;
- layer *info;
- {
-     int j;
-     short insamp[2304];
-     unsigned long samples_read;
-     int lay;
-     lay = info->lay;
- 
-     if ( (lay == 3) && (info->version == 0) )
-     {
- 	if ( stereo == 2 )
- 	{
- 	    samples_read = read_samples( musicin, insamp, num_samples,
- 					 (unsigned long) 1152 );
- 	    for ( j = 0; j < 576; j++ )
- 	    {
- 		buffer[0][j] = insamp[2 * j];
- 		buffer[1][j] = insamp[2 * j + 1];
- 	    }
- 	}
- 	else
- 	{
- 	    samples_read = read_samples( musicin, insamp, num_samples,
- 					 (unsigned long) 576 );
- 	    for ( j = 0; j < 576; j++ )
- 	    {
- 		buffer[0][j] = insamp[j];
- 		buffer[1][j] = 0;
- 	    }
- 	}
-     }
-     else
-     {
- 	if (lay == 1){
- 	    if(stereo == 2){ /* layer 1, stereo */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 768);
- 		for(j=0;j<448;j++) {
- 		    if(j<64) {
- 			buffer[0][j] = buffer[0][j+384];
- 			buffer[1][j] = buffer[1][j+384];
- 		    }
- 		    else {
- 			buffer[0][j] = insamp[2*j-128];
- 			buffer[1][j] = insamp[2*j-127];
- 		    }
- 		}
- 	    }
- 	    else { /* layer 1, mono */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 384);
- 		for(j=0;j<448;j++){
- 		    if(j<64) {
- 			buffer[0][j] = buffer[0][j+384];
- 			buffer[1][j] = 0;
- 		    }
- 		    else {
- 			buffer[0][j] = insamp[j-64];
- 			buffer[1][j] = 0;
- 		    }
- 		}
- 	    }
- 	}
- 	else {
- 	    if(stereo == 2){ /* layer 2 (or 3), stereo */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 2304);
- 		for(j=0;j<1152;j++) {
- 		    buffer[0][j] = insamp[2*j];
- 		    buffer[1][j] = insamp[2*j+1];
- 		}
- 	    }
- 	    else { /* layer 2 (or 3), mono */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 1152);
- 		for(j=0;j<1152;j++){
- 		    buffer[0][j] = insamp[j];
- 		    buffer[1][j] = 0;
- 		}
- 	    }
- 	}
-     }
-     return(samples_read);
- }
-  
- /************************************************************************
- *
- * read_ana_window()
- *
- * PURPOSE:  Reads encoder window file "enwindow" into array #ana_win#
- *
- ************************************************************************/
-  
- void read_ana_window(ana_win)
- double FAR ana_win[HAN_SIZE];
- {
-     int i,j[4];
-     FILE *fp;
-     double f[4];
-     char t[150];
-  
-     if (!(fp = OpenTableFile("enwindow") ) ) {
-        printf("Please check analysis window table 'enwindow'\n");
-        exit(1);
-     }
-     for (i=0;i<512;i+=4) {
-        fgets(t, 150, fp);
-        sscanf(t,"C[%d] = %lf C[%d] = %lf C[%d] = %lf C[%d] = %lf\n",
-               j, f,j+1,f+1,j+2,f+2,j+3,f+3);
-        if (i==j[0]) {
-           ana_win[i] = f[0];
-           ana_win[i+1] = f[1];
-           ana_win[i+2] = f[2];
-           ana_win[i+3] = f[3];
-        }
-        else {
-           printf("Check index in analysis window table\n");
-           exit(1);
-        }
-        fgets(t,150,fp);
-     }
-     fclose(fp);
- }
- 
- /************************************************************************
- *
- * window_subband()
- *
- * PURPOSE:  Overlapping window on PCM samples
- *
- * SEMANTICS:
- * 32 16-bit pcm samples are scaled to fractional 2's complement and
- * concatenated to the end of the window buffer #x#. The updated window
- * buffer #x# is then windowed by the analysis window #c# to produce the
- * windowed sample #z#
- *
- ************************************************************************/
-  
- void window_subband(buffer, z, k)
- short FAR **buffer;
- double FAR z[HAN_SIZE];
- int k;
- {
-     typedef double FAR XX[2][HAN_SIZE];
-     static XX FAR *x;
-     int i, j;
-     static off[2] = {0,0};
-     static char init = 0;
-     static double FAR *c;
-     if (!init) {
-         c = (double FAR *) mem_alloc(sizeof(double) * HAN_SIZE, "window");
-         read_ana_window(c);
-         x = (XX FAR *) mem_alloc(sizeof(XX),"x");
-         for (i=0;i<2;i++)
-             for (j=0;j<HAN_SIZE;j++)
-                 (*x)[i][j] = 0;
-         init = 1;
-     }
- 
-     /* replace 32 oldest samples with 32 new samples */
-     for (i=0;i<32;i++) (*x)[k][31-i+off[k]] = (double) *(*buffer)++/SCALE;
-     /* shift samples into proper window positions */
-     for (i=0;i<HAN_SIZE;i++) z[i] = (*x)[k][(i+off[k])&HAN_SIZE-1] * c[i];
-     off[k] += 480;              /*offset is modulo (HAN_SIZE-1)*/
-     off[k] &= HAN_SIZE-1;
- 
- }
-  
- /************************************************************************
- *
- * create_ana_filter()
- *
- * PURPOSE:  Calculates the analysis filter bank coefficients
- *
- * SEMANTICS:
- * Calculates the analysis filterbank coefficients and rounds to the
- * 9th decimal place accuracy of the filterbank tables in the ISO
- * document.  The coefficients are stored in #filter#
- 
- ************************************************************************/
-  
- void create_ana_filter(filter)
- double FAR filter[SBLIMIT][64];
- {
-    register int i,k;
-  
-    for (i=0; i<32; i++)
-       for (k=0; k<64; k++) {
-           if ((filter[i][k] = 1e9*cos((double)((2*i+1)*(16-k)*PI64))) >= 0)
-              modf(filter[i][k]+0.5, &filter[i][k]);
-           else
-              modf(filter[i][k]-0.5, &filter[i][k]);
-           filter[i][k] *= 1e-9;
-    }
- }
- 
- /************************************************************************
- *
- * filter_subband()
- *
- * PURPOSE:  Calculates the analysis filter bank coefficients
- *
- * SEMANTICS:
- *      The windowed samples #z# is filtered by the digital filter matrix #m#
- * to produce the subband samples #s#. This done by first selectively
- * picking out values from the windowed samples, and then multiplying
- * them by the filter matrix, producing 32 subband samples.
- *
- ************************************************************************/
-  
- void filter_subband(z,s)
- double FAR z[HAN_SIZE], s[SBLIMIT];
- {
-    double y[64];
-    int i,j;
- static char init = 0;
-    typedef double MM[SBLIMIT][64];
- static MM FAR *m;
- #ifdef MS_DOS
-    long    SIZE_OF_MM;
-    SIZE_OF_MM      = SBLIMIT*64;
-    SIZE_OF_MM      *= 8;
-    if (!init) {
-        m = (MM FAR *) mem_alloc(SIZE_OF_MM, "filter");
-        create_ana_filter(*m);
-        init = 1;
-    }
- #else
-    if (!init) {
-        m = (MM FAR *) mem_alloc(sizeof(MM), "filter");
-        create_ana_filter(*m);
-        init = 1;
-    }
- #endif
-    for (i=0;i<64;i++) for (j=0, y[i] = 0;j<8;j++) y[i] += z[i+64*j];
-    for (i=0;i<SBLIMIT;i++)
-        for (j=0, s[i]= 0;j<64;j++) s[i] += (*m)[i][j] * y[j];
- }
- 
- /************************************************************************
- * encode_info()
- *
- * PURPOSE:  Puts the syncword and header information on the output
- * bitstream.
- *
- ************************************************************************/
-  
- void encode_info(fr_ps,bs)
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-         layer *info = fr_ps->header;
-  
-         putbits(bs,0xfff,12);                    /* syncword 12 bits */
-         put1bit(bs,info->version);               /* ID        1 bit  */
-         putbits(bs,4-info->lay,2);               /* layer     2 bits */
-         put1bit(bs,!info->error_protection);     /* bit set => no err prot */
-         putbits(bs,info->bitrate_index,4);
-         putbits(bs,info->sampling_frequency,2);
-         put1bit(bs,info->padding);
-         put1bit(bs,info->extension);             /* private_bit */
-         putbits(bs,info->mode,2);
-         putbits(bs,info->mode_ext,2);
-         put1bit(bs,info->copyright);
-         put1bit(bs,info->original);
-         putbits(bs,info->emphasis,2);
- }
-  
- /************************************************************************
- *
- * mod()
- *
- * PURPOSE:  Returns the absolute value of its argument
- *
- ************************************************************************/
-  
- double mod(a)
- double a;
- {
-     return (a > 0) ? a : -a;
- }
-  
- /************************************************************************
- *
- * I_combine_LR    (Layer I)
- * II_combine_LR   (Layer II)
- *
- * PURPOSE:Combines left and right channels into a mono channel
- *
- * SEMANTICS:  The average of left and right subband samples is put into
- * #joint_sample#
- *
- * Layer I and II differ in frame length and # subbands used
- *
- ************************************************************************/
-  
- void I_combine_LR(sb_sample, joint_sample)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- {   /* make a filtered mono for joint stereo */
-     int sb, smp;
-  
-    for(sb = 0; sb<SBLIMIT; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-         joint_sample[0][smp][sb] = .5 *
-                     (sb_sample[0][0][smp][sb] + sb_sample[1][0][smp][sb]);
- }
-  
- void II_combine_LR(sb_sample, joint_sample, sblimit)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- int sblimit;
- {  /* make a filtered mono for joint stereo */
-    int sb, smp, sufr;
-  
-    for(sb = 0; sb<sblimit; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-          for(sufr = 0; sufr<3; ++sufr)
-             joint_sample[sufr][smp][sb] = .5 * (sb_sample[0][sufr][smp][sb]
-                                            + sb_sample[1][sufr][smp][sb]);
- }
-  
- /************************************************************************
- *
- * I_scale_factor_calc     (Layer I)
- * II_scale_factor_calc    (Layer II)
- *
- * PURPOSE:For each subband, calculate the scale factor for each set
- * of the 12 subband samples
- *
- * SEMANTICS:  Pick the scalefactor #multiple[]# just larger than the
- * absolute value of the peak subband sample of 12 samples,
- * and store the corresponding scalefactor index in #scalar#.
- *
- * Layer II has three sets of 12-subband samples for a given
- * subband.
- *
- ************************************************************************/
-  
- void I_scale_factor_calc(sb_sample,scalar,stereo)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo;
- {
-    int i,j, k;
-    double s[SBLIMIT];
-  
-    for (k=0;k<stereo;k++) {
-      for (i=0;i<SBLIMIT;i++)
-        for (j=1, s[i] = mod(sb_sample[k][0][0][i]);j<SCALE_BLOCK;j++)
-          if (mod(sb_sample[k][0][j][i]) > s[i])
-             s[i] = mod(sb_sample[k][0][j][i]);
-  
-      for (i=0;i<SBLIMIT;i++)
-        for (j=SCALE_RANGE-2,scalar[k][0][i]=0;j>=0;j--) /* $A 6/16/92 */
-          if (s[i] <= multiple[j]) {
-             scalar[k][0][i] = j;
-             break;
-          }
-    }
- }
- 
- /******************************** Layer II ******************************/
-  
- void II_scale_factor_calc(sb_sample,scalar,stereo,sblimit)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo,sblimit;
- {
-   int i,j, k,t;
-   double s[SBLIMIT];
-  
-   for (k=0;k<stereo;k++) for (t=0;t<3;t++) {
-     for (i=0;i<sblimit;i++)
-       for (j=1, s[i] = mod(sb_sample[k][t][0][i]);j<SCALE_BLOCK;j++)
-         if (mod(sb_sample[k][t][j][i]) > s[i])
-              s[i] = mod(sb_sample[k][t][j][i]);
-  
-   for (i=0;i<sblimit;i++)
-     for (j=SCALE_RANGE-2,scalar[k][t][i]=0;j>=0;j--)    /* $A 6/16/92 */
-       if (s[i] <= multiple[j]) {
-          scalar[k][t][i] = j;
-          break;
-       }
-       for (i=sblimit;i<SBLIMIT;i++) scalar[k][t][i] = SCALE_RANGE-1;
-     }
- }
- 
- /************************************************************************
- *
- * pick_scale  (Layer II)
- *
- * PURPOSE:For each subband, puts the smallest scalefactor of the 3
- * associated with a frame into #max_sc#.  This is used
- * used by Psychoacoustic Model I.
- * (I would recommend changin max_sc to min_sc)
- *
- ************************************************************************/
-  
- void pick_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-   int i,j,k,max;
-   int stereo  = fr_ps->stereo;
-   int sblimit = fr_ps->sblimit;
-  
-   for (k=0;k<stereo;k++)
-     for (i=0;i<sblimit;max_sc[k][i] = multiple[max],i++)
-       for (j=1, max = scalar[k][0][i];j<3;j++)
-          if (max > scalar[k][j][i]) max = scalar[k][j][i];
-   for (i=sblimit;i<SBLIMIT;i++) max_sc[0][i] = max_sc[1][i] = 1E-20;
- }
- 
- /************************************************************************
- *
- * put_scale   (Layer I)
- *
- * PURPOSE:Sets #max_sc# to the scalefactor index in #scalar.
- * This is used by Psychoacoustic Model I
- *
- ************************************************************************/
-  
- void put_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-    int i,j,k, max;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-  
-    for (k=0;k<stereo;k++) for (i=0;i<SBLIMIT;i++)
-         max_sc[k][i] = multiple[scalar[k][0][i]];
- }
-  
- /************************************************************************
- *
- * II_transmission_pattern (Layer II only)
- *
- * PURPOSE:For a given subband, determines whether to send 1, 2, or
- * all 3 of the scalefactors, and fills in the scalefactor
- * select information accordingly
- *
- * SEMANTICS:  The subbands and channels are classified based on how much
- * the scalefactors changes over its three values (corresponding
- * to the 3 sets of 12 samples per subband).  The classification
- * will send 1 or 2 scalefactors instead of three if the scalefactors
- * do not change much.  The scalefactor select information,
- * #scfsi#, is filled in accordingly.
- *
- ************************************************************************/
-  
- void II_transmission_pattern(scalar, scfsi, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int dscf[2];
-    int class[2],i,j,k;
- static int pattern[5][5] = {0x123, 0x122, 0x122, 0x133, 0x123,
-                             0x113, 0x111, 0x111, 0x444, 0x113,
-                             0x111, 0x111, 0x111, 0x333, 0x113,
-                             0x222, 0x222, 0x222, 0x333, 0x123,
-                             0x123, 0x122, 0x122, 0x133, 0x123};
-  
-    for (k=0;k<stereo;k++)
-      for (i=0;i<sblimit;i++) {
-        dscf[0] =  (scalar[k][0][i]-scalar[k][1][i]);
-        dscf[1] =  (scalar[k][1][i]-scalar[k][2][i]);
-        for (j=0;j<2;j++) {
-          if (dscf[j]<=-3) class[j] = 0;
-          else if (dscf[j] > -3 && dscf[j] <0) class[j] = 1;
-               else if (dscf[j] == 0) class[j] = 2;
-                    else if (dscf[j] > 0 && dscf[j] < 3) class[j] = 3;
-                         else class[j] = 4;
-        }
-        switch (pattern[class[0]][class[1]]) {
-          case 0x123 :    scfsi[k][i] = 0;
-                          break;
-          case 0x122 :    scfsi[k][i] = 3;
-                          scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x133 :    scfsi[k][i] = 3;
-                          scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x113 :    scfsi[k][i] = 1;
-                          scalar[k][1][i] = scalar[k][0][i];
-                          break;
-          case 0x111 :    scfsi[k][i] = 2;
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-                          break;
-          case 0x222 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x333 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x444 :    scfsi[k][i] = 2;
-                          if (scalar[k][0][i] > scalar[k][2][i])
-                               scalar[k][0][i] = scalar[k][2][i];
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-       }
-    }
- }
-  
- /************************************************************************
- *
- * I_encode_scale  (Layer I)
- * II_encode_scale (Layer II)
- *
- * PURPOSE:The encoded scalar factor information is arranged and
- * queued into the output fifo to be transmitted.
- *
- * For Layer II, the three scale factors associated with
- * a given subband and channel are transmitted in accordance
- * with the scfsi, which is transmitted first.
- *
- ************************************************************************/
-  
- void I_encode_scale(scalar, bit_alloc, fr_ps, bs)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int i,j;
-  
-    for (i=0;i<SBLIMIT;i++) for (j=0;j<stereo;j++)
-       if (bit_alloc[j][i]) putbits(bs,scalar[j][0][i],6);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_scale(bit_alloc, scfsi, scalar, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int i,j,k;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  putbits(bs,scfsi[k][i],2);
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  /* above jsbound, bit_alloc[0][i] == ba[1][i] */
-         switch (scfsi[k][i]) {
-            case 0: for (j=0;j<3;j++)
-                      putbits(bs,scalar[k][j][i],6);
-                    break;
-            case 1:
-            case 3: putbits(bs,scalar[k][0][i],6);
-                    putbits(bs,scalar[k][2][i],6);
-                    break;
-            case 2: putbits(bs,scalar[k][0][i],6);
-         }
- }
-  
- /*=======================================================================\
- |                                                                        |
- |      The following routines are done after the masking threshold       |
- | has been calculated by the fft analysis routines in the Psychoacoustic |
- | model. Using the MNR calculated, the actual number of bits allocated   |
- | to each subband is found iteratively.                                  |
- |                                                                        |
- \=======================================================================*/
-  
- /************************************************************************
- *
- * I_bits_for_nonoise  (Layer I)
- * II_bits_for_nonoise (Layer II)
- *
- * PURPOSE:Returns the number of bits required to produce a
- * mask-to-noise ratio better or equal to the noise/no_noise threshold.
- *
- * SEMANTICS:
- * bbal = # bits needed for encoding bit allocation
- * bsel = # bits needed for encoding scalefactor select information
- * banc = # bits needed for ancillary data (header info included)
- *
- * For each subband and channel, will add bits until one of the
- * following occurs:
- * - Hit maximum number of bits we can allocate for that subband
- * - MNR is better than or equal to the minimum masking level
- *   (NOISY_MIN_MNR)
- * Then the bits required for scalefactors, scfsi, bit allocation,
- * and the subband samples are tallied (#req_bits#) and returned.
- *
- * (NOISY_MIN_MNR) is the smallest MNR a subband can have before it is
- * counted as 'noisy' by the logic which chooses the number of JS
- * subbands.
- *
- * Joint stereo is supported.
- *
- ************************************************************************/
- 
- static double snr[18] = {0.00, 7.00, 11.00, 16.00, 20.84,
-                          25.28, 31.59, 37.75, 43.84,
-                          49.89, 55.93, 61.96, 67.98, 74.01,
-                          80.03, 86.05, 92.01, 98.01};
- 
- int I_bits_for_nonoise(perm_smr, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int req_bits = 0;
-  
-    /* initial b_anc (header) allocation bits */
-    req_bits = 32 + 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-  
-    for(i=0; i<SBLIMIT; ++i)
-      for(j=0; j<((i<jsbound)?stereo:1); ++j) {
-        for(k=0;k<14; ++k)
-          if( (-perm_smr[j][i] + snr[k]) >= NOISY_MIN_MNR)
-            break; /* we found enough bits */
-          if(stereo == 2 && i >= jsbound)     /* check other JS channel */
-            for(;k<14; ++k)
-              if( (-perm_smr[1-j][i] + snr[k]) >= NOISY_MIN_MNR) break;
-          if(k>0) req_bits += (k+1)*SCALE_BLOCK + 6*((i>=jsbound)?stereo:1);
-    }
-    return req_bits;
- }
-  
- /***************************** Layer II  ********************************/
-  
- int II_bits_for_nonoise(perm_smr, scfsi, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int sb,ch,ba;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-    int req_bits = 0, bbal = 0, berr = 0, banc = 32;
-    int maxAlloc, sel_bits, sc_bits, smp_bits;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
- 
-    /* added 92-08-11 shn */
-    if (fr_ps->header->error_protection) berr=16; else berr=0; 
-  
-    for (sb=0; sb<jsbound; ++sb)
-      bbal += stereo * (*alloc)[sb][0].bits;
-    for (sb=jsbound; sb<sblimit; ++sb)
-      bbal += (*alloc)[sb][0].bits;
-    req_bits = banc + bbal + berr;
-  
-    for(sb=0; sb<sblimit; ++sb)
-      for(ch=0; ch<((sb<jsbound)?stereo:1); ++ch) {
-        maxAlloc = (1<<(*alloc)[sb][0].bits)-1;
-        sel_bits = sc_bits = smp_bits = 0;
-        for(ba=0;ba<maxAlloc-1; ++ba)
-          if( (-perm_smr[ch][sb] + snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-              >= NOISY_MIN_MNR)
-             break;      /* we found enough bits */
-        if(stereo == 2 && sb >= jsbound) /* check other JS channel */
-          for(;ba<maxAlloc-1; ++ba)
-            if( (-perm_smr[1-ch][sb]+ snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-                >= NOISY_MIN_MNR)
-              break;
-        if(ba>0) {
-          smp_bits = SCALE_BLOCK * ((*alloc)[sb][ba].group * (*alloc)[sb][ba].bits);
-          /* scale factor bits required for subband */
-          sel_bits = 2;
-          sc_bits  = 6 * sfsPerScfsi[scfsi[ch][sb]];
-          if(stereo == 2 && sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            sel_bits += 2;
-            sc_bits  += 6 * sfsPerScfsi[scfsi[1-ch][sb]];
-          }
-          req_bits += smp_bits+sel_bits+sc_bits;
-        }
-    }
-    return req_bits;
- }
-  
- /************************************************************************
- *
- * I_main_bit_allocation   (Layer I)
- * II_main_bit_allocation  (Layer II)
- *
- * PURPOSE:For joint stereo mode, determines which of the 4 joint
- * stereo modes is needed.  Then calls *_a_bit_allocation(), which
- * allocates bits for each of the subbands until there are no more bits
- * left, or the MNR is at the noise/no_noise threshold.
- *
- * SEMANTICS:
- *
- * For joint stereo mode, joint stereo is changed to stereo if
- * there are enough bits to encode stereo at or better than the
- * no-noise threshold (NOISY_MIN_MNR).  Otherwise, the system
- * iteratively allocates less bits by using joint stereo until one
- * of the following occurs:
- * - there are no more noisy subbands (MNR >= NOISY_MIN_MNR)
- * - mode_ext has been reduced to 0, which means that all but the
- *   lowest 4 subbands have been converted from stereo to joint
- *   stereo, and no more subbands may be converted
- *
- *     This function calls *_bits_for_nonoise() and *_a_bit_allocation().
- *
- ************************************************************************/
-  
- void I_main_bit_allocation(perm_smr, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs;
-    int  mode, mode_ext, lay, i;
-    int  rq_db, av_db = *adb;
- static  int init = 0;
-  
-    if(init == 0) {
-      /* rearrange snr for layer I */
-      snr[2] = snr[3];
-      for (i=3;i<16;i++) snr[i] = snr[i+2];
-      init = 1;
-    }
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if(rq_db = I_bits_for_nonoise(perm_smr, fr_ps) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-           --mode_ext;
-           fr_ps->jsbound = js_bound(lay, mode_ext);
-           rq_db = I_bits_for_nonoise(perm_smr, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_main_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs, nn;
-    int  mode, mode_ext, lay;
-    int  rq_db, av_db = *adb;
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if((rq_db=II_bits_for_nonoise(perm_smr, scfsi, fr_ps)) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-          --mode_ext;
-          fr_ps->jsbound = js_bound(lay, mode_ext);
-          rq_db = II_bits_for_nonoise(perm_smr, scfsi, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps);
- }
-  
- /************************************************************************
- *
- * I_a_bit_allocation  (Layer I)
- * II_a_bit_allocation (Layer II)
- *
- * PURPOSE:Adds bits to the subbands with the lowest mask-to-noise
- * ratios, until the maximum number of bits for the subband has
- * been allocated.
- *
- * SEMANTICS:
- * 1. Find the subband and channel with the smallest MNR (#min_sb#,
- *    and #min_ch#)
- * 2. Calculate the increase in bits needed if we increase the bit
- *    allocation to the next higher level
- * 3. If there are enough bits available for increasing the resolution
- *    in #min_sb#, #min_ch#, and the subband has not yet reached its
- *    maximum allocation, update the bit allocation, MNR, and bits
-     available accordingly
- * 4. Repeat until there are no more bits left, or no more available
- *    subbands. (A subband is still available until the maximum
- *    number of bits for the subband has been allocated, or there
- *    aren't enough bits to go to the next higher resolution in the
-     subband.)
- *
- ************************************************************************/
-  
- int I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps) /* return noisy sbs */
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, k, smpl_bits, scale_bits, min_sb, min_ch, oth_ch;
-    int bspl, bscf, ad, noisy_sbs, done = 0, bbal ;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
-  
-    if (!init) {
-       init = 1;
-       if (fr_ps->header->error_protection) berr = 16;  /* added 92-08-11 shn */
-    }
-    bbal = 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-    *adb -= bbal + berr + banc;
-    ad= *adb;
-  
-    for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = mnr[0][0]+1;    min_sb = -1; min_ch = -1;
-      for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++)
-        /* go on only if there are bits left */
-        if (used[k][i] != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-        }
-      if(min_sb > -1) {   /* there was something to find */
-        /* first step of bit allocation is biggest */
-        if (used[min_ch][min_sb])  { smpl_bits = SCALE_BLOCK; scale_bits = 0; }
-        else                       { smpl_bits = 24; scale_bits = 6; }
-        if(min_sb >= jsbound)        scale_bits *= stereo;
-  
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-  
-        if (ad >= bspl + bscf + scale_bits + smpl_bits) {
-          bspl += smpl_bits; /* bit for subband sample */
-          bscf += scale_bits; /* bit for scale factor */
-          bit_alloc[min_ch][min_sb]++;
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb]
-                                + snr[bit_alloc[min_ch][min_sb]];
-          /* Check if subband has been fully allocated max bits */
-          if (bit_alloc[min_ch][min_sb] ==  14 ) used[min_ch][min_sb] = 2;
-        }
-        else            /* no room to improve this band */
-          used[min_ch][min_sb] = 2; /*   for allocation anymore */
-        if(stereo == 2 && min_sb >= jsbound) {
-          oth_ch = 1-min_ch;  /* joint-st : fix other ch */
-          bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb]
-                                + snr[bit_alloc[oth_ch][min_sb]];
-        }
-      }
-    } while(min_sb>-1);     /* i.e. still some sub-bands to find */
- 
-    /* Calculate the number of bits left, add on to pointed var */
-    ad -= bspl+bscf;
-    *adb = ad;
- 
-    /* see how many channels are noisy */
-    noisy_sbs = 0; small = mnr[0][0];
-    for(k=0; k<stereo; ++k) {
-      for(i = 0; i< SBLIMIT; ++i) {
-        if(mnr[k][i] < NOISY_MIN_MNR)   ++noisy_sbs;
-        if(small > mnr[k][i])           small = mnr[k][i];
-      }
-    }
-    return noisy_sbs;
- }
- 
- /***************************** Layer II  ********************************/
-  
- int II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, min_ch, min_sb, oth_ch, k, increment, scale, seli, ba;
-    int bspl, bscf, bsel, ad, noisy_sbs, bbal=0;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
-  
-    if (!init) { 
-        init = 1;  
-        if (fr_ps->header->error_protection) berr=16; /* added 92-08-11 shn */
-    }
-    for (i=0; i<jsbound; ++i)
-      bbal += stereo * (*alloc)[i][0].bits;
-    for (i=jsbound; i<sblimit; ++i)
-      bbal += (*alloc)[i][0].bits;
-    *adb -= bbal + berr + banc;
-    ad = *adb;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = bsel = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = 999999.0; min_sb = -1; min_ch = -1;
-      for (i=0;i<sblimit;i++) for(k=0;k<stereo;++k)
-        if (used[k][i]  != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-      }
-      if(min_sb > -1) {   /* there was something to find */
-        /* find increase in bit allocation in subband [min] */
-        increment = SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].group *
-                         (*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].bits);
-        if (used[min_ch][min_sb])
-          increment -= SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]].group*
-                            (*alloc)[min_sb][bit_alloc[min_ch][min_sb]].bits);
-  
-        /* scale factor bits required for subband [min] */
-        oth_ch = 1 - min_ch;    /* above js bound, need both chans */
-        if (used[min_ch][min_sb]) scale = seli = 0;
-        else {          /* this channel had no bits or scfs before */
-          seli = 2;
-          scale = 6 * sfsPerScfsi[scfsi[min_ch][min_sb]];
-          if(stereo == 2 && min_sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            seli += 2;
-            scale += 6 * sfsPerScfsi[scfsi[oth_ch][min_sb]];
-          }
-        }
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-        if (ad >= bspl + bscf + bsel + seli + scale + increment) {
-          ba = ++bit_alloc[min_ch][min_sb]; /* next up alloc */
-          bspl += increment;  /* bits for subband sample */
-          bscf += scale;      /* bits for scale factor */
-          bsel += seli;       /* bits for scfsi code */
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-          /* Check if subband has been fully allocated max bits */
-          if (ba >= (1<<(*alloc)[min_sb][0].bits)-1) used[min_ch][min_sb] = 2;
-        }
-        else used[min_ch][min_sb] = 2; /* can't increase this alloc */
-        if(min_sb >= jsbound && stereo == 2) {
-          /* above jsbound, alloc applies L+R */
-          ba = bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-        }
-      }
-    } while(min_sb > -1);   /* until could find no channel */
-    /* Calculate the number of bits left */
-    ad -= bspl+bscf+bsel;   *adb = ad;
-    for (i=sblimit;i<SBLIMIT;i++) for (k=0;k<stereo;k++) bit_alloc[k][i]=0;
-  
-    noisy_sbs = 0;  small = mnr[0][0];      /* calc worst noise in case */
-    for(k=0;k<stereo;++k) {
-      for (i=0;i<sblimit;i++) {
-        if (small > mnr[k][i]) small = mnr[k][i];
-        if(mnr[k][i] < NOISY_MIN_MNR) ++noisy_sbs; /* noise is not masked */
- 
-      }
-    }
-    return noisy_sbs;
- }
-  
- /************************************************************************
- *
- * I_subband_quantization  (Layer I)
- * II_subband_quantization (Layer II)
- *
- * PURPOSE:Quantizes subband samples to appropriate number of bits
- *
- * SEMANTICS:  Subband samples are divided by their scalefactors, which
-  makes the quantization more efficient. The scaled samples are
- * quantized by the function a*x+b, where a and b are functions of
- * the number of quantization levels. The result is then truncated
- * to the appropriate number of bits and the MSB is inverted.
- *
- * Note that for fractional 2's complement, inverting the MSB for a
-  negative number x is equivalent to adding 1 to it.
- *
- ************************************************************************/
-  
- static double a[17] = {
-   0.750000000, 0.625000000, 0.875000000, 0.562500000, 0.937500000,
-   0.968750000, 0.984375000, 0.992187500, 0.996093750, 0.998046875,
-   0.999023438, 0.999511719, 0.999755859, 0.999877930, 0.999938965,
-   0.999969482, 0.999984741 };
-  
- static double b[17] = {
-   -0.250000000, -0.375000000, -0.125000000, -0.437500000, -0.062500000,
-   -0.031250000, -0.015625000, -0.007812500, -0.003906250, -0.001953125,
-   -0.000976563, -0.000488281, -0.000244141, -0.000122070, -0.000061035,
-   -0.000030518, -0.000015259 };
-  
- void I_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                             bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT]; /* L+R for j-stereo if necess */
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, n, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    double d;
- static char init = 0;
- 
-    if (!init) {
-      init = 1;
-      /* rearrange quantization coef to correspond to layer I table */
-      a[1] = a[2]; b[1] = b[2];
-      for (i=2;i<15;i++) { a[i] = a[i+2]; b[i] = b[i+2]; }
-    }
-    for (j=0;j<SCALE_BLOCK;j++) for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        if (bit_alloc[k][i]) {
-          /* for joint stereo mode, have to construct a single subband stream
-             for the js channels.  At present, we calculate a set of mono
-             subband samples and pass them through the scaling system to
-             generate an alternate normalised sample stream.
-  
-             Could normalise both streams (divide by their scfs), then average
-             them.  In bad conditions, this could give rise to spurious
-             cancellations.  Instead, we could just select the sb stream from
-             the larger channel (higher scf), in which case _that_ channel
-             would be 'properly' reconstructed, and the mate would just be a
-             scaled version.  Spec recommends averaging the two (unnormalised)
-             subband channels, then normalising this new signal without
-             actually sending this scale factor... This means looking ahead.
-          */
-          if(stereo == 2 && i>=jsbound)
-            /* use the joint data passed in */
-            d = j_samps[0][j][i] / multiple[j_scale[0][i]];
-          else
-            d = sb_samples[k][0][j][i] / multiple[scalar[k][0][i]];
-          /* scale and quantize floating point sample */
-          n = bit_alloc[k][i];
-          d = d * a[n-1] + b[n-1];
-          /* extract MSB N-1 bits from the floating point sample */
-          if (d >= 0) sig = 1;
-          else { sig = 0; d += 1.0; }
-          sbband[k][0][j][i] = (unsigned int) (d * (double) (1L<<n));
-          /* tag the inverted sign bit to sbband at position N */
-          if (sig) sbband[k][0][j][i] |= 1<<n;
-        }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                              bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, s, n, qnt, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    unsigned int stps;
-    double d;
-    al_table *alloc = fr_ps->alloc;
- 
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j++)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              /* scale and quantize floating point sample */
-              if(stereo == 2 && i>=jsbound)       /* use j-stereo samples */
-                d = j_samps[s][j][i] / multiple[j_scale[s][i]];
-              else
-                d = sb_samples[k][s][j][i] / multiple[scalar[k][s][i]];
-              if (mod(d) > 1.0)
-                printf("Not scaled properly %d %d %d %d\n",k,s,j,i);
-              qnt = (*alloc)[i][bit_alloc[k][i]].quant;
-              d = d * a[qnt] + b[qnt];
-              /* extract MSB N-1 bits from the floating point sample */
-              if (d >= 0) sig = 1;
-              else { sig = 0; d += 1.0; }
-              n = 0;
- #ifndef MS_DOS
-              stps = (*alloc)[i][bit_alloc[k][i]].steps;
-              while ((1L<<n) < stps) n++;
- #else
-              while  ( ( (unsigned long)(1L<<(long)n) <
-                        ((unsigned long) ((*alloc)[i][bit_alloc[k][i]].steps)
-                         & 0xffff
-                         )
-                        ) && ( n <16)
-                      ) n++;
- #endif
-              n--;
-              sbband[k][s][j][i] = (unsigned int) (d * (double) (1L<<n));
-              /* tag the inverted sign bit to sbband at position N */
-              /* The bit inversion is a must for grouping with 3,5,9 steps
-                 so it is done for all subbands */
-              if (sig) sbband[k][s][j][i] |= 1<<n;
-            }
-            for (s=0;s<3;s++)
-              for (j=sblimit;j<SBLIMIT;j++)
-                for (i=0;i<SCALE_BLOCK;i++) for (k=0;k<stereo;k++) sbband[k][s][i][j] = 0;
- }
-  
- /*************************************************************************
- * I_encode_bit_alloc  (Layer I)
- * II_encode_bit_alloc (Layer II)
- *
- * PURPOSE:Writes bit allocation information onto bitstream
- *
- * Layer I uses 4 bits/subband for bit allocation information,
- * and Layer II uses 4,3,2, or 0 bits depending on the
- * quantization table used.
- *
- ************************************************************************/
-  
- void I_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++) putbits(bs,bit_alloc[k][i],4);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (i=0;i<sblimit;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        putbits(bs,bit_alloc[k][i],(*alloc)[i][0].bits);
- }
-  
- /************************************************************************
- *
- * I_sample_encoding   (Layer I)
- * II_sample_encoding  (Layer II)
- *
- * PURPOSE:Put one frame of subband samples on to the bitstream
- *
- * SEMANTICS:  The number of bits allocated per sample is read from
- * the bit allocation information #bit_alloc#.  Layer 2
- * supports writing grouped samples for quantization steps
- * that are not a power of 2.
- *
- ************************************************************************/
-  
- void I_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for(j=0;j<SCALE_BLOCK;j++) {
-      for(i=0;i<SBLIMIT;i++)
-        for(k=0;k<((i<jsbound)?stereo:1);k++)
-          if(bit_alloc[k][i]) putbits(bs,sbband[k][0][j][i],bit_alloc[k][i]+1);
-    }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    unsigned int temp;
-    unsigned int i,j,k,s,x,y;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j+=3)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              if ((*alloc)[i][bit_alloc[k][i]].group == 3) {
-                for (x=0;x<3;x++) putbits(bs,sbband[k][s][j+x][i],
-                                          (*alloc)[i][bit_alloc[k][i]].bits);
-              }
-              else {
-                y =(*alloc)[i][bit_alloc[k][i]].steps;
-                temp = sbband[k][s][j][i] +
-                       sbband[k][s][j+1][i] * y +
-                       sbband[k][s][j+2][i] * y * y;
-                putbits(bs,temp,(*alloc)[i][bit_alloc[k][i]].bits);
-              }
-            }
- }
-  
- /************************************************************************
- *
- * encode_CRC
- *
- ************************************************************************/
-  
- void encode_CRC(crc, bs)
- unsigned int crc;
- Bit_stream_struc *bs;
- {
-    putbits(bs, crc, 16);
- }
--- 0 ----
diff -r -c -N encoder/encoder.h lame3.70/encoder.h
*** encoder/encoder.h	Wed Jan 22 02:43:14 1997
--- lame3.70/encoder.h	Wed Mar 15 13:37:16 2000
***************
*** 1,337 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: encoder.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: encoder.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
-  *          Davis Pan                                                 *
-  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
-  *                              into "common.h" and "encoder.h".      *
-  *                              Ported to Macintosh and Unix.         *
-  *                              Added function prototypes for more    *
-  *                              rigorous type checking.               *
-  * 27jun91  dpwe (Aware)        moved "alloc_*" types, pros to common *
-  *                              Use ifdef PROTO_ARGS for prototypes   *
-  *                              prototypes reflect frame_params struct*
-  * 7/10/91  Earle Jennings      Conversion of all floats to FLOAT     *
-  * 10/3/91  Don H. Lee          implemented CRC-16 error protection   *
-  *                              Additions and revisions are marked    *
-  *                              with "dhl" for clarity                *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  *                              Modified some function prototypes.    *
-  * 7/27/92  Masahiro Iwadare    FFT modifications for Layer 3         *
-  * 8/3/92   Mike Li             removed declaration _stklen for DOS.  *
-  * 9/22/92  jddevine@aware.com  Fix protos for _scale_factor_calc()   *
-  * 11/04/94 Jon Rowlands        Fix protos for usage()                *
-  * 07/11/95 Soeren H. Nielsen   Changed defs. and protos for LSF      *
-  **********************************************************************/
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
  *
! *  Encoder Include Files
  *
  ***********************************************************************/
  
- /***********************************************************************
- *
- *  Encoder Definitions
- *
- ***********************************************************************/
  
! /* General Definitions */
  
! /* Default Input Arguments (for command line control) */
  
- #define DFLT_LAY        2      /* default encoding layer is II */
- #define DFLT_MOD        's'    /* default mode is stereo */
- #define DFLT_PSY        1      /* default psych model is 1 */
- #define DFLT_SFQ        44.1   /* default input sampling rate is 44.1 kHz */
- #define DFLT_EMP        'n'    /* default de-emphasis is none */
- #define DFLT_EXT        ".mpg" /* default output file extension */
  
- #define FILETYPE_ENCODE 'TEXT'
- #define CREATOR_ENCODE  'MpgD'
  
! /* This is the smallest MNR a subband can have before it is counted
!    as 'noisy' by the logic which chooses the number of JS subbands */
  
! #define NOISY_MIN_MNR   0.0
  
! /* Psychacoustic Model 1 Definitions */
  
- #define CB_FRACTION     0.33
- #define MAX_SNR         1000
- #define NOISE           10
- #define TONE            20
- #define DBMIN           -200.0
- #define LAST            -1
- #define STOP            -100
- #define POWERNORM       90.3090 /* = 20 * log10(32768) to normalize */
-                                 /* max output power to 96 dB per spec */
  
- /* Psychoacoustic Model 2 Definitions */
  
! #define LOGBLKSIZE      10
! #define BLKSIZE         1024
! #define HBLKSIZE        513
  #define CBANDS          63
- #define LXMIN           32.0
  
! /***********************************************************************
! *
! *  Encoder Type Definitions
! *
! ***********************************************************************/
  
! /* Psychoacoustic Model 1 Type Definitions */
  
- typedef int        IFFT2[FFT_SIZE/2];
- typedef int        IFFT[FFT_SIZE];
- typedef double     D9[9];
- typedef double     D10[10];
- typedef double     D640[640];
- typedef double     D1408[1408];
- typedef double     DFFT2[FFT_SIZE/2];
- typedef double     DFFT[FFT_SIZE];
- typedef double     DSBL[SBLIMIT];
- typedef double     D2SBL[2][SBLIMIT];
- 
- typedef struct {
-         int        line;
-         double     bark, hear, x;
- } g_thres, *g_ptr;
- 
- typedef struct {
-         double     x;
-         int        type, next, map;
- } mask, *mask_ptr;
- 
- /* Psychoacoustic Model 2 Type Definitions */
- 
- typedef int        ICB[CBANDS];
- typedef int        IHBLK[HBLKSIZE];
- typedef FLOAT      F32[32];
- typedef FLOAT      F2_32[2][32];
- typedef FLOAT      FCB[CBANDS];
- typedef FLOAT      FCBCB[CBANDS][CBANDS];
- typedef FLOAT      FBLK[BLKSIZE];
- typedef FLOAT      FHBLK[HBLKSIZE];
- typedef FLOAT      F2HBLK[2][HBLKSIZE];
- typedef FLOAT      F22HBLK[2][2][HBLKSIZE];
- typedef double     DCB[CBANDS];
  
- /***********************************************************************
- *
- *  Encoder Function Prototype Declarations
- *
- ***********************************************************************/
  
! /* The following functions are in the file "musicin.c" */
  
- #ifdef        PROTO_ARGS
- extern void   obtain_parameters(frame_params*, int*, unsigned long*,
-                            char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
- extern void   parse_args(int, char**, frame_params*, int*, unsigned long*,
-                            char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
- extern void   print_config(frame_params*, int*,
-                            char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
- void   usage(void);
- extern void   aiff_check(char*, IFF_AIFF*, int*);
- #else
- extern void   obtain_parameters();
- extern void   parse_args();
- extern void   print_config();
- static void   usage();
- extern void   aiff_check();
- #endif
- 
- /* The following functions are in the file "encode.c" */
- 
- #ifdef        PROTO_ARGS
- extern unsigned long    read_samples(FILE*, short[2304], unsigned long,
-                            unsigned long);
- #if 0
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, int);
- #else
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, layer* info);
- #endif
- extern void   read_ana_window(double[HAN_SIZE]);
- extern void   window_subband(short**, double[HAN_SIZE], int);
- extern void   create_ana_filter(double[SBLIMIT][64]);
- extern void   filter_subband(double[HAN_SIZE], double[SBLIMIT]);
- extern void   encode_info(frame_params*, Bit_stream_struc*);
- extern double mod(double);
- extern void   I_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT]);
- extern void   II_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], int);
- extern void   I_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int);
- extern void   II_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int, int);
- extern void   pick_scale(unsigned int[2][3][SBLIMIT], frame_params*,
-                            double[2][SBLIMIT]);
- extern void   put_scale(unsigned int[2][3][SBLIMIT], frame_params*,
-                            double[2][SBLIMIT]);
- extern void   II_transmission_pattern(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*);
- extern void   II_encode_scale(unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_scale(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern int    II_bits_for_nonoise(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            frame_params*);
- extern void   II_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern int    II_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_bits_for_nonoise(double[2][SBLIMIT], frame_params*);
- extern void   I_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern void   I_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   II_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   encode_CRC(unsigned int, Bit_stream_struc*);
- #else
- extern unsigned long  read_samples();
- extern unsigned long  get_audio();
- extern void        read_ana_window();
- extern void        window_subband();
- extern void        create_ana_filter();
- extern void        filter_subband();
- extern void        encode_info();
- extern double      mod();
- extern void        I_combine_LR();
- extern void        II_combine_LR();
- extern void        I_scale_factor_calc();
- extern void        II_scale_factor_calc();
- extern void        pick_scale();
- extern void        put_scale();
- extern void        II_transmission_pattern();
- extern void        II_encode_scale();
- extern void        I_encode_scale();
- extern int         II_bits_for_nonoise();
- extern void        II_main_bit_allocation();
- extern int         II_a_bit_allocation();
- extern int         I_bits_for_nonoise();
- extern void        I_main_bit_allocation();
- extern int         I_a_bit_allocation();
- extern void        I_subband_quantization();
- extern void        II_subband_quantization();
- extern void        II_encode_bit_alloc();
- extern void        I_encode_bit_alloc();
- extern void        I_sample_encoding();
- extern void        II_sample_encoding();
- extern void        encode_CRC();
- #endif
- 
- /* The following functions are in the file "tonal.c" */
- 
- #ifdef     PROTO_ARGS
- extern void        read_cbound(int, int);
- extern void        read_freq_band(g_ptr*, int, int);
- extern void        make_map(mask[HAN_SIZE], g_thres*);
- extern double      add_db(double, double);
- extern void        II_f_f_t(double[FFT_SIZE], mask[HAN_SIZE]);
- extern void        II_hann_win(double[FFT_SIZE]);
- extern void        II_pick_max(mask[HAN_SIZE], double[SBLIMIT]);
- extern void        II_tonal_label(mask[HAN_SIZE], int*);
- extern void        noise_label(mask*, int*, g_thres*);
- extern void        subsampling(mask[HAN_SIZE], g_thres*, int*, int*);
- extern void        threshold(mask[HAN_SIZE], g_thres*, int*, int*, int);
- extern void        II_minimum_mask(g_thres*, double[SBLIMIT], int);
- extern void        II_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT],
-                            int);
- extern void        II_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
- extern void        I_f_f_t(double[FFT_SIZE/2], mask[HAN_SIZE/2]);
- extern void        I_hann_win(double[FFT_SIZE/2]);
- extern void        I_pick_max(mask[HAN_SIZE/2], double[SBLIMIT]);
- extern void        I_tonal_label(mask[HAN_SIZE/2], int*);
- extern void        I_minimum_mask(g_thres*, double[SBLIMIT]);
- extern void        I_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT]);
- extern void        I_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
- #else
- extern void        read_cbound();
- extern void        read_freq_band();
- extern void        make_map();
- extern double      add_db();
- extern void        II_f_f_t();
- extern void        II_hann_win();
- extern void        II_pick_max();
- extern void        II_tonal_label();
- extern void        noise_label();
- extern void        subsampling();
- extern void        threshold();
- extern void        II_minimum_mask();
- extern void        II_smr();
- extern void        II_Psycho_One();
- extern void        I_f_f_t();
- extern void        I_hann_win();
- extern void        I_pick_max();
- extern void        I_tonal_label();
- extern void        I_minimum_mask();
- extern void        I_smr();
- extern void        I_Psycho_One();
- #endif
- 
- /* The following functions are in the file "psy.c" */
- 
- #ifdef     PROTO_ARGS
- extern void        psycho_anal(short int*, short int[1056], int, int,
-                            FLOAT[32], double);
- #else
- extern void        psycho_anal();
- #endif
- 
- /* The following functions are in the file "subs.c" */
- 
- #ifdef     PROTO_ARGS
- extern void        fft(FLOAT[BLKSIZE], FLOAT[BLKSIZE], FLOAT[BLKSIZE],
-                            FLOAT[BLKSIZE], int );
- #else
- extern void        fft();
- #endif
  #endif
--- 1,78 ----
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
  *
! *  encoder and decoder delays
  *
  ***********************************************************************/
+ /* 
+ layerIII enc->dec delay:  1056    (observed)
+ layerII  enc->dec dealy:   480    (observed)
  
  
! polyphase 256-16             (dec or enc)        = 240
! mdct      256+32  (9*32)     (dec or enc)        = 288
! total:    512+16
  
! */
  
  
  
! /* ENCDELAY  The encoder delay.  
  
!    Minimum allowed is MDCTDELAY (see below)
!    
!    The first 96 samples will be attenuated, so using a value
!    less than 96 will result in lost data in the first 96-ENCDELAY
!    samples. 
  
!    suggested: 800
!    set to 1160 to sync with FhG.
! */
! #define ENCDELAY 800
  
  
  
! 
! /* delay of the MDCT used in mdct.c */
! /* original ISO routiens had a delay of 528!  Takehiro's routines: */
! #define MDCTDELAY 48  
! #define FFTOFFSET (224+MDCTDELAY)
! 
! /*
! Most decoders, including the one we use,  have a delay of 528 samples.  
! */
! #define DECDELAY 528
! 
! 
! /* number of subbands */
! #define         SBLIMIT                 32
! 
! /* parition bands bands */
  #define CBANDS          63
  
! /* number of critical bands/scale factor bands where masking is computed*/
! #define SBPSY_l 21
! #define SBPSY_s 12
  
! /* total number of scalefactor bands encoded */
! #define SBMAX_l 22
! #define SBMAX_s 13
  
  
  
! /* FFT sizes */
! #define BLKSIZE         1024
! #define HBLKSIZE        513
! #define BLKSIZE_s 256
! #define HBLKSIZE_s 129
! 
! 
! /* #define switch_pe        1800 */
! #define NORM_TYPE       0
! #define START_TYPE      1
! #define SHORT_TYPE      2
! #define STOP_TYPE       3
! 
  
  #endif
diff -r -c -N encoder/fft.c lame3.70/fft.c
*** encoder/fft.c	Wed Dec 31 17:00:00 1969
--- lame3.70/fft.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,356 ----
+ /*
+ ** FFT and FHT routines
+ **  Copyright 1988, 1993; Ron Mayer
+ **  
+ **  fht(fz,n);
+ **      Does a hartley transform of "n" points in the array "fz".
+ **      
+ ** NOTE: This routine uses at least 2 patented algorithms, and may be
+ **       under the restrictions of a bunch of different organizations.
+ **       Although I wrote it completely myself; it is kind of a derivative
+ **       of a routine I once authored and released under the GPL, so it
+ **       may fall under the free software foundation's restrictions;
+ **       it was worked on as a Stanford Univ project, so they claim
+ **       some rights to it; it was further optimized at work here, so
+ **       I think this company claims parts of it.  The patents are
+ **       held by R. Bracewell (the FHT algorithm) and O. Buneman (the
+ **       trig generator), both at Stanford Univ.
+ **       If it were up to me, I'd say go do whatever you want with it;
+ **       but it would be polite to give credit to the following people
+ **       if you use this anywhere:
+ **           Euler     - probable inventor of the fourier transform.
+ **           Gauss     - probable inventor of the FFT.
+ **           Hartley   - probable inventor of the hartley transform.
+ **           Buneman   - for a really cool trig generator
+ **           Mayer(me) - for authoring this particular version and
+ **                       including all the optimizations in one package.
+ **       Thanks,
+ **       Ron Mayer; mayer@acuson.com
+ ** and added some optimization by
+ **           Mather    - idea of using lookup table
+ **           Takehiro  - some dirty hack for speed up
+ */
+ 
+ #include <math.h>
+ #include "util.h"
+ #include "psymodel.h"
+ #include "lame.h"
+ 
+ #define TRI_SIZE (5-1) /* 1024 =  4**5 */
+ static FLOAT costab[TRI_SIZE*2];
+ static FLOAT window[BLKSIZE / 2], window_s[BLKSIZE_s / 2];
+ 
+ static INLINE void fht(FLOAT *fz, short n)
+ {
+     short k4;
+     FLOAT *fi, *fn, *gi;
+     FLOAT *tri;
+ 
+     fn = fz + n;
+     tri = &costab[0];
+     k4 = 4;
+     do {
+ 	FLOAT s1, c1;
+ 	short i, k1, k2, k3, kx;
+ 	kx  = k4 >> 1;
+ 	k1  = k4;
+ 	k2  = k4 << 1;
+ 	k3  = k2 + k1;
+ 	k4  = k2 << 1;
+ 	fi  = fz;
+ 	gi  = fi + kx;
+ 	do {
+ 	    FLOAT f0,f1,f2,f3;
+ 	    f1      = fi[0]  - fi[k1];
+ 	    f0      = fi[0]  + fi[k1];
+ 	    f3      = fi[k2] - fi[k3];
+ 	    f2      = fi[k2] + fi[k3];
+ 	    fi[k2]  = f0     - f2;
+ 	    fi[0 ]  = f0     + f2;
+ 	    fi[k3]  = f1     - f3;
+ 	    fi[k1]  = f1     + f3;
+ 	    f1      = gi[0]  - gi[k1];
+ 	    f0      = gi[0]  + gi[k1];
+ 	    f3      = SQRT2  * gi[k3];
+ 	    f2      = SQRT2  * gi[k2];
+ 	    gi[k2]  = f0     - f2;
+ 	    gi[0 ]  = f0     + f2;
+ 	    gi[k3]  = f1     - f3;
+ 	    gi[k1]  = f1     + f3;
+ 	    gi     += k4;
+ 	    fi     += k4;
+ 	} while (fi<fn);
+ 	c1 = tri[0];
+ 	s1 = tri[1];
+ 	for (i = 1; i < kx; i++) {
+ 	    FLOAT c2,s2;
+ 	    c2 = 1 - (2*s1)*s1;
+ 	    s2 = (2*s1)*c1;
+ 	    fi = fz + i;
+ 	    gi = fz + k1 - i;
+ 	    do {
+ 		FLOAT a,b,g0,f0,f1,g1,f2,g2,f3,g3;
+ 		b       = s2*fi[k1] - c2*gi[k1];
+ 		a       = c2*fi[k1] + s2*gi[k1];
+ 		f1      = fi[0 ]    - a;
+ 		f0      = fi[0 ]    + a;
+ 		g1      = gi[0 ]    - b;
+ 		g0      = gi[0 ]    + b;
+ 		b       = s2*fi[k3] - c2*gi[k3];
+ 		a       = c2*fi[k3] + s2*gi[k3];
+ 		f3      = fi[k2]    - a;
+ 		f2      = fi[k2]    + a;
+ 		g3      = gi[k2]    - b;
+ 		g2      = gi[k2]    + b;
+ 		b       = s1*f2     - c1*g3;
+ 		a       = c1*f2     + s1*g3;
+ 		fi[k2]  = f0        - a;
+ 		fi[0 ]  = f0        + a;
+ 		gi[k3]  = g1        - b;
+ 		gi[k1]  = g1        + b;
+ 		b       = c1*g2     - s1*f3;
+ 		a       = s1*g2     + c1*f3;
+ 		gi[k2]  = g0        - a;
+ 		gi[0 ]  = g0        + a;
+ 		fi[k3]  = f1        - b;
+ 		fi[k1]  = f1        + b;
+ 		gi     += k4;
+ 		fi     += k4;
+ 	    } while (fi<fn);
+ 	    c2 = c1;
+ 	    c1 = c2 * tri[0] - s1 * tri[1];
+ 	    s1 = c2 * tri[1] + s1 * tri[0];
+         }
+ 	tri += 2;
+     } while (k4<n);
+ }
+ 
+ static const short rv_tbl[] = {
+     0x00,    0x80,    0x40,    0xc0,    0x20,    0xa0,    0x60,    0xe0,
+     0x10,    0x90,    0x50,    0xd0,    0x30,    0xb0,    0x70,    0xf0,
+     0x08,    0x88,    0x48,    0xc8,    0x28,    0xa8,    0x68,    0xe8,
+     0x18,    0x98,    0x58,    0xd8,    0x38,    0xb8,    0x78,    0xf8,
+     0x04,    0x84,    0x44,    0xc4,    0x24,    0xa4,    0x64,    0xe4,
+     0x14,    0x94,    0x54,    0xd4,    0x34,    0xb4,    0x74,    0xf4,
+     0x0c,    0x8c,    0x4c,    0xcc,    0x2c,    0xac,    0x6c,    0xec,
+     0x1c,    0x9c,    0x5c,    0xdc,    0x3c,    0xbc,    0x7c,    0xfc,
+     0x02,    0x82,    0x42,    0xc2,    0x22,    0xa2,    0x62,    0xe2,
+     0x12,    0x92,    0x52,    0xd2,    0x32,    0xb2,    0x72,    0xf2,
+     0x0a,    0x8a,    0x4a,    0xca,    0x2a,    0xaa,    0x6a,    0xea,
+     0x1a,    0x9a,    0x5a,    0xda,    0x3a,    0xba,    0x7a,    0xfa,
+     0x06,    0x86,    0x46,    0xc6,    0x26,    0xa6,    0x66,    0xe6,
+     0x16,    0x96,    0x56,    0xd6,    0x36,    0xb6,    0x76,    0xf6,
+     0x0e,    0x8e,    0x4e,    0xce,    0x2e,    0xae,    0x6e,    0xee,
+     0x1e,    0x9e,    0x5e,    0xde,    0x3e,    0xbe,    0x7e,    0xfe
+ };
+ 
+ 
+ 
+ 
+ #define ch01(index)  (buffer[chn][index])
+ #define ch2(index)  (((FLOAT)(0.5*SQRT2))*(buffer[0][index] + buffer[1][index]))
+ #define ch3(index)  (((FLOAT)(0.5*SQRT2))*(buffer[0][index] - buffer[1][index]))
+ 
+ #define ml00(f)	(window[i        ] * f(i))
+ #define ml10(f)	(window[0x1ff - i] * f(i + 0x200))
+ #define ml20(f)	(window[i + 0x100] * f(i + 0x100))
+ #define ml30(f)	(window[0x0ff - i] * f(i + 0x300))
+ 
+ #define ml01(f)	(window[i + 0x001] * f(i + 0x001))
+ #define ml11(f)	(window[0x1fe - i] * f(i + 0x201))
+ #define ml21(f)	(window[i + 0x101] * f(i + 0x101))
+ #define ml31(f)	(window[0x0fe - i] * f(i + 0x301))
+ 
+ #define ms00(f)	(window_s[i       ] * f(i + k))
+ #define ms10(f)	(window_s[0x7f - i] * f(i + k + 0x80))
+ #define ms20(f)	(window_s[i + 0x40] * f(i + k + 0x40))
+ #define ms30(f)	(window_s[0x3f - i] * f(i + k + 0xc0))
+ 
+ #define ms01(f)	(window_s[i + 0x01] * f(i + k + 0x01))
+ #define ms11(f)	(window_s[0x7e - i] * f(i + k + 0x81))
+ #define ms21(f)	(window_s[i + 0x41] * f(i + k + 0x41))
+ #define ms31(f)	(window_s[0x3e - i] * f(i + k + 0xc1))
+ 
+ 
+ 
+ void fft_short(
+     FLOAT x_real[3][BLKSIZE_s], int chn, short *buffer[2])
+ {
+     short i, j, b;
+ 
+     for (b = 0; b < 3; b++) {
+ 	FLOAT *x = &x_real[b][BLKSIZE_s / 2];
+ 	short k = (576 / 3) * (b + 1);
+ 	j = BLKSIZE_s / 8 - 1;
+ 	if (chn < 2) {
+ 	    do {
+ 		FLOAT f0,f1,f2,f3, w;
+ 
+ 		i = rv_tbl[j << 2];
+ 
+ 		f0 = ms00(ch01); w = ms10(ch01); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms20(ch01); w = ms30(ch01); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x -= 4;
+ 		x[0] = f0 + f2;
+ 		x[2] = f0 - f2;
+ 		x[1] = f1 + f3;
+ 		x[3] = f1 - f3;
+ 
+ 		f0 = ms01(ch01); w = ms11(ch01); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms21(ch01); w = ms31(ch01); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x[BLKSIZE_s / 2 + 0] = f0 + f2;
+ 		x[BLKSIZE_s / 2 + 2] = f0 - f2;
+ 		x[BLKSIZE_s / 2 + 1] = f1 + f3;
+ 		x[BLKSIZE_s / 2 + 3] = f1 - f3;
+ 	    } while (--j >= 0);
+ 	} else if (chn == 2) {
+ 	    do {
+ 		FLOAT f0,f1,f2,f3, w;
+ 
+ 		i = rv_tbl[j << 2];
+ 
+ 		f0 = ms00(ch2); w = ms10(ch2); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms20(ch2); w = ms30(ch2); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x -= 4;
+ 		x[0] = f0 + f2;
+ 		x[2] = f0 - f2;
+ 		x[1] = f1 + f3;
+ 		x[3] = f1 - f3;
+ 
+ 		f0 = ms01(ch2); w = ms11(ch2); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms21(ch2); w = ms31(ch2); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x[BLKSIZE_s / 2 + 0] = f0 + f2;
+ 		x[BLKSIZE_s / 2 + 2] = f0 - f2;
+ 		x[BLKSIZE_s / 2 + 1] = f1 + f3;
+ 		x[BLKSIZE_s / 2 + 3] = f1 - f3;
+ 	    } while (--j >= 0);
+ 	} else {
+ 	    do {
+ 		FLOAT f0,f1,f2,f3, w;
+ 
+ 		i = rv_tbl[j << 2];
+ 
+ 		f0 = ms00(ch3); w = ms10(ch3); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms20(ch3); w = ms30(ch3); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x -= 4;
+ 		x[0] = f0 + f2;
+ 		x[2] = f0 - f2;
+ 		x[1] = f1 + f3;
+ 		x[3] = f1 - f3;
+ 
+ 		f0 = ms01(ch3); w = ms11(ch3); f1 = f0 - w; f0 = f0 + w;
+ 		f2 = ms21(ch3); w = ms31(ch3); f3 = f2 - w; f2 = f2 + w;
+ 
+ 		x[BLKSIZE_s / 2 + 0] = f0 + f2;
+ 		x[BLKSIZE_s / 2 + 2] = f0 - f2;
+ 		x[BLKSIZE_s / 2 + 1] = f1 + f3;
+ 		x[BLKSIZE_s / 2 + 3] = f1 - f3;
+ 	    } while (--j >= 0);
+ 	}
+ 
+ 	fht(x, BLKSIZE_s);
+     }
+ }
+ 
+ void fft_long(
+     FLOAT x[BLKSIZE], int chn, short *buffer[2])
+ {
+     short i,jj = BLKSIZE / 8 - 1;
+     x += BLKSIZE / 2;
+ 
+     if (chn < 2) {
+ 	do {
+ 	    FLOAT f0,f1,f2,f3, w;
+ 
+ 	    i = rv_tbl[jj];
+ 	    f0 = ml00(ch01); w = ml10(ch01); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml20(ch01); w = ml30(ch01); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x -= 4;
+ 	    x[0] = f0 + f2;
+ 	    x[2] = f0 - f2;
+ 	    x[1] = f1 + f3;
+ 	    x[3] = f1 - f3;
+ 
+ 	    f0 = ml01(ch01); w = ml11(ch01); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml21(ch01); w = ml31(ch01); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x[BLKSIZE / 2 + 0] = f0 + f2;
+ 	    x[BLKSIZE / 2 + 2] = f0 - f2;
+ 	    x[BLKSIZE / 2 + 1] = f1 + f3;
+ 	    x[BLKSIZE / 2 + 3] = f1 - f3;
+ 	} while (--jj >= 0);
+     } else if (chn == 2) {
+ 	do {
+ 	    FLOAT f0,f1,f2,f3, w;
+ 
+ 	    i = rv_tbl[jj];
+ 	    f0 = ml00(ch2); w = ml10(ch2); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml20(ch2); w = ml30(ch2); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x -= 4;
+ 	    x[0] = f0 + f2;
+ 	    x[2] = f0 - f2;
+ 	    x[1] = f1 + f3;
+ 	    x[3] = f1 - f3;
+ 
+ 	    f0 = ml01(ch2); w = ml11(ch2); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml21(ch2); w = ml31(ch2); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x[BLKSIZE / 2 + 0] = f0 + f2;
+ 	    x[BLKSIZE / 2 + 2] = f0 - f2;
+ 	    x[BLKSIZE / 2 + 1] = f1 + f3;
+ 	    x[BLKSIZE / 2 + 3] = f1 - f3;
+ 	} while (--jj >= 0);
+     } else {
+ 	do {
+ 	    FLOAT f0,f1,f2,f3, w;
+ 
+ 	    i = rv_tbl[jj];
+ 	    f0 = ml00(ch3); w = ml10(ch3); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml20(ch3); w = ml30(ch3); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x -= 4;
+ 	    x[0] = f0 + f2;
+ 	    x[2] = f0 - f2;
+ 	    x[1] = f1 + f3;
+ 	    x[3] = f1 - f3;
+ 
+ 	    f0 = ml01(ch3); w = ml11(ch3); f1 = f0 - w; f0 = f0 + w;
+ 	    f2 = ml21(ch3); w = ml31(ch3); f3 = f2 - w; f2 = f2 + w;
+ 
+ 	    x[BLKSIZE / 2 + 0] = f0 + f2;
+ 	    x[BLKSIZE / 2 + 2] = f0 - f2;
+ 	    x[BLKSIZE / 2 + 1] = f1 + f3;
+ 	    x[BLKSIZE / 2 + 3] = f1 - f3;
+ 	} while (--jj >= 0);
+     }
+ 
+     fht(x, BLKSIZE);
+ }
+ 
+ 
+ void init_fft(void)
+ {
+     int i;
+ 
+     FLOAT r = PI*0.125;
+     for (i = 0; i < TRI_SIZE; i++) {
+ 	costab[i*2  ] = cos(r);
+ 	costab[i*2+1] = sin(r);
+ 	r *= 0.25;
+     }
+ 
+     /*
+      * calculate HANN window coefficients 
+      */
+     for (i = 0; i < BLKSIZE / 2; i++)
+ 	window[i] = 0.5 * (1.0 - cos(2.0 * PI * (i + 0.5) / BLKSIZE));
+     for (i = 0; i < BLKSIZE_s / 2; i++)
+ 	window_s[i] = 0.5 * (1.0 - cos(2.0 * PI * (i + 0.5) / BLKSIZE_s));
+ }
diff -r -c -N encoder/fft.h lame3.70/fft.h
*** encoder/fft.h	Wed Dec 31 17:00:00 1969
--- lame3.70/fft.h	Sun Feb 13 11:52:59 2000
***************
*** 0 ****
--- 1,10 ----
+ #ifndef FFT_H
+ #define FFT_H
+ 
+ #include "encoder.h"
+ 
+ void fft_long(FLOAT x_real[BLKSIZE], int, short **);
+ void fft_short(FLOAT x_real[3][BLKSIZE_s], int, short **);
+ void init_fft(void);
+ 
+ #endif
diff -r -c -N encoder/formatBitstream.c lame3.70/formatBitstream.c
*** encoder/formatBitstream.c	Wed Jan 22 02:43:14 1997
--- lame3.70/formatBitstream.c	Sun Feb 20 07:09:34 2000
***************
*** 17,40 ****
  #include <stdio.h>
  #include <assert.h>
  
- #ifndef EXIT_FAILURE
- #define EXIT_FAILURE 1
- #endif
- 
  /* globals */
  static int BitCount       = 0;
  static int ThisFrameSize  = 0;
  static int BitsRemaining  = 0;
! static BitsFcnPtr PutBits = NULL;
  
  /* forward declarations */
  static int store_side_info( BF_FrameData *frameInfo );
  static int main_data( BF_FrameData *frameInfo, BF_FrameResults *results );
  static int side_queue_elements( int *forwardFrameLength, int *forwardSILength );
! static void free_side_queues();
! static void WriteMainDataBits( unsigned val,
!                                unsigned nbits,
! 			       BF_FrameResults *results );
  /*
    BitStreamFrame is the public interface to the bitstream
    formatting package. It writes one frame of main data per call.
--- 17,41 ----
  #include <stdio.h>
  #include <assert.h>
  
  /* globals */
  static int BitCount       = 0;
  static int ThisFrameSize  = 0;
  static int BitsRemaining  = 0;
! 
! void InitFormatBitStream(void)
! {
! 	BitCount		= 0;
! 	ThisFrameSize	= 0;
! 	BitsRemaining	= 0;
! }
  
  /* forward declarations */
  static int store_side_info( BF_FrameData *frameInfo );
  static int main_data( BF_FrameData *frameInfo, BF_FrameResults *results );
  static int side_queue_elements( int *forwardFrameLength, int *forwardSILength );
! static void free_side_queues(void);
! static void WriteMainDataBits( u_int val,u_int nbits,BF_FrameResults *results );
! 
  /*
    BitStreamFrame is the public interface to the bitstream
    formatting package. It writes one frame of main data per call.
***************
*** 49,65 ****
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
  
-     /* get ptr to bit writing function */
-     PutBits = frameInfo->putbits;
-     assert( PutBits );
      /* save SI and compute its length */
      results->SILength = store_side_info( frameInfo );
  
--- 50,64 ----
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
+ static int elements, forwardFrameLength, forwardSILength; 
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
  
      /* save SI and compute its length */
      results->SILength = store_side_info( frameInfo );
  
***************
*** 87,108 ****
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
! 
!     /* get ptr to bit writing function */
!     PutBits = frameInfo->putbits;
!     assert( PutBits );
! 
!     elements = side_queue_elements( &forwardFrameLength, &forwardSILength );
  
      if ( elements )
      {
! 	int bitsRemaining = forwardFrameLength - forwardSILength;
! 	int wordsRemaining = bitsRemaining / 32;
! 	while ( wordsRemaining-- )
! 	    WriteMainDataBits( 0, 32, results );
! 	WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
--- 86,103 ----
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      if ( elements )
      {
!       int bitsRemaining = forwardFrameLength - forwardSILength;
!       int wordsRemaining = bitsRemaining / 32;
!       while ( wordsRemaining-- ) {
! 	WriteMainDataBits( 0, 32, results );
!       }
!       WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
+     
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
***************
*** 115,121 ****
      BitCount       = 0;
      ThisFrameSize  = 0;
      BitsRemaining  = 0;    
-     PutBits        = NULL;
      return;
  }
  
--- 110,115 ----
***************
*** 123,137 ****
  BF_PartLength( BF_BitstreamPart *part )
  {
      BF_BitstreamElement *ep = part->element;
!     int i, bits;
  
-     bits = 0;
      for ( i = 0; i < part->nrEntries; i++, ep++ )
! 	bits += ep->length;
      return bits;
  }
  
! 
  /*
    The following is all private to this file
  */
--- 117,131 ----
  BF_PartLength( BF_BitstreamPart *part )
  {
      BF_BitstreamElement *ep = part->element;
!     u_int i;
! 	int	bits=0;
  
      for ( i = 0; i < part->nrEntries; i++, ep++ )
! 		bits += ep->length;
      return bits;
  }
  
! 
  /*
    The following is all private to this file
  */
***************
*** 148,155 ****
      BF_PartHolder *spectrumSIPH[MAX_GRANULES][MAX_CHANNELS];
  } MYSideInfo;
  
! static MYSideInfo *get_side_info();
! static int write_side_info();
  typedef int (*PartWriteFcnPtr)( BF_BitstreamPart *part, BF_FrameResults *results );
  
  
--- 142,149 ----
      BF_PartHolder *spectrumSIPH[MAX_GRANULES][MAX_CHANNELS];
  } MYSideInfo;
  
! static MYSideInfo *get_side_info(void);
! static int write_side_info(void);
  typedef int (*PartWriteFcnPtr)( BF_BitstreamPart *part, BF_FrameResults *results );
  
  
***************
*** 157,173 ****
  writePartMainData( BF_BitstreamPart *part, BF_FrameResults *results )
  {
      BF_BitstreamElement *ep;
!     int i, bits;
  
      assert( results );
      assert( part );
  
-     bits = 0;
      ep = part->element;
      for ( i = 0; i < part->nrEntries; i++, ep++ )
      {
! 	WriteMainDataBits( ep->value, ep->length, results );
! 	bits += ep->length;
      }
      return bits;
  }
--- 151,167 ----
  writePartMainData( BF_BitstreamPart *part, BF_FrameResults *results )
  {
      BF_BitstreamElement *ep;
!     u_int	i;
! 	int		bits=0;
  
      assert( results );
      assert( part );
  
      ep = part->element;
      for ( i = 0; i < part->nrEntries; i++, ep++ )
      {
! 		WriteMainDataBits( ep->value, ep->length, results );
! 		bits += ep->length;
      }
      return bits;
  }
***************
*** 176,191 ****
  writePartSideInfo( BF_BitstreamPart *part, BF_FrameResults *results )
  {
      BF_BitstreamElement *ep;
!     int i, bits;
  
      assert( part );
  
-     bits = 0;
      ep = part->element;
      for ( i = 0; i < part->nrEntries; i++, ep++ )
      {
! 	(*PutBits)( ep->value, ep->length );
! 	bits += ep->length;
      }
      return bits;
  }
--- 170,185 ----
  writePartSideInfo( BF_BitstreamPart *part, BF_FrameResults *results )
  {
      BF_BitstreamElement *ep;
!     u_int	i;
! 	int		bits=0;
  
      assert( part );
  
      ep = part->element;
      for ( i = 0; i < part->nrEntries; i++, ep++ )
      {
! 		putMyBits( ep->value, ep->length );
! 		bits += ep->length;
      }
      return bits;
  }
***************
*** 216,244 ****
  */
  
  static void
! WriteMainDataBits( unsigned val,
! 		   unsigned nbits,
  		   BF_FrameResults *results )
  {
      assert( nbits <= 32 );
      if ( BitCount == ThisFrameSize )
      {
  	BitCount = write_side_info();
  	BitsRemaining = ThisFrameSize - BitCount;
      }
!     if ( nbits == 0 )
! 	return;
!     if ( nbits > BitsRemaining )
      {
  	unsigned extra = val >> (nbits - BitsRemaining);
  	nbits -= BitsRemaining;
! 	(*PutBits)( extra, BitsRemaining );
  	BitCount = write_side_info();
  	BitsRemaining = ThisFrameSize - BitCount;
! 	(*PutBits)( val, nbits );
      }
      else
! 	(*PutBits)( val, nbits );
      BitCount += nbits;
      BitsRemaining -= nbits;
      assert( BitCount <= ThisFrameSize );
--- 210,238 ----
  */
  
  static void
! WriteMainDataBits( u_int val,
! 		   u_int nbits,
  		   BF_FrameResults *results )
  {
      assert( nbits <= 32 );
+     if ( nbits == 0 )
+ 	return;
      if ( BitCount == ThisFrameSize )
      {
  	BitCount = write_side_info();
  	BitsRemaining = ThisFrameSize - BitCount;
      }
!     if ( nbits > (u_int)BitsRemaining )
      {
  	unsigned extra = val >> (nbits - BitsRemaining);
  	nbits -= BitsRemaining;
! 	putMyBits( extra, BitsRemaining );
  	BitCount = write_side_info();
  	BitsRemaining = ThisFrameSize - BitCount;
! 	putMyBits( val, nbits );
      }
      else
! 	putMyBits( val, nbits );
      BitCount += nbits;
      BitsRemaining -= nbits;
      assert( BitCount <= ThisFrameSize );
***************
*** 246,254 ****
      assert( (BitCount + BitsRemaining) == ThisFrameSize );
  }
  
! 
  static int
! write_side_info()
  {
      MYSideInfo *si;
      int bits, ch, gr;
--- 240,248 ----
      assert( (BitCount + BitsRemaining) == ThisFrameSize );
  }
  
! 
  static int
! write_side_info(void)
  {
      MYSideInfo *si;
      int bits, ch, gr;
***************
*** 284,290 ****
  side_queue_elements( int *frameLength, int *SILength )
  {
      int elements = 0;
!     side_info_link *l = side_queue_head;
  
      *frameLength = 0;
      *SILength    = 0;
--- 278,284 ----
  side_queue_elements( int *frameLength, int *SILength )
  {
      int elements = 0;
!     side_info_link *l;
  
      *frameLength = 0;
      *SILength    = 0;
***************
*** 302,308 ****
  store_side_info( BF_FrameData *info )
  {
      int ch, gr;
!     side_info_link *l = NULL;
      /* obtain a side_info_link to store info */
      side_info_link *f = side_queue_free;
      int bits = 0;
--- 296,302 ----
  store_side_info( BF_FrameData *info )
  {
      int ch, gr;
!     side_info_link *l;
      /* obtain a side_info_link to store info */
      side_info_link *f = side_queue_free;
      int bits = 0;
***************
*** 318,324 ****
  	if ( l == NULL )
  	{
  	    fprintf( stderr, "cannot allocate side_info_link" );
! 	    exit( EXIT_FAILURE );
  	}
  	l->next = NULL;
  	l->side_info.headerPH  = BF_newPartHolder( info->header->nrEntries );
--- 312,318 ----
  	if ( l == NULL )
  	{
  	    fprintf( stderr, "cannot allocate side_info_link" );
! 	    exit( 1);
  	}
  	l->next = NULL;
  	l->side_info.headerPH  = BF_newPartHolder( info->header->nrEntries );
***************
*** 377,383 ****
  }
  
  static MYSideInfo*
! get_side_info()
  {
      side_info_link *f = side_queue_free;
      side_info_link *l = side_queue_head;
--- 371,377 ----
  }
  
  static MYSideInfo*
! get_side_info(void)
  {
      side_info_link *f = side_queue_free;
      side_info_link *l = side_queue_head;
***************
*** 404,410 ****
  }
  
  static void
! free_side_queues()
  {
      side_info_link *l, *next;
      
--- 398,404 ----
  }
  
  static void
! free_side_queues(void)
  {
      side_info_link *l, *next;
      
***************
*** 445,457 ****
  */
  BF_PartHolder *BF_newPartHolder( int max_elements )
  {
!     BF_PartHolder *newPH    = calloc( 1, sizeof(BF_PartHolder) );
      assert( newPH );
      newPH->max_elements  = max_elements;
!     newPH->part          = calloc( 1, sizeof(BF_BitstreamPart) );
      assert( newPH->part );
!     newPH->part->element = calloc( max_elements, sizeof(BF_BitstreamElement) );
!     assert( newPH->part->element );
      newPH->part->nrEntries = 0;
      return newPH;
  }
--- 439,451 ----
  */
  BF_PartHolder *BF_newPartHolder( int max_elements )
  {
!     BF_PartHolder *newPH    = (BF_PartHolder*) calloc( 1, sizeof(BF_PartHolder) );
      assert( newPH );
      newPH->max_elements  = max_elements;
!     newPH->part          = (BF_BitstreamPart*) calloc( 1, sizeof(BF_BitstreamPart) );
      assert( newPH->part );
!     newPH->part->element = (BF_BitstreamElement*) calloc( max_elements, sizeof(BF_BitstreamElement) );
!     if (max_elements>0) assert( newPH->part->element );
      newPH->part->nrEntries = 0;
      return newPH;
  }
***************
*** 465,471 ****
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart )
  {
      BF_BitstreamElement *pElem;
!     int i;
  
      theHolder->part->nrEntries = 0;
      for ( i = 0; i < thePart->nrEntries; i++ )
--- 459,465 ----
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart )
  {
      BF_BitstreamElement *pElem;
!     u_int i;
  
      theHolder->part->nrEntries = 0;
      for ( i = 0; i < thePart->nrEntries; i++ )
***************
*** 536,548 ****
  /*
    Add a bit value and length to the element list in thePH
  */
! BF_PartHolder *BF_addEntry( BF_PartHolder *thePH, uint32 value, uint16 length )
  {
      BF_BitstreamElement myElement;
      myElement.value  = value;
      myElement.length = length;
      if ( length )
! 	return BF_addElement( thePH, &myElement );
      else
! 	return thePH;
  }
--- 530,543 ----
  /*
    Add a bit value and length to the element list in thePH
  */
! BF_PartHolder *BF_addEntry( BF_PartHolder *thePH, u_int value, u_int length )
  {
      BF_BitstreamElement myElement;
      myElement.value  = value;
      myElement.length = length;
+ 
      if ( length )
! 		return BF_addElement( thePH, &myElement );
      else
! 		return thePH;
  }
diff -r -c -N encoder/formatBitstream.h lame3.70/formatBitstream.h
*** encoder/formatBitstream.h	Wed Jan 22 02:43:15 1997
--- lame3.70/formatBitstream.h	Sat Feb 19 06:32:30 2000
***************
*** 13,18 ****
--- 13,21 ----
    1995/09/06  mc@fivebats.com           created
  
  */
+ 
+ #include "machine.h"
+ 
  #ifndef MAX_CHANNELS
  #define MAX_CHANNELS 2
  #endif
***************
*** 21,37 ****
  #define MAX_GRANULES 2
  #endif
  
- /* Find the ANSI header for these! */
- typedef unsigned int   uint32;
- typedef unsigned short uint16;
- 
  /*
    This is the prototype for the function pointer you must
    provide to write bits to the bitstream. It should write
    'length' bits from 'value,' msb first. Bits in value are
    assumed to be right-justified.
  */
! typedef void (*BitsFcnPtr)( uint32 value, uint16 length );
  
  /*
    A BitstreamElement contains encoded data
--- 24,36 ----
  #define MAX_GRANULES 2
  #endif
  
  /*
    This is the prototype for the function pointer you must
    provide to write bits to the bitstream. It should write
    'length' bits from 'value,' msb first. Bits in value are
    assumed to be right-justified.
  */
! void putMyBits( u_int value, u_int length );
  
  /*
    A BitstreamElement contains encoded data
***************
*** 41,48 ****
  */
  typedef struct
  {
!     uint32 value;
!     uint16 length;
  } BF_BitstreamElement;
  
  /*
--- 40,47 ----
  */
  typedef struct
  {
!     u_int value;
!     u_short length;
  } BF_BitstreamElement;
  
  /*
***************
*** 54,60 ****
  */
  typedef struct
  {
!     uint32              nrEntries;
      BF_BitstreamElement *element;
  } BF_BitstreamPart;
  
--- 53,59 ----
  */
  typedef struct
  {
!     u_int              nrEntries;
      BF_BitstreamElement *element;
  } BF_BitstreamPart;
  
***************
*** 70,76 ****
  
  typedef struct BF_FrameData
  {
-     BitsFcnPtr       putbits;  /* your low-level bitstream function */
      int              frameLength;
      int              nGranules;
      int              nChannels;
--- 69,74 ----
***************
*** 97,145 ****
      int nextBackPtr;
  } BF_FrameResults;
  
- /*
-   The following is a shorthand bitstream syntax for
-   the type of bitstream this package will create.
-   The bitstream has headers and side information that
-   are placed at appropriate sections to allow framing.
-   The main data is placed where it fits in a manner
-   similar to layer3, which means that main data for a
-   frame may be written to the bitstream before the
-   frame's header and side information is written.
- 
- BitstreamFrame()
- {
-     Header();
-     FrameSI();
- 
-     for ( ch )
- 	ChannelSI();
- 
-     for ( gr )
- 	for ( ch )
- 	    SpectrumSI();
- 
-     MainData();
- }
- 
- MainData()
- {
-     for ( gr )
- 	for ( ch )
- 	{
- 	    Scalefactors();
- 	    CodedData();
- 	    UserSpectrum();
- 	}
-     UserFrameData();
- }
- 
- */
  
  /*
    public functions in formatBitstream.c
  */
  
  /* count the bits in a BitstreamPart */
  int  BF_PartLength( BF_BitstreamPart *part );
  
--- 95,109 ----
      int nextBackPtr;
  } BF_FrameResults;
  
  
  /*
    public functions in formatBitstream.c
  */
  
+ 
+ /* Initialize the bitstream */
+ void InitFormatBitStream(void);
+ 
  /* count the bits in a BitstreamPart */
  int  BF_PartLength( BF_BitstreamPart *part );
  
***************
*** 149,154 ****
--- 113,120 ----
  /* write any remaining frames to the bitstream, padding with zeros */
  void BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results );
  
+ 
+ 
  typedef struct BF_PartHolder
  {
      int              max_elements;
***************
*** 158,165 ****
  BF_PartHolder *BF_newPartHolder( int max_elements );
  BF_PartHolder *BF_resizePartHolder( BF_PartHolder *oldPH, int max_elements );
  BF_PartHolder *BF_addElement( BF_PartHolder *thePH, BF_BitstreamElement *theElement );
! BF_PartHolder *BF_addEntry( BF_PartHolder *thePH, uint32 value, uint16 length );
  BF_PartHolder *BF_NewHolderFromBitstreamPart( BF_BitstreamPart *thePart );
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart );
  BF_PartHolder *BF_freePartHolder( BF_PartHolder *thePH );
! #endif
--- 124,132 ----
  BF_PartHolder *BF_newPartHolder( int max_elements );
  BF_PartHolder *BF_resizePartHolder( BF_PartHolder *oldPH, int max_elements );
  BF_PartHolder *BF_addElement( BF_PartHolder *thePH, BF_BitstreamElement *theElement );
! BF_PartHolder *BF_addEntry( BF_PartHolder *thePH, u_int value, u_int length );
  BF_PartHolder *BF_NewHolderFromBitstreamPart( BF_BitstreamPart *thePart );
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart );
  BF_PartHolder *BF_freePartHolder( BF_PartHolder *thePH );
! 
! #endif  /* #ifndef _FORMAT_BITSTREAM_H */
diff -r -c -N encoder/get_audio.c lame3.70/get_audio.c
*** encoder/get_audio.c	Wed Dec 31 17:00:00 1969
--- lame3.70/get_audio.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,937 ----
+ #include "util.h"
+ #include "get_audio.h"
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ 
+ #if (defined LIBSNDFILE || defined LAMESNDFILE)
+ 
+ #ifdef _WIN32
+ /* needed to set stdin to binary on windoze machines */
+ #include <io.h>
+ #endif
+ 
+ 
+ 
+ static FILE *musicin=NULL;  /* input file pointer */
+ static unsigned long num_samples;
+ static int samp_freq;
+ static int input_bitrate;
+ static int num_channels;
+ static int count_samples_carefully;
+ 
+ int read_samples_pcm(lame_global_flags *gfp,short sample_buffer[2304],int frame_size, int samples_to_read);
+ int read_samples_mp3(lame_global_flags *gfp,FILE *musicin,short int mpg123pcm[2][1152],int num_chan);
+ 
+ 
+ 
+ 
+ 
+ void lame_init_infile(lame_global_flags *gfp)
+ {
+   /* open the input file */
+   count_samples_carefully=0;
+   OpenSndFile(gfp,gfp->inPath,gfp->in_samplerate,gfp->num_channels);  
+   /* if GetSndSampleRate is non zero, use it to overwrite the default */
+   if (GetSndSampleRate()) gfp->in_samplerate=GetSndSampleRate();
+   if (GetSndChannels()) gfp->num_channels=GetSndChannels();
+   gfp->num_samples = GetSndSamples();
+ }
+ void lame_close_infile(lame_global_flags *gfp)
+ {
+   CloseSndFile(gfp);
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * lame_readframe()
+ *
+ * PURPOSE:  reads a frame of audio data from a file to the buffer,
+ *   aligns the data for future processing, and separates the
+ *   left and right channels
+ *
+ *
+ ************************************************************************/
+ int lame_readframe(lame_global_flags *gfp,short int Buffer[2][1152])
+ {
+   int iread;
+ 
+   /* note: if input is gfp->stereo and output is mono, get_audio() 
+    * will return  .5*(L+R) in channel 0,  and nothing in channel 1. */
+   iread = get_audio(gfp,Buffer,gfp->stereo);
+   
+   /* check to see if we overestimated/underestimated totalframes */
+   if (iread==0)  gfp->totalframes = Min(gfp->totalframes,gfp->frameNum+2);
+   if (gfp->frameNum > (gfp->totalframes-1)) gfp->totalframes = gfp->frameNum;
+   return iread;
+ }
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * get_audio()
+ *
+ * PURPOSE:  reads a frame of audio data from a file to the buffer,
+ *   aligns the data for future processing, and separates the
+ *   left and right channels
+ *
+ *
+ ************************************************************************/
+ int get_audio(lame_global_flags *gfp,short buffer[2][1152],int stereo)
+ {
+ 
+   int		j;
+   short	insamp[2304];
+   int samples_read;
+   int framesize,samples_to_read;
+   static unsigned long num_samples_read;
+   unsigned long remaining;
+   int num_channels = gfp->num_channels;
+ 
+   if (gfp->frameNum==0) {
+     num_samples_read=0;
+     num_samples= GetSndSamples();
+   }
+   framesize = gfp->mode_gr*576;
+ 
+   samples_to_read = framesize;
+   if (count_samples_carefully) { 
+     /* if this flag has been set, then we are carefull to read 
+      * exactly num_samples and no more.  This is usefull for .wav and .aiff
+      * files which have id3 or other tags at the end.  Note that if you
+      * are using LIBSNDFILE, this is not necessary */
+     remaining=num_samples-Min(num_samples,num_samples_read);
+     if (remaining < (unsigned long)framesize) 
+       samples_to_read = remaining;
+   }
+ 
+ 
+   if (gfp->input_format==sf_mp3) {
+     /* decode an mp3 file for the input */
+     samples_read=read_samples_mp3(gfp,musicin,buffer,num_channels);
+   }else{
+     samples_read = read_samples_pcm(gfp,insamp,num_channels*framesize,num_channels*samples_to_read);
+     samples_read /=num_channels;
+ 
+     for(j=0;j<framesize;j++) {
+       buffer[0][j] = insamp[num_channels*j];
+       if (num_channels==2) buffer[1][j] = insamp[2*j+1];
+       else buffer[1][j]=0;
+     }
+   }
+ 
+   /* dont count things in this case to avoid overflows */
+   if (num_samples!=MAX_U_32_NUM) num_samples_read += samples_read;
+   return(samples_read);
+ 
+ }
+   
+ 
+ 
+ 
+ 
+ 
+ 
+   
+ int GetSndBitrate(void)
+ {
+ 	return input_bitrate;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ int read_samples_mp3(lame_global_flags *gfp,FILE *musicin,short int mpg123pcm[2][1152],int stereo)
+ {
+ #if (defined  AMIGA_MPEGA || defined HAVEMPGLIB) 
+   int j,out=0;
+ #ifdef HAVEGTK
+   static int framesize=0;
+   int ch;
+ #endif
+ 
+   out=lame_decode_fromfile(musicin,mpg123pcm[0],mpg123pcm[1]);
+   /* out = -1:  error, probably EOF */
+   /* out = 0:   not possible with lame_decode_fromfile() */
+   /* out = number of output samples */
+ 
+   if (out==-1) {
+     for ( j = 0; j < 1152; j++ ) {
+       mpg123pcm[0][j] = 0;
+       mpg123pcm[1][j] = 0;
+     }
+   }
+ 
+ 
+ #ifdef HAVEGTK
+   if (gfp->gtkflag) {
+     framesize=1152;
+     if (out==576) framesize=576;
+     
+     /* add a delay of framesize-DECDELAY, which will make the total delay
+      * exactly one frame, so we can sync MP3 output with WAV input */
+     
+     for ( ch = 0; ch < stereo; ch++ ) {
+       for ( j = 0; j < framesize-DECDELAY; j++ )
+ 	pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+framesize];
+       for ( j = 0; j < framesize; j++ ) 
+ 	pinfo->pcmdata2[ch][j+framesize-DECDELAY] = mpg123pcm[ch][j];
+     }
+   
+   pinfo->frameNum123 = gfp->frameNum-1;
+   pinfo->frameNum = gfp->frameNum;
+   }
+ #endif
+   if (out==-1) return 0;
+   else return out;
+ #else
+   fprintf(stderr,"Error: libmp3lame was not compiled with I/O support \n");
+   exit(1);
+ #endif
+ }
+ #endif  /* LAMESNDFILE or LIBSNDFILE */
+ 
+ 
+ 
+ 
+ #ifdef LIBSNDFILE 
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #include <stdio.h>
+ 
+ /* External references */
+ 
+ static SNDFILE*	gs_pSndFileIn=NULL;
+ static SF_INFO	gs_wfInfo;
+ 
+ 
+ unsigned long GetSndSamples(void)
+ {
+        return gs_wfInfo.samples;
+ }
+ int GetSndSampleRate(void)
+ {
+ 	return gs_wfInfo.samplerate;
+ }
+ 
+ int GetSndChannels(void)
+ {
+ 	return gs_wfInfo.channels;
+ }
+ 
+ void CloseSndFile(lame_global_flags *gfp)
+ {
+   if (gfp->input_format==sf_mp3) {
+ #ifndef AMIGA_MPEGA
+     if (fclose(musicin) != 0){
+       fprintf(stderr, "Could not close audio input file\n");
+       exit(2);
+     }
+ #endif
+   }else{
+ 	if (gs_pSndFileIn)
+ 	{
+ 		if (sf_close(gs_pSndFileIn) !=0)
+ 		{
+ 			fprintf(stderr, "Could not close sound file \n");
+ 			exit(2);
+ 		}
+ 	}
+   }
+ }
+ 
+ 
+ 
+ FILE * OpenSndFile(lame_global_flags *gfp,const char* lpszFileName, int default_samp,
+ int default_channels)
+ {
+   input_bitrate=0;
+   if (gfp->input_format==sf_mp3) {
+ #ifdef AMIGA_MPEGA
+     if (-1==lame_decode_initfile(lpszFileName,&num_channels,&samp_freq,&input_bitrate,&num_samples)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", lpszFileName);
+       exit(1);
+     }
+ #endif
+ #ifdef HAVEMPGLIB
+     if ((musicin = fopen(lpszFileName, "rb")) == NULL) {
+       fprintf(stderr, "Could not find \"%s\".\n", lpszFileName);
+       exit(1);
+     }
+     if (-1==lame_decode_initfile(musicin,&num_channels,&samp_freq,&input_bitrate,&num_samples)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", lpszFileName);
+       exit(1);
+     }
+ #endif
+     gs_wfInfo.samples=num_samples;
+     gs_wfInfo.channels=num_channels;
+     gs_wfInfo.samplerate=samp_freq;
+ 
+   } else {
+ 
+     /* Try to open the sound file */
+     /* set some defaults incase input is raw PCM */
+     gs_wfInfo.seekable=(gfp->input_format!=sf_raw);  /* if user specified -r, set to not seekable */
+     gs_wfInfo.samplerate=default_samp;
+     gs_wfInfo.pcmbitwidth=16;
+     gs_wfInfo.channels=default_channels;
+     if (DetermineByteOrder()==order_littleEndian) {
+       if (gfp->swapbytes) gs_wfInfo.format=SF_FORMAT_RAW_BE;
+       else gs_wfInfo.format=SF_FORMAT_RAW_LE;
+     } else {
+       if (gfp->swapbytes) gs_wfInfo.format=SF_FORMAT_RAW_LE;
+       else gs_wfInfo.format=SF_FORMAT_RAW_BE;
+     }
+ 
+     gs_pSndFileIn=sf_open_read(lpszFileName,&gs_wfInfo);
+ 
+         /* Check result */
+ 	if (gs_pSndFileIn==NULL)
+ 	{
+ 	        sf_perror(gs_pSndFileIn);
+ 		fprintf(stderr, "Could not open sound file \"%s\".\n", lpszFileName);
+ 		exit(1);
+ 	}
+ 
+     if ((gs_wfInfo.format==SF_FORMAT_RAW_LE) || 
+ 	(gs_wfInfo.format==SF_FORMAT_RAW_BE)) 
+       gfp->input_format=sf_raw;
+ 
+ #ifdef _DEBUG_SND_FILE
+ 	printf("\n\nSF_INFO structure\n");
+ 	printf("samplerate        :%d\n",gs_wfInfo.samplerate);
+ 	printf("samples           :%d\n",gs_wfInfo.samples);
+ 	printf("channels          :%d\n",gs_wfInfo.channels);
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("format            :");
+ 
+ 	/* new formats from sbellon@sbellon.de  1/2000 */
+         if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_WAV)
+ 	  printf("Microsoft WAV format (big endian). ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_AIFF)
+ 	  printf("Apple/SGI AIFF format (little endian). ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_AU)
+ 	  printf("Sun/NeXT AU format (big endian). ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_AULE)
+ 	  printf("DEC AU format (little endian). ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_RAW)
+ 	  printf("RAW PCM data. ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_PAF)
+ 	  printf("Ensoniq PARIS file format. ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_SVX)
+ 	  printf("Amiga IFF / SVX8 / SV16 format. ");
+ 	if ((gs_wfInfo.format&SF_FORMAT_TYPEMASK)==SF_FORMAT_NIST)
+ 	  printf("Sphere NIST format. ");
+ 
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_PCM)
+ 	  printf("PCM data in 8, 16, 24 or 32 bits.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_FLOAT)
+ 	  printf("32 bit Intel x86 floats.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_ULAW)
+ 	  printf("U-Law encoded.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_ALAW)
+ 	  printf("A-Law encoded.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_IMA_ADPCM)
+ 	  printf("IMA ADPCM.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_MS_ADPCM)
+ 	  printf("Microsoft ADPCM.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_PCM_BE)
+ 	  printf("Big endian PCM data.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_PCM_LE)
+ 	  printf("Little endian PCM data.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_PCM_S8)
+ 	  printf("Signed 8 bit PCM.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_PCM_U8)
+ 	  printf("Unsigned 8 bit PCM.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_SVX_FIB)
+ 	  printf("SVX Fibonacci Delta encoding.");
+ 	if ((gs_wfInfo.format&SF_FORMAT_SUBMASK)==SF_FORMAT_SVX_EXP)
+ 	  printf("SVX Exponential Delta encoding.");
+ 
+ 
+ 
+ 
+ 	printf("\n");
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("sections          :%d\n",gs_wfInfo.sections);
+ 	printf("seekable          :\n",gs_wfInfo.seekable);
+ #endif
+   }
+ 
+   if (gs_wfInfo.samples==MAX_U_32_NUM) {
+     struct stat sb;
+     /* try to figure out num_samples */
+     if (0==stat(lpszFileName,&sb)) {
+       /* try file size, assume 2 bytes per sample */
+       if (gfp->input_format == sf_mp3) {
+ 	FLOAT totalseconds = (sb.st_size*8.0/(1000.0*GetSndBitrate()));
+ 	gs_wfInfo.samples= totalseconds*GetSndSampleRate();
+       }else{
+ 	gs_wfInfo.samples = sb.st_size/(2*GetSndChannels());
+       }
+     }
+   }
+   return musicin;    
+ }
+ 
+ 
+ /************************************************************************
+ *
+ * read_samples()
+ *
+ * PURPOSE:  reads the PCM samples from a file to the buffer
+ *
+ *  SEMANTICS:
+ * Reads #samples_read# number of shorts from #musicin# filepointer
+ * into #sample_buffer[]#.  Returns the number of samples read.
+ *
+ ************************************************************************/
+ 
+ int read_samples_pcm(lame_global_flags *gfp,short sample_buffer[2304],int frame_size,int samples_to_read)
+ {
+     int 		samples_read;
+     int			rcode;
+ 
+     samples_read=sf_read_short(gs_pSndFileIn,sample_buffer,samples_to_read);
+     
+     rcode = samples_read;
+     if (samples_read < frame_size)
+       {
+ 	/*fprintf(stderr,"Insufficient PCM input for one frame - fillout with zeros\n"); 
+ 	*/
+ 	if (samples_read<0) samples_read=0;
+ 	for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
+       }
+ 
+ 	if (8==gs_wfInfo.pcmbitwidth)
+ 	  for (; samples_read >= 0; sample_buffer[samples_read] = sample_buffer[samples_read--] * 256);
+ 
+     return(rcode);
+ }
+ 
+ 
+ #endif /* ifdef LIBSNDFILE */
+ #ifdef LAMESNDFILE 
+ 
+ /************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  *
+  * OLD ISO/LAME routines follow.  Used if you dont have LIBSNDFILE
+  * or for stdin/stdout support
+  *
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************/
+ 
+ /* Replacement for forward fseek(,,SEEK_CUR), because fseek() fails on pipes */
+ int fskip(FILE *sf,long num_bytes,int dummy)
+ {
+   char data[1024];
+   int nskip = 0;
+   while (num_bytes > 0) {
+     nskip = (num_bytes>1024) ? 1024 : num_bytes;
+     num_bytes -= fread(data,(size_t)1,(size_t)nskip,sf);
+   }
+   /* return 0 if last read was successful */
+   return num_bytes;
+ }
+ 
+ 
+ 
+ void CloseSndFile(lame_global_flags *gfp)
+ {
+   if (fclose(musicin) != 0){
+     fprintf(stderr, "Could not close audio input file\n");
+     exit(2);
+   }
+ }
+ 
+ 
+ unsigned long GetSndSamples(void)
+ {
+        return num_samples;
+ }
+ int GetSndSampleRate(void)
+ {
+ 	return samp_freq;
+ }
+ 
+ int GetSndChannels(void)
+ {
+ 	return num_channels;
+ }
+ 
+ 
+ FILE * OpenSndFile(lame_global_flags *gfp,const char* inPath, int default_samp,
+ int default_channels)
+ {
+   struct stat sb;
+   void parse_file_header(lame_global_flags *gfp,FILE *sf);
+   /* set the defaults from info incase we cannot determine them from file */
+   num_samples=MAX_U_32_NUM;
+   samp_freq=default_samp;
+   num_channels = default_channels;
+   
+   if (!strcmp(inPath, "-")) {
+     /* Read from standard input. */
+ #ifdef __EMX__
+     _fsetmode(stdin,"b");
+ #elif (defined  __BORLANDC__)
+     setmode(_fileno(stdin), O_BINARY);
+ #elif (defined  __CYGWIN__)
+     setmode(fileno(stdin), _O_BINARY);
+ #elif (defined _WIN32)
+     _setmode(_fileno(stdin), _O_BINARY);
+ #endif
+     musicin = stdin;
+   } else {
+     if ((musicin = fopen(inPath, "rb")) == NULL) {
+       fprintf(stderr, "Could not find \"%s\".\n", inPath);
+       exit(1);
+     }
+   }
+   
+   input_bitrate=0;
+   if (gfp->input_format==sf_mp3) {
+ #ifdef AMIGA_MPEGA
+     if (-1==lame_decode_initfile(inPath,&num_channels,&samp_freq,&input_bitrate,&num_samples)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", inPath);
+       exit(1);
+     }
+ #endif
+ #ifdef HAVEMPGLIB
+     if (-1==lame_decode_initfile(musicin,&num_channels,&samp_freq,&input_bitrate,&num_samples)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", inPath);
+       exit(1);
+     }
+ #endif
+  }else{
+    if (gfp->input_format != sf_raw) {
+      parse_file_header(gfp,musicin);
+    }
+    
+    if (gfp->input_format==sf_raw) {
+      /* assume raw PCM */
+      fprintf(stderr, "Assuming raw pcm input file");
+      if (gfp->swapbytes==TRUE)
+        fprintf(stderr, " : Forcing byte-swapping\n");
+      else
+        fprintf(stderr, "\n");
+    }
+  }
+     
+   if (num_samples==MAX_U_32_NUM && musicin != stdin) {
+     /* try to figure out num_samples */
+     if (0==stat(inPath,&sb)) {  
+       /* try file size, assume 2 bytes per sample */
+       if (gfp->input_format == sf_mp3) {
+ 	FLOAT totalseconds = (sb.st_size*8.0/(1000.0*GetSndBitrate()));
+ 	num_samples= totalseconds*GetSndSampleRate();
+       }else{
+ 	num_samples = sb.st_size/(2*GetSndChannels());
+       }
+     }
+   }
+   return musicin;
+ }
+   
+   
+ /************************************************************************
+ *
+ * read_samples()
+ *
+ * PURPOSE:  reads the PCM samples from a file to the buffer
+ *
+ *  SEMANTICS:
+ * Reads #samples_read# number of shorts from #musicin# filepointer
+ * into #sample_buffer[]#.  Returns the number of samples read.
+ *
+ ************************************************************************/
+ 
+ int read_samples_pcm(lame_global_flags *gfp,short sample_buffer[2304], int frame_size,int samples_to_read)
+ {
+     int samples_read;
+     int rcode;
+     int iswav=(gfp->input_format==sf_wave);
+ 
+     samples_read = fread(sample_buffer, sizeof(short), samples_to_read, musicin);
+     if (ferror(musicin)) {
+       fprintf(stderr, "Error reading input file\n");
+       exit(2);
+     }
+ 
+     /*
+        Samples are big-endian. If this is a little-endian machine
+        we must swap
+      */
+     if ( NativeByteOrder == order_unknown )
+       {
+ 	NativeByteOrder = DetermineByteOrder();
+ 	if ( NativeByteOrder == order_unknown )
+ 	  {
+ 	    fprintf( stderr, "byte order not determined\n" );
+ 	    exit( 1 );
+ 	  }
+       }
+     /* intel=littleEndian */
+     if (!iswav && ( NativeByteOrder == order_littleEndian ))
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+     if (iswav && ( NativeByteOrder == order_bigEndian ))
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+     if (gfp->swapbytes==TRUE)
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+ 
+     rcode=samples_read;
+     if (samples_read < frame_size) {
+       if (samples_read<0) samples_read=0;
+       /*fprintf(stderr,"Insufficient PCM input for one frame - fillout with zeros\n");
+       */
+       for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
+     }
+     return(rcode);
+ }
+ 
+ 
+ 
+ #define WAV_ID_RIFF 0x52494646 /* "RIFF" */
+ #define WAV_ID_WAVE 0x57415645 /* "WAVE" */
+ #define WAV_ID_FMT  0x666d7420 /* "fmt " */
+ #define WAV_ID_DATA 0x64617461 /* "data" */
+ 
+ typedef struct fmt_chunk_data_struct {
+ 	short	format_tag;			 /* Format category */
+ 	u_short channels;			 /* Number of channels */
+ 	u_long	samples_per_sec;	 /* Sampling rate */
+ 	u_long	avg_bytes_per_sec;	 /* For buffer estimation */
+ 	u_short block_align;		 /* Data block size */
+ 	u_short bits_per_sample;	 /* for PCM data, anyway... */
+ } fmt_chunk_data;
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * wave_check
+ *
+ * PURPOSE:	Checks Wave header information to make sure it is valid.
+ *			Exits if not.
+ *
+ ************************************************************************/
+ 
+ static void
+ wave_check(char *file_name, fmt_chunk_data *wave_info)
+ {
+ 	if (wave_info->bits_per_sample != 16) {
+ 		fprintf(stderr, "%d-bit sample-size is not supported!\n",
+ 			wave_info->bits_per_sample);
+ 		exit(1);
+ 	}
+ }
+ 
+ 
+ /*****************************************************************************
+  *
+  *	Read Microsoft Wave headers
+  *
+  *	By the time we get here the first 32-bits of the file have already been
+  *	read, and we're pretty sure that we're looking at a WAV file.
+  *
+  *****************************************************************************/
+ 
+ static int
+ parse_wave_header(FILE *sf)
+ {
+ 	fmt_chunk_data wave_info;
+ 	int is_wav = 0;
+ 	long data_length = 0, file_length, subSize = 0;
+ 	int loop_sanity = 0;
+ 
+ 	memset(&wave_info, 0, sizeof(wave_info));
+ 
+ 	file_length = Read32BitsHighLow(sf);
+ 
+ 	if (Read32BitsHighLow(sf) != WAV_ID_WAVE)
+ 		return 0;
+ 
+ 	for (loop_sanity = 0; loop_sanity < 20; ++loop_sanity) {
+ 		u_int type = Read32BitsHighLow(sf);
+ 
+ 		if (type == WAV_ID_FMT) {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			if (subSize < 16) {
+ 			  /*fprintf(stderr,
+ 			    "'fmt' chunk too short (only %ld bytes)!", subSize);  */
+ 				return 0;
+ 			}
+ 
+ 			wave_info.format_tag		= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.channels			= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.samples_per_sec	= Read32BitsLowHigh(sf);
+ 			subSize -= 4;
+ 			wave_info.avg_bytes_per_sec = Read32BitsLowHigh(sf);
+ 			subSize -= 4;
+ 			wave_info.block_align		= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.bits_per_sample	= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 
+ 			/* fprintf(stderr, "   skipping %d bytes\n", subSize); */
+ 
+ 			if (subSize > 0) {
+ 				if (fskip(sf, (long)subSize, SEEK_CUR) != 0 )
+ 					return 0;
+ 			};
+ 
+ 		} else if (type == WAV_ID_DATA) {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			data_length = subSize;
+ 			is_wav = 1;
+ 			/* We've found the audio data.	Read no further! */
+ 			break;
+ 
+ 		} else {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 ) return 0;
+ 		}
+ 	}
+ 
+ 	if (is_wav) {
+ 		/* make sure the header is sane */
+ 		wave_check("name", &wave_info);
+ 
+ 		num_channels  = wave_info.channels;
+ 		samp_freq     = wave_info.samples_per_sec;
+ 		num_samples   = data_length / (wave_info.channels * wave_info.bits_per_sample / 8);
+ 	}
+ 	return is_wav;
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * aiff_check
+ *
+ * PURPOSE:	Checks AIFF header information to make sure it is valid.
+ *			Exits if not.
+ *
+ ************************************************************************/
+ 
+ static void
+ aiff_check2(const char *file_name, IFF_AIFF *pcm_aiff_data)
+ {
+ 	if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
+ 	   fprintf(stderr, "Sound data is not PCM in \"%s\".\n", file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
+ 		fprintf(stderr, "Sound data is not %d bits in \"%s\".\n",
+ 				(unsigned int) sizeof(short) * BITS_IN_A_BYTE, file_name);
+ 		exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->numChannels != 1 &&
+ 		pcm_aiff_data->numChannels != 2) {
+ 	   fprintf(stderr, "Sound data is not mono or stereo in \"%s\".\n",
+ 			   file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->blkAlgn.blockSize != 0) {
+ 	   fprintf(stderr, "Block size is not %d bytes in \"%s\".\n",
+ 			   0, file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->blkAlgn.offset != 0) {
+ 	   fprintf(stderr, "Block offset is not %d bytes in \"%s\".\n",
+ 			   0, file_name);
+ 	   exit(1);
+ 	}
+ }
+ 
+ /*****************************************************************************
+  *
+  *	Read Audio Interchange File Format (AIFF) headers.
+  *
+  *	By the time we get here the first 32-bits of the file have already been
+  *	read, and we're pretty sure that we're looking at an AIFF file.
+  *
+  *****************************************************************************/
+ 
+ static int
+ parse_aiff_header(FILE *sf)
+ {
+ 	int is_aiff = 0;
+ 	long chunkSize = 0, subSize = 0;
+ 	IFF_AIFF aiff_info;
+ 
+ 	memset(&aiff_info, 0, sizeof(aiff_info));
+ 	chunkSize = Read32BitsHighLow(sf);
+ 	
+ 	if ( Read32BitsHighLow(sf) != IFF_ID_AIFF )
+ 		return 0;
+ 	
+ 	while ( chunkSize > 0 )
+ 	{
+ 		u_int type = 0;
+ 		chunkSize -= 4;
+ 
+ 		type = Read32BitsHighLow(sf);
+ 
+ 		/* fprintf(stderr,
+ 			"found chunk type %08x '%4.4s'\n", type, (char*)&type); */
+ 
+ 		/* don't use a switch here to make it easier to use 'break' for SSND */
+ 		if (type == IFF_ID_COMM) {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			aiff_info.numChannels	  = Read16BitsHighLow(sf);
+ 			subSize -= 2;
+ 			aiff_info.numSampleFrames = Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 			aiff_info.sampleSize	  = Read16BitsHighLow(sf);
+ 			subSize -= 2;
+ 			aiff_info.sampleRate	  = ReadIeeeExtendedHighLow(sf);
+ 			subSize -= 10;
+ 
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 )
+ 				return 0;
+ 
+ 		} else if (type == IFF_ID_SSND) {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			aiff_info.blkAlgn.offset	= Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 			aiff_info.blkAlgn.blockSize = Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 
+ 			if (fskip(sf, aiff_info.blkAlgn.offset, SEEK_CUR) != 0 )
+ 				return 0;
+ 
+ 			aiff_info.sampleType = IFF_ID_SSND;
+ 			is_aiff = 1;
+ 
+ 			/* We've found the audio data.	Read no further! */
+ 			break;
+ 			
+ 		} else {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 )
+ 				return 0;
+ 		}
+ 	}
+ 
+ 	/* fprintf(stderr, "Parsed AIFF %d\n", is_aiff); */
+ 	if (is_aiff) {
+ 		/* make sure the header is sane */
+ 		aiff_check2("name", &aiff_info);
+ 		num_channels  = aiff_info.numChannels;
+ 		samp_freq     = aiff_info.sampleRate;
+ 		num_samples   = aiff_info.numSampleFrames;
+ 	}
+ 	return is_aiff;
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * parse_file_header
+ *
+ * PURPOSE: Read the header from a bytestream.  Try to determine whether
+ *		   it's a WAV file or AIFF without rewinding, since rewind
+ *		   doesn't work on pipes and there's a good chance we're reading
+ *		   from stdin (otherwise we'd probably be using libsndfile).
+ *
+ * When this function returns, the file offset will be positioned at the
+ * beginning of the sound data.
+ *
+ ************************************************************************/
+ 
+ void parse_file_header(lame_global_flags *gfp,FILE *sf)
+ {
+ 	u_int type = 0;
+ 	type = Read32BitsHighLow(sf);
+ 
+ 	/* fprintf(stderr,
+ 		"First word of input stream: %08x '%4.4s'\n", type, (char*) &type); */
+ 
+ 	count_samples_carefully=0;
+ 	gfp->input_format = sf_raw;
+ 
+ 	if (type == WAV_ID_RIFF) {
+ 		/* It's probably a WAV file */
+ 		if (parse_wave_header(sf)) {
+ 			gfp->input_format = sf_wave;
+ 			count_samples_carefully=1;
+ 		}
+ 
+ 	} else if (type == IFF_ID_FORM) {
+ 		/* It's probably an AIFF file */
+ 		if (parse_aiff_header(sf)) {
+ 			gfp->input_format = sf_aiff;
+ 			count_samples_carefully=1;
+ 		}
+ 	}
+ 	if (gfp->input_format==sf_raw) {
+ 	  /*
+ 	  ** Assume it's raw PCM.	 Since the audio data is assumed to begin
+ 	  ** at byte zero, this will unfortunately require seeking.
+ 	  */
+ 	  if (fseek(sf, 0L, SEEK_SET) != 0) {
+ 	    /* ignore errors */
+ 	  }
+ 	  gfp->input_format = sf_raw;
+ 	}
+ }
+ #endif  /* LAMESNDFILE */
+ 
+ 
diff -r -c -N encoder/get_audio.h lame3.70/get_audio.h
*** encoder/get_audio.h	Wed Dec 31 17:00:00 1969
--- lame3.70/get_audio.h	Thu Mar 16 12:05:26 2000
***************
*** 0 ****
--- 1,94 ----
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #ifndef GET_AUDIO_H_INCLUDED
+ #define GET_AUDIO_H_INCLUDED
+ 
+ #if (defined LIBSNDFILE || defined LAMESNDFILE)
+ 
+ 
+ /* AIFF Definitions */
+ 
+ #define IFF_ID_FORM 0x464f524d /* "FORM" */
+ #define IFF_ID_AIFF 0x41494646 /* "AIFF" */
+ #define IFF_ID_COMM 0x434f4d4d /* "COMM" */
+ #define IFF_ID_SSND 0x53534e44 /* "SSND" */
+ #define IFF_ID_MPEG 0x4d504547 /* "MPEG" */
+ 
+ 
+ 
+ void CloseSndFile(lame_global_flags *gfp);
+ FILE * OpenSndFile(lame_global_flags *gfp,const char* lpszFileName,int default_samp, int 
+    default_chan);
+ unsigned long GetSndSamples(void);
+ int		GetSndSampleRate(void);
+ int		GetSndChannels(void);
+ int		GetSndBitrate(void);
+ 
+ 
+ int get_audio(lame_global_flags *gfp,short buffer[2][1152],int stereo);
+ 
+ 
+ 
+ #ifdef LIBSNDFILE
+ /* INCLUDE the sound library header file */
+ #ifdef _MSC_VER
+ 	/* one byte alignment for WIN32 platforms */
+ 	#pragma pack(push,1)
+ 	#include "./libsndfile/src/sndfile.h"
+ 	#pragma pack(pop,1)
+ #else
+ 	#include "sndfile.h"
+ #endif
+ 
+ 
+ #else
+ /*****************************************************************
+  * LAME/ISO built in audio file I/O routines 
+  *******************************************************************/
+ #include "portableio.h"
+ #include "ieeefloat.h"
+ 
+ 
+ typedef struct  blockAlign_struct {
+     unsigned long   offset;
+     unsigned long   blockSize;
+ } blockAlign;
+ 
+ typedef struct  IFF_AIFF_struct {
+     short           numChannels;
+     unsigned long   numSampleFrames;
+     short           sampleSize;
+     FLOAT           sampleRate;
+     unsigned long   sampleType;
+     blockAlign      blkAlgn;
+ } IFF_AIFF;
+ 
+ extern int            aiff_read_headers(FILE*, IFF_AIFF*);
+ extern int            aiff_seek_to_sound_data(FILE*);
+ extern int            aiff_write_headers(FILE*, IFF_AIFF*);
+ extern int parse_wavheader(void);
+ extern int parse_aiff(const char fn[]);
+ extern void   aiff_check(const char*, IFF_AIFF*, int*);
+ 
+ 
+ #endif	/* ifndef _LIBSNDDLL */
+ #endif  /* ifdef LAMESNDFILE or LIBSNDFILE */
+ #endif	/* ifndef GET_AUDIO_H_INCLUDED*/
diff -r -c -N encoder/gpkplotting.c lame3.70/gpkplotting.c
*** encoder/gpkplotting.c	Wed Dec 31 17:00:00 1969
--- lame3.70/gpkplotting.c	Wed Nov 24 01:42:07 1999
***************
*** 0 ****
--- 1,282 ----
+ #ifdef HAVEGTK
+ #include "gpkplotting.h"
+ #include "string.h"
+ 
+ static gint num_plotwindows = 0;
+ static gint max_plotwindows = 10;
+ static GdkPixmap *pixmaps[10];
+ static GtkWidget *pixmapboxes[10];
+ 
+ 
+ 
+ 
+ /* compute a gdkcolor */
+ void setcolor(GtkWidget *widget, GdkColor *color, gint red,gint green,gint blue)
+ {
+ 
+   /* colors in GdkColor are taken from 0 to 65535, not 0 to 255.    */
+   color->red = red * (65535/255);
+   color->green = green * (65535/255);
+   color->blue = blue * (65535/255);
+   color->pixel = (gulong)(color->red*65536 + color->green*256 + color->blue);
+   /* find closest in colormap, if needed */
+   gdk_color_alloc(gtk_widget_get_colormap(widget),color);
+ }
+ 
+ 
+ void gpk_redraw(GdkPixmap *pixmap, GtkWidget *pixmapbox)
+ {
+   /* redraw the entire pixmap */
+   gdk_draw_pixmap(pixmapbox->window,
+ 		  pixmapbox->style->fg_gc[GTK_WIDGET_STATE (pixmapbox)],
+ 		  pixmap,0,0,0,0,
+ 		  pixmapbox->allocation.width,
+ 		  pixmapbox->allocation.height);
+ }
+ 
+ 
+ static GdkPixmap **findpixmap(GtkWidget *widget)
+ {
+   int i;
+   for (i=0; i<num_plotwindows  && widget != pixmapboxes[i] ; i++);
+   if (i>=num_plotwindows) {
+     g_print("findpixmap(): bad argument widget \n");
+     return NULL;
+   }
+   return &pixmaps[i];
+ }
+ 
+ void gpk_graph_draw(GtkWidget *widget,               /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint *points;
+   int i;
+   gint16 width,height;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+ #ifndef _WIN32
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+ #else
+       fixed_font = gdk_font_load ("-misc-fixed-large-r-*-*-*-100-*-*-*-*-*-*");
+ #endif
+ 
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     points = g_malloc(n*sizeof(GdkPoint));
+     for (i=0; i<n ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     gdk_draw_lines(*ppixmap,gc,points,n);
+     g_free(points);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_rectangle_draw(GtkWidget *widget,              /* plot on this widged */
+ 			gdouble *xcord, gdouble *ycord, /* corners */
+ 			gdouble xmn,gdouble ymn,        /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color)
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     for (i=0; i<2 ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     width=points[1].x-points[0].x + 1;
+     height=points[1].y-points[0].y + 1;
+     gdk_draw_rectangle(*ppixmap,gc,TRUE,
+ 		       points[0].x,points[0].y,width,height);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_bargraph_draw(GtkWidget *widget,           /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    int barwidth,                    /* bar width. 0=compute based on window size */    
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height,x,y,barheight;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+ #ifndef _WIN32
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+ #else
+       fixed_font = gdk_font_load ("-misc-fixed-large-r-*-*-*-100-*-*-*-*-*-*");
+ #endif
+ 
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     for (i=0; i<n ; i++) {
+       points[1].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[1].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       points[0].x = points[1].x;
+       points[0].y = height-1;
+ 
+       x = .5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       y = .5+((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       if (!barwidth) barwidth  = (width/(n+1))-1;
+       barwidth = barwidth > 5 ? 5 : barwidth;
+       barwidth = barwidth < 1 ? 1 : barwidth;
+       barheight = height-1 - y;
+       /* gdk_draw_lines(*ppixmap,gc,points,2); */
+       gdk_draw_rectangle(*ppixmap,gc,TRUE,x,y,barwidth,barheight);
+ 
+     }
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ 
+ 
+ /* Create a new backing pixmap of the appropriate size */
+ static gint
+ configure_event (GtkWidget *widget, GdkEventConfigure *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     if (*ppixmap) gdk_pixmap_unref(*ppixmap);
+     *ppixmap = gdk_pixmap_new(widget->window,
+ 			    widget->allocation.width,
+ 			    widget->allocation.height,
+ 			    -1);
+     gdk_draw_rectangle (*ppixmap,
+ 			widget->style->white_gc,
+ 			TRUE,
+ 			0, 0,
+ 			widget->allocation.width,
+ 			widget->allocation.height);
+   }
+   return TRUE;
+ }
+ 
+ 
+ 
+ /* Redraw the screen from the backing pixmap */
+ static gint
+ expose_event (GtkWidget *widget, GdkEventExpose *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     gdk_draw_pixmap(widget->window,
+ 		    widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		    *ppixmap,
+ 		    event->area.x, event->area.y,
+ 		    event->area.x, event->area.y,
+ 		    event->area.width, event->area.height);
+   }
+ 
+   return FALSE;
+ }
+ 
+ 
+ 
+ 
+ 
+ GtkWidget *gpk_plot_new(int width, int height)
+ {
+   GtkWidget *pixmapbox;
+    
+   pixmapbox = gtk_drawing_area_new();
+   gtk_drawing_area_size(GTK_DRAWING_AREA(pixmapbox),width,height);
+   gtk_signal_connect (GTK_OBJECT (pixmapbox), "expose_event",
+ 		      (GtkSignalFunc) expose_event, NULL);
+   gtk_signal_connect (GTK_OBJECT(pixmapbox),"configure_event",
+ 		      (GtkSignalFunc) configure_event, NULL);
+   gtk_widget_set_events (pixmapbox, GDK_EXPOSURE_MASK);
+ 
+   if (num_plotwindows < max_plotwindows) {
+     pixmapboxes[num_plotwindows] = pixmapbox;
+     pixmaps[num_plotwindows] = NULL;
+     num_plotwindows ++;
+   } else {
+     g_print("gtk_plotarea_new(): exceeded maximum of 10 plotarea windows\n");
+   }
+ 
+   return pixmapbox;
+ }
+ 
+ 
+ #endif
diff -r -c -N encoder/gpkplotting.h lame3.70/gpkplotting.h
*** encoder/gpkplotting.h	Wed Dec 31 17:00:00 1969
--- lame3.70/gpkplotting.h	Wed Nov 24 01:42:08 1999
***************
*** 0 ****
--- 1,27 ----
+ #include <gtk/gtk.h>
+ 
+ /* allocate a graphing widget */
+ GtkWidget *gpk_plot_new(int width,int height);
+ 
+ /* graph a function in the graphing widged */
+ void gpk_graph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title,GdkColor *color);
+ 
+ /* draw a rectangle in the graphing widget */
+ void gpk_rectangle_draw(GtkWidget *widget,                  /* plot on this widged */
+ 			gdouble xcord[2], gdouble ycord[2], /* corners */
+ 			gdouble xmn,gdouble ymn,            /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color);                         /* color to use */
+ 
+ /* make a bar graph in the graphing widged */
+ void gpk_bargraph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title, int bwidth,GdkColor *color);
+ 
+ /* set forground color  */
+ void setcolor(GtkWidget *widget, GdkColor *color,int red,int green,int blue);
+ 
diff -r -c -N encoder/gtkanal.c lame3.70/gtkanal.c
*** encoder/gtkanal.c	Wed Dec 31 17:00:00 1969
--- lame3.70/gtkanal.c	Thu Apr  6 12:50:49 2000
***************
*** 0 ****
--- 1,1410 ----
+ #ifdef HAVEGTK
+ #include <math.h>
+ #include <gtk/gtk.h>
+ #include "gpkplotting.h"
+ #include "util.h"
+ #include "gtkanal.h"
+ #include "version.h"
+ #include "lame.h"
+ #include "tables.h"
+ #include "quantize-pvt.h"
+ #include <assert.h>
+ 
+ int gtkflag;
+ 
+ extern int makeframe(void);
+ 
+ /* global variables for the state of the system */
+ static gint idle_keepgoing;        /* processing of frames is ON */
+ static gint idle_count_max;   /* number of frames to process before plotting */
+ static gint idle_count;       /* pause & plot when idle_count=idel_count_max */
+ static gint idle_end=0;      /* process all frames, stop at last frame  */
+ static gint idle_back = 0;     /* set when we are displaying the old data */
+ static int mp3done = 0;         /* last frame has been read */
+ static GtkWidget *frameprogress; /* progress bar */ 
+ static GtkWidget *framecounter;  /* progress counter */ 
+ 
+ static int subblock_draw[3] = { 1, 1, 1 };
+ 
+ /* main window */
+ GtkWidget *window;
+ /* Backing pixmap for drawing areas */
+ GtkWidget *pcmbox;       /* PCM data plotted here */
+ GtkWidget *winbox;       /* mpg123 synthesis data plotted here */
+ GtkWidget *enerbox[2];   /* spectrum, gr=0,1 plotted here */
+ GtkWidget *mdctbox[2];   /* mdct coefficients gr=0,1 plotted here */
+ GtkWidget *sfbbox[2];    /* scalefactors gr=0,1 plotted here */
+ GtkWidget *headerbox;    /* mpg123 header info shown here */
+ 
+ plotting_data *pinfo,*pplot;
+ plotting_data Pinfo[NUMPINFO];
+ 
+ struct gtkinfostruct {
+   int filetype;           /* input file type 0=WAV, 1=MP3 */
+   int msflag;             /* toggle between L&R vs M&S PCM data display */
+   int chflag;             /* toggle between L & R channels */
+   int kbflag;             /* toggle between wave # and barks */
+   int flag123;            /* show mpg123 frame info, OR ISO encoder frame info */
+   double avebits;         /* running average bits per frame */
+   int approxbits;         /* (approx) bits per frame */
+   int maxbits;            /* max bits per frame used so far*/
+   int totemph;            /* total of frames with de-emphasis */
+   int totms;              /* total frames with ms_stereo */
+   int totis;              /* total frames with i_stereo */
+   int totshort;           /* total granules with short blocks */
+   int totmix;             /* total granules with mixed blocks */
+   int pupdate;            /* plot while processing, or only when needed */
+   int sfblines;           /* plot scalefactor bands in MDCT plot */
+   int totalframes;
+ } gtkinfo;
+ 
+ 
+ static lame_global_flags *gfp;
+ 
+ /**********************************************************************
+  * read one frame and encode it 
+  **********************************************************************/
+ int gtkmakeframe(void)
+ {
+   int iread = 0;
+   static int init=0;
+   static int mpglag;
+   static short int Buffer[2][1152];
+   int ch,j;
+   int mp3count = 0;
+   int mp3out = 0;
+   short mpg123pcm[2][1152];
+   char mp3buffer[LAME_MAXMP3BUFFER];
+   
+ 
+ #ifndef HAVEMPGLIB
+   fprintf(stderr,"Error: GTK frame analyzer requires MPGLIB\n");
+   exit(1);
+ #else
+   /* even if iread=0, get_audio hit EOF and returned Buffer=all 0's.  encode
+    * and decode to flush any previous buffers from the decoder */
+ 
+   pinfo->frameNum = gfp->frameNum;
+   pinfo->sampfreq=gfp->out_samplerate;
+   pinfo->framesize=576*gfp->mode_gr;
+   pinfo->stereo = gfp->stereo;
+ 
+   if (gfp->input_format == sf_mp3) {
+     iread=lame_readframe(gfp,Buffer);
+     gfp->frameNum++;
+   }else {
+     while (gfp->frameNum == pinfo->frameNum) {
+       if (gfp->frameNum==0 && !init) {
+ 	mpglag=1;
+ 	lame_decode_init();
+       }
+       if (gfp->frameNum==1) init=0; /* reset for next time frameNum==0 */
+       iread=lame_readframe(gfp,Buffer);
+       
+       
+       mp3count=lame_encode(gfp,Buffer,mp3buffer,sizeof(mp3buffer)); /* encode frame */
+       assert( !(mp3count > 0 && gfp->frameNum == pinfo->frameNum));
+       /* not possible to produce mp3 data without encoding at least 
+        * one frame of data which would increment gfp->frameNum */
+     }
+     mp3out=lame_decode(mp3buffer,mp3count,mpg123pcm[0],mpg123pcm[1]); /* re-synthesis to pcm */
+     /* mp3out = 0:  need more data to decode */
+     /* mp3out = -1:  error.  Lets assume 0 pcm output */
+     /* mp3out = number of samples output */
+     if (mp3out>0) assert(mp3out==pinfo->framesize);
+     if (mp3out!=0) {
+       /* decoded output is for frame pinfo->frameNum123 
+        * add a delay of framesize-DECDELAY, which will make the total delay
+        * exactly one frame */
+       pinfo->frameNum123=pinfo->frameNum-mpglag;
+       for ( ch = 0; ch < pinfo->stereo; ch++ ) {
+ 	for ( j = 0; j < pinfo->framesize-DECDELAY; j++ )
+ 	  pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+pinfo->framesize];
+ 	for ( j = 0; j < pinfo->framesize; j++ ) {
+ 	  pinfo->pcmdata2[ch][j+pinfo->framesize-DECDELAY] = 
+ 	    (mp3out==-1) ? 0 : mpg123pcm[ch][j];
+ 	}
+       }
+     }else{
+       if (mpglag == MAXMPGLAG) {
+ 	fprintf(stderr,"READ_AHEAD set too low - not enough frame buffering.\n");
+ 	fprintf(stderr,"MP3x display of input and output PCM data out of sync.\n");
+       }
+       else mpglag++; 
+       pinfo->frameNum123=-1;  /* no frame output */
+     }
+   }
+ #endif
+   return iread;
+ }
+ 
+ 
+ void plot_frame(void)
+ {
+   int i,j,n,ch,gr;
+   gdouble *xcord,*ycord;
+   gdouble xmx,xmn,ymx,ymn;
+   double *data,*data2,*data3;
+   char title2[80];
+   char label[80],label2[80];
+   char *title;
+   plotting_data *pplot1;
+   plotting_data *pplot2 = NULL;
+ 
+   double en,samp;
+   int sampindex,version=0;
+   static int firstcall=1;
+   static GdkColor *barcolor,*color,*grcolor[2];
+   static GdkColor yellow,gray,cyan,magenta,orange,pink,red,green,blue,black,oncolor,offcolor;
+   int blocktype[2][2];
+   int headbits;
+   int mode_gr = 2;
+ 
+   /* find the frame where mpg123 produced output coming from input frame
+    * pinfo.  i.e.:   out_frame + out_frame_lag = input_frame  */
+   for (i=1; i<=MAXMPGLAG; i++ ) {
+     if ((pplot-i)->frameNum123 == pplot->frameNum ) {
+       pplot2 = pplot-i;
+       break;
+     }
+   }
+   if (i > MAXMPGLAG) {
+     fprintf(stderr,"input/output pcm syncing problem.  should not happen!\n");
+     pplot2=pplot-1;
+   }
+ 
+ 
+   /* however, the PCM data is delayed by 528 samples in the encoder filterbanks.
+    * We added another 1152-528 delay to this so the PCM data is *exactly* one 
+    * frame behind the header & MDCT information */
+   pplot1 =pplot2 +1;                   /* back one frame for header info, MDCT */
+ 
+   /* allocate these GC's only once */
+   if (firstcall) {
+     firstcall=0;
+     /*    grcolor[0] = &magenta; */
+     grcolor[0] = &blue;
+     grcolor[1] = &green;
+     barcolor = &gray;
+ 
+     setcolor(headerbox,&oncolor,255,0,0);
+     setcolor(headerbox,&offcolor,175,175,175);
+     setcolor(pcmbox,&red,255,0,0);
+     setcolor(pcmbox,&pink,255,0,255);
+     setcolor(pcmbox,&magenta,255,0,100);
+     setcolor(pcmbox,&orange,255,127,0);
+     setcolor(pcmbox,&cyan,0,255,255);
+     setcolor(pcmbox,&green,0,255,0);
+     setcolor(pcmbox,&blue,0,0,255);
+     setcolor(pcmbox,&black,0,0,0);
+     setcolor(pcmbox,&gray,100,100,100);
+     setcolor(pcmbox,&yellow,255,255,0);
+ 
+   }
+ 
+   /*******************************************************************
+    * frame header info
+    *******************************************************************/
+   if (pplot1->sampfreq)
+     samp=pplot1->sampfreq;
+   else samp=1;
+   sampindex = SmpFrqIndex((long)samp, &version);
+ 
+   ch = gtkinfo.chflag;
+   
+   headbits = 32 + ((pplot1->stereo==2) ? 256 : 136);
+   gtkinfo.approxbits = (pplot1->bitrate*1000*1152.0/samp) - headbits;
+   /*font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");*/
+   sprintf(title2,"%3.1fkHz %ikbs ",samp/1000,pplot1->bitrate);
+   gtk_text_freeze (GTK_TEXT(headerbox));
+   gtk_text_backward_delete(GTK_TEXT(headerbox),
+ 			    gtk_text_get_length(GTK_TEXT(headerbox)));
+   gtk_text_set_point(GTK_TEXT(headerbox),0);
+   gtk_text_insert(GTK_TEXT(headerbox),NULL,&oncolor,NULL,title2, -1);
+   title = " mono ";
+   if (2==pplot1->stereo) title = pplot1->js ? " js " : " s ";
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title, -1);
+   color = pplot1->ms_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"ms ", -1);
+   color = pplot1->i_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"is ", -1);
+ 
+   color = pplot1->crc ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"crc ", -1);
+   color = pplot1->padding ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"pad ", -1);
+ 
+   color = pplot1->emph ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"em ", -1);
+ 
+   sprintf(title2,"c1=%i,%i ",pplot1->big_values[0][ch],pplot1->big_values[1][ch]);
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &black, NULL,title2, -1);
+ 
+   color = pplot1->scfsi[ch] ? &oncolor : &offcolor ; 
+   sprintf(title2,"scfsi=%i            ",pplot1->scfsi[ch]);
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,title2, -1);
+   if (gtkinfo.filetype) 
+     sprintf(title2," mdb=%i %i/NA",pplot1->maindata,pplot1->totbits);
+   else
+     sprintf(title2," mdb=%i   %i/%i",
+ 	  pplot1->maindata,pplot1->totbits,pplot->resvsize);
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title2, -1);
+   gtk_text_thaw (GTK_TEXT(headerbox));
+ 
+ 
+ 
+   /*******************************************************************
+    * block type
+    *******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) 
+     if (gtkinfo.flag123) 
+       blocktype[gr][ch]=pplot1->mpg123blocktype[gr][ch];
+     else blocktype[gr][ch]=pplot->blocktype[gr][ch]; 
+ 
+   
+   /*******************************************************************
+    * draw the PCM data *
+    *******************************************************************/
+   n = 1600;  /* PCM frame + FFT window:   224 + 1152 + 224  */
+   xcord = g_malloc(n*sizeof(gdouble));
+   ycord = g_malloc(n*sizeof(gdouble));
+ 
+ 
+   if (gtkinfo.msflag) 
+     title=ch ? "Side Channel" :  "Mid Channel";
+   else 
+     title=ch ? "Right Channel" : "Left Channel";
+ 
+   sprintf(title2,"%s  mask_ratio=%3.2f  %3.2f  ener_ratio=%3.2f  %3.2f",
+ 	  title,
+ 	  pplot->ms_ratio[0],pplot->ms_ratio[1],
+ 	  pplot->ms_ener_ratio[0],pplot->ms_ener_ratio[1]);
+ 
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1;
+ 
+   /*  0  ... 224      draw in black, connecting to 224 pixel
+    * 1375 .. 1599     draw in black  connecting to 1375 pixel
+    * 224 ... 1375     MP3 frame.  draw in blue
+    */
+ 
+   /* draw the title */
+   gpk_graph_draw(pcmbox,0,xcord,ycord,xmn,ymn,xmx,ymx,1,title2,
+ 		 &black);
+ 
+ 
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < mode_gr ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+   /* bars representing FFT windows */
+   xcord[0] = 0;       ycord[0] = ymn+3000;
+   xcord[1] = 1024-1;  ycord[1] = ymn+1000;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[0]);
+   xcord[0] = 576;          ycord[0] = ymn+2000;
+   xcord[1] = 576+1024-1;   ycord[1] = ymn;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[1]);
+ 
+ 
+   /* plot PCM data */
+   for (i=0; i<n; i++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot->pcmdata[0][i]-pplot->pcmdata[1][i]) : 
+       .5*(pplot->pcmdata[0][i]+pplot->pcmdata[1][i]);
+     else 
+       ycord[i]=pplot->pcmdata[ch][i];
+   }
+ 
+   /* skip plot if we are doing an mp3 file */
+   if (!gtkinfo.filetype) {
+     n = 224;    /* number of points on end of blue part */
+     /* data left of frame */
+     gpk_graph_draw(pcmbox,n+1,xcord,ycord,xmn,ymn,xmx,ymx,0,title2,&black);
+     /* data right of frame */
+     gpk_graph_draw(pcmbox,n+1,&xcord[1152+n-1],&ycord[1152+n-1],
+ 		   xmn,ymn,xmx,ymx,0,title2,&black);
+     /* the actual frame */
+     gpk_graph_draw(pcmbox,1152,&xcord[n],&ycord[n],xmn,ymn,xmx,ymx,0,title2,&black);
+   }
+ 
+ 
+   /*******************************************************************/
+   /* draw the PCM re-synthesis data */
+   /*******************************************************************/
+   n = 1152;
+   /*
+   sprintf(title2,"Re-synthesis  mask_ratio=%3.2f  %3.2f  ener_ratio=%3.2f  %3.2f",
+ 	  pplot->ms_ratio[0],pplot->ms_ratio[1],
+ 	  pplot->ms_ener_ratio[0],pplot->ms_ener_ratio[1]);
+   */
+   title="Re-synthesis";
+ 
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1; 
+   gpk_graph_draw(winbox,0,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,1,title,&black);
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < 2 ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+ 
+ 
+ 
+   n = 224;
+   for (j=1152-n,i=0; i<=n; i++,j++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot1->pcmdata2[0][j]-
+                           pplot1->pcmdata2[1][j]) : 
+       .5*(pplot1->pcmdata2[0][j]+pplot1->pcmdata2[1][j]);
+     else 
+       ycord[i]=pplot1->pcmdata2[ch][j];
+   }
+   gpk_graph_draw(winbox,n+1,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+   n = 1152;
+   for (i=0; i<n; i++) {
+     xcord[i] = i+224;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot2->pcmdata2[0][i]-pplot2->pcmdata2[1][i]) : 
+       .5*(pplot2->pcmdata2[0][i]+pplot2->pcmdata2[1][i]);
+     else 
+       ycord[i]=pplot2->pcmdata2[ch][i];
+   }
+   gpk_graph_draw(winbox,n,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+ 
+ 
+ 
+ 
+   /*******************************************************************/
+   /* draw the MDCT energy spectrum */
+   /*******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) {
+     int bits;
+     char *blockname="";
+     switch (blocktype[gr][ch]) {
+     case 0: blockname = "normal"; 	break;
+     case 1:  	blockname = "start";	break;
+     case 2: 	blockname = "short"; 	break;
+     case 3: 	blockname = "end"; 	break;
+     }
+     strcpy(label,blockname);
+     if (pplot1->mixed[gr][ch]) strcat(label,"(mixed)");
+ 
+     
+     
+     
+     n = 576;
+     if (gtkinfo.flag123) {
+       data = pplot1->mpg123xr[gr][0];
+       data2 = pplot1->mpg123xr[gr][1];
+     }else{
+       data = pplot->xr[gr][0];
+       data2 = pplot->xr[gr][1];
+     }
+     
+ 
+     xmn = 0;
+     xmx = n-1;
+     ymn=0;
+     ymx=11;
+ 
+     /* draw title, erase old plot */
+     if (gtkinfo.flag123) bits=pplot1->mainbits[gr][ch];
+     else bits=pplot->LAMEmainbits[gr][ch];
+     sprintf(title2,"MDCT%1i(%s) bits=%i q=%i ",gr,label,bits,
+ 	      pplot1->qss[gr][ch]);
+     gpk_bargraph_draw(mdctbox[gr],0,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+ 
+     /* draw some hash marks showing scalefactor bands */
+     if (gtkinfo.sfblines) {
+       int fac,nsfb, *scalefac;
+       if (blocktype[gr][ch]==SHORT_TYPE) {
+ 	nsfb=SBMAX_s;
+ 	fac=3;
+ 	scalefac = scalefac_band.s;
+       }else{
+ 	nsfb=SBMAX_l;
+ 	fac=1;
+ 	scalefac = scalefac_band.l;
+       }
+       for (i=nsfb-7 ; i<nsfb; i++) {
+ 	ycord[0] = .8*ymx;  ycord[1] = ymn;
+ 	xcord[0] = fac*scalefac[i];
+ 	xcord[1] = xcord[0];
+ 	gpk_rectangle_draw(mdctbox[gr],xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+     }   
+ 
+ 
+ 
+     ymn=9e20;
+     ymx=-9e20;
+     for (i=0; i<n; i++) {
+       double coeff;
+       xcord[i] = i;
+       if (gtkinfo.msflag){
+ 	coeff = ch ?  .5*(data[i]-data2[i]) : .5*(data[i]+data2[i]) ;
+       }else{
+ 	coeff = ch ? data2[i] : data[i];
+       }
+       if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+         coeff = 0;
+       ycord[i]=coeff*coeff*1e10;
+       ycord[i] = log10( MAX( ycord[i],(double) 1)); 
+       ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+       ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+     }
+     /*  print the min/max
+ 	sprintf(title2,"MDCT%1i %5.2f %5.2f  bits=%i",gr,ymn,ymx,
+ 	pplot1->mainbits[gr][ch]);
+     */
+     if (gtkinfo.flag123) bits=pplot1->mainbits[gr][ch];
+     else bits=pplot->LAMEmainbits[gr][ch];
+     
+     
+     sprintf(title2,"MDCT%1i(%s) bits=%i q=%i ",gr,label,bits,
+ 	      pplot1->qss[gr][ch]);
+ 
+     xmn = 0;
+     xmx = n-1;
+     ymn=0;
+     ymx=11;
+     gpk_bargraph_draw(mdctbox[gr],n,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,0,title2,0,barcolor);
+   }
+   
+ 
+ 
+   
+   /*******************************************************************
+    * draw the psy model energy spectrum (k space) 
+    * l3psy.c computes pe, en, thm for THIS granule.  
+    *******************************************************************/
+  if (gtkinfo.kbflag){
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+       n = HBLKSIZE; /* only show half the spectrum */
+ 
+       data = &pplot->energy[gr][ch][0];
+       
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+         if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+           ycord[i] = 0;
+         else
+ 	  ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       for (en=0 , j=0; j<BLKSIZE ; j++) 
+ 	en += pplot->energy[gr][ch][j];
+ 
+       sprintf(title2,"FFT%1i  pe=%4.1fK  en=%5.2e ",gr,
+ 	      pplot->pe[gr][ch]/1000,en);
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n;
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+       
+     }
+   }else{
+     /*******************************************************************
+      * draw the psy model energy spectrum (scalefactor bands)
+      *******************************************************************/
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+ 
+       if (blocktype[gr][ch]==2) {
+ 	n = 3*SBMAX_s; 
+ 	data = &pplot->en_s[gr][ch][0];
+ 	data2 = &pplot->thr_s[gr][ch][0];
+ 	data3 = &pplot->xfsf_s[gr][ch][0];
+       } else {
+ 	n = SBMAX_l; 
+ 	data = &pplot->en[gr][ch][0];
+ 	data2 = &pplot->thr[gr][ch][0];
+ 	data3 = &pplot->xfsf[gr][ch][0];
+       }
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+         if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+           ycord[i] = 0;
+         else
+ 	  ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+ 
+ 
+ 
+       /* en = max energy difference amoung the 3 short FFTs for this granule */
+       en = pplot->ers[gr][ch];
+       sprintf(title2,"FFT%1i pe=%4.1fK/%3.1f n=%i/%3.1f/%3.1f/%3.1f",gr,
+ 	      pplot->pe[gr][ch]/1000,en,pplot->over[gr][ch],
+ 	      pplot->max_noise[gr][ch],
+ 	      pplot->over_noise[gr][ch],
+ 	      pplot->tot_noise[gr][ch]);
+ 
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n+1; /* a little extra because of the bar thickness */
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+ 
+ 
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+         if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+           ycord[i] = 0;
+         else
+ 	  ycord[i] = log10( MAX( data3[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,&red);  
+ 
+       
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1 + (.25*n)/SBMAX_l;
+         if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+           ycord[i] = 0;
+         else
+ 	  ycord[i] = log10( MAX( data2[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,grcolor[gr]);
+     }
+   }
+ 
+   /*******************************************************************
+    * draw scalefactors 
+    *******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) {
+       double ggain;
+       if (blocktype[gr][ch]==2) {
+ 	n = 3*SBMAX_s; 
+ 	if (gtkinfo.flag123) data = pplot1->sfb_s[gr][ch];
+ 	else data = pplot->LAMEsfb_s[gr][ch];
+       } else {
+ 	n = SBMAX_l; 
+ 	if (gtkinfo.flag123) data = pplot1->sfb[gr][ch];
+ 	else data = pplot->LAMEsfb[gr][ch];
+       }
+ 
+       ymn=-1;
+       ymx=10;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+         if (blocktype[gr][ch]==SHORT_TYPE && !subblock_draw[i % 3])
+           ycord[i] = 0;
+         else
+ 	  ycord[i] = -data[i];
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+ 
+       if (blocktype[gr][ch]==2) {
+ 	sprintf(label2,
+ 		"SFB scale=%i %i%i%i",
+ 		pplot1->scalefac_scale[gr][ch],
+ 		pplot1->sub_gain[gr][ch][0],
+ 		pplot1->sub_gain[gr][ch][1],
+ 		pplot1->sub_gain[gr][ch][2]);
+       }else{
+ 	sprintf(label2,"SFB scale=%i",pplot1->scalefac_scale[gr][ch]);
+       }
+       
+       if (gtkinfo.flag123) ggain = -(pplot1->qss[gr][ch]-210)/4.0;
+       else ggain = -(pplot->LAMEqss[gr][ch]-210)/4.0;
+ 
+       sprintf(title2," gain=%4.1f",ggain);
+       strcat(label2,title2);
+       
+       xmn = 1;
+       xmx = n+1;
+       gpk_bargraph_draw(sfbbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,label2,0,grcolor[gr]);
+ 
+       ycord[0] = ycord[1] = 0;
+       xcord[0] = 1;
+       xcord[1] = n+1;
+       gpk_rectangle_draw(sfbbox[gr],xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+ 
+       
+     }
+ 
+ 
+ }
+ 
+ 
+ 
+ static void update_progress(void)
+ {    
+   char label[80];
+   int tf=gfp->totalframes;
+   if (gtkinfo.totalframes>0) tf=gtkinfo.totalframes;
+ 
+   sprintf(label,"Frame:%4i/%4i  %6.2fs",
+ 	 pplot->frameNum,(int)tf-1, pplot->frametime);
+   gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) pplot->frameNum);
+   gtk_label_set_text(GTK_LABEL(framecounter),label);
+ }
+ 
+ 
+ 
+ static void analyze(void)
+ {
+     if ( idle_keepgoing) {
+       idle_count = 0;
+       idle_count_max=0;
+       idle_keepgoing=0;
+       idle_end=0;
+     }
+     plot_frame();   
+     update_progress(); 
+ }
+ 
+ static void plotclick( GtkWidget *widget, gpointer   data )
+ {   analyze(); }
+ 
+ 
+ 
+ 
+ static int frameadv1(GtkWidget *widget, gpointer   data )
+ {
+   int i;
+   if (idle_keepgoing ){
+     if (idle_back) {
+       /* frame displayed is the old frame.  to advance, just swap in new frame */
+       idle_back--;
+       pplot = &Pinfo[READ_AHEAD+idle_back];
+     }else{
+       /* advance the frame by reading in a new frame */
+       pplot = &Pinfo[READ_AHEAD];
+       if (mp3done) { 
+ 	/* dont try to read any more frames, and quit if "finish MP3" was selected */
+ 	/*	if (idle_finish) gtk_main_quit(); */
+ 	idle_count_max=0; 
+         idle_end=0;
+       } else {
+ 	/* read in the next frame */
+ 	for (i=NUMPINFO-1 ; i>0 ; i--)
+ 	  memcpy(&Pinfo[i],&Pinfo[i-1],sizeof(plotting_data));
+ 	pinfo = &Pinfo[0];
+ 	pinfo->num_samples = gtkmakeframe();
+ 	if (pinfo->num_samples==0 && gtkinfo.totalframes==0) 
+ 	  /* allow an extra frame to flush decoder buffers */
+ 	  gtkinfo.totalframes = pinfo->frameNum +2;
+ 
+ 	if (pinfo->sampfreq) 
+ 	  pinfo->frametime = (pinfo->frameNum)*1152.0/pinfo->sampfreq;
+ 	else pinfo->frametime=0;
+ 
+         /* eof? 
+ 	if (!pinfo->num_samples) if (idle_finish) gtk_main_quit();
+ 	*/
+ 
+ 	pinfo->totbits = 0;
+ 	{ int gr,ch;
+ 	for (gr = 0 ; gr < 2 ; gr ++) 
+ 	  for (ch = 0 ; ch < 2 ; ch ++) {
+ 	    gtkinfo.totshort += (pinfo->mpg123blocktype[gr][ch]==2);
+ 	    gtkinfo.totmix  += !(pinfo->mixed[gr][ch]==0);
+ 	    pinfo->totbits += pinfo->mainbits[gr][ch];
+ 	  }
+ 	}
+ 	if (pinfo->frameNum > 0) /* start averaging at second frame */
+ 	  gtkinfo.avebits = (gtkinfo.avebits*((pinfo->frameNum)-1)
+ 	  + pinfo->totbits ) /(pinfo->frameNum);
+ 
+ 	gtkinfo.maxbits=MAX(gtkinfo.maxbits,pinfo->totbits);
+ 	gtkinfo.totemph += !(pinfo->emph==0);
+ 	gtkinfo.totms   += !(pinfo->ms_stereo==0);
+ 	gtkinfo.totis   += !(pinfo->i_stereo==0);
+ 
+ 	if (gtkinfo.totalframes>0)
+ 	  if (pplot->frameNum >= gtkinfo.totalframes-1) mp3done=1;
+       }
+     }
+ 
+     idle_count++;
+     if (gtkinfo.pupdate) plot_frame();
+     update_progress();
+     if ((idle_count>=idle_count_max) && (! idle_end)) analyze();
+   }
+   return 1;
+ }
+ 
+ 
+ static void frameadv( GtkWidget *widget, gpointer   data )
+ {
+     int adv;
+ 
+     if (!strcmp((char *) data,"-1")) {
+       /* ignore if we've already gone back as far as possible */
+       if (pplot->frameNum==0 || (idle_back==NUMBACK)) return;  
+       idle_back++;
+       pplot = &Pinfo[READ_AHEAD+idle_back];
+       analyze();
+       return;
+     }
+ 
+ 
+     adv = 1;
+     if (!strcmp((char *) data,"1")) adv = 1;
+     if (!strcmp((char *) data,"10")) adv = 10;
+     if (!strcmp((char *) data,"100")) adv = 100;
+     if (!strcmp((char *) data,"finish")) idle_end = 1;
+ 
+ 
+     if (idle_keepgoing) {
+       /* already running - que up additional frame advance requests */
+       idle_count_max += adv; 
+     }
+     else {
+       /* turn on idleing */
+       idle_count_max = adv;
+       idle_count = 0;
+       idle_keepgoing = 1;
+     }
+ }
+ 
+ 
+ 
+ 
+ /* another callback */
+ static void delete_event( GtkWidget *widget,
+                    GdkEvent  *event,
+ 		   gpointer   data )
+ {
+     gtk_main_quit ();
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ static void channel_option (GtkWidget *widget, gpointer data)
+ {
+   long option;
+   option = (long) data;
+   switch (option) {
+   case 1:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0; 
+     break;
+   case 2:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=1; 
+     break;
+   case 3:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=0; 
+     break;
+   case 4:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=1; 
+   }
+   analyze();
+ }
+ static void spec_option (GtkWidget *widget, gpointer data)
+ {
+   long option;
+   option = (long) data;
+   switch (option) {
+   case 1:
+     gtkinfo.kbflag=0;
+     break;
+   case 2:
+     gtkinfo.kbflag=1;
+     break;
+   case 3:
+     gtkinfo.flag123=0;
+     break;
+   case 4:
+     gtkinfo.flag123=1;
+     break;
+   case 5:
+     gtkinfo.pupdate=1;
+     break;
+   case 6:
+     gtkinfo.pupdate=0;
+     break;
+   case 7:
+     gtkinfo.sfblines = !gtkinfo.sfblines;
+     break;
+   }
+   analyze();
+ }
+ 
+ static gint key_press_event (GtkWidget *widget, GdkEventKey *event)
+ {
+   if (event->keyval == '1') {
+     subblock_draw[0] = 1;
+     subblock_draw[1] = 0;
+     subblock_draw[2] = 0;
+     analyze();
+   }
+   else if (event->keyval == '2') {
+     subblock_draw[0] = 0;
+     subblock_draw[1] = 1;
+     subblock_draw[2] = 0;
+     analyze();
+   }
+   else if (event->keyval == '3') {
+     subblock_draw[0] = 0;
+     subblock_draw[1] = 0;
+     subblock_draw[2] = 1;
+     analyze();
+   }
+   else if (event->keyval == '0') {
+     subblock_draw[0] = 1;
+     subblock_draw[1] = 1;
+     subblock_draw[2] = 1;
+     analyze();
+   }
+   /* analyze(); */  /* dont redraw entire window for every key! */
+   return 0;
+ }
+ 
+ 
+ 
+ static void text_window (GtkWidget *widget, gpointer data)
+ {
+   long option;
+   GtkWidget *hbox,*vbox,*button,*box;
+   GtkWidget *textwindow,*vscrollbar;
+   char text[80];
+ 
+   option = (long) data;
+   
+   textwindow = gtk_window_new(GTK_WINDOW_DIALOG);
+   gtk_signal_connect_object (GTK_OBJECT (window), "delete_event",
+ 		      GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 		      GTK_OBJECT (textwindow));
+ 
+   gtk_container_set_border_width (GTK_CONTAINER (textwindow), 0);
+   vbox = gtk_vbox_new(FALSE,0);
+   hbox = gtk_hbox_new(FALSE,0);
+ 
+   button = gtk_button_new_with_label ("close");
+   gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+ 			     GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 			     GTK_OBJECT (textwindow));
+ 
+   box = gtk_text_new (NULL, NULL);
+   gtk_text_set_editable (GTK_TEXT (box), FALSE);
+   vscrollbar = gtk_vscrollbar_new (GTK_TEXT(box)->vadj);
+ 
+ 
+   switch (option) {
+   case 0: 
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Documentation");
+     gtk_widget_set_usize(box,450,500); 
+     gtk_text_set_word_wrap(GTK_TEXT(box),TRUE);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"Frame header information: "\
+ 		"First the bitrate, sampling frequency and mono, stereo or jstereo "\
+ 		"indicators are displayed .  If the bitstream is jstereo, then mid/side "\
+ 		"stereo or intensity stereo may be on (indicated in red).  If "\
+ 		"de-emphasis is used, this is also indicated in red.  The mdb value is "\
+ 		"main_data_begin.  The encoded data starts this many bytes *before* the "\
+ 		"frame header.  A large value of mdb means the bitstream has saved some "\
+ 		"bits into the reservoir, which it may allocate for some future frame. "\
+ 		"The two numbers after mdb are the size (in bits) used to encode the "\
+ 		"MDCT coefficients for this frame, followed byt the size of the bit "\
+ 		"resevoir before encoding this frame.  The maximum frame size and a "\
+ 		"running average are given in the Stats pull down menu.  A large "\
+ 		"maximum frame size indicates the bitstream has made use of the bit "\
+ 		"reservoir. \n\n",-1);
+ 
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM data (top graph): "\
+ 		"The PCM data is plotted in black.  The layer3 frame is divided into 2 "\
+ 		"granules of 576 samples (marked with yellow vertical lines).  In the "\
+ 		"case of normal, start and stop blocks, the MDCT coefficients for each "\
+ 		"granule are computed using a 1152 sample window centered over the "\
+ 		"granule.  In the case of short blocks, the granule is further divided "\
+ 		"into 3 blocks of 192 samples (also marked with yellow vertical lines)."\
+ 		"The MDCT coefficients for these blocks are computed using 384 sample "\
+ 		"windows centered over the 192 sample window.  (This info not available "\
+ 		"when analyzing .mp3 files.)  For the psycho-acoustic model, a windowed "\
+ 		"FFT is computed for each granule.  The range of these windows "\
+ 		"is denoted by the blue and green bars.\n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM re-synthesis data (second graph): "\
+ 		"Same as the PCM window described above.  The data displayed is the "\
+ 		"result of encoding and then decoding the original sample. \n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"MDCT windows: "\
+ 		"Shows the energy in the MDCT spectrum for granule 0 (left window) "\
+ 		"and granule 1 (right window).  The text also shows the blocktype "\
+ 		"used, the number of bits used to encode the coefficients and the "\
+ 		"number of extra bits allocated from the reservoir.  The MDCT pull down "\
+ 		"window will toggle between the original unquantized MDCT coefficients "\
+ 		"and the compressed (quantized) coefficients.\n\n",-1); 
+  
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"FFT window: "\
+ 		"The gray bars show the energy in the FFT spectrum used by the "\
+ 		"psycho-acoustic model.  Granule 0 is in the left window, granule 1 in "\
+ 		"the right window.  The green and blue bars show how much distortion is "\
+ 		"allowable, as computed by the psycho-acoustic model. The red bars show "\
+ 		"the actual distortion after encoding.  There is one FFT for each "\
+ 		"granule, computed with a 1024 Hann window centered over the "\
+ 		"appropriate granule.  (the range of this 1024 sample window is shown "\
+ 		"by the blue and green bars in the PCM data window).  The Spectrum pull "\
+ 		"down window will toggle between showing the energy in equally spaced "\
+ 		"frequency domain and the scale factor bands used by layer3.  Finally, "\
+ 		"the perceptual entropy, total energy and number of scalefactor bands "\
+ 		"with audible distortion is shown.  (This info not available when "\
+ 		"analyzing .mp3 files.)",-1);
+ 
+     break;
+   case 1:
+ 	/* Set the about box information */
+     gtk_window_set_title (GTK_WINDOW (textwindow), "About");
+     gtk_widget_set_usize(box,350,260);
+ 
+     sprintf(text,"LAME version %s \nwww.sulaco.org/mp3\n\n",get_lame_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+ 
+     sprintf(text,"psycho-acoustic model:  GPSYCHO version %s\n",get_psy_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     sprintf(text,"frame analyzer: MP3x version %s\n\n",get_mp3x_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		    "decoder:  mpg123/mpglib  .59q  \nMichael Hipp (www.mpg123.de)\n\n",-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+     "Encoder, decoder & psy-models based on ISO\ndemonstration source. ",-1);
+     break;
+ 
+   case 2:
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Statistics");
+     gtk_widget_set_usize(box,350,260);
+     sprintf(text,"frames processed so far: %i \n",Pinfo[0].frameNum+1);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"granules processed so far: %i \n\n",4*(Pinfo[0].frameNum+1));
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (approximate): %i\n",
+ 	    gtkinfo.approxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (from LAME): %i\n",
+ 	    4*Pinfo[0].mean_bits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"bitsize of largest frame: %i \n",gtkinfo.maxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"average bits/frame: %3.1f \n\n",gtkinfo.avebits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"ms_stereo frames: %i \n",gtkinfo.totms);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"i_stereo frames: %i \n",gtkinfo.totis);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"de-emphasis frames: %i \n",gtkinfo.totemph);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"short block granules: %i \n",gtkinfo.totshort);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mixed block granules: %i \n",gtkinfo.totmix);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     break;
+   }
+ 
+ 
+ 
+   gtk_widget_show (vscrollbar);
+   gtk_widget_show (box);
+   gtk_widget_show (vbox);
+   gtk_widget_show (hbox);
+   gtk_widget_show (button);
+ 
+   gtk_box_pack_start (GTK_BOX(hbox), box, FALSE, TRUE, 0);
+   gtk_box_pack_start(GTK_BOX(hbox), vscrollbar, FALSE, FALSE, 0);
+   gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 0);
+   gtk_box_pack_end (GTK_BOX (vbox), button, FALSE, TRUE, 0);
+   gtk_container_add (GTK_CONTAINER (textwindow), vbox); 
+   gtk_widget_show(textwindow);
+ 
+ }
+ 
+ 
+ 
+ 
+ /* #include <strings.h>*/
+ 
+ 
+ /* This is the GtkItemFactoryEntry structure used to generate new menus.
+    Item 1: The menu path. The letter after the underscore indicates an
+            accelerator key once the menu is open.
+    Item 2: The accelerator key for the entry
+    Item 3: The callback function.
+    Item 4: The callback action.  This changes the parameters with
+            which the function is called.  The default is 0.
+    Item 5: The item type, used to define what kind of an item it is.
+            Here are the possible values:
+ 
+            NULL               -> "<Item>"
+            ""                 -> "<Item>"
+            "<Title>"          -> create a title item
+            "<Item>"           -> create a simple item
+            "<CheckItem>"      -> create a check item
+            "<ToggleItem>"     -> create a toggle item
+            "<RadioItem>"      -> create a radio item
+            <path>             -> path of a radio item to link against
+            "<Separator>"      -> create a separator
+            "<Branch>"         -> create an item to hold sub items
+            "<LastBranch>"     -> create a right justified branch 
+ */
+ 
+ static GtkItemFactoryEntry menu_items[] = {
+   {"/_File",         NULL,         NULL, 0, "<Branch>"},
+   /*
+   {"/File/_New",     "<control>N", print_hello, 0, NULL},
+   {"/File/_Open",    "<control>O", print_hello, 0, NULL},
+   {"/File/_Save",    "<control>S", print_hello, 0, NULL},
+   {"/File/Save _As", NULL,         NULL, 0, NULL},
+   {"/File/sep1",     NULL,         NULL, 0, "<Separator>"},
+   {"/File/Quit",     "<control>Q", gtk_main_quit, 0, NULL}, 
+   */
+   {"/File/_Quit",     "<control>Q", delete_event, 0, NULL}, 
+ 
+   {"/_Plotting",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Plotting/_While advancing" ,  NULL,  spec_option, 5, NULL},
+   {"/Plotting/_After advancing",  NULL,  spec_option, 6, NULL},
+ 
+   {"/_Channel",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Channel/show _Left" ,  NULL,  channel_option, 1, NULL},
+   {"/Channel/show _Right",  NULL,  channel_option, 2, NULL},
+   {"/Channel/show _Mid" ,   NULL,  channel_option, 3, NULL},
+   {"/Channel/show _Side",   NULL,  channel_option, 4, NULL},
+ 
+   {"/_Spectrum",                   NULL,  NULL, 0, "<Branch>"},
+   {"/Spectrum/_Scalefactor bands",  NULL,  spec_option, 1, NULL},
+   {"/Spectrum/_Wave number",        NULL,  spec_option, 2, NULL},
+ 
+   {"/_MDCT",                         NULL,  NULL, 0, "<Branch>"},
+   {"/MDCT/_Original",               NULL,  spec_option, 3, NULL},
+   {"/MDCT/_Compressed",             NULL,  spec_option, 4, NULL},
+   {"/MDCT/_Toggle SFB lines",       NULL,  spec_option, 7, NULL},
+ 
+   {"/_Stats",                         NULL,  NULL, 0, "<Branch>"},
+   {"/Stats/_Show",               NULL,  text_window, 2, NULL},
+ 
+   {"/_Help",         NULL,         NULL, 0, "<LastBranch>"},
+   {"/_Help/_Documentation",   NULL,   text_window, 0, NULL},
+   {"/_Help/_About",           NULL,   text_window, 1, NULL},
+ };
+ 
+ 
+ static void get_main_menu(GtkWidget *window, GtkWidget ** menubar) {
+   int nmenu_items = sizeof(menu_items) / sizeof(menu_items[0]);
+   GtkItemFactory *item_factory;
+   GtkAccelGroup *accel_group;
+ 
+   accel_group = gtk_accel_group_new();
+ 
+   /* This function initializes the item factory.
+      Param 1: The type of menu - can be GTK_TYPE_MENU_BAR, GTK_TYPE_MENU,
+               or GTK_TYPE_OPTION_MENU.
+      Param 2: The path of the menu.
+      Param 3: A pointer to a gtk_accel_group.  The item factory sets up
+               the accelerator table while generating menus.
+   */
+ 
+   item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<main>", 
+ 				       accel_group);
+ 
+   /* This function generates the menu items. Pass the item factory,
+      the number of items in the array, the array itself, and any
+      callback data for the the menu items. */
+   gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, NULL);
+ 
+   /* Attach the new accelerator group to the window. */
+   gtk_accel_group_attach (accel_group, GTK_OBJECT (window));
+ 
+   if (menubar)
+     /* Finally, return the actual menu bar created by the item factory. */ 
+     *menubar = gtk_item_factory_get_widget(item_factory, "<main>");
+ }
+ 
+ 
+ 
+ 
+ int gtkcontrol(lame_global_flags *gfp2)
+ {
+     /* GtkWidget is the storage type for widgets */
+     GtkWidget *button;
+     GtkAdjustment *adj;
+     GtkWidget *mbox;        /* main box */
+     GtkWidget *box1;        /* frame control buttons go */
+     GtkWidget *box2;        /* frame counters */
+     GtkWidget *box3;        /* frame header info */
+     GtkWidget *table;       /* table for all the plotting areas */
+     GtkWidget *menubar;
+ 
+     gint tableops,graphx,graphy;
+     char frameinfo[80];
+ 
+     graphx = 500;  /* minimum allowed size of pixmap */
+     graphy = 95;
+ 
+     gfp=gfp2;
+ 
+     /* set some global defaults/variables */
+     gtkinfo.filetype = (gfp->input_format == sf_mp3);
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0;
+     gtkinfo.kbflag=0;
+     gtkinfo.flag123 = (gfp->input_format == sf_mp3); /* MP3 file=use mpg123 output */
+     gtkinfo.pupdate=0;
+     gtkinfo.avebits = 0;
+     gtkinfo.maxbits = 0;
+     gtkinfo.approxbits = 0;
+     gtkinfo.totemph = 0;
+     gtkinfo.totms = 0;
+     gtkinfo.totis = 0;
+     gtkinfo.totshort = 0;
+     gtkinfo.totmix = 0;
+     gtkinfo.sfblines= 1;
+     gtkinfo.totalframes = 0;
+ 
+     memset((char *) Pinfo, 0, sizeof(Pinfo));
+     pplot = &Pinfo[READ_AHEAD];
+ 
+     strcpy(frameinfo,"MP3x: ");
+     strncat(frameinfo,gfp->inPath,70);
+ 
+     window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+     gtk_window_set_title (GTK_WINDOW (window), frameinfo);
+     gtk_signal_connect (GTK_OBJECT (window), "delete_event",
+ 			GTK_SIGNAL_FUNC (delete_event), NULL);
+ 
+     gtk_signal_connect_object (GTK_OBJECT (window), "key_press_event",
+ 		      GTK_SIGNAL_FUNC(key_press_event),
+ 		      GTK_OBJECT (window));
+ 
+     gtk_container_set_border_width (GTK_CONTAINER (window), 0);
+ 
+ 
+     mbox = gtk_vbox_new(FALSE, 0);
+ 
+ 
+     /* layout of mbox */
+     box1 = gtk_hbox_new(FALSE, 0);
+     box2 = gtk_hbox_new(FALSE, 0);
+     box3 = gtk_hbox_new(FALSE, 0);
+     table = gtk_table_new (5, 2, FALSE);
+     tableops = GTK_FILL | GTK_EXPAND | GTK_SHRINK;
+     get_main_menu(window, &menubar);
+ 
+     gtk_box_pack_start(GTK_BOX(mbox), menubar, FALSE, TRUE, 0);
+     gtk_box_pack_end (GTK_BOX (mbox), box1, FALSE, TRUE, 0);
+     gtk_box_pack_end(GTK_BOX (mbox),box2, FALSE, TRUE, 0);
+     gtk_box_pack_start(GTK_BOX (mbox),box3, FALSE, TRUE, 0);
+     gtk_box_pack_start (GTK_BOX (mbox), table, TRUE, TRUE, 0);
+     gtk_container_add (GTK_CONTAINER (window), mbox); 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box3  frame header info */
+     /*********************************************************************/
+     /*
+     headerbox = gtk_label_new(" ");
+     gtk_label_set_justify(GTK_LABEL(headerbox),GTK_JUSTIFY_LEFT); 
+     */
+     headerbox = gtk_text_new (NULL, NULL);
+     gtk_text_set_editable (GTK_TEXT (headerbox), FALSE);
+     gtk_widget_set_usize(headerbox,200,20);
+     gtk_widget_show (headerbox);
+     gtk_box_pack_start(GTK_BOX (box3),headerbox, TRUE, TRUE, 0);
+     
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box2   frame counters  */
+     /*********************************************************************/
+     framecounter = gtk_label_new("");
+     gtk_widget_show(framecounter);
+     gtk_box_pack_start(GTK_BOX (box2),framecounter, FALSE, TRUE, 0);
+ 
+     adj = (GtkAdjustment *) gtk_adjustment_new (0, 0,(gint) gfp->totalframes-1, 0, 0, 0);
+     frameprogress = gtk_progress_bar_new_with_adjustment (adj);
+     /* Set the format of the string that can be displayed in the
+      * trough of the progress bar:
+      * %p - percentage
+      * %v - value
+      * %l - lower range value
+      * %u - upper range value */
+     gtk_progress_set_format_string (GTK_PROGRESS (frameprogress),
+ 	                            "%p%%");
+     gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) 0);
+     gtk_progress_set_show_text (GTK_PROGRESS (frameprogress),TRUE);
+     gtk_widget_show (frameprogress);
+     gtk_box_pack_end (GTK_BOX (box2), frameprogress, FALSE, TRUE, 0);
+ 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box1  buttons along bottom */
+     /*********************************************************************/
+     button = gtk_button_new_with_label ("-1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "-1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+10");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "10");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+100");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "100");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("last frame");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "finish");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("stop/plot");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (plotclick), NULL);
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+ 
+     /*********************************************************************/
+     /* stuff in table.  all the plotting windows */
+     /*********************************************************************/
+     pcmbox = gpk_plot_new(graphx,graphy);
+     gtk_table_attach (GTK_TABLE(table),pcmbox,0,2,0,1,tableops,tableops,2,2 );
+     gtk_widget_show (pcmbox);
+ 
+     winbox = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),winbox,0,2,1,2,tableops,tableops,2,2);
+     gtk_widget_show (winbox);
+ 
+ 
+     mdctbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),mdctbox[0],0,1,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[0]);
+ 
+     mdctbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),mdctbox[1],1,2,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[1]);
+ 
+     enerbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),enerbox[0],0,1,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[0]);
+ 
+     enerbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),enerbox[1],1,2,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[1]);
+ 
+     sfbbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),sfbbox[0],0,1,4,5,tableops,tableops,2,2);
+     gtk_widget_show (sfbbox[0]);
+ 
+     sfbbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),sfbbox[1],1,2,4,5,tableops,tableops,2,2);
+     gtk_widget_show (sfbbox[1]);
+ 
+ 
+ 
+ 
+     gtk_idle_add((GtkFunction) frameadv1, NULL);
+     gtk_widget_show(menubar); 
+     gtk_widget_show(box2); 
+     gtk_widget_show(box3); 
+     gtk_widget_show(table);
+     gtk_widget_show(box1);
+     gtk_widget_show (mbox);
+     gtk_widget_show (window);     /* show smallest allowed window */
+ 
+     /* make window bigger.   */ 
+     /* now the user will be able to shrink it, if desired */
+     /* gtk_widget_set_usize(mbox,500,500);  */
+     /* gtk_widget_show (window); */     /* show smallest allowed window */
+ 
+ 
+     
+     idle_keepgoing=1;             /* processing of frames is ON */
+     idle_count_max=READ_AHEAD+1;  /* number of frames to process before plotting */
+     idle_count=0;                 /* pause & plot when idle_count=idle_count_max */
+ 
+ 
+     gtk_main ();
+     if (!mp3done) exit(2);
+     return(0);
+ }
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/gtkanal.h lame3.70/gtkanal.h
*** encoder/gtkanal.h	Wed Dec 31 17:00:00 1969
--- lame3.70/gtkanal.h	Wed Mar 29 22:39:41 2000
***************
*** 0 ****
--- 1,68 ----
+ #ifndef GTKANAL_DOT_H
+ #define GTKANAL_DOT_H
+ #include "lame.h"
+ #include "encoder.h"
+ 
+ #define READ_AHEAD 10             /* number of frames to read ahead */
+ #define MAXMPGLAG READ_AHEAD      /* if the mpg123 lag becomes bigger than this 				     we have to stop */
+ #define NUMBACK 6                 /* number of frames we can back up */
+ #define NUMPINFO (NUMBACK+READ_AHEAD+1)
+ 
+ 
+ 
+ typedef struct {
+   int frameNum;           /* current frame number */
+   int frameNum123;
+   int num_samples;        /* number of pcm samples read for this frame */
+   double frametime;       /* starting time of frame, in seconds */
+   double pcmdata[2][1600];
+   double pcmdata2[2][1152+1152-DECDELAY];
+   double xr[2][2][576];
+   double mpg123xr[2][2][576];
+   double ms_ratio[2];
+   double ms_ener_ratio[2];
+ 
+   /* L,R, M and S values */
+   double energy[2][4][BLKSIZE];
+   double pe[2][4];
+   double thr[2][4][SBMAX_l];
+   double en[2][4][SBMAX_l];
+   double thr_s[2][4][3*SBMAX_s];
+   double en_s[2][4][3*SBMAX_s];
+   double ers[2][4];
+ 
+   double sfb[2][2][SBMAX_l];
+   double sfb_s[2][2][3*SBMAX_s];
+   double LAMEsfb[2][2][SBMAX_l];
+   double LAMEsfb_s[2][2][3*SBMAX_s];
+ 
+   int LAMEqss[2][2];
+   int qss[2][2];
+   int big_values[2][2];
+   int sub_gain[2][2][3];
+ 
+   double xfsf[2][2][SBMAX_l];
+   double xfsf_s[2][2][3*SBMAX_s];
+ 
+   int over[2][2];
+   double tot_noise[2][2];
+   double max_noise[2][2];
+   double over_noise[2][2];
+   int blocktype[2][2];
+   int scalefac_scale[2][2];
+   int mpg123blocktype[2][2];
+   int mixed[2][2];
+   int mainbits[2][2];
+   int LAMEmainbits[2][2];
+   int framesize,stereo,js,ms_stereo,i_stereo,emph,bitrate,sampfreq,maindata;
+   int crc,padding;
+   int scfsi[2],mean_bits,resvsize;
+   int totbits;
+ } plotting_data;
+  
+ 
+ int gtkcontrol(lame_global_flags *gfp);
+ extern plotting_data *pinfo;
+ extern int gtkflag;
+ 
+ #endif
diff -r -c -N encoder/huffman.c lame3.70/huffman.c
*** encoder/huffman.c	Wed Jan 22 02:43:15 1997
--- lame3.70/huffman.c	Wed Dec 31 17:00:00 1969
***************
*** 1,380 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: huffman.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: huffman.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   changes made since last update:                                  *
-  *   date   programmers                comment                        *
-  *27.2.92   F.O.Witte                  (ITT Intermetall)              *
-  *				       email: otto.witte@itt-sc.de    *
-  *				       tel:   ++49 (761)517-125	      *
-  *				       fax:   ++49 (761)517-880	      *
-  *12.6.92   J. Pineda                  Added sign bit to decoder.     *
-  * 08/24/93 M. Iwadare                 Changed for 1 pass decoding.   *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      Bug fixes in Layer III code           *
-  *********************************************************************/	
- #include <stdlib.h>
- #include "common.h"
- #include "huffman.h"
-      
- HUFFBITS dmask = 1 << (sizeof(HUFFBITS)*8-1);
- unsigned int hs = sizeof(HUFFBITS)*8;
- 
- struct huffcodetab ht[HTN];	/* array of all huffcodtable headers	*/
- 				/* 0..31 Huffman code table 0..31	*/
- 				/* 32,33 count1-tables			*/
- 
- /* read the huffman encode table */
- int read_huffcodetab(fi) 
- FILE *fi;
- {
- 
-   char line[100],command[40],huffdata[40];
-   unsigned int t,i,j,k,nn,x,y,n=0;
-   unsigned int xl, yl, len;
-   HUFFBITS h;
-   int	hsize;
-   
-   hsize = sizeof(HUFFBITS)*8; 
-   do {
-       fgets(line,99,fi);
-   } while ((line[0] == '#') || (line[0] < ' ') );
-   
-   do {    
-     while ((line[0]=='#') || (line[0] < ' ')) {
-       fgets(line,99,fi);
-     } 
- 
-     sscanf(line,"%s %s %u %u %u",command,ht[n].tablename,
- 			         &xl,&yl,&ht[n].linbits);
-     if (strcmp(command,".end")==0)
-       return n;
-     else if (strcmp(command,".table")!=0) {
-       fprintf(stderr,"huffman table %u data corrupted\n",n);
-       return -1;
-     }
-     ht[n].linmax = (1<<ht[n].linbits)-1;
-    
-     sscanf(ht[n].tablename,"%u",&nn);
-     if (nn != n) {
-       fprintf(stderr,"wrong table number %u\n",n);
-       return(-2);
-     } 
- 
-     ht[n].xlen = xl;
-     ht[n].ylen = yl;
- 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
- 
-     sscanf(line,"%s %u",command,&t);
-     if (strcmp(command,".reference")==0) {
-       ht[n].ref   = t;
-       ht[n].table = ht[t].table;
-       ht[n].hlen  = ht[t].hlen;
-       if ( (xl != ht[t].xlen) ||
-            (yl != ht[t].ylen)  ) {
-         fprintf(stderr,"wrong table %u reference\n",n);
-         return (-3);
-       };
-       do {
-         fgets(line,99,fi);
-       } while ((line[0] == '#') || (line[0] < ' ') );
-     } 
-     else {
- 	ht[n].ref  = -1;
-       ht[n].table=(HUFFBITS *) calloc(xl*yl,sizeof(HUFFBITS));
-       if (ht[n].table == NULL) {
-          fprintf(stderr,"unsufficient heap error\n");
-          return (-4);
-       }
-       ht[n].hlen=(unsigned char *) calloc(xl*yl,sizeof(unsigned char));
-       if (ht[n].hlen == NULL) {
-          fprintf(stderr,"unsufficient heap error\n");
-          return (-4);
-       }
-       for (i=0; i<xl; i++) {
-         for (j=0;j<yl; j++) {
- 	  if (xl>1) 
-             sscanf(line,"%u %u %u %s",&x, &y, &len,huffdata);
- 	  else 
-             sscanf(line,"%u %u %s",&x,&len,huffdata);
-           h=0;k=0;
- 	  while (huffdata[k]) {
-             h <<= 1;
-             if (huffdata[k] == '1')
-               h++;
-             else if (huffdata[k] != '0'){
-               fprintf(stderr,"huffman-table %u bit error\n",n);
-               return (-5);
-             };
-             k++;
-           };
-           if (k != len) {
-            fprintf(stderr,
-               "warning: wrong codelen in table %u, pos [%2u][%2u]\n",
- 	       n,i,j);
-           };
-           ht[n].table[i*xl+j] = h;
-           ht[n].hlen[i*xl+j] = (unsigned char) len;
- 	  do {
-             fgets(line,99,fi);
-           } while ((line[0] == '#') || (line[0] < ' '));
-         }
-       }
-     }
-     n++;
-   } while (1);
- }
- 
- /* read the huffman decoder table */
- int read_decoder_table(fi) 
- FILE *fi;
- {
-   int n,i,nn,t;
-   unsigned int v0,v1;
-   char command[100],line[100];
-   for (n=0;n<HTN;n++) {
-     /* .table number treelen xlen ylen linbits */ 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
-      
-     sscanf(line,"%s %s %u %u %u %u",command,ht[n].tablename,
-            &ht[n].treelen, &ht[n].xlen, &ht[n].ylen, &ht[n].linbits);
-     if (strcmp(command,".end")==0)
-       return n;
-     else if (strcmp(command,".table")!=0) {
-       fprintf(stderr,"huffman table %u data corrupted\n",n);
-       return -1;
-     }
-     ht[n].linmax = (1<<ht[n].linbits)-1;
-    
-     sscanf(ht[n].tablename,"%u",&nn);
-     if (nn != n) {
-       fprintf(stderr,"wrong table number %u\n",n);
-       return(-2);
-     } 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
- 
-     sscanf(line,"%s %u",command,&t);
-     if (strcmp(command,".reference")==0) {
-       ht[n].ref   = t;
-       ht[n].val   = ht[t].val;
-       ht[n].treelen  = ht[t].treelen;
-       if ( (ht[n].xlen != ht[t].xlen) ||
-            (ht[n].ylen != ht[t].ylen)  ) {
-         fprintf(stderr,"wrong table %u reference\n",n);
-         return (-3);
-       };
-       while ((line[0] == '#') || (line[0] < ' ') ) {
-         fgets(line,99,fi);
-       }
-     }    
-     else if (strcmp(command,".treedata")==0) {
-       ht[n].ref  = -1;
-       if ( ht[n].treelen )
-       {
- 	  ht[n].val = (unsigned char (*)[2]) 
- 	      calloc(2*(ht[n].treelen),sizeof(unsigned char));
- 	  if (ht[n].val == NULL) {
- 	      fprintf(stderr, "heaperror at table %d\n",n);
- 	      exit (-10);
- 	  }
-       }
-       else
- 	  ht[n].val = NULL;
-       for (i=0;i<ht[n].treelen; i++) {
-         fscanf(fi,"%x %x",&v0, &v1);
-         ht[n].val[i][0]=(unsigned char)v0;
-         ht[n].val[i][1]=(unsigned char)v1;
-       }
-       fgets(line,99,fi); /* read the rest of the line */
-     }
-     else {
-       fprintf(stderr,"huffman decodertable error at table %d\n",n);
-     }
-   }
-   return n;
- }
- 
- 
- /* do the huffman coding,  */
- /* note! for counta,countb - the 4 bit value is passed in y, set x to 0 */
- /* return value: 0-no error, 1 decode error				*/
- void huffman_coder( x, y, h, bs)
- unsigned int x; 	/* x-value */
- unsigned int y; 	/* y-value */
- struct huffcodetab *h; 	/* pointer to huffman code record 	*/
- Bit_stream_struc *bs;  	/* pointer to open write bitstream 	*/
- {
-   HUFFBITS huffbits; /* data left aligned */
-   HUFFBITS linbitsX; 
-   HUFFBITS linbitsY;
-   unsigned int len;
-   unsigned int xl1 = h->xlen-1;
-   unsigned int yl1 = h->ylen-1;
-   linbitsX = 0;
-   linbitsY = 0;
-   if (h->table == NULL) return;
-   if (((x < xl1) || (xl1==0)) && (y < yl1)) {
-     huffbits = h->table[x*(h->xlen)+y];
-     len = h->hlen[x*(h->xlen)+y];
-     putbits(bs,huffbits,len);
-     return;
-   }  
-   else if (x >= xl1) {
-     linbitsX = x-xl1;
-     if (linbitsX > h->linmax) {
-       fprintf(stderr,"warning: Huffman X table overflow\n");
-       linbitsX= h->linmax;
-     };
-     if (y >= yl1) {
-       huffbits = h->table[(h->ylen)*(h->xlen)-1];
-       len = h->hlen[(h->ylen)*(h->xlen)-1];
-       putbits(bs,huffbits,len);
-       linbitsY = y-yl1;
-       if (linbitsY > h->linmax) {
-         fprintf(stderr,"warning: Huffman Y table overflow\n");
-         linbitsY = h->linmax;
-       };
-       if (h->linbits) {
-         putbits(bs,linbitsX,h->linbits);
-         putbits(bs,linbitsY,h->linbits);
-       }
-     } 
-     else { /* x>= h->xlen, y<h->ylen */
-       huffbits = h->table[(h->ylen)*xl1+y];
-       len = h->hlen[(h->ylen)*xl1+y];
-       putbits(bs,huffbits,len);
-       if (h->linbits) {
-         putbits(bs,linbitsX,h->linbits);
-       }
-     }
-   }
-   else  { /* ((x < h->xlen) && (y>=h->ylen)) */
-     huffbits = h->table[(h->ylen)*x+yl1];
-     len = h->hlen[(h->ylen)*x+yl1];
-     putbits(bs,huffbits,len);
-     linbitsY = y-yl1;
-     if (linbitsY > h->linmax) {
-       fprintf(stderr,"warning: Huffman Y table overflow\n");
-       linbitsY = h->linmax;
-     };
-     if (h->linbits) {
-        putbits(bs,linbitsY,h->linbits);
-     }
-   }
- }
- 
- /* do the huffman-decoding 						*/
- /* note! for counta,countb -the 4 bit value is returned in y, discard x */
- int huffman_decoder(h, x, y, v, w)
- struct huffcodetab *h;	/* pointer to huffman code record	*/
- /* unsigned */ int *x; 	/* returns decoded x value 		*/
- /* unsigned */ int *y;	/* returns decoded y value		*/
- int *v;
- int *w;
- {  
-   HUFFBITS level;
-   int point = 0;
-   int error = 1;
-   level     = dmask;
-   if (h->val == NULL) return 2;
- 
-   /* table 0 needs no bits */
-   if ( h->treelen == 0)
-   {  *x = *y = 0;
-      return 0;
-   }
- 
- 
-   /* Lookup in Huffman table. */
- 
-   do {
-     if (h->val[point][0]==0) {   /*end of tree*/
-       *x = h->val[point][1] >> 4;
-       *y = h->val[point][1] & 0xf;
- 
-       error = 0;
-       break;
-     } 
-     if (hget1bit()) {
-       while (h->val[point][1] >= MXOFF) point += h->val[point][1]; 
-       point += h->val[point][1];
-     }
-     else {
-       while (h->val[point][0] >= MXOFF) point += h->val[point][0]; 
-       point += h->val[point][0];
-     }
-     level >>= 1;
-   } while (level  || (point < ht->treelen) );
-   
-   /* Check for error. */
-   
-   if (error) { /* set x and y to a medium value as a simple concealment */
-     printf("Illegal Huffman code in data.\n");
-     *x = (h->xlen-1 << 1);
-     *y = (h->ylen-1 << 1);
-   }
- 
-   /* Process sign encodings for quadruples tables. */
- 
-   if (h->tablename[0] == '3'
-       && (h->tablename[1] == '2' || h->tablename[1] == '3')) {
-      *v = (*y>>3) & 1;
-      *w = (*y>>2) & 1;
-      *x = (*y>>1) & 1;
-      *y = *y & 1;
- 
-      /* v, w, x and y are reversed in the bitstream. 
-         switch them around to make test bistream work. */
-      
- /*   {int i=*v; *v=*y; *y=i; i=*w; *w=*x; *x=i;}  MI */
- 
-      if (*v)
-         if (hget1bit() == 1) *v = -*v;
-      if (*w)
-         if (hget1bit() == 1) *w = -*w;
-      if (*x)
-         if (hget1bit() == 1) *x = -*x;
-      if (*y)
-         if (hget1bit() == 1) *y = -*y;
-      }
-      
-   /* Process sign and escape encodings for dual tables. */
-   
-   else {
-   
-       /* x and y are reversed in the test bitstream.
-          Reverse x and y here to make test bitstream work. */
- 	 
- /*    removed 11/11/92 -ag  
- 		{int i=*x; *x=*y; *y=i;} 
- */      
-      if (h->linbits)
-        if ((h->xlen-1) == *x) 
-          *x += hgetbits(h->linbits);
-      if (*x)
-         if (hget1bit() == 1) *x = -*x;
-      if (h->linbits)	  
-        if ((h->ylen-1) == *y)
-          *y += hgetbits(h->linbits);
-      if (*y)
-         if (hget1bit() == 1) *y = -*y;
-      }
- 	  
-   return error;  
- }
--- 0 ----
diff -r -c -N encoder/huffman.h lame3.70/huffman.h
*** encoder/huffman.h	Wed Jan 22 02:43:15 1997
--- lame3.70/huffman.h	Wed Dec 31 17:00:00 1969
***************
*** 1,60 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: huffman.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: huffman.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *  27.2.92 F.O.Witte (ITT Intermetall)				      *
-  *  8/24/93 M. Iwadare          Changed for 1 pass decoding.          *
-  *  7/14/94 J. Koller		useless 'typedef' before huffcodetab  *
-  *				removed				      *
-  *********************************************************************/	
-  
- #define HUFFBITS unsigned long int
- #define HTN	34
- #define MXOFF	250
-  
- struct huffcodetab {
-   char tablename[3];	/*string, containing table_description	*/
-   unsigned int xlen; 	/*max. x-index+			      	*/ 
-   unsigned int ylen;	/*max. y-index+				*/
-   unsigned int linbits; /*number of linbits			*/
-   unsigned int linmax;	/*max number to be stored in linbits	*/
-   int ref;		/*a positive value indicates a reference*/
-   HUFFBITS *table;	/*pointer to array[xlen][ylen]		*/
-   unsigned char *hlen;	/*pointer to array[xlen][ylen]		*/
-   unsigned char(*val)[2];/*decoder tree				*/ 
-   unsigned int treelen;	/*length of decoder tree		*/
- };
- 
- extern struct huffcodetab ht[HTN];/* global memory block		*/
- 				/* array of all huffcodtable headers	*/
- 				/* 0..31 Huffman code table 0..31	*/
- 				/* 32,33 count1-tables			*/
- #ifdef PROTO_ARGS
- 
- extern int read_huffcodetab(FILE *); 
- extern int read_decoder_table(FILE *);
-  
- extern void huffman_coder(unsigned int, unsigned int,
- 			  struct huffcodetab *, Bit_stream_struc *);
- 			  
- extern int huffman_decoder(struct huffcodetab *,
- 			   /* unsigned */ int *, /* unsigned */ int*, int*, int*);
- 
- #else
- 
- extern int read_huffcodetab(); 
- extern int read_decoder_table(); 
- extern void huffman_coder();
- extern int huffman_decoder();
- 
- #endif
--- 0 ----
diff -r -c -N encoder/i386/CVS/Entries lame3.70/i386/CVS/Entries
*** encoder/i386/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/CVS/Entries	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,6 ----
+ /fft.nas/1.2/Wed Feb  2 14:58:41 2000//Tlame3_70
+ /fft3dn.nas/1.1/Sun Jan 30 22:53:49 2000//Tlame3_70
+ /fftfpu.nas/1.1/Sun Jan 30 22:53:49 2000//Tlame3_70
+ /fftsse.nas/1.1/Sun Jan 30 22:53:49 2000//Tlame3_70
+ /ffttbl.nas/1.1/Sun Jan 30 22:53:49 2000//Tlame3_70
+ D
diff -r -c -N encoder/i386/CVS/Repository lame3.70/i386/CVS/Repository
*** encoder/i386/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/CVS/Repository	Thu Apr  6 12:50:36 2000
***************
*** 0 ****
--- 1 ----
+ lame/i386
diff -r -c -N encoder/i386/CVS/Root lame3.70/i386/CVS/Root
*** encoder/i386/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/CVS/Root	Thu Apr  6 12:50:36 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/i386/CVS/Tag lame3.70/i386/CVS/Tag
*** encoder/i386/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/CVS/Tag	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/i386/fft.nas lame3.70/i386/fft.nas
*** encoder/i386/fft.nas	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/fft.nas	Wed Feb  2 07:58:41 2000
***************
*** 0 ****
--- 1,267 ----
+ 
+ ;	for new GOGO-no-coda (1999/09)
+ ;	Copyright (C) 1999 shigeo
+ ;	special thanks to Keiichi SAKAI, URURI
+ %include "nasm.h"
+ 
+ 	globaldef fht_3DN
+ 	globaldef fht
+ 	externdef costab_fft
+ 	externdef sintab_fft
+ 	externdef gray_index
+ 
+ 	segment_data
+ 	align 16
+ D_MSB1_0	dd	0         ,0x80000000
+ D_SQRT2	dd	1.414213562,1.414213562
+ t_s0	dd	0	;[ t_c:t_s]
+ t_c0	dd	0
+ t_c1	dd	0	;[-t_s:t_c]
+ t_s1	dd	0
+ D_s1c1	dd	0, 0
+ D_Mc1s1	dd	0, 0
+ D_s2c2	dd	0, 0
+ D_Mc2s2	dd	0, 0
+ D_0_1	dd	1.0, 0.0
+ S_05	DD	0.5
+ S_00005	DD	0.0005
+ fht		dd	0	;
+ 
+ 	segment_code
+ 
+ ;************************************************************************
+ 
+ ;	by shigeo
+ ;	99/08/16
+ ;	23000clk 
+ ;	18500clk bit reversal from gogo1 by URURI
+ 
+ ;void fht(float *fz, int n);
+ 	align 16
+ fht_3DN:
+ 	push	ebx
+ 	push	esi
+ 	push	edi
+ 	push	ebp
+ %assign _P 4*4
+ 	;... fht()
+ 
+ 	mov	esi,[esp+_P+4]	;esi=fz
+ 	mov	ecx,[esp+_P+8]	;ecx=n
+ 
+ 	;
+ 	movq	mm7,[D_MSB1_0]	;mm7=[1<<31:0]
+ 
+ %assign LOCAL_STACK	16
+ 	sub	esp,LOCAL_STACK
+ %assign _P (_P+LOCAL_STACK)
+ 	xor	eax,eax
+ 	mov	[esp],eax	;k=0
+ %define k dword [esp]
+ %define kx	dword [esp+4]
+ %define fn dword [esp+8]
+ 
+ .lp30:	;k=0; do{
+ 	mov	ecx,k
+ 	add	ecx,2
+ 	mov	k,ecx
+ 	mov	eax,1
+ 	shl	eax,cl		;eax=k1 = 1<<k
+ 	lea	ebx,[eax+eax]	;ebx=k2 = k1*2
+ 	lea	ecx,[eax+eax*2]	;ecx=k3 = k2 + k1 = k1*3
+ 	lea	edx,[ebx+ebx]	;edx=k4 = k1*4
+ 	mov	esi,eax
+ 	shr	esi,1		;esi=kx=k1>>1
+ 	mov	kx,esi		;()
+ 	mov	edi,[esp+_P+4]	;edi=fi=fz
+ 	lea	ebp,[edi+esi*4]	;ebp=gi=fz+kx
+ 	mov	esi,[esp+_P+8]	;esi=n
+ 	lea	esi,[edi+esi*4]	;esi=fn=fz+n
+ 	movq	mm6,[D_SQRT2]	;mm6=[2:2]
+ 
+ .lp31:	;fn=fz+n; do{ FLOAT g0,f0,f1,...
+ 	movd	mm0,[edi]	;mm0=[0:fi[ 0]]
+ 	movd	mm1,[edi+eax*4]	;mm1=[0:fi[k1]]
+ 	punpckldq	mm0,mm0	;mm0=[fi_0 :fi_0 ]
+ 	punpckldq	mm1,mm1	;mm1=[fi_k1:fi_k1]
+ 	movd	mm2,[edi+ebx*4]
+ 	movd	mm3,[edi+ecx*4]
+ 	punpckldq	mm2,mm2	;mm2=[fi_k2:fi_k2]
+ 	punpckldq	mm3,mm3	;mm3=[fi_k3:fi_k3]
+ 	pxor	mm1,mm7		;mm1=[-fi_k1:fi_k1]
+ 	pxor	mm3,mm7		;mm3=[-fi_k3:fi_k3]
+ 	pfadd	mm0,mm1		;mm0=[f1:f0]=[fi_0 -fi_k1 : fi_0 +fi_k1]
+ 	pfadd	mm2,mm3		;mm2=[f3:f2]=[fi_k2-fi_k3 : fi_k2+fi_k3]
+ 	movq	mm3,mm0		;mm3=[f1:f0]
+ 	pfadd	mm0,mm2		;mm0=[f1+f3:f0+f2]
+ 	movd	[edi],mm0	;fi[0]=f0+f2
+ 	psrlq	mm0,32		;mm0=[0:f1+f3]
+ 	pfsub	mm3,mm2		;mm3=[f1-f3:f0-f2]
+ 	movd	[edi+eax*4],mm0	;fi[k1]=f1+f3
+ 	movd	[edi+ebx*4],mm3	;fi[k2]=f0-f2
+ 	psrlq	mm3,32		;mm3=[0:f1-f3]
+ 	movd	[edi+ecx*4],mm3	;fi[k3]=f1-f3
+ 
+ 	movd	mm0,[ebp]	;mm0=[0:gi_0]
+ 	movd	mm1,[ebp+eax*4]	;mm1=[0:gi_k1]
+ 	punpckldq	mm0,mm0	;mm0=[gi_0 :gi_0 ]
+ 	punpckldq	mm1,mm1	;mm1=[gi_k1:gi_k1]
+ 	movd	mm2,[ebp+ebx*4]	;mm2=[0:gi_k2]
+ 	pxor	mm1,mm7		;mm1=[-gi_k1:gi_k1]
+ 	punpckldq	mm2,[ebp+ecx*4]	;mm2=[gi_k3:gi_k2]
+ 	pfadd	mm0,mm1		;mm0=[g1:g0]=[gi_0 -gi_k1:gi_0 +gi_k1]
+ 	pfmul	mm2,mm6		;mm2=[g3:g2]=sqrt2 * [gi_k3:gi_k2]
+ 	movq	mm1,mm0		;mm1=[g1:g0]
+ 	pfadd	mm0,mm2		;mm0=[g1+g3:g0+g2]
+ 	movd	[ebp],mm0	;gi[0]=g0+g2
+ 	psrlq	mm0,32		;mm0=[0:g1+g3]
+ 	pfsub	mm1,mm2		;mm1=[g1-g3:g0-g2]
+ 	movd	[ebp+eax*4],mm0	;gi[k1]=g1+g3
+ 	movd	[ebp+ebx*4],mm1	;gi[k2]=g0-g2
+ 	psrlq	mm1,32		;mm1=[0:g1-g3]
+ 	movd	[ebp+ecx*4],mm1	;gi[k3]=g1-g3
+ 	lea	edi,[edi+edx*4]	;fi += k4
+ 	lea	ebp,[ebp+edx*4]	;gi += k4
+ 	cmp	edi,esi
+ 	jc	near .lp31	;}while(fi<fn);
+ 
+ ;	O.K.
+ 
+ 	mov	fn,esi		;fn=fz+n
+ 	;
+ 	;eax=k1,ebx=k2,ecx=k3,edx=k4
+ 
+ 	mov	edi,k
+ 	lea	ebp,[costab_fft+edi*4]
+ 	mov	ebp,[ebp]	;ebp=t_c
+ 	mov	[t_c0],ebp
+ 	mov	[t_c1],ebp	;t_c
+ 	lea	ebp,[sintab_fft+edi*4]
+ 	mov	ebp,[ebp]	;ebx=t_s
+ 	mov	[t_s0],ebp
+ 	xor	ebp,0x80000000
+ 	mov	[t_s1],ebp	;-t_s
+ 
+ 	movq	mm1,[D_0_1]	;mm1=[0:1]
+ 	movq	[D_s1c1],mm1	;mm1=[s1:c1]
+ 	mov	esi,1		;esi=i=1
+ 
+ .lp32:	;	for(i=1;i<kx;i++){
+ 	movq	mm0,[D_s1c1]	;mm1=[s1:t]=[s1:c1]
+ 	movq	mm2,mm0
+ 	pfmul	mm0,[t_c1]	;mm0=[-s1*t_s: t*t_c]
+ 	pfmul	mm2,[t_s0]	;mm2=[ s1*t_c: t*t_s]
+ 	pfacc	mm0,mm2		;mm0=[s1:c1]=[ s1*t_c+t*t_s:-s1*t_s+t*t_c]
+ 	movq	mm2,mm0		;mm2=[s1:c1]
+ 	movq	[D_s1c1],mm0	;
+ 	movq	mm6,mm2
+ 	punpckldq	mm5,mm6
+ 	punpckhdq	mm6,mm5	;mm6=[ c1:s1]
+ 	pxor	mm6,mm7		;mm6=[-c1:s1]
+ 	movq	[D_Mc1s1],mm6	;
+ 	pfmul	mm2,mm2		;mm2=[s1*s1:c1*c1]
+ 	movq	mm3,mm0		;mm3=[s1:c1]
+ 	pxor	mm2,mm7		;mm2=[-s1*s1:c1*c1]
+ 	psrlq	mm3,32		;mm3=[ 0:s1]
+ 	pfacc	mm2,mm2		;mm2=[c2:c2]=[c1*c1-s1*s1:<]
+ 	pfmul	mm0,mm3		;mm0=[ 0:c1*s1]
+ 	pfadd	mm0,mm0		;mm0=[0:s2]=[ 0:2*c1*s1]
+ 	punpckldq	mm2,mm0	;mm2=[s2:c2]
+ 	movq	[D_s2c2],mm2	;
+ 
+ 	punpckldq	mm0,mm2
+ 	punpckhdq	mm2,mm0	;mm2=[c2:s2]
+ 	pxor	mm2,mm7		;mm2=[-c2:s2]
+ 	movq	[D_Mc2s2],mm2	;
+ 
+ 	mov	edi,[esp+_P+4]	;edi=fz
+ 	lea	edi,[edi+esi*4]	;edi=fz+i
+ 
+ 	mov	ebp,[esp+_P+4]	;ebp=fz
+ 	neg	esi		;esi=-i
+ 	lea	ebp,[ebp+eax*4]	;ebp=fz+k1
+ 	lea	ebp,[ebp+esi*4]	;ebp=gi=fz+k1-i
+ 	neg	esi		;esi=i
+ 
+ .lp33:	;	do{ FLOAT a,b,g0,f0,f1,g1,f2,g2,f3,g3;
+ 
+ 	movd	mm0,[edi+eax*4]	;mm0=[0:fi_k1]
+ 	punpckldq	mm0,[ebp+eax*4]	;mm0=[gi_k1:fi_k1]
+ 	movq	mm1,mm0
+ 	pfmul	mm0,[D_s2c2]	;mm0=[ s2*gi_k1:c2*fi_k1]
+ 	pfmul	mm1,[D_Mc2s2]	;mm1=[-c2*gi_k1:s2*fi_k1]
+ 	pfacc	mm0,mm1		;mm0=[b:a]
+ 	movd	mm4,[edi]	;mm4=[0:fi_0]
+ 	movq	mm3,mm0		;mm3=[b:a]
+ 	punpckldq	mm4,[ebp]	;mm4=[gi_0:fi_0]
+ 	pfadd	mm3,mm4		;mm3=[g0:f0]=[gi_0+b:fi_0+a]
+ 	pfsub	mm4,mm0		;mm4=[g1:f1]=[gi_0-b:fi_0-a]
+ 
+ 	movd	mm0,[edi+ecx*4]	;mm0=[0:fi_k3]
+ 	punpckldq	mm0,[ebp+ecx*4]	;mm0=[gi_k3:fi_k3]
+ 	movq	mm1,mm0
+ 	pfmul	mm0,[D_s2c2]	;mm0=[ s2*gi_k3:c2*fi_k3]
+ 	pfmul	mm1,[D_Mc2s2]	;mm1=[-c2*gi_k3:s2*fi_k3]
+ 	pfacc	mm0,mm1		;mm0=[b:a]
+ 	movd	mm5,[edi+ebx*4]	;mm5=[0:fi_k2]
+ 	movq	mm6,mm0		;mm6=[b:a]
+ 	punpckldq	mm5,[ebp+ebx*4]	;mm5=[gi_k2:fi_k2]
+ 	pfadd	mm6,mm5		;mm6=[g2:f2]=[gi_k2+b:fi_k2+a]
+ 	pfsub	mm5,mm0		;mm5=[g3:f3]=[gi_k2-b:fi_k2-a]
+ 
+ 	punpckldq	mm1,mm6	;mm1=[f2:*]
+ 	movq	mm0,[D_s1c1]	;mm0=[s1:c1]
+ 	punpckhdq	mm1,mm5	;mm1=[g3:f2]
+ 	pfmul	mm0,mm1		;mm0=[ s1*g3:c1*f2]
+ 	movq	mm2,[D_Mc1s1]	;mm2=[-c1:s1]
+ 	pfmul	mm2,mm1		;mm2=[-c1*g3:s1*f2]
+ 	pfacc	mm0,mm2		;mm0=[b:a]
+ 
+ 	punpckldq	mm1,mm3	;mm1=[f0:*]
+ 	punpckhdq	mm1,mm4	;mm1=[g1:f0]
+ 	movq	mm2,mm0		;mm2=[b:a]
+ 	pfadd	mm0,mm1		;mm0=[g1+b:f0+a]
+ 	pfsubr	mm2,mm1		;mm2=[g1-b:f0-a]
+ 	movd	[edi],mm0	;fi[0]=f0+a
+ 	psrlq	mm0,32		;mm0=[0:g1+b]
+ 	movd	[edi+ebx*4],mm2	;fi[k2]=f0-a
+ 	psrlq	mm2,32		;mm2=[0:g1-b]
+ 	movd	[ebp+eax*4],mm0	;gi[k1]=g1+b
+ 	movd	[ebp+ecx*4],mm2	;gi[k3]=g1-b
+ 	psrlq	mm6,32		;mm6=[0:g2]
+ 	movq	mm0,[D_s1c1]	;mm0=[s1:c1]
+ 	punpckldq	mm5,mm6	;mm5=[g2:f3]
+ 	pfmul	mm0,mm5		;mm0=[g2* s1:f3*c1]
+ 	pfmul	mm5,[D_Mc1s1]	;mm5=[g2*-c1:f3*s1]
+ 	pfacc	mm0,mm5		;mm0=[-b:a]
+ 	psrlq	mm3,32		;mm3=[0:g0]
+ 	movq	mm1,mm0		;mm1=[-b:a]
+ 	punpckldq	mm3,mm4	;mm3=[f1:g0]
+ 	pfadd	mm0,mm3		;mm0=[f1-b:g0+a]
+ 	pfsubr	mm1,mm3		;mm1=[f1+b:g0-a]
+ 	movd	[ebp],mm0	;gi[0]=g0+a
+ 	psrlq	mm0,32		;mm0=[0:f1-b]
+ 	movd	[ebp+ebx*4],mm1	;gi[k2]=g0-a
+ 	psrlq	mm1,32		;mm1=[0:f1+b]
+ 	movd	[edi+ecx*4],mm0	;fi[k3]=f1-b
+ 	movd	[edi+eax*4],mm1	;fi[k1]=f1+b
+ 
+ 	lea	edi,[edi+edx*4]	;fi += k4
+ 	lea	ebp,[ebp+edx*4]	;gi += k4
+ 	cmp	edi,fn
+ 	jc	near .lp33	;}while(fi<fn)
+ 	inc	esi
+ 	cmp	esi,kx
+ 	jnz	near .lp32	;}
+ 	cmp	edx,[esp+_P+8]
+ 	jnz	near .lp30	;}while(k4<n)
+ 
+ 
+ .exit:
+ 	add	esp,LOCAL_STACK
+ 	femms
+ 	pop	ebp
+ 	pop	edi
+ 	pop	esi
+ 	pop	ebx
+ 	ret
diff -r -c -N encoder/i386/fft3dn.nas lame3.70/i386/fft3dn.nas
*** encoder/i386/fft3dn.nas	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/fft3dn.nas	Sun Jan 30 15:53:49 2000
***************
*** 0 ****
--- 1,672 ----
+ ; back port from GOGO-no coda 2.24b by Takehiro TOMINAGA
+ 
+ ; GOGO-no-coda
+ ;	Copyright (C) 1999 shigeo
+ ;	special thanks to URURI
+ 
+ %include "nasm.h"
+ 
+ 	externdef costab_fft
+ 	externdef sintab_fft
+ 
+ 	segment_data
+ 	align 32
+ D_1_41421	dd	1.41421356	, 1.41421356
+ D_1_0	dd	1.0		, 1.0
+ D_0_5	dd	0.5		, 0.5
+ D_0_25	dd	0.25	, 0.25
+ D_0_02236	dd	0.02236067	, 0.02236067
+ D_0_0005	dd	0.0005	, 0.0005
+ D_0_0	dd	0.0		, 0.0
+ 
+ D_1_0_D_0_0	dd	0.0		, 1.0
+ D_0_0_D_1_0	dd	1.0		, 0.0
+ 
+ D_MSB1_0	dd	0x00000000	, 0x80000000
+ D_MSB1_1	dd	0x80000000	, 0x80000000
+ D_MSB0_1	dd	0x80000000	, 0x00000000
+ 
+ 	segment_code
+ 
+ ;void fht_3DN2(float *fz, int n);
+ proc	fht_3DN2
+ 
+ %$fz	arg	4
+ %$n	arg	4
+ 
+ %$k	local	4
+ 
+ %$Ps2_Pc2	local	8
+ %$Mc2_Ps2	local	8
+ 
+ %$t_s	local	8
+ %$t_c	local	8
+ 	alloc
+ 
+ 	femms
+ 	pushd	ebp, ebx, esi, edi
+ 
+ fht_3DN_1st_part:
+ 
+ fht_3DN_2nd_part:
+ 
+ fht_3DN_3rd_part:
+ 
+ .do_init:
+ 	mov	r3, 16			;k1*fsize = 4*fsize = k4
+ 	mov	r4, 8			;kx = k1/2
+ 	mov	r2, 48			;k3*fsize
+ 	mov	dword [sp(%$k)], 2	;k = 2
+ 	mov	r0, [sp(%$fz)]		;fi
+ 	lea	r1, [r0+8]		;gi = fi + kx
+ 	jmp	.do
+ 
+ 	align 16
+ .do:
+ 	pmov	mm6, [D_MSB1_0]		;MSB1_0
+ 	pmov	mm7, [D_1_41421]
+ 
+ .do2:
+ 	;f
+ 	pmov	mm1, [r0+r3]	;fi1
+ 	pmov	mm4, [r0+r2]	;fi3
+ 	pmov	mm0, [r0]		;fi0
+ 	pmov	mm3, [r0+r3*2]	;fi2
+ 
+ 	pupldq	mm1, mm1
+ 	pupldq	mm4, mm4
+ 	pupldq	mm0, mm0		;fi0 | fi0
+ 	pupldq	mm3, mm3		;fi2 | fi2
+ 
+ 	pxor	mm1, mm6		;-fi1 | fi1
+ 	pxor	mm4, mm6		;-fi3 | fi3
+ 
+ 	pfadd	mm0, mm1		;f1 | f0
+ 	pfadd	mm3, mm4		;f3 | f2
+ 
+ 	pmov	mm4, mm0
+ 	pfadd	mm0, mm3		;fi1 | fi0
+ 	pfsub	mm4, mm3		;fi3 | fi2
+ 
+ 	pmovd	[r0], mm0		;fi[0]
+ 	puphdq	mm0, mm0
+ 	pmovd	[r0+r3*2], mm4	;fi[k2]
+ 	puphdq	mm4, mm4
+ 
+ 	pmovd	[r0+r3], mm0	;fi[k1]
+ 	pmovd	[r0+r2], mm4	;fi[k3]
+ 
+ 	;g
+ 	pmov	mm1, [r1+r3]	;gi1
+ 	pmov	mm0, [r1]		;gi0
+ 	pmov	mm3, [r1+r3*2]	;gi2
+ 	pmov	mm5, [r1+r2]	;gi3
+ 
+ 	pupldq	mm1, mm1
+ 	pupldq	mm0, mm0		;gi0 | gi0
+ 	pupldq	mm3, mm5		;gi3 | gi2
+ 
+ 	pxor	mm1, mm6		;-gi1 | gi1
+ 
+ 	pfadd	mm0, mm1		;g1 | g0
+ 	pfmul	mm3, mm7		;g3 | g2
+ 
+ 	pmov	mm4, mm0
+ 	pfadd	mm0, mm3		;gi1 | gi0
+ 	pfsub	mm4, mm3		;gi3 | gi2
+ 
+ 	pmovd	[r1], mm0		;gi[0]
+ 	puphdq	mm0, mm0
+ 	pmovd	[r1+r3*2], mm4	;gi[k2]
+ 	puphdq	mm4, mm4
+ 
+ 	pmovd	[r1+r3], mm0	;gi[k1]
+ 	pmovd	[r1+r2], mm4	;gi[k3]
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near .do2
+ 
+ 	
+ 	mov	r0, [sp(%$k)]
+ 	pmov	mm0, [costab_fft +r0*4]
+ 	pmov	mm1, [sintab_fft +r0*4]
+ 	pupldq	mm0, mm0
+ 	pupldq	mm1, mm1
+ 	pmov	mm6, [D_1_0_D_0_0]		;c1 | s1
+ 	pmov	mm7, [D_0_0_D_1_0]		;-s1 | c1
+ 	pmov	[sp(%$t_c)], mm0
+ 	pmov	[sp(%$t_s)], mm1
+ 
+ .for_init:
+ 	mov	r5, 4		;i = 1*fsize
+ 	jmp	.for
+ 
+ 	align 16
+ .for:
+ 	pfmul	mm6, [sp(%$t_c)]	;c1*t_c | s1*t_c
+ 	pfmul	mm7, [sp(%$t_s)]	;-s1*t_s | c1*t_s
+ 
+ 	pfadd	mm6, mm7		;c1 | s1
+ 	pmov	mm7, [D_MSB0_1]
+ 
+ 	pmov	mm1, mm6
+ 	pxor	mm7, mm6		;c1 | -s1
+ 
+ 	puphdq	mm1, mm1		;c1
+ 	pmov	mm0, mm7
+ 
+ 	pupldq	mm2, mm7
+ 	pfmul	mm0, mm6		;c1*c1 | -s1*s1
+ 	pfmul	mm1, mm6		;c1*s1
+ 
+ 	puphdq	mm7, mm2		;-s1 | c1
+ 	pfacc	mm0, mm0		;c2
+ 	pfadd	mm1, mm1		;s2 = 2*c1*s1
+ 
+ 	pupldq	mm1, mm0		;c2 | s2
+ 	pupldq	mm0, mm1		;s2 | c2
+ 
+ 	pxor	mm1, [D_MSB1_0]	;-c2 | s2
+ 
+ 	pmov	[sp(%$Ps2_Pc2)], mm0
+ 	pmov	[sp(%$Mc2_Ps2)], mm1
+ 
+ 	mov	r0, [sp(%$fz)]
+ 	mov	r1, [sp(%$fz)]
+ 	add	r0, r5		;r0 = fi
+ 	add	r1, r3
+ 	sub	r1, r5		;r1 = gi
+ 	jmp	.do3
+ 
+ 	align 16
+ .do3:
+ 	pmov	mm2, [r0+r3]
+ 	pmov	mm4, [r1+r3]
+ 	pmov	mm3, [r0+r2]
+ 	pmov	mm5, [r1+r2]
+ 
+ 	pupldq	mm2, mm2
+ 	pupldq	mm4, mm4
+ 	pupldq	mm3, mm3
+ 	pupldq	mm5, mm5
+ 
+ 	pmov	mm0, [sp(%$Ps2_Pc2)]
+ 	pmov	mm1, [sp(%$Mc2_Ps2)]
+ 
+ 	pfmul	mm2, mm0		;s2 * fi1 | c2 * fi1
+ 	pfmul	mm4, mm1		;-c2 * gi1 | s2 * gi1
+ 	pfmul	mm3, mm0		;s2 * fi3 | c2 * fi3
+ 	pfmul	mm5, mm1		;-c2 * gi3 | s2 * gi3
+ 
+ 	pfadd	mm2, mm4		;b | a
+ 	pfadd	mm3, mm5		;d | c
+ 
+ 	pmov	mm0, [r0]
+ 	pmov	mm4, [r1]
+ 	pmov	mm1, [r0+r3*2]
+ 	pmov	mm5, [r1+r3*2]
+ 
+ 	pupldq	mm0, mm4		;gi0 | fi0
+ 	pupldq	mm1, mm5		;gi2 | fi2
+ 
+ 	pmov	mm4, mm2
+ 	pmov	mm5, mm3
+ 
+ 	pfadd	mm2, mm0		;g0 | f0
+ 	pfadd	mm3, mm1		;g2 | f2
+ 
+ 	pfsub	mm0, mm4		;g1 | f1
+ 	pfsub	mm1, mm5		;g3 | f3
+ 
+ 
+ 	pmov	mm4, mm3
+ 	pmov	mm5, mm1
+ 
+ 	pupldq	mm4, mm4		;f2 | f2
+ 	puphdq	mm5, mm5		;g3 | g3
+ 	puphdq	mm3, mm3		;g2 | g2
+ 	pupldq	mm1, mm1		;f3 | f3
+ 
+ 	pfmul	mm4, mm6		;f2 * c1 | f2 * s1
+ 	pfmul	mm5, mm7		;g3 * -s1 | g3 * c1
+ 	pfmul	mm3, mm6		;g2 * c1 | g2 * s1
+ 	pfmul	mm1, mm7		;f3 * -s1 | f3 * c1
+ 
+ 	pfsub	mm4, mm5		;a | b
+ 	pfadd	mm3, mm1		;d | c
+ 
+ 	pmov	mm5, mm2
+ 	pmov	mm1, mm0
+ 
+ 	pupldq	mm2, mm2		;f0 | f0
+ 	pupldq	mm0, mm0		;f1 | f1
+ 
+ 	puphdq	mm1, mm2		;f0 | g1
+ 	puphdq	mm5, mm0		;f1 | g0
+ 
+ 	pmov	mm2, mm4
+ 	pmov	mm0, mm3
+ 
+ 	pfadd	mm4, mm1		;fi0 | gi1
+ 	pfadd	mm3, mm5		;fi1 | gi0
+ 	pfsub	mm1, mm2		;fi2 | gi3
+ 	pfsub	mm5, mm0		;fi3 | gi2
+ 
+ 	pmovd	[r1+r3], mm4	;gi[k1]
+ 	puphdq	mm4, mm4
+ 	pmovd	[r1], mm3		;gi[0]
+ 	puphdq	mm3, mm3
+ 	pmovd	[r1+r2], mm1	;gi[k3]
+ 	puphdq	mm1, mm1
+ 	pmovd	[r1+r3*2], mm5	;gi[k2]
+ 	puphdq	mm5, mm5
+ 
+ 	pmovd	[r0], mm4		;fi[0]
+ 	pmovd	[r0+r3], mm3	;fi[k1]
+ 	pmovd	[r0+r3*2], mm1	;fi[k2]
+ 	pmovd	[r0+r2], mm5	;fi[k3]
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near	.do3
+ 
+ 	add	r5, 4
+ 	cmp	r5, r4
+ 	jb near	.for
+ 
+ 	cmp	r3, [sp(%$n)]
+ 	jae	.exit
+ 
+ 	add	dword [sp(%$k)], 2	;k  += 2;
+ 	lea	r3, [r3*4]		;k1 *= 4
+ 	lea	r2, [r2*4]		;k3 *= 4
+ 	lea	r4, [r4*4]		;kx *= 4
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+r4]		;gi = fi + kx
+ 	jmp	.do
+ 
+ .exit:
+ 	femms
+ 	popd	ebp, ebx, esi, edi
+ endproc
+ 
+ ;***********************************************************************
+ %ifdef USE_E3DN
+ 
+ ;void fht_E3DN(float *fz, int n);
+ proc	fht_E3DN
+ 
+ %$fz	arg	4
+ %$n	arg	4
+ 
+ %$k	local	4
+ 
+ %$Ps2_Pc2	local	8
+ %$Mc2_Ps2	local	8
+ 
+ %$t_s	local	8
+ %$t_c	local	8
+ 	alloc
+ 
+ 	femms
+ 	pushd	ebp, ebx, esi, edi
+ 
+ fht_E3DN_1st_part:
+ 
+ fht_E3DN_2nd_part:
+ 
+ fht_E3DN_3rd_part:
+ 
+ .do_init:
+ 	mov	r3, 16			;k1*fsize = 4*fsize = k4
+ 	mov	r4, 8			;kx = k1/2
+ 	mov	r2, 48			;k3*fsize
+ 	mov	dword [sp(%$k)], 2	;k = 2
+ 	mov	r0, [sp(%$fz)]		;fi
+ 	lea	r1, [r0+8]		;gi = fi + kx
+ 	jmp	.do
+ 
+ 	align 16
+ .do:
+ 	pmov	mm7, [D_1_41421]
+ 
+ .do2:
+ 	pmov	mm0, [r0]		;fi0
+ 	pupldq	mm0, [r0+r3]	;fi1 | fi0
+ 	pmov	mm1, [r0+r3*2]	;fi2
+ 	pupldq	mm1, [r0+r2]	;fi3 | fi2
+ 	pmov	mm3, [r1]		;gi0
+ 	pupldq	mm3, [r1+r3]	;gi1 | gi0
+ 	pmov	mm4, [r1+r2]	;gi3
+ 	pupldq	mm4, [r1+r3*2]	;gi2 | gi3
+ 
+ 	pfpnacc	mm0, mm0		;f0 | f1
+ 	pfpnacc	mm1, mm1		;f2 | f3
+ 	pfpnacc	mm3, mm3		;g0 | g1
+ 	pfmul	mm4, mm7		;g2 | g3
+ 
+ 	pmov	mm2, mm0
+ 	pfadd	mm0, mm1		;fi0 | fi1
+ 	pfsub	mm2, mm1		;fi2 | fi3
+ 	pmov	mm5, mm3
+ 	pfadd	mm3, mm4		;gi0 | gi1
+ 	pfsub	mm5, mm4		;gi2 | gi3
+ 
+ 	pmovd	[r0+r3], mm0	;fi[k1]
+ 	puphdq	mm0, mm0
+ 	pmovd	[r0+r2], mm2	;fi[k3]
+ 	puphdq	mm2, mm2
+ 	pmovd	[r1+r3], mm3	;gi[k1]
+ 	puphdq	mm3, mm3
+ 	pmovd	[r1+r2], mm5	;gi[k3]
+ 	puphdq	mm5, mm5
+ 
+ 	pmovd	[r0], mm0		;fi[0]
+ 	pmovd	[r0+r3*2], mm2	;fi[k2]
+ 	pmovd	[r1], mm3		;gi[0]
+ 	pmovd	[r1+r3*2], mm5	;gi[k2]
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near .do2
+ 
+ 	
+ 	mov	r0, [sp(%$k)]
+ 	pmov	mm0, [costab_fft +r0*4]
+ 	pmov	mm1, [sintab_fft +r0*4]
+ 	pupldq	mm0, mm0
+ 	pupldq	mm1, mm1
+ 	pmov	mm6, [D_1_0_D_0_0]		;c1 | s1
+ 	pmov	mm7, [D_0_0_D_1_0]		;-s1 | c1
+ 	pmov	[sp(%$t_c)], mm0
+ 	pmov	[sp(%$t_s)], mm1
+ 
+ .for_init:
+ 	mov	r5, 4		;i = 1*fsize
+ 	jmp	.for
+ 
+ 	align 16
+ .for:
+ 	pfmul	mm6, [sp(%$t_c)]	;c1*t_c | s1*t_c
+ 	pfmul	mm7, [sp(%$t_s)]	;-s1*t_s | c1*t_s
+ 
+ 	pfadd	mm6, mm7		;c1 | s1
+ 	pmov	mm7, [D_MSB0_1]
+ 
+ 	pswapd	mm1, mm6		;s1 | c1
+ 	pswapd	mm0, mm6
+ 	pxor	mm7, mm6		;c1 | -s1
+ 
+ 	pfmul	mm1, mm6		;c1*s1 | c1*s1
+ 	pfmul	mm0, mm0		;s1*s1 | c1*c1
+ 	pswapd	mm7, mm7		;-s1 | c1
+ 
+ 	pfpnacc	mm0, mm1		;s2 = 2*c1*s1 | c2 = c1*c1-s1*s1
+ 	pswapd	mm1, mm0		;c2 | s2
+ 	pxor	mm1, [D_MSB1_0]	;-c2 | s2
+ 
+ 	pmov	[sp(%$Ps2_Pc2)], mm0
+ 	pmov	[sp(%$Mc2_Ps2)], mm1
+ 
+ 	mov	r0, [sp(%$fz)]
+ 	mov	r1, [sp(%$fz)]
+ 	add	r0, r5		;r0 = fi
+ 	add	r1, r3
+ 	sub	r1, r5		;r1 = gi
+ 	jmp	.do3
+ 
+ 	align 16
+ .do3:
+ 	pmov	mm0, [r0+r2]
+ 	pmov	mm2, [r1+r2]
+ 	pmov	mm1, [r0+r3]
+ 	pmov	mm3, [r1+r3]
+ 
+ 	pupldq	mm0, mm0
+ 	pupldq	mm2, mm2
+ 	pupldq	mm1, mm1
+ 	pupldq	mm3, mm3
+ 
+ 	pmov	mm4, [sp(%$Ps2_Pc2)]
+ 	pmov	mm5, [sp(%$Mc2_Ps2)]
+ 
+ 	pfmul	mm0, mm4		;s2 * fi3 | c2 * fi3
+ 	pfmul	mm2, mm5		;-c2 * gi3 | s2 * gi3
+ 	pfmul	mm1, mm4		;s2 * fi1 | c2 * fi1
+ 	pfmul	mm3, mm5		;-c2 * gi1 | s2 * gi1
+ 
+ 	pfadd	mm0, mm2		;d | c
+ 	pfadd	mm1, mm3		;b | a
+ 
+ 	pmov	mm2, [r0+r3*2]	;fi2
+ 	pupldq	mm3, [r1+r3*2]	;gi2 | -
+ 	pmov	mm4, [r0]		;fi0
+ 	pupldq	mm5, [r1]		;gi0 | -
+ 
+ 	pupldq	mm2, mm0		;c | fi2
+ 	puphdq	mm3, mm0		;d | gi2
+ 	pupldq	mm4, mm1		;a | fi0
+ 	puphdq	mm5, mm1		;b | gi0
+ 
+ 	pfpnacc	mm2, mm2		;f2 | f3
+ 	pfpnacc	mm3, mm3		;g2 | g3
+ 	pfpnacc	mm4, mm4		;f0 | f1
+ 	pfpnacc	mm5, mm5		;g0 | g1
+ 
+ 	pmov	mm0, mm2
+ 	pmov	mm1, mm3
+ 	pupldq	mm2, mm2		;f3 | f3
+ 	pupldq	mm3, mm3		;g3 | g3
+ 	puphdq	mm0, mm0		;f2 | f2
+ 	puphdq	mm1, mm1		;g2 | g2
+ 
+ 	pswapd	mm4, mm4		;f1 | f0
+ 	pswapd	mm5, mm5		;g1 | g0
+ 
+ 	pfmul	mm0, mm7		;f2 *-s1 | f2 * c1
+ 	pfmul	mm3, mm6		;g3 * c1 | g3 * s1
+ 	pfmul	mm1, mm6		;g2 * c1 | g2 * s1
+ 	pfmul	mm2, mm7		;f3 *-s1 | f3 * c1
+ 
+ 	pfadd	mm0, mm3		;-b | a
+ 	pfadd	mm1, mm2		; d | c
+ 
+ 	pmov	mm2, mm5
+ 	pmov	mm3, mm4
+ 	pupldq	mm4, mm0		; a | f0
+ 	pupldq	mm5, mm1		; c | g0
+ 	puphdq	mm2, mm0		;-b | g1
+ 	puphdq	mm3, mm1		; d | f1
+ 
+ 	pfpnacc	mm4, mm4		;fi0 | fi2
+ 	pfpnacc	mm5, mm5		;gi0 | gi2
+ 	pfpnacc	mm2, mm2		;gi3 | gi1
+ 	pfpnacc	mm3, mm3		;fi1 | fi3
+ 
+ 	pmovd	[r0+r3*2], mm4	;fi[k2]
+ 	puphdq	mm4, mm4
+ 	pmovd	[r1+r3*2], mm5	;gi[k2]
+ 	puphdq	mm5, mm5
+ 	pmovd	[r1+r3], mm2	;gi[k1]
+ 	puphdq	mm2, mm2
+ 	pmovd	[r0+r2], mm3	;fi[k3]
+ 	puphdq	mm3, mm3
+ 
+ 	pmovd	[r0], mm4		;fi[0]
+ 	pmovd	[r1], mm5		;gi[0]
+ 	pmovd	[r1+r2], mm2	;gi[k3]
+ 	pmovd	[r0+r3], mm3	;fi[k1]
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near	.do3
+ 
+ 	add	r5, 4
+ 	cmp	r5, r4
+ 	jb near	.for
+ 
+ 	cmp	r3, [sp(%$n)]
+ 	jae	.exit
+ 
+ 	add	dword [sp(%$k)], 2	;k  += 2;
+ 	lea	r3, [r3*4]		;k1 *= 4
+ 	lea	r2, [r2*4]		;k3 *= 4
+ 	lea	r4, [r4*4]		;kx *= 4
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+r4]		;gi = fi + kx
+ 	jmp	.do
+ 
+ .exit:
+ 	femms
+ 	popd	ebp, ebx, esi, edi
+ endproc
+ 
+ %endif
+ 
+ ;***********************************************************************
+ 
+ ;void fft_side_3DN(float in[2][1024], int s, float *ret); /* s = MSFREQ 420 */
+ proc fft_side_3DN
+ 
+ %$in	arg	4
+ %$s	arg	4
+ %$pret	arg	4
+ 
+ 	femms
+ 	pushd	ebx, esi
+ 
+ .for_init:
+ 	mov	r0, [sp(%$in)]		;r0 = &in[0][0]
+ 	lea	r1, [r0+fsizen(1024)]	;r1 = &in[1][0]
+ 
+ 	mov	r2, [sp(%$s)]
+ 	mov	r3, fsizen(1023)
+ 	shl	r2, 2			;r2 = s * fsize
+ 	sub	r3, r2			;r3 = (1023-s) * fsize
+ 
+ 	mov	r4, fsizen(512)		;r4 = 512 * fsize
+ 	pxor	mm7, mm7
+ 	jmp	.for
+ 
+ 	align 16
+ .for:
+ 	pmov	mm0, [r0+r3]
+ 	pmov	mm1, [r1+r3]
+ 	pmov	mm2, [r0+r2]
+ 	pfsub	mm0, mm1
+ 	pmov	mm3, [r1+r2]
+ 	pfsub	mm2, mm3
+ 	pmov	mm4, [r0+r3-fsizen(2)]
+ 	pfmul	mm0, mm0
+ 	pmov	mm5, [r1+r3-fsizen(2)]
+ 	pfmul	mm2, mm2
+ 	pmov	mm1, [r0+r2+fsizen(2)]
+ 	pupldq	mm6, mm0
+ 	pmov	mm3, [r1+r2+fsizen(2)]
+ 	pfadd	mm7, mm2
+ 	pfsub	mm4, mm5
+ 	puphdq	mm0, mm6
+ 	pfsub	mm1, mm3
+ 	pfadd	mm7, mm0
+ 
+ 	pfmul	mm4, mm4
+ 	add	r2, fsizen(4)
+ 	pfmul	mm1, mm1
+ 	sub	r3, fsizen(4)
+ 	pupldq	mm6, mm4
+ 	pfadd	mm7, mm1
+ 	cmp	r2, r4
+ 	puphdq	mm4, mm6
+ 	pfadd	mm7, mm4
+ 	jb	.for
+ 
+ 	pmov	mm0, [r0+r2]
+ 	pmov	mm1, [r1+r2]
+ 	pmov	mm2, [D_0_25]
+ 	pfsub	mm0, mm1
+ 	pmov	mm3, [D_0_5]
+ 	pfacc	mm7, mm7
+ 	pfmul	mm0, mm0
+ 	pfmul	mm7, mm2
+ 	pfmul	mm0, mm3
+ 	mov	r0, [sp(%$pret)]
+ 	pfadd	mm0, mm7
+ 
+ 	pmovd	[r0], mm0
+ .exit:
+ 	femms
+ 	popd	ebx, esi
+ endproc
+ 
+ ;***********************************************************************
+ %ifdef USE_E3DN
+ 
+ ;void fft_side_E3DN(float in[2][1024], int s, float *ret); /* s = MSFREQ 420 */
+ proc fft_side_E3DN
+ 
+ %$in	arg	4
+ %$s	arg	4
+ %$pret	arg	4
+ 
+ 	femms
+ 	pushd	ebx, esi
+ 
+ .for_init:
+ 	mov	r0, [sp(%$in)]		;r0 = &in[0][0]
+ 	lea	r1, [r0+fsizen(1024)]	;r1 = &in[1][0]
+ 
+ 	mov	r2, [sp(%$s)]
+ 	mov	r3, fsizen(1023)
+ 	shl	r2, 2			;r2 = s * fsize
+ 	sub	r3, r2			;r3 = (1023-s) * fsize
+ 
+ 	mov	r4, fsizen(512)		;r4 = 512 * fsize
+ 	pxor	mm7, mm7
+ 	jmp	.for
+ 
+ 	align 16
+ .for:
+ 	pmov	mm0, [r0+r3]
+ 	pfsub	mm0, [r1+r3]
+ 	pmov	mm4, [r0+r3-fsizen(2)]
+ 	pfsub	mm4, [r1+r3-fsizen(2)]
+ 	pmov	mm2, [r0+r2]
+ 	pfsub	mm2, [r1+r2]
+ 	pmov	mm1, [r0+r2+fsizen(2)]
+ 	pfsub	mm1, [r1+r2+fsizen(2)]
+ 	pfmul	mm0, mm0
+ 	pfmul	mm4, mm4
+ 	pfmul	mm2, mm2
+ 	pfmul	mm1, mm1
+ 	pswapd	mm0, mm0
+ 	pswapd	mm4, mm4
+ 	pfadd	mm7, mm2
+ 	add	r2, fsizen(4)
+ 	pfadd	mm7, mm1
+ 	sub	r3, fsizen(4)
+ 	pfadd	mm7, mm0
+ 	cmp	r2, r4
+ 	pfadd	mm7, mm4
+ 	jb	.for
+ 
+ 	pmov	mm0, [r0+r2]
+ 	pfsub	mm0, [r1+r2]
+ 	pfacc	mm7, mm7
+ 	pfmul	mm0, mm0
+ 	pfmul	mm7, [D_0_25]
+ 	pfmul	mm0, [D_0_5]
+ 	mov	r0, [sp(%$pret)]
+ 	pfadd	mm0, mm7
+ 
+ 	pmovd	[r0], mm0
+ .exit:
+ 	femms
+ 	popd	ebx, esi
+ endproc
+ 
+ %endif
diff -r -c -N encoder/i386/fftfpu.nas lame3.70/i386/fftfpu.nas
*** encoder/i386/fftfpu.nas	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/fftfpu.nas	Sun Jan 30 15:53:49 2000
***************
*** 0 ****
--- 1,619 ----
+ ; back port from GOGO-no coda 2.24b by Takehiro TOMINAGA
+ 
+ ; GOGO-no-coda
+ ;	Copyright (C) 1999 shigeo
+ ;	special thanks to URURI
+ 
+ %include "nasm.h"
+ 
+ 	externdef costab_fft
+ 	externdef sintab_fft
+ 
+ 	segment_data
+ 	align 32
+ D_1_41421	dd	1.41421356
+ D_1_0	dd	1.0
+ D_0_5	dd	0.5
+ D_0_25	dd	0.25
+ D_0_0005	dd	0.0005
+ D_0_0	dd	0.0
+ 
+ 	segment_code
+ 
+ ;void fht(float *fz, int n);
+ proc	fht_FPU
+ 
+ %$fz	arg	4
+ %$n	arg	4
+ 
+ %$k	local	4
+ 
+ %$f0	local	4
+ %$f1	local	4
+ %$f2	local	4
+ %$f3	local	4
+ 
+ %$g0	local	4
+ %$g1	local	4
+ %$g2	local	4
+ %$g3	local	4
+ 
+ %$s1	local	4
+ %$c1	local	4
+ %$s2	local	4
+ %$c2	local	4
+ 
+ %$t_s	local	4
+ %$t_c	local	4
+ 	alloc
+ 
+ 	pushd	ebp, ebx, esi, edi
+ 
+ fht_FPU_1st_part:
+ 
+ fht_FPU_2nd_part:
+ 
+ fht_FPU_3rd_part:
+ 
+ .do_init:
+ 	mov	r3, 16		;k1*fsize = 4*fsize = k4
+ 	mov	r4, 8		;kx = k1/2
+ 	mov	r2, 48		;k3*fsize
+ 	mov	dword [sp(%$k)], 2	;k = 2
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+8]		;gi = fi + kx
+ 
+ .do:
+ .do2:
+ 	;f
+ 	fld	dword [r0]
+ 	fsub	dword [r0+r3]
+ 
+ 	fld	dword [r0]
+ 	fadd	dword [r0+r3]
+ 
+ 	fld	dword [r0+r3*2]
+ 	fsub	dword [r0+r2]
+ 
+ 	fld	dword [r0+r3*2]
+ 	fadd	dword [r0+r2]		;f2 f3 f0 f1
+ 
+ 	fld	st2			;f0 f2 f3 f0 f1
+ 	fadd	st0, st1
+ 	fstp	dword [r0]		;fi[0]
+ 
+ 	fld	st3			;f1 f2 f3 f0 f1
+ 	fadd	st0, st2
+ 	fstp	dword [r0+r3]		;fi[k1]
+ 
+ 	fsubr	st0, st2		;f0-f2 f3 f0 f1
+ 	fstp	dword [r0+r3*2]		;fi[k2]
+ 
+ 	fsubr	st0, st2		;f1-f3 f0 f1
+ 	fstp	dword [r0+r2]		;fi[k3]
+ 	fcompp
+ 
+ 	;g
+ 	fld	dword [r1]
+ 	fsub	dword [r1+r3]
+ 
+ 	fld	dword [r1]
+ 	fadd	dword [r1+r3]
+ 
+ 	fld	dword [D_1_41421]
+ 	fmul	dword [r1+r2]
+ 
+ 	fld	dword [D_1_41421]
+ 	fmul	dword [r1+r3*2]		;g2 g3 g0 g1
+ 
+ 	fld	st2			;g0 g2 g3 g0 g1
+ 	fadd	st0, st1
+ 	fstp	dword [r1]		;gi[0]
+ 
+ 	fld	st3			;g1 g2 g3 g0 g1
+ 	fadd	st0, st2
+ 	fstp	dword [r1+r3]		;gi[k1]
+ 
+ 	fsubr	st0, st2		;g0-g2 g3 g0 g1
+ 	fstp	dword [r1+r3*2]		;gi[k2]
+ 
+ 	fsubr	st0, st2		;g1-g3 g0 g1
+ 	fstp	dword [r1+r2]		;gi[k3]
+ 	fcompp
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb	.do2
+ 
+ 
+ 	mov	r0, [sp(%$k)]
+ 	fld	dword [costab_fft +r0*4]
+ 	fstp	dword [sp(%$t_c)]
+ 	fld	dword [sintab_fft +r0*4]
+ 	fstp	dword [sp(%$t_s)]
+ 	fld	dword [D_1_0]
+ 	fstp	dword [sp(%$c1)]
+ 	fld	dword [D_0_0]
+ 	fstp	dword [sp(%$s1)]
+ 
+ .for_init:
+ 	mov	r5, 4		;i = 1*fsize
+ 
+ .for:
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$t_c)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$t_s)]
+ 	fsubp	st1, st0		;c1
+ 
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$t_s)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$t_c)]
+ 	faddp	st1, st0		;s1 c1
+ 	
+ 	fld	st1
+ 	fmul	st0, st0		;c1c1 s1 c1
+ 	fld	st1
+ 	fmul	st0, st0		;s1s1 c1c1 s1 c1
+ 	fsubp	st1, st0		;c2 s1 c1
+ 	fstp	dword [sp(%$c2)]	;s1 c1
+ 
+ 	fld	st1			;c1 s1 c1
+ 	fmul	st0, st1		;c1s1 s1 c1
+ 	fadd	st0, st0		;s2 s1 c1
+ 	fstp	dword [sp(%$s2)]	;s1 c1
+ 
+ 	fstp	dword [sp(%$s1)]	;c1
+ 	fstp	dword [sp(%$c1)]	;
+ 	
+ 	mov	r0, [sp(%$fz)]
+ 	add	r0, r5		;r0 = fi
+ 	mov	r1, [sp(%$fz)]
+ 	add	r1, r3
+ 	sub	r1, r5		;r1 = gi
+ 
+ .do3:
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r0+r3]
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r1+r3]
+ 	fsubp	st1, st0		;b = s2*fi[k1] - c2*gi[k1]
+ 
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r0+r3]
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r1+r3]
+ 	faddp	st1, st0		;a = c2*fi[k1] + s2*gi[k1]  b
+ 
+ 	fld	dword [r0]
+ 	fsub	st0, st1		;f1 a b
+ 	fstp	dword [sp(%$f1)]	;a b
+ 
+ 	fadd	dword [r0]		;f0 b
+ 	fstp	dword [sp(%$f0)]	;b
+ 
+ 	fld	dword [r1]
+ 	fsub	st0, st1		;g1 b
+ 	fstp	dword [sp(%$g1)]	;b
+ 
+ 	fadd	dword [r1]		;g0
+ 	fstp	dword [sp(%$g0)]	;
+ 
+ 
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r0+r2]
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r1+r2]
+ 	fsubp	st1, st0		;b = s2*fi[k3] - c2*gi[k3]
+ 
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r0+r2]
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r1+r2]
+ 	faddp	st1, st0		;a = c2*fi[k3] + s2*gi[k3]  b
+ 
+ 	fld	dword [r0+r3*2]
+ 	fsub	st0, st1		;f3 a b
+ 	fstp	dword [sp(%$f3)]	;a b
+ 
+ 	fadd	dword [r0+r3*2]	;f2 b
+ 	fstp	dword [sp(%$f2)]	;b
+ 
+ 	fld	dword [r1+r3*2]
+ 	fsub	st0, st1		;g3 b
+ 	fstp	dword [sp(%$g3)]	;b
+ 
+ 	fadd	dword [r1+r3*2]	;g2
+ 	fstp	dword [sp(%$g2)]	;
+ 
+ 
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$f2)]
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$g3)]
+ 	fsubp	st1, st0		;b = s1*f2 - c1*g3
+ 	
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$f2)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$g3)]
+ 	faddp	st1, st0		;a = c1*f2 + s1*g3  b
+ 
+ 	fld	dword [sp(%$f0)]
+ 	fsub	st0, st1		;fi[k2] a b
+ 	fstp	dword [r0+r3*2]
+ 
+ 	fadd	dword [sp(%$f0)]	;fi[0] b
+ 	fstp	dword [r0]
+ 
+ 	fld	dword [sp(%$g1)]
+ 	fsub	st0, st1		;gi[k3] b
+ 	fstp	dword [r1+r2]
+ 
+ 	fadd	dword [sp(%$g1)]	;gi[k1]
+ 	fstp	dword [r1+r3]
+ 
+ 
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$g2)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$f3)]
+ 	fsubp	st1, st0		;b = c1*g2 - s1*f3
+ 	
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$g2)]
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$f3)]
+ 	faddp	st1, st0		;a = s1*g2 + c1*f3  b
+ 
+ 	fld	dword [sp(%$g0)]
+ 	fsub	st0, st1		;gi[k2] a b
+ 	fstp	dword [r1+r3*2]
+ 
+ 	fadd	dword [sp(%$g0)]	;gi[0] b
+ 	fstp	dword [r1]
+ 
+ 	fld	dword [sp(%$f1)]
+ 	fsub	st0, st1		;fi[k3] b
+ 	fstp	dword [r0+r2]
+ 
+ 	fadd	dword [sp(%$f1)]	;fi[k1]
+ 	fstp	dword [r0+r3]
+ 
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near	.do3
+ 
+ 	add	r5, 4
+ 	cmp	r5, r4
+ 	jb near	.for
+ 
+ 	cmp	r3, [sp(%$n)]
+ 	jae	.exit
+ 
+ 	add	dword [sp(%$k)], 2	;k  += 2;
+ 	lea	r3, [r3*4]		;k1 *= 4
+ 	lea	r2, [r2*4]		;k3 *= 4
+ 	lea	r4, [r4*4]		;kx *= 4
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+r4]		;gi = fi + kx
+ 	jmp	.do
+ 
+ .exit:
+ 	popd	ebp, ebx, esi, edi
+ endproc
+ 
+ ;*************************************************************
+ 
+ ;void fht_FPU_FXCH(float *fz, int n);
+ proc	fht_FPU_FXCH
+ 
+ %$fz	arg	4
+ %$n	arg	4
+ 
+ %$k	local	4
+ 
+ %$f0	local	4
+ %$f1	local	4
+ %$f2	local	4
+ %$f3	local	4
+ 
+ %$g0	local	4
+ %$g1	local	4
+ %$g2	local	4
+ %$g3	local	4
+ 
+ %$s1	local	4
+ %$c1	local	4
+ %$s2	local	4
+ %$c2	local	4
+ 
+ %$t_s	local	4
+ %$t_c	local	4
+ 	alloc
+ 
+ 	pushd	ebp, ebx, esi, edi
+ 
+ fht_FPU_FXCH_1st_part:
+ 
+ fht_FPU_FXCH_2nd_part:
+ 
+ fht_FPU_FXCH_3rd_part:
+ 
+ .do_init:
+ 	mov	r3, 16		;k1*fsize = 4*fsize = k4
+ 	mov	r4, 8		;kx = k1/2
+ 	mov	r2, 48		;k3*fsize
+ 	mov	dword [sp(%$k)], 2	;k = 2
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+8]		;gi = fi + kx
+ 
+ .do:
+ .do2:
+ 	;f
+ 	fld	dword [r0]
+ 	fsub	dword [r0+r3]
+ 	fld	dword [r0]
+ 	fadd	dword [r0+r3]
+ 
+ 	fld	dword [r0+r3*2]
+ 	fsub	dword [r0+r2]
+ 	fld	dword [r0+r3*2]
+ 	fadd	dword [r0+r2]		;f2 f3 f0 f1
+ 
+ 	fld	st3
+ 	fld	st3
+ 	fxch	st5
+ 	fadd	st0, st3
+ 	fxch	st4
+ 	fadd	st0, st2
+ 	fxch	st3
+ 	fsubp	st1, st0
+ 	fxch	st1
+ 	fsubp	st4, st0
+ 	fxch	st2
+ 
+ 	fstp	dword [r0+r3]		;fi[k1]
+ 	fstp	dword [r0]		;fi[0]
+ 	fstp	dword [r0+r2]		;fi[k3]
+ 	fstp	dword [r0+r3*2]		;fi[k2]
+ 
+ 	;g
+ 	fld	dword [r1]
+ 	fsub	dword [r1+r3]
+ 	fld	dword [r1]
+ 	fadd	dword [r1+r3]
+ 
+ 	fld	dword [D_1_41421]
+ 	fmul	dword [r1+r2]
+ 	fld	dword [D_1_41421]
+ 	fmul	dword [r1+r3*2]		;g2 g3 g0 g1
+ 
+ 	fld	st3
+ 	fld	st3
+ 	fxch	st5
+ 	fadd	st0, st3
+ 	fxch	st4
+ 	fadd	st0, st2
+ 	fxch	st3
+ 	fsubp	st1, st0
+ 	fxch	st1
+ 	fsubp	st4, st0
+ 	fxch	st2
+ 
+ 	fstp	dword [r1+r3]		;gi[k1]
+ 	fstp	dword [r1]		;gi[0]
+ 	fstp	dword [r1+r2]		;gi[k3]
+ 	fstp	dword [r1+r3*2]		;gi[k2]
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb	.do2
+ 
+ 
+ 	mov	r0, [sp(%$k)]
+ 	fld	dword [costab_fft +r0*4]
+ 	fld	dword [sintab_fft +r0*4]
+ 	fld	dword [D_1_0]
+ 	fld	dword [D_0_0]
+ 	fxch	st3
+ 	fstp	dword [sp(%$t_c)]
+ 	fxch	st1
+ 	fstp	dword [sp(%$t_s)]
+ 	fstp	dword [sp(%$c1)]
+ 	fstp	dword [sp(%$s1)]
+ 
+ .for_init:
+ 	mov	r5, 4		;i = 1*fsize
+ 
+ .for:
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$t_c)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$t_s)]
+ 
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$t_s)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$t_c)]
+ 	fxch	st2
+ 	fsubp	st3, st0		;c1
+ 	faddp	st1, st0		;s1 c1
+ 	
+ 	fld	st1
+ 	fxch	st2
+ 	fmul	st0, st0		;c1c1 s1 c1
+ 	fld	st1
+ 	fxch	st2
+ 	fmul	st0, st0		;s1s1 c1c1 s1 c1
+ 
+ 	fxch	st3
+ 	fst	dword [sp(%$c1)]	;c1
+ 	fxch	st2
+ 	fst	dword [sp(%$s1)]	;s1 c1c1 c1 s1s1
+ 
+ 	fmulp	st2, st0
+ 	fsubrp	st2, st0
+ 	fadd	st0, st0		;s2 c2
+ 	fxch	st1
+ 	fstp	dword [sp(%$c2)]
+ 	fstp	dword [sp(%$s2)]
+ 
+ 	mov	r0, [sp(%$fz)]
+ 	mov	r1, [sp(%$fz)]
+ 	add	r0, r5		;r0 = fi
+ 	add	r1, r3
+ 	sub	r1, r5		;r1 = gi
+ 
+ .do3:
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r0+r3]
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r1+r3]
+ 
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r0+r3]
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r1+r3]
+ 	fxch	st2
+ 	fsubp	st3, st0		;b = s2*fi[k1] - c2*gi[k1]
+ 	faddp	st1, st0		;a = c2*fi[k1] + s2*gi[k1]  b
+ 
+ 	fld	dword [r1]
+ 	fsub	st0, st2		;g1 a b
+ 	fxch	st2
+ 	fadd	dword [r1]		;g0 a g1
+ 
+ 	fld	dword [r0]
+ 	fsub	st0, st2		;f1 g0 a g1
+ 	fxch	st2
+ 	fadd	dword [r0]		;f0 g0 f1 g1
+ 
+ 	fxch	st3
+ 	fstp	dword [sp(%$g1)]
+ 	fstp	dword [sp(%$g0)]
+ 	fstp	dword [sp(%$f1)]
+ 	fstp	dword [sp(%$f0)]
+ 
+ 
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r0+r2]
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r1+r2]
+ 
+ 	fld	dword [sp(%$c2)]
+ 	fmul	dword [r0+r2]
+ 	fld	dword [sp(%$s2)]
+ 	fmul	dword [r1+r2]
+ 	fxch	st2
+ 	fsubp	st3, st0		;b = s2*fi[k3] - c2*gi[k3]
+ 	faddp	st1, st0		;a = c2*fi[k3] + s2*gi[k3]  b
+ 
+ 
+ 	fld	dword [r1+r3*2]
+ 	fsub	st0, st2		;g3 a b
+ 	fxch	st2
+ 	fadd	dword [r1+r3*2]	;g2 a g3
+ 
+ 	fld	dword [r0+r3*2]
+ 	fsub	st0, st2		;f3 g2 a g3
+ 	fxch	st2
+ 	fadd	dword [r0+r3*2]	;f2 g2 f3 g3
+ 
+ 	fxch	st3
+ 	fstp	dword [sp(%$g3)]
+ 	fstp	dword [sp(%$g2)]
+ 	fstp	dword [sp(%$f3)]
+ 	fstp	dword [sp(%$f2)]
+ 
+ 
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$f2)]
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$g3)]
+ 	
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$f2)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$g3)]
+ 	fxch	st2
+ 	fsubp	st3, st0		;b = s1*f2 - c1*g3
+ 	faddp	st1, st0		;a = c1*f2 + s1*g3  b
+ 
+ 	fld	dword [sp(%$g1)]
+ 	fsub	st0, st2		;gi[k3] a b
+ 	fxch	st2
+ 	fadd	dword [sp(%$g1)]	;gi[k1] a gi[k3]
+ 
+ 	fld	dword [sp(%$f0)]
+ 	fsub	st0, st2		;fi[k2] gi[k1] a gi[k3]
+ 	fxch	st2
+ 	fadd	dword [sp(%$f0)]	;fi[0] gi[k1] fi[k2] gi[k3]
+ 
+ 	fxch	st3
+ 	fstp	dword [r1+r2]
+ 	fstp	dword [r1+r3]
+ 	fstp	dword [r0+r3*2]
+ 	fstp	dword [r0]
+ 
+ 
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$g2)]
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$f3)]
+ 	
+ 	fld	dword [sp(%$s1)]
+ 	fmul	dword [sp(%$g2)]
+ 	fld	dword [sp(%$c1)]
+ 	fmul	dword [sp(%$f3)]
+ 	fxch	st2
+ 	fsubp	st3, st0		;b = c1*g2 - s1*f3
+ 	faddp	st1, st0		;a = s1*g2 + c1*f3  b
+ 
+ 	fld	dword [sp(%$f1)]
+ 	fsub	st0, st2		;fi[k3] a b
+ 	fxch	st2
+ 	fadd	dword [sp(%$f1)]	;fi[k1] a fi[k3]
+ 
+ 	fld	dword [sp(%$g0)]
+ 	fsub	st0, st2		;gi[k2] fi[k1] a fi[k3]
+ 	fxch	st2
+ 	fadd	dword [sp(%$g0)]	;gi[0] fi[k1] gi[k2] fi[k3]
+ 
+ 	fxch	st3
+ 	fstp	dword [r0+r2]
+ 	fstp	dword [r0+r3]
+ 	fstp	dword [r1+r3*2]
+ 	fstp	dword [r1]
+ 
+ 
+ 	lea	r0, [r0+r3*4]
+ 	lea	r1, [r1+r3*4]
+ 	cmp	r0, r6
+ 	jb near	.do3
+ 
+ 	add	r5, 4
+ 	cmp	r5, r4
+ 	jb near	.for
+ 
+ 	cmp	r3, [sp(%$n)]
+ 	jae	.exit
+ 
+ 	add	dword [sp(%$k)], 2	;k  += 2;
+ 	lea	r3, [r3*4]		;k1 *= 4
+ 	lea	r2, [r2*4]		;k3 *= 4
+ 	lea	r4, [r4*4]		;kx *= 4
+ 	mov	r0, [sp(%$fz)]	;fi
+ 	lea	r1, [r0+r4]		;gi = fi + kx
+ 	jmp	.do
+ 
+ .exit:
+ 	popd	ebp, ebx, esi, edi
+ endproc
+ 
+ 	end
diff -r -c -N encoder/i386/fftsse.nas lame3.70/i386/fftsse.nas
*** encoder/i386/fftsse.nas	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/fftsse.nas	Sun Jan 30 15:53:49 2000
***************
*** 0 ****
--- 1,538 ----
+ ; back port from GOGO-no coda 2.24b by Takehiro TOMINAGA
+ 
+ ; GOGO-no-coda
+ ;	Copyright (C) 1999 shigeo
+ ;	special thanks to Keiichi SAKAI
+ 
+ %include "nasm.h"
+ 
+ 	globaldef fht_SSE
+ 	globaldef fft_side_SSE
+ 	externdef costab_fft
+ 	externdef sintab_fft
+ 
+ 	segment_data
+ 	align 16
+ Q_MMPP	dd	0x0,0x0,0x80000000,0x80000000
+ Q_MPMP	dd	0x0,0x80000000,0x0,0x80000000
+ Q_002	dd	0.02236068, 0.02236068, 0.02236068, 0.02236068
+ D_SQRT2	dd	1.414213562,1.414213562
+ S_025	dd	0.25
+ S_05	DD	0.5
+ S_00005	DD	0.0005
+ 
+ 	segment_code
+ ;------------------------------------------------------------------------
+ ;	by K. SAKAI
+ ;	99/08/18	PIII 23k[clk]
+ ;	99/08/19	 PIII 22k[clk]
+ ;	99/08/20	bit reversal  PIII 17k[clk]
+ ;	99/08/23	 unroll PIII 14k[clk]
+ ;	99/11/12	clean up
+ ;
+ ;void fht_SSE(float *fz, int n);
+ 	align 16
+ fht_SSE:
+ 	push	ebx
+ 	push	esi
+ 	push	edi
+ 	push	ebp
+ %assign _P 4*4
+ 
+ 	;2
+ 	mov	eax,[esp+_P+4]	;eax=fz
+ 	mov	ebp,[esp+_P+8]	;=n
+ 	shl	ebp,2
+ 	add	ebp,eax		; fn  = fz + n, 
+ 
+ 	xor	ecx,ecx		; ecx=k=0
+ 	xor	eax,eax
+ 	mov	al,4		; =k1=1*(sizeof float)	// 4, 16, 64, 256,...
+ 	xor	edx,edx
+ 	mov	dl,12		; =k3=3*k1
+ 	jmp	short .lp2
+ 
+ 	align	16
+ .lp2:				; do{
+ 	add	cl,2		; k  += 2;
+ 	shl	eax,2
+ 	shl	edx,2
+ 
+ 	mov	esi,[esp+_P+4]	;esi=fi=fz
+ 	mov	edi,eax
+ 	shr	edi,1
+ 	add	edi,esi		; edi=gi=fi+ki/2
+ 
+ ; 2FPU
+ 	movss	xmm7,[D_SQRT2]
+ 	jmp	short .lp20
+ 
+ 	align	16
+ .lp20:				; do{
+ ;                       f0     = fi[0 ] + fi[k1];
+ ;                       f2     = fi[k2] + fi[k3];
+ ;                       f1     = fi[0 ] - fi[k1];
+ ;                       f3     = fi[k2] - fi[k3];
+ ;                       fi[0 ] = f0     + f2;
+ ;                       fi[k1] = f1     + f3;
+ ;                       fi[k2] = f0     - f2;
+ ;                       fi[k3] = f1     - f3;
+ 	fld	dword [esi]
+ 	fadd	dword [esi+eax]
+ 	fld	dword [esi+eax*2]
+ 	fadd	dword [esi+edx]
+ 
+ 	fld	dword [esi]
+ 	fsub	dword [esi+eax]
+ 	fld	dword [esi+eax*2]
+ 	fsub	dword [esi+edx]
+ 
+ 	fld	st1
+ 	fadd	st0,st1
+ 	fstp	dword [esi+eax]
+ 	fsubp	st1,st0
+ 	fstp	dword [esi+edx]
+ 
+ 	fld	st1
+ 	fadd	st0,st1
+ 	fstp	dword [esi]
+ 	fsubp	st1,st0
+ 	fstp	dword [esi+eax*2]
+ 
+ 	lea	esi,[esi + eax*4]	; = fi += (k1 * 4);
+ ;	add	esi,eax
+ ;	add	esi,edx
+ ;                       g0     = gi[0 ] + gi[k1];
+ ;                       g2     = SQRT2  * gi[k2];
+ ;                       g1     = gi[0 ] - gi[k1];
+ ;                       g3     = SQRT2  * gi[k3];
+ ;                       gi[0 ] = g0     + g2;
+ ;                       gi[k2] = g0     - g2;
+ ;                       gi[k1] = g1     + g3;
+ ;                       gi[k3] = g1     - g3;
+ 	fld	dword [edi]
+ 	fadd	dword [edi+eax]
+ 	fld	dword [D_SQRT2]
+ 	fmul	dword [edi+eax*2]
+ 
+ 	fld	dword [edi]
+ 	fsub	dword [edi+eax]
+ 	fld	dword [D_SQRT2]
+ 	fmul	dword [edi+edx]
+ 
+ 	fld	st1
+ 	fadd	st0,st1
+ 	fstp	dword [edi+eax]
+ 	fsubp	st1,st0
+ 	fstp	dword [edi+edx]
+ 
+ 	fld	st1
+ 	fadd	st0,st1
+ 	fstp	dword [edi]
+ 	fsubp	st1,st0
+ 	fstp	dword [edi+eax*2]
+ 
+ 	lea	edi,[edi + eax*4]	; = gi += (k1 * 4);
+ 	cmp	esi,ebp
+ 	jl	near .lp20		; while (fi<fn);
+ 
+ ;               i = 1; //for (i=1;i<kx;i++){
+ ;                       c1 = 1.0*t_c - 0.0*t_s;
+ ;                       s1 = 0.0*t_c + 1.0*t_s;
+ 	movss	xmm6,[costab_fft + ecx*4]
+ 	movss	xmm1,[sintab_fft + ecx*4]
+ 	shufps	xmm6,xmm1,0x00	; = {s1, s1, c1, c1}
+ 	shufps	xmm6,xmm6,0x28	; = {+c1, +s1, +s1, +c1}
+ ;                       c2 = c1*c1 - s1*s1;
+ ;                       s2 = c1*s1 + s1*c1;
+ 	movaps	xmm4,xmm6
+ 	movaps	xmm7,xmm6
+ 	unpcklps	xmm4,xmm4	; = {s1, s1, c1, c1}
+ 	shufps	xmm7,xmm7,0x41
+ 	mulps	xmm4,xmm6	; = {s1*c1, s1*s1, c1*s1, c1*c1}
+ 	xorps	xmm7,[Q_MMPP]	; = {-s1, -c1, +c1, +s1}
+ 	movhlps	xmm3,xmm4
+ 	xorps	xmm3,[Q_MPMP]
+ 	subps	xmm4,xmm3	; = {--, --, s2, c2}
+ 	movlhps	xmm4,xmm4	; = {+s2, +c2, +s2, +c2}
+ 	movaps	xmm5,xmm4
+ 	shufps	xmm5,xmm5,0x11
+ 	xorps	xmm5,[Q_MPMP]	; = {-c2, +s2, -c2, +s2}
+ 	mov	esi,[esp+_P+4]	; = fz
+ 	lea	edi,[esi + eax - 4]	; edi = gi = fz +k1-i
+ 	add	esi,4		; esi = fi = fz + i
+ 	jmp	short .lp21
+ 
+ 	align	16
+ .lp21:				; do{
+ ;                               a       = c2*fi[k1] + s2*gi[k1];
+ ;                               b       = s2*fi[k1] - c2*gi[k1];
+ ;                               c       = c2*fi[k3] + s2*gi[k3];
+ ;                               d       = s2*fi[k3] - c2*gi[k3];
+ ;                               f0      = fi[0 ]        + a;
+ ;                               g0      = gi[0 ]        + b;
+ ;                               f2      = fi[k1 * 2]    + c;
+ ;                               g2      = gi[k1 * 2]    + d;
+ ;                               f1      = fi[0 ]        - a;
+ ;                               g1      = gi[0 ]        - b;
+ ;                               f3      = fi[k1 * 2]    - c;
+ ;                               g3      = gi[k1 * 2]    - d;
+ 
+ 	movss	xmm0,[esi + eax]	; = fi[k1]
+ 	movss	xmm2,[esi + edx]	; = fi[k3]
+ 	shufps	xmm0,xmm2,0x00	; = {fi[k3], fi[k3], fi[k1], fi[k1]}
+ 	movss	xmm1,[edi + eax]	; = fi[k1]
+ 	movss	xmm3,[edi + edx]	; = fi[k3]
+ 	shufps	xmm1,xmm3,0x00	; = {gi[k3], gi[k3], gi[k1], gi[k1]}
+ 	movss	xmm2,[esi]		; = fi[0]
+ 	mulps	xmm0,xmm4		; *= {+s2, +c2, +s2, +c2}
+ 	movss	xmm3,[esi + eax*2]	; = fi[k2]
+ 	unpcklps	xmm2,xmm3	; = {--, --, fi[k2], fi[0]}
+ 	mulps	xmm1,xmm5		; *= {-c2, +s2, -c2, +s2}
+ 	movss	xmm3,[edi + eax*2]	; = gi[k2]
+ 	addps	xmm0,xmm1		; = {d, c, b, a}
+ 	movss	xmm1,[edi]		; = gi[0]
+ 	unpcklps	xmm1,xmm3	; = {--,  --, gi[k2], gi[0]}
+ 	unpcklps	xmm2,xmm1	; = {gi[k2], fi[k2], gi[0], fi[0]}
+ 	movaps	xmm1,xmm2
+ 	addps	xmm1,xmm0	; = {g2, f2, g0, f0}
+ 	subps	xmm2,xmm0	; = {g3, f3, g1, f1}
+ 
+ ;                               a       = c1*f2     + s1*g3;
+ ;                               c       = s1*g2     + c1*f3;
+ ;                               b       = s1*f2     - c1*g3;
+ ;                               d       = c1*g2     - s1*f3;
+ ;                               fi[0 ]  = f0        + a;
+ ;                               gi[0 ]  = g0        + c;
+ ;                               gi[k1]  = g1        + b;
+ ;                               fi[k1]  = f1        + d;
+ ;                               fi[k1 * 2]  = f0    - a;
+ ;                               gi[k1 * 2]  = g0    - c;
+ ;                               gi[k3]      = g1    - b;
+ ;                               fi[k3]      = f1    - d;
+ 	movaps	xmm3,xmm1
+ 	movhlps	xmm1,xmm1	; = {g2, f2, g2, f2}
+ 	shufps	xmm3,xmm2,0x14	; = {f1, g1, g0, f0}
+ 	mulps	xmm1,xmm6	; *= {+c1, +s1, +s1, +c1}
+ 	shufps	xmm2,xmm2,0xBB	; = {f3, g3, f3, g3}
+ 	mulps	xmm2,xmm7	; *= {-s1, -c1, +c1, +s1}
+ 	addps	xmm1,xmm2	; = {d, b, c, a}
+ 	movaps	xmm2,xmm3
+ 	addps	xmm3,xmm1	; = {fi[k1], gi[k1], gi[0], fi[0]}
+ 	subps	xmm2,xmm1	; = {fi[k3], gi[k3], gi[k1*2], fi[k1*2]}
+ 	movhlps	xmm0,xmm3
+ 	movss	[esi],xmm3
+ 	shufps	xmm3,xmm3,0x55
+ 	movss	[edi+eax],xmm0
+ 	shufps	xmm0,xmm0,0x55
+ 	movss	[edi],xmm3
+ 	movss	[esi+eax],xmm0
+ 	movhlps	xmm0,xmm2
+ 	movss	[esi+eax*2],xmm2
+ 	shufps	xmm2,xmm2,0x55
+ 	movss	[edi+edx],xmm0
+ 	shufps	xmm0,xmm0,0x55
+ 	movss	[edi+eax*2],xmm2
+ 	lea	edi,[edi + eax*4] ; gi += (k1 * 4);
+ 	movss	[esi+edx],xmm0
+ 	lea	esi,[esi + eax*4] ; fi += (k1 * 4);
+ 	cmp	esi,ebp
+ 	jl	near .lp21		; while (fi<fn);
+ ; unrolldo loop43+4
+ 
+ ; forunrolling
+ ; kx=   2,   8,  32,  128
+ ; k4=  16,  64, 256, 1024
+ ;       0, 6/2,30/2,126/2
+ ; at here
+ ;	xmm6 = {--, --, s1, c1}
+ ;               c3 = c1; s3 = s1;
+ 	xor	ebx,ebx
+ 	mov	bl,4*4		; = i = 4
+ 	cmp	ebx,eax		; i < k1
+ 	jnl	near .F22
+ 
+ 	shufps	xmm6,xmm6,0x14	; = {c1, s1, s1, c1}
+ 	jmp	short .F220
+ 
+ 	align	16
+ ;               for (i=4;i<k1;i+=4){ // for (i=2;i<k1/2;i+=2){
+ .lp22:
+ 	shufps	xmm6,xmm6,0x69	; xmm6 = {c3, s3, s3, c3}
+ .F220:
+ ; at here, xmm6 is {c3, s3, s3, c3}
+ ;                       c1 = c3*t_c - s3*t_s;
+ ;                       s1 = c3*t_s + s3*t_c;
+ 	movss	xmm0,[costab_fft + ecx*4]
+ 	movss	xmm1,[sintab_fft + ecx*4]
+ 	shufps	xmm0,xmm1,0x00	; = {t_s, t_s, t_c, t_c}
+ 	mulps	xmm6,xmm0
+ 	movhlps	xmm4,xmm6
+ 	xorps	xmm4,[Q_MPMP]
+ 	subps	xmm6,xmm4	; = {--, --, s1, c1}
+ 
+ ;                       c3 = c1*t_c - s1*t_s;
+ ;                       s3 = s1*t_c + c1*t_s;
+ 	shufps	xmm6,xmm6,0x14	; = {c1, s1, s1, c1}
+ 	mulps	xmm0,xmm6
+ 	movhlps	xmm3,xmm0
+ 	xorps	xmm3,[Q_MPMP]
+ 	subps	xmm0,xmm3	; = {--, --, s3, c3}
+ 
+ 	unpcklps	xmm6,xmm0	; xmm6 = {s3, s1, c3, c1}
+ 	shufps	xmm6,xmm6,0xB4	; xmm6 = {s1, s3, c3, c1}
+ 
+ ;                       c2 = c1*c1 - s1*s1;
+ ;                       c4 = c3*c3 - s3*s3;
+ ;                       s4 = s3*c3 + s3*c3;
+ ;                       s2 = s1*c1 + s1*c1;
+ 	movaps	xmm7,xmm6
+ 	movaps	xmm4,xmm6
+ 	shufps	xmm7,xmm7,0x14
+ 	shufps	xmm4,xmm4,0xEB
+ 	xorps	xmm4,[Q_MMPP]	; = {-c3,-c1, s3, s1}
+ 	mulps	xmm7,xmm6
+ 	mulps	xmm4,xmm6
+ 	shufps	xmm4,xmm4,0x1B
+ 	addps	xmm7,xmm4	; xmm7 = {s2, s4, c4, c2}
+ 
+ ;                       fi = fz +i;
+ ;                       gi = fz +k1-i;
+ 	mov	edi,[esp+_P+4]	; = fz
+ 	mov	esi,ebx
+ 	shr	esi,1
+ 	sub	edi,esi		; edi = fz - i/2
+ 	lea	esi,[edi + ebx]	; esi = fi = fz +i/2
+ 	add	edi,eax		; edi = gi = fz +k1-i/2
+ 	sub	edi,4
+ ;                       do{
+ .lp220:
+ ; unrolldo loop51+4
+ ;                               a       = c2*fi[k1  ] + s2*gi[k1  ];
+ ;                               e       = c4*fi[k1+1] + s4*gi[k1-1];
+ ;                               f       = s4*fi[k1+1] - c4*gi[k1-1];
+ ;                               b       = s2*fi[k1  ] - c2*gi[k1  ];
+ ;                               c       = c2*fi[k3  ] + s2*gi[k3  ];
+ ;                               g       = c4*fi[k3+1] + s4*gi[k3-1];
+ ;                               h       = s4*fi[k3+1] - c4*gi[k3-1];
+ ;                               d       = s2*fi[k3  ] - c2*gi[k3  ];
+ 
+ 	movaps	xmm4,xmm7	; xmm7 = {s2, s4, c4, c2}
+ 	shufps	xmm4,xmm4,0x1B
+ 	xorps	xmm4,[Q_MMPP]
+ 	movlps	xmm0,[esi+eax]
+ 	movlps	xmm1,[edi+eax]
+ 	movlps	xmm2,[esi+edx]
+ 	movlps	xmm3,[edi+edx]
+ 	shufps	xmm0,xmm0,0x14
+ 	shufps	xmm1,xmm1,0x41
+ 	shufps	xmm2,xmm2,0x14
+ 	shufps	xmm3,xmm3,0x41
+ 	mulps	xmm0,xmm7
+ 	mulps	xmm1,xmm4
+ 	mulps	xmm2,xmm7
+ 	mulps	xmm3,xmm4
+ 	addps	xmm0,xmm1	; xmm0 = {b, f, e, a}
+ 	addps	xmm2,xmm3	; xmm2 = {d, h, g, c}
+ ;17
+ 
+ ;                               f0      = fi[0   ]    + a;
+ ;                               f4      = fi[0 +1]    + e;
+ ;                               g4      = gi[0 -1]    + f;
+ ;                               g0      = gi[0   ]    + b;
+ ;                               f1      = fi[0   ]    - a;
+ ;                               f5      = fi[0 +1]    - e;
+ ;                               g5      = gi[0 -1]    - f;
+ ;                               g1      = gi[0   ]    - b;
+ ;                               f2      = fi[k2  ]    + c;
+ ;                               f6      = fi[k2+1]    + g;
+ ;                               g6      = gi[k2-1]    + h;
+ ;                               g2      = gi[k2  ]    + d;
+ ;                               f3      = fi[k2  ]    - c;
+ ;                               f7      = fi[k2+1]    - g;
+ ;                               g7      = gi[k2-1]    - h;
+ ;                               g3      = gi[k2  ]    - d;
+ 	movlps	xmm4,[esi      ]
+ 	movhps	xmm4,[edi      ]
+ 	movaps	xmm1,xmm4
+ 	subps	xmm1,xmm0	; xmm1 = {g1, g5, f5, f1}
+ 	movlps	xmm5,[esi+eax*2]
+ 	movhps	xmm5,[edi+eax*2]
+ 	movaps	xmm3,xmm5
+ 	subps	xmm3,xmm2	; xmm3 = {g3, g7, f7, f3}
+ 	addps	xmm0,xmm4	; xmm0 = {g0, g4, f4, f0}
+ 	addps	xmm2,xmm5	; xmm2 = {g2, g6, f6, f2}
+ ;10
+ 
+ ;                               a       = c1*f2     + s1*g3;	* + *
+ ;                               e       = c3*f6     + s3*g7;
+ ;                               g       = s3*g6     + c3*f7;
+ ;                               c       = s1*g2     + c1*f3;
+ ;                               d       = c1*g2     - s1*f3;	* - *
+ ;                               h       = c3*g6     - s3*f7;
+ ;                               f       = s3*f6     - c3*g7;
+ ;                               b       = s1*f2     - c1*g3;
+ 
+ 	movaps	xmm5,xmm6	; xmm6 = {s1, s3, c3, c1}
+ 	shufps	xmm5,xmm5,0x1B	; = {c1, c3, s3, s1}
+ 	movaps	xmm4,xmm2
+ 	mulps	xmm4,xmm6
+ 	shufps	xmm2,xmm2,0x1B	; xmm2 = {f2, f6, g6, g2}
+ 	mulps	xmm2,xmm6
+ 	mulps	xmm5,xmm3
+ 	mulps	xmm3,xmm6
+ 	shufps	xmm3,xmm3,0x1B
+ 	addps	xmm4,xmm3	; = {c, g, e, a}
+ 	subps	xmm2,xmm5	; = {b, f, h, d}
+ ;10
+ 
+ ;                               fi[0   ]  = f0        + a;
+ ;                               fi[0 +1]  = f4        + e;
+ ;                               gi[0 -1]  = g4        + g;
+ ;                               gi[0   ]  = g0        + c;
+ ;                               fi[k2  ]  = f0        - a;
+ ;                               fi[k2+1]  = f4        - e;
+ ;                               gi[k2-1]  = g4        - g;
+ ;                               gi[k2  ]  = g0        - c;
+ ;                               fi[k1  ]  = f1        + d;
+ ;                               fi[k1+1]  = f5        + h;
+ ;                               gi[k1-1]  = g5        + f;
+ ;                               gi[k1  ]  = g1        + b;
+ ;                               fi[k3  ]  = f1        - d;
+ ;                               fi[k3+1]  = f5        - h;
+ ;                               gi[k3-1]  = g5        - f;
+ ;                               gi[k3  ]  = g1        - b;
+ 	movaps	xmm3,xmm0
+ 	subps	xmm0,xmm4
+ 	movlps	[esi+eax*2],xmm0
+ 	movhps	[edi+eax*2],xmm0
+ 	addps	xmm4,xmm3
+ 	movlps	[esi      ],xmm4
+ 	movhps	[edi      ],xmm4
+ 
+ 	movaps	xmm5,xmm1
+ 	subps	xmm1,xmm2
+ 	movlps	[esi+edx  ],xmm1
+ 	movhps	[edi+edx  ],xmm1
+ 	addps	xmm2,xmm5
+ 	movlps	[esi+eax  ],xmm2
+ 	movhps	[edi+eax  ],xmm2
+ ; 14
+ ;                               gi     += k4;
+ ;                               fi     += k4;
+ 	lea	edi,[edi + eax*4] ; gi += (k1 * 4);
+ 	lea	esi,[esi + eax*4] ; fi += (k1 * 4);
+ 	cmp	esi,ebp
+ 	jl	near .lp220		; while (fi<fn);
+ ;                       } while (fi<fn);
+ 
+ 	add	ebx,4*4		; i+= 4
+ 	cmp	ebx,eax		; i < k1
+ 	jl	near .lp22
+ ;               }
+ .F22:
+ 
+ 	cmp	eax,[esp+_P+8]	; while ((k1 * 4)<n);
+ 	jl	near .lp2
+ 
+ 	pop	ebp
+ 	pop	edi
+ 	pop	esi
+ 	pop	ebx
+ 	ret
+ 
+ ;------------------------------------------------------------------------
+ ;	99/11/12	Initial version for SSE by K. SAKAI, 4300clk@P3
+ ; This routine is very slow when wsamp_r_int is not aligned to 16byte boundary.
+ ;
+ ;void fft_side_SSE( float in[2][1024], int s, float *ret)
+ ;        energy = (in[0][512] - in[1][512])^2;
+ ;        energy = (in[0][1024-s] - in[1][1024-s])^2;
+ ;        for (i=s,j=1024-s;i<512;i++,j--){
+ ;                a = in[0][i] - in[1][i];
+ ;                energy += a*a;
+ ;                b = in[0][j-1] - in[1][j-1];
+ ;                energy += b*b;
+ ;        }
+ ;        *ret = energy * 0.25;
+ 
+ 	align	16
+ fft_side_SSE:
+ 	mov	ecx,[esp+8]	; = i = s
+ 	mov	edx,1024
+ 	sub	edx,ecx		; = j
+ 	mov	eax,[esp+4]	; = in
+ 	movss	xmm7,[eax+1024*0*4+512*4]
+ 	movss	xmm1,[eax+1024*1*4+512*4]
+ 	subss	xmm7,xmm1
+ 	mulss	xmm7,xmm7
+ 	movss	xmm2,[eax+1024*0*4+edx*4]
+ 	movss	xmm3,[eax+1024*1*4+edx*4]
+ 	subss	xmm2,xmm3
+ 	mulss	xmm2,xmm2
+ 	addss	xmm7,xmm2
+ 
+ 	test	cl,1
+ 	jz	.even
+ 
+ .odd:	dec	edx
+ 	movss	xmm0,[eax+1024*0*4+ecx*4]
+ 	movss	xmm1,[eax+1024*1*4+ecx*4]
+ 	inc	ecx
+ 	movss	xmm2,[eax+1024*0*4+edx*4]
+ 	movss	xmm3,[eax+1024*1*4+edx*4]
+ 	cmp	ecx,edx
+ 	subss	xmm0,xmm1
+ 	subss	xmm2,xmm3
+ 	mulss	xmm0,xmm0
+ 	mulss	xmm2,xmm2
+ 	addss	xmm7,xmm0
+ 	addss	xmm7,xmm2
+ 	je	near .exit1
+ 
+ .even:	test	cl,2
+ 	jz	.f0
+ 	sub	edx,2
+ 	movlps	xmm0,[eax+1024*0*4+ecx*4]
+ 	movlps	xmm1,[eax+1024*1*4+ecx*4]
+ 	add	ecx,2
+ 	movhps	xmm0,[eax+1024*0*4+edx*4]
+ 	movhps	xmm1,[eax+1024*1*4+edx*4]
+ 	cmp	ecx,edx
+ 	subps	xmm0,xmm1
+ 	mulps	xmm0,xmm0
+ 	addps	xmm7,xmm0
+ 	je	.exit4
+ 	jmp	short .f0
+ 
+ 	align	16
+ .f0:
+ .lp0:
+ 	sub	edx,4
+ 	movaps	xmm0,[eax+1024*0*4+ecx*4]
+ 	movaps	xmm1,[eax+1024*1*4+ecx*4]
+ 	add	ecx,4
+ 	subps	xmm0,xmm1
+ 	mulps	xmm0,xmm0
+ 	addps	xmm7,xmm0
+ 	movaps	xmm2,[eax+1024*0*4+edx*4]
+ 	movaps	xmm3,[eax+1024*1*4+edx*4]
+ 	cmp	ecx,edx
+ 	subps	xmm2,xmm3
+ 	mulps	xmm2,xmm2
+ 	addps	xmm7,xmm2
+ 	jne	.lp0
+ 
+ .exit4:	movhlps	xmm6,xmm7
+ 	addps	xmm7,xmm6
+ 	movaps	xmm6,xmm7
+ 	shufps	xmm6,xmm6,01010101B
+ 	addss	xmm7,xmm6
+ 
+ .exit1:	mulss	xmm7,[S_025]
+ 	mov	eax,[esp+12]
+ 	movss	[eax],xmm7
+ 	ret
+ 
+ 
+ 	end
diff -r -c -N encoder/i386/ffttbl.nas lame3.70/i386/ffttbl.nas
*** encoder/i386/ffttbl.nas	Wed Dec 31 17:00:00 1969
--- lame3.70/i386/ffttbl.nas	Sun Jan 30 15:53:49 2000
***************
*** 0 ****
--- 1,78 ----
+ 
+ ;	for new GOGO-no-coda (1999/09)
+ ;	Copyright (C) 1999 shigeo
+ ;	special thanks to URURI, Keiichi SAKAI
+ 
+ 
+ ;	fft sin,cos,gray
+ ;	99/08/21
+ ;	99/09/01()
+ ;	99/09/14 
+ 
+ %include "nasm.h"
+ 
+ 	globaldef	costab_fft
+ 	globaldef	sintab_fft
+ 	globaldef	gray_index
+ 
+ 	segment_data
+ 	align 16
+ 
+ costab_fft:
+ 	dd 0.000000000000
+ 	dd 0.707106781187
+ 	dd 0.923879532511
+ 	dd 0.980785280403
+ 	dd 0.995184726672
+ 	dd 0.998795456205
+ 	dd 0.999698818696
+ 	dd 0.999924701839
+ 	dd 0.999981175283
+ 	dd 0.999995293810
+ 	dd 0.999998823452
+ 	dd 0.999999705863
+ 	dd 0.999999926466
+ 	dd 0.999999981616
+ 	dd 0.999999995404
+ 	dd 0.999999998851
+ 
+ sintab_fft:
+ 	dd 1.000000000000
+ 	dd 0.707106781187
+ 	dd 0.382683432365
+ 	dd 0.195090322016
+ 	dd 0.098017140330
+ 	dd 0.049067674327
+ 	dd 0.024541228523
+ 	dd 0.012271538286
+ 	dd 0.006135884649
+ 	dd 0.003067956763
+ 	dd 0.001533980186
+ 	dd 0.000766990319
+ 	dd 0.000383495188
+ 	dd 0.000191747597
+ 	dd 0.000095873799
+ 	dd 0.000047936900
+ 
+ 		align 16
+ gray_index:
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 7
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 8
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 7
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 9
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 7
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 8
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 7
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 6
+ 		db	2, 3, 2, 4, 2, 3, 2, 5, 2, 3, 2, 4, 2, 3, 2, 10
+ 
+ 	segment_code
+ 
+ 	end
diff -r -c -N encoder/id3tag.c lame3.70/id3tag.c
*** encoder/id3tag.c	Wed Dec 31 17:00:00 1969
--- lame3.70/id3tag.c	Sun Mar  5 11:37:28 2000
***************
*** 0 ****
--- 1,112 ----
+ /*
+  * functions for writing ID3 tags in LAME
+  *
+  * text functions stolen from mp3info by Ricardo Cerqueira <rmc@rccn.net>
+  * adapted for LAME by Conrad Sanderson <c.sanderson@me.gu.edu.au>
+  *
+  * 
+  */ 
+  
+ #include <stdio.h>
+ #include <string.h>
+ #include "id3tag.h"
+ ID3TAGDATA id3tag;
+  
+ /*
+  * If "string" is shorter than "length", pad it with ' ' (spaces)
+  */
+ 
+ static void id3_pad(char *string, int length) {
+ 	int l;  l=strlen(string);
+ 	
+ 	while(l<length) { string[l] = ' '; l++; }
+ 	string[l]='\0';
+ 	}
+ 
+ 
+ /*
+  * initialize temporary fields
+  */
+ 
+ void id3_inittag(ID3TAGDATA *tag) {
+ 	strcpy( tag->title, "");
+ 	strcpy( tag->artist, "");
+ 	strcpy( tag->album, "");
+ 	strcpy( tag->year, "");    
+ 	strcpy( tag->comment, "");
+ 	strcpy( tag->genre, "");	/* unset genre */
+ 	tag->track = 0;
+ 
+ 	tag->valid = 0;		/* not ready for writing*/
+ 	}
+ 
+ /*
+  * build an ID3 tag from temporary fields
+  */
+ 
+ void id3_buildtag(ID3TAGDATA *tag) {
+ 	strcpy(tag->tagtext,"TAG");
+ 
+ 	id3_pad( tag->title, 30);   strncat( tag->tagtext, tag->title,30);
+ 	id3_pad( tag->artist, 30);  strncat( tag->tagtext, tag->artist,30);
+ 	id3_pad( tag->album, 30);   strncat( tag->tagtext, tag->album,30);
+ 	id3_pad( tag->year, 4);     strncat( tag->tagtext, tag->year,4);
+ 	id3_pad( tag->comment, 30); strncat( tag->tagtext, tag->comment,30);
+ 	id3_pad( tag->genre, 1);    strncat( tag->tagtext, tag->genre,1);
+ 
+ 	if( tag->track != 0 ) {
+ 		tag->tagtext[125] = '\0';
+ 		tag->tagtext[126] = tag->track;
+ 	}
+ 	tag->valid = 1;		/* ready for writing*/
+ 	}
+ 
+ /*
+  * write ID3 tag 
+  */
+ 
+ int id3_writetag(char* filename, ID3TAGDATA *tag) {
+ 	FILE* f;
+ 	if( ! tag->valid ) return -1;
+ 
+ 	f=fopen(filename,"rb+");	if(!f) return -1;
+ 
+ 	fseek(f,0,SEEK_END); fwrite(tag->tagtext,1,128,f);
+ 	fclose(f); return 0;
+ 	}
+ 
+ 
+ 
+ 
+ 
+ int genre_last=147;
+ char *genre_list[]={
+ 	"Blues", "Classic Rock", "Country", "Dance", "Disco", "Funk",
+ 	"Grunge", "Hip-Hop", "Jazz", "Metal", "New Age", "Oldies",
+ 	"Other", "Pop", "R&B", "Rap", "Reggae", "Rock",
+ 	"Techno", "Industrial", "Alternative", "Ska", "Death Metal", "Pranks",
+ 	"Soundtrack", "Euro-Techno", "Ambient", "Trip-Hop", "Vocal", "Jazz+Funk",
+ 	"Fusion", "Trance", "Classical", "Instrumental", "Acid", "House",
+ 	"Game", "Sound Clip", "Gospel", "Noise", "AlternRock", "Bass",
+ 	"Soul", "Punk", "Space", "Meditative", "Instrumental Pop", "Instrumental Rock",
+ 	"Ethnic", "Gothic", "Darkwave", "Techno-Industrial", "Electronic", "Pop-Folk",
+ 	"Eurodance", "Dream", "Southern Rock", "Comedy", "Cult", "Gangsta",
+ 	"Top 40", "Christian Rap", "Pop/Funk", "Jungle", "Native American", "Cabaret",
+ 	"New Wave", "Psychadelic", "Rave", "Showtunes", "Trailer", "Lo-Fi",
+ 	"Tribal", "Acid Punk", "Acid Jazz", "Polka", "Retro", "Musical",
+ 	"Rock & Roll", "Hard Rock", "Folk", "Folk/Rock", "National Folk", "Swing",
+ 	"Fast-Fusion", "Bebob", "Latin", "Revival", "Celtic", "Bluegrass", "Avantgarde",
+ 	"Gothic Rock", "Progressive Rock", "Psychedelic Rock", "Symphonic Rock", "Slow Rock", "Big Band",
+ 	"Chorus", "Easy Listening", "Acoustic", "Humour", "Speech", "Chanson",
+ 	"Opera", "Chamber Music", "Sonata", "Symphony", "Booty Bass", "Primus",
+ 	"Porn Groove", "Satire", "Slow Jam", "Club", "Tango", "Samba",
+ 	"Folklore", "Ballad", "Power Ballad", "Rhythmic Soul", "Freestyle", "Duet",
+ 	"Punk Rock", "Drum Solo", "A capella", "Euro-House", "Dance Hall",
+ 	"Goa", "Drum & Bass", "Club House", "Hardcore", "Terror",
+ 	"Indie", "BritPop", "NegerPunk", "Polsk Punk", "Beat",
+ 	"Christian Gangsta", "Heavy Metal", "Black Metal", "Crossover", "Contemporary C",
+ 	"Christian Rock", "Merengue", "Salsa", "Thrash Metal", "Anime", "JPop",
+ 	"SynthPop",
+ };
+ 
+ 
diff -r -c -N encoder/id3tag.h lame3.70/id3tag.h
*** encoder/id3tag.h	Wed Dec 31 17:00:00 1969
--- lame3.70/id3tag.h	Mon Mar  6 12:53:03 2000
***************
*** 0 ****
--- 1,29 ----
+ #ifndef ID3TAG_H_INCLUDED
+ #define ID3TAG_H_INCLUDED
+ typedef struct
+ {
+ 	int used;
+ 	int valid;
+ 	char title[31];
+ 	char artist[31];
+ 	char album[31];
+ 	char year[5];
+ 	char comment[31];
+ 	char tagtext[128];
+ 	char genre[1];
+ 	unsigned char track;
+ 
+ }   ID3TAGDATA;
+ 
+ void id3_inittag(ID3TAGDATA *tag);
+ void id3_buildtag(ID3TAGDATA *tag);
+ int id3_writetag(char* filename, ID3TAGDATA *tag);
+ 
+ 
+ /*
+  * Array of all possible music genre. Grabbed from id3ed
+  */
+ extern ID3TAGDATA id3tag;          /* id3tag info */
+ extern int genre_last;
+ extern char *genre_list[];
+ #endif
diff -r -c -N encoder/ieeefloat.c lame3.70/ieeefloat.c
*** encoder/ieeefloat.c	Wed Jan 22 02:43:17 1997
--- lame3.70/ieeefloat.c	Mon Feb 21 16:05:05 2000
***************
*** 41,54 ****
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: ieeefloat.c,v 1.1 1993/06/11 17:45:46 malcolm Exp $
   *
   * $Log: ieeefloat.c,v $
   * Revision 1.1  1993/06/11  17:45:46  malcolm
   * Initial revision
   *
   */
  
  #include	<stdio.h>
  #include	<math.h>
  #include	"ieeefloat.h"
--- 41,65 ----
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: ieeefloat.c,v 1.3 2000/02/21 23:05:05 markt Exp $
   *
   * $Log: ieeefloat.c,v $
+  * Revision 1.3  2000/02/21 23:05:05  markt
+  * some 64bit DEC Alpha patches
+  *
+  * Revision 1.2  2000/02/19 13:32:30  afaber
+  * Fixed many warning messages when compiling with MSVC
+  *
+  * Revision 1.1.1.1  1999/11/24 08:42:58  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 1.1  1993/06/11  17:45:46  malcolm
   * Initial revision
   *
   */
  
+ #include        <limits.h>
  #include	<stdio.h>
  #include	<math.h>
  #include	"ieeefloat.h"
***************
*** 82,89 ****
  
  
  defdouble
! ConvertFromIeeeSingle(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	mantissa, expon;
--- 93,99 ----
  
  
  defdouble
! ConvertFromIeeeSingle(char* bytes)
  {
  	defdouble	f;
  	long	mantissa, expon;
***************
*** 106,121 ****
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (bits & 0x7fffff);
! 				f = ldexp((defdouble)mantissa, expon - SEXP_OFFSET - SEXP_POSITION + 1);
  			}
  			else {				/* Normalized number */
  				mantissa = (bits & 0x7fffff) + 0x800000;	/* Insert hidden bit */
! 				f = ldexp((defdouble)mantissa, expon - SEXP_OFFSET - SEXP_POSITION);
  			}
  		}
  	}
  
! 	if (bits & 0x80000000)
  		return -f;
  	else
  		return f;
--- 116,131 ----
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (bits & 0x7fffff);
! 				f = ldexp((defdouble) mantissa, (int) (expon - SEXP_OFFSET - SEXP_POSITION + 1));
  			}
  			else {				/* Normalized number */
  				mantissa = (bits & 0x7fffff) + 0x800000;	/* Insert hidden bit */
! 				f = ldexp((defdouble) mantissa, (int) (expon - SEXP_OFFSET - SEXP_POSITION));
  			}
  		}
  	}
  
! 	if (bits & LONG_MIN)
  		return -f;
  	else
  		return f;
***************
*** 126,140 ****
  
  
  void
! ConvertToIeeeSingle(num, bytes)
! defdouble num;
! char* bytes;
  {
  	long	sign;
  	register long bits;
  
  	if (num < 0) {	/* Can't distinguish a negative zero */
! 		sign = 0x80000000;
  		num *= -1;
  	} else {
  		sign = 0;
--- 136,148 ----
  
  
  void
! ConvertToIeeeSingle(defdouble num, char* bytes)
  {
  	long	sign;
  	register long bits;
  
  	if (num < 0) {	/* Can't distinguish a negative zero */
! 		sign = LONG_MIN;
  		num *= -1;
  	} else {
  		sign = 0;
***************
*** 177,186 ****
  		}
  	}
  
! 	bytes[0] = bits >> 24;	/* Copy to byte string */
! 	bytes[1] = bits >> 16;
! 	bytes[2] = bits >> 8;
! 	bytes[3] = bits;
  }
  
  
--- 185,194 ----
  		}
  	}
  
! 	bytes[0] = (char)(bits >> 24);	/* Copy to byte string */
! 	bytes[1] = (char)(bits >> 16);
! 	bytes[2] = (char)(bits >> 8);
! 	bytes[3] = (char)(bits);
  }
  
  
***************
*** 195,202 ****
  
  
  defdouble
! ConvertFromIeeeDouble(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	mantissa, expon;
--- 203,209 ----
  
  
  defdouble
! ConvertFromIeeeDouble(char* bytes)
  {
  	defdouble	f;
  	long	mantissa, expon;
***************
*** 223,235 ****
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (first & 0x000FFFFF);
! 				f = ldexp((defdouble)mantissa, expon - DEXP_OFFSET - DEXP_POSITION + 1);
! 				f += ldexp(UnsignedToFloat(second), expon - DEXP_OFFSET - DEXP_POSITION + 1 - 32);
  			}
  			else {				/* Normalized number */
  				mantissa = (first & 0x000FFFFF) + 0x00100000;	/* Insert hidden bit */
! 				f = ldexp((defdouble)mantissa, expon - DEXP_OFFSET - DEXP_POSITION);
! 				f += ldexp(UnsignedToFloat(second), expon - DEXP_OFFSET - DEXP_POSITION - 32);
  			}
  		}
  	}
--- 230,242 ----
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (first & 0x000FFFFF);
! 				f = ldexp((defdouble) mantissa, (int) (expon - DEXP_OFFSET - DEXP_POSITION + 1));
! 				f += ldexp(UnsignedToFloat(second), (int) (expon - DEXP_OFFSET - DEXP_POSITION + 1 - 32));
  			}
  			else {				/* Normalized number */
  				mantissa = (first & 0x000FFFFF) + 0x00100000;	/* Insert hidden bit */
! 				f = ldexp((defdouble) mantissa, (int) (expon - DEXP_OFFSET - DEXP_POSITION));
! 				f += ldexp(UnsignedToFloat(second), (int) (expon - DEXP_OFFSET - DEXP_POSITION - 32));
  			}
  		}
  	}
***************
*** 245,259 ****
  
  
  void
! ConvertToIeeeDouble(num, bytes)
! defdouble num;
! char *bytes;
  {
  	long	sign;
  	long	first, second;
  
  	if (num < 0) {	/* Can't distinguish a negative zero */
! 		sign = 0x80000000;
  		num *= -1;
  	} else {
  		sign = 0;
--- 252,264 ----
  
  
  void
! ConvertToIeeeDouble(defdouble num, char *bytes)
  {
  	long	sign;
  	long	first, second;
  
  	if (num < 0) {	/* Can't distinguish a negative zero */
! 		sign = LONG_MIN;
  		num *= -1;
  	} else {
  		sign = 0;
***************
*** 310,323 ****
  		}
  	}
  	
! 	bytes[0] = first >> 24;
! 	bytes[1] = first >> 16;
! 	bytes[2] = first >> 8;
! 	bytes[3] = first;
! 	bytes[4] = second >> 24;
! 	bytes[5] = second >> 16;
! 	bytes[6] = second >> 8;
! 	bytes[7] = second;
  }
  
  
--- 315,328 ----
  		}
  	}
  	
! 	bytes[0] = (char)(first >> 24);
! 	bytes[1] = (char)(first >> 16);
! 	bytes[2] = (char)(first >> 8);
! 	bytes[3] = (char)(first);
! 	bytes[4] = (char)(second >> 24);
! 	bytes[5] = (char)(second >> 16);
! 	bytes[6] = (char)(second >> 8);
! 	bytes[7] = (char)(second);
  }
  
  
***************
*** 326,333 ****
   ****************************************************************/
  
  defdouble
! ConvertFromIeeeExtended(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	expon;
--- 331,337 ----
   ****************************************************************/
  
  defdouble
! ConvertFromIeeeExtended(char* bytes)
  {
  	defdouble	f;
  	long	expon;
***************
*** 359,366 ****
  		}
  		else {
  			expon -= 16383;
! 			f  = ldexp(UnsignedToFloat(hiMant), expon-=31);
! 			f += ldexp(UnsignedToFloat(loMant), expon-=32);
  		}
  	}
  
--- 363,370 ----
  		}
  		else {
  			expon -= 16383;
! 			f  = ldexp(UnsignedToFloat(hiMant), (int) (expon -= 31));
! 			f += ldexp(UnsignedToFloat(loMant), (int) (expon -= 32));
  		}
  	}
  
***************
*** 375,383 ****
  
  
  void
! ConvertToIeeeExtended(num, bytes)
! defdouble num;
! char *bytes;
  {
  	int	sign;
  	int expon;
--- 379,385 ----
  
  
  void
! ConvertToIeeeExtended(defdouble num, char *bytes)
  {
  	int	sign;
  	int expon;
***************
*** 413,426 ****
  	
  	bytes[0] = expon >> 8;
  	bytes[1] = expon;
! 	bytes[2] = hiMant >> 24;
! 	bytes[3] = hiMant >> 16;
! 	bytes[4] = hiMant >> 8;
! 	bytes[5] = hiMant;
! 	bytes[6] = loMant >> 24;
! 	bytes[7] = loMant >> 16;
! 	bytes[8] = loMant >> 8;
! 	bytes[9] = loMant;
  }
  
  /****************************************************************
--- 415,428 ----
  	
  	bytes[0] = expon >> 8;
  	bytes[1] = expon;
! 	bytes[2] = (char)(hiMant >> 24);
! 	bytes[3] = (char)(hiMant >> 16);
! 	bytes[4] = (char)(hiMant >> 8);
! 	bytes[5] = (char)(hiMant);
! 	bytes[6] = (char)(loMant >> 24);
! 	bytes[7] = (char)(loMant >> 16);
! 	bytes[8] = (char)(loMant >> 8);
! 	bytes[9] = (char)(loMant);
  }
  
  /****************************************************************
***************
*** 467,474 ****
  
  
  int
! GetHexValue(x)
! register int x;
  {
  	x &= 0x7F;
  	
--- 469,475 ----
  
  
  int
! GetHexValue(register int x)
  {
  	x &= 0x7F;
  	
***************
*** 486,493 ****
  
  
  void
! Hex2Bytes(hex, bytes)
! register char *hex, *bytes;
  {
  	for ( ; *hex; hex += 2) {
  		*bytes++ = (GetHexValue(hex[0]) << 4) | GetHexValue(hex[1]);
--- 487,493 ----
  
  
  void
! Hex2Bytes(register char *hex, register char *bytes)
  {
  	for ( ; *hex; hex += 2) {
  		*bytes++ = (GetHexValue(hex[0]) << 4) | GetHexValue(hex[1]);
***************
*** 498,505 ****
  
  
  int
! GetHexSymbol(x)
! register int x;
  {
  	x &= 0xF;
  	if (x <= 9)
--- 498,504 ----
  
  
  int
! GetHexSymbol(register int x)
  {
  	x &= 0xF;
  	if (x <= 9)
***************
*** 511,519 ****
  
  
  void
! Bytes2Hex(bytes, hex, nBytes)
! register char *bytes, *hex;
! register int nBytes;
  {
  	for ( ; nBytes--; bytes++) {
  		*hex++ = GetHexSymbol(*bytes >> 4);
--- 510,516 ----
  
  
  void
! Bytes2Hex(register char *bytes, register char *hex, register int nBytes)
  {
  	for ( ; nBytes--; bytes++) {
  		*hex++ = GetHexSymbol(*bytes >> 4);
***************
*** 524,532 ****
  
  
  void
! MaybeSwapBytes(bytes, nBytes)
! char* bytes;
! int nBytes;
  {
  #ifdef LITTLE_ENDIAN
  	register char *p, *q, t;
--- 521,527 ----
  
  
  void
! MaybeSwapBytes(char* bytes, int nBytes)
  {
  #ifdef LITTLE_ENDIAN
  	register char *p, *q, t;
***************
*** 543,550 ****
  
  
  float
! MachineIEEESingle(bytes)
! char* bytes;
  {
  	float t;
  	MaybeSwapBytes(bytes, 4);
--- 538,544 ----
  
  
  float
! MachineIEEESingle(char* bytes)
  {
  	float t;
  	MaybeSwapBytes(bytes, 4);
***************
*** 555,562 ****
  
  
  Double
! MachineIEEEDouble(bytes)
! char* bytes;
  {
  	Double t;
  	MaybeSwapBytes(bytes, 8);
--- 549,555 ----
  
  
  Double
! MachineIEEEDouble(char* bytes)
  {
  	Double t;
  	MaybeSwapBytes(bytes, 8);
***************
*** 567,574 ****
  
  
  void
! TestFromIeeeSingle(hex)
! char *hex;
  {
  	defdouble f;
  	union SParts p;
--- 560,566 ----
  
  
  void
! TestFromIeeeSingle(char *hex)
  {
  	defdouble f;
  	union SParts p;
***************
*** 589,596 ****
  
  
  void
! TestToIeeeSingle(f)
! defdouble f;
  {
  	union SParts p;
  	char bytes[4];
--- 581,587 ----
  
  
  void
! TestToIeeeSingle(defdouble f)
  {
  	union SParts p;
  	char bytes[4];
***************
*** 613,620 ****
  
  
  void
! TestFromIeeeDouble(hex)
! char *hex;
  {
  	defdouble f;
  	union DParts p;
--- 604,610 ----
  
  
  void
! TestFromIeeeDouble(char *hex)
  {
  	defdouble f;
  	union DParts p;
***************
*** 636,643 ****
  }
  
  void
! TestToIeeeDouble(f)
! defdouble f;
  {
  	union DParts p;
  	char bytes[8];
--- 626,632 ----
  }
  
  void
! TestToIeeeDouble(defdouble f)
  {
  	union DParts p;
  	char bytes[8];
***************
*** 663,670 ****
  
  
  void
! TestFromIeeeExtended(hex)
! char *hex;
  {
  	defdouble f;
  	union EParts p;
--- 652,658 ----
  
  
  void
! TestFromIeeeExtended(char *hex)
  {
  	defdouble f;
  	union EParts p;
***************
*** 701,708 ****
  
  
  void
! TestToIeeeExtended(f)
! defdouble f;
  {
  	char bytes[12];
  	char hex[24+1];
--- 689,695 ----
  
  
  void
! TestToIeeeExtended(defdouble f)
  {
  	char bytes[12];
  	char hex[24+1];
***************
*** 736,751 ****
  
  #include	<signal.h>
  
! void SignalFPE(i, j)
! int	i;
! void (*j)();
  {
  	printf("[Floating Point Interrupt Caught.]\n", i, j);
  	signal(SIGFPE, SignalFPE);
  }
  	
  void
! main()
  {
  	long d[3];
  	char bytes[12];
--- 723,736 ----
  
  #include	<signal.h>
  
! void SignalFPE(int i, void (*j)())
  {
  	printf("[Floating Point Interrupt Caught.]\n", i, j);
  	signal(SIGFPE, SignalFPE);
  }
  	
  void
! main(void)
  {
  	long d[3];
  	char bytes[12];
diff -r -c -N encoder/ieeefloat.h lame3.70/ieeefloat.h
*** encoder/ieeefloat.h	Wed Jan 22 02:43:17 1997
--- lame3.70/ieeefloat.h	Wed Nov 24 01:42:58 1999
***************
*** 43,51 ****
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: ieeefloat.h,v 1.1 1993/06/11 17:45:46 malcolm Exp $
   *
   * $Log: ieeefloat.h,v $
   * Revision 1.1  1993/06/11  17:45:46  malcolm
   * Initial revision
   *
--- 43,55 ----
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: ieeefloat.h,v 1.1.1.1 1999/11/24 08:42:58 markt Exp $
   *
   * $Log: ieeefloat.h,v $
+  * Revision 1.1.1.1  1999/11/24 08:42:58  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 1.1  1993/06/11  17:45:46  malcolm
   * Initial revision
   *
diff -r -c -N encoder/l3bitstream-pvt.h lame3.70/l3bitstream-pvt.h
*** encoder/l3bitstream-pvt.h	Wed Jan 22 02:43:15 1997
--- lame3.70/l3bitstream-pvt.h	Thu Apr  6 12:50:49 2000
***************
*** 2,10 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3bitstream-pvt.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
   *
   * $Log: l3bitstream-pvt.h,v $
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
--- 2,23 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3bitstream-pvt.h,v 1.4 2000/03/21 23:02:17 markt Exp $
   *
   * $Log: l3bitstream-pvt.h,v $
+  * Revision 1.4  2000/03/21 23:02:17  markt
+  * replaced all "gf." by gfp->
+  *
+  * Revision 1.3  2000/02/01 11:26:32  takehiro
+  * scalefactor's structure changed
+  *
+  * Revision 1.2  1999/12/09 00:44:34  cisc
+  * Removed write_ancillary_data() prototype. (No longer used)
+  *
+  * Revision 1.1.1.1  1999/11/24 08:42:59  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
***************
*** 14,26 ****
  #ifndef L3BITSTREAM_PVT_H
  #define L3BITSTREAM_PVT_H
  
! static int encodeSideInfo( III_side_info_t  *si );
  
! static void encodeMainData( int              l3_enc[2][2][576],
  			    III_side_info_t  *si,
! 			    III_scalefac_t   *scalefac );
! 
! static void write_ancillary_data( char *theData, int lengthInBits );
  
  static void drain_into_ancillary_data( int lengthInBits );
  
--- 27,38 ----
  #ifndef L3BITSTREAM_PVT_H
  #define L3BITSTREAM_PVT_H
  
! static int encodeSideInfo( lame_global_flags *gfp,III_side_info_t  *si );
  
! static void encodeMainData( lame_global_flags *gfp,
! 			    int              l3_enc[2][2][576],
  			    III_side_info_t  *si,
! 			    III_scalefac_t   scalefac[2][2] );
  
  static void drain_into_ancillary_data( int lengthInBits );
  
diff -r -c -N encoder/l3bitstream.c lame3.70/l3bitstream.c
*** encoder/l3bitstream.c	Wed Jan 22 02:43:15 1997
--- lame3.70/l3bitstream.c	Thu Apr  6 12:50:49 2000
***************
*** 2,14 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
-  * $Id: l3bitstream.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: l3bitstream.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
   **********************************************************************/
  /*
    Revision History:
--- 2,7 ----
***************
*** 20,36 ****
  */
  
  #include <stdlib.h>
  #include "l3bitstream.h" /* the public interface */
! #include "l3psy.h"
! #include "mdct.h"
! #include "loop.h"
  #include "formatBitstream.h"
! #include "huffman.h"
  #include <assert.h>
  #include "l3bitstream-pvt.h"
  
- static int stereo = 1;
- static frame_params *fr_ps  = NULL;
  static Bit_stream_struc *bs = NULL;
  
  BF_FrameData    *frameData    = NULL;
--- 13,28 ----
  */
  
  #include <stdlib.h>
+ #include "lame.h"
  #include "l3bitstream.h" /* the public interface */
! #include "encoder.h"
! #include "quantize.h"
! #include "quantize-pvt.h"
  #include "formatBitstream.h"
! #include "tables.h"
  #include <assert.h>
  #include "l3bitstream-pvt.h"
  
  static Bit_stream_struc *bs = NULL;
  
  BF_FrameData    *frameData    = NULL;
***************
*** 48,54 ****
  BF_PartHolder *userFrameDataPH;
  
  
! void putMyBits( uint32 val, uint16 len )
  {
      putbits( bs, val, len );
  }
--- 40,46 ----
  BF_PartHolder *userFrameDataPH;
  
  
! void putMyBits( u_int val, u_int len )
  {
      putbits( bs, val, len );
  }
***************
*** 65,99 ****
    */
  
  void
! III_format_bitstream( int              bitsPerFrame,
! 		      frame_params     *in_fr_ps,
  		      int              l3_enc[2][2][576],
  		      III_side_info_t  *l3_side,
! 		      III_scalefac_t   *scalefac,
! 		      Bit_stream_struc *in_bs,
! 		      double           (*xr)[2][576],
! 		      char             *ancillary,
! 		      int              ancillary_bits )
  {
!     int gr, ch, i, mode_gr;
!     fr_ps = in_fr_ps;
      bs = in_bs;
!     stereo = fr_ps->stereo;
!     mode_gr = (fr_ps->header->version == 1) ? 2 : 1;
!     
      if ( frameData == NULL )
      {
! 	frameData = calloc( 1, sizeof(*frameData) );
  	assert( frameData );
      }
      if ( frameResults == NULL )
      {
! 	frameResults = calloc( 1, sizeof(*frameData) );
! 	assert( frameData );
      }
      if ( !PartHoldersInitialized )
      {
! 	headerPH = BF_newPartHolder( 12 );
  	frameSIPH = BF_newPartHolder( 12 );
  
  	for ( ch = 0; ch < MAX_CHANNELS; ch++ )
--- 57,86 ----
    */
  
  void
! III_format_bitstream( lame_global_flags *gfp,
!                       int              bitsPerFrame,
  		      int              l3_enc[2][2][576],
  		      III_side_info_t  *l3_side,
! 		      III_scalefac_t   scalefac[2][2],
! 		      Bit_stream_struc *in_bs)
  {
!     int gr, ch;
      bs = in_bs;
! 
      if ( frameData == NULL )
      {
! 	frameData = calloc( 1,sizeof *frameData);
  	assert( frameData );
      }
      if ( frameResults == NULL )
      {
! 	frameResults = calloc( 1,sizeof *frameResults);
! 	assert( frameResults );
      }
+ 
      if ( !PartHoldersInitialized )
      {
! 	headerPH = BF_newPartHolder( 14 ); 
  	frameSIPH = BF_newPartHolder( 12 );
  
  	for ( ch = 0; ch < MAX_CHANNELS; ch++ )
***************
*** 111,152 ****
  	PartHoldersInitialized = 1;
      }
  
! #if 1
!     for ( gr = 0; gr < mode_gr; gr++ )
! 	for ( ch =  0; ch < stereo; ch++ )
! 	{
! 	    int *pi = &l3_enc[gr][ch][0];
! 	    double *pr = &xr[gr][ch][0];
! 	    for ( i = 0; i < 576; i++, pr++, pi++ )
! 	    {
! 		if ( (*pr < 0) && (*pi > 0) )
! 		    *pi *= -1;
! 	    }
! 	}
! #endif
  
-     encodeSideInfo( l3_side );
-     encodeMainData( l3_enc, l3_side, scalefac );
-     write_ancillary_data( ancillary, ancillary_bits );
  
!     if ( l3_side->resvDrain )
! 	drain_into_ancillary_data( l3_side->resvDrain );
      /*
        Put frameData together for the call
        to BitstreamFrame()
      */
-     frameData->putbits     = putMyBits;
      frameData->frameLength = bitsPerFrame;
!     frameData->nGranules   = mode_gr;
!     frameData->nChannels   = stereo;
      frameData->header      = headerPH->part;
      frameData->frameSI     = frameSIPH->part;
  
!     for ( ch = 0; ch < stereo; ch++ )
  	frameData->channelSI[ch] = channelSIPH[ch]->part;
  
!     for ( gr = 0; gr < mode_gr; gr++ )
! 	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    frameData->spectrumSI[gr][ch]   = spectrumSIPH[gr][ch]->part;
  	    frameData->scaleFactors[gr][ch] = scaleFactorsPH[gr][ch]->part;
--- 98,124 ----
  	PartHoldersInitialized = 1;
      }
  
!     encodeSideInfo( gfp,l3_side );
!     encodeMainData( gfp,l3_enc, l3_side, scalefac );
  
  
! 
!     drain_into_ancillary_data( l3_side->resvDrain );
      /*
        Put frameData together for the call
        to BitstreamFrame()
      */
      frameData->frameLength = bitsPerFrame;
!     frameData->nGranules   = gfp->mode_gr;
!     frameData->nChannels   = gfp->stereo;
      frameData->header      = headerPH->part;
      frameData->frameSI     = frameSIPH->part;
  
!     for ( ch = 0; ch < gfp->stereo; ch++ )
  	frameData->channelSI[ch] = channelSIPH[ch]->part;
  
!     for ( gr = 0; gr < gfp->mode_gr; gr++ )
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	{
  	    frameData->spectrumSI[gr][ch]   = spectrumSIPH[gr][ch]->part;
  	    frameData->scaleFactors[gr][ch] = scaleFactorsPH[gr][ch]->part;
***************
*** 159,202 ****
  
      /* we set this here -- it will be tested in the next loops iteration */
      l3_side->main_data_begin = frameResults->nextBackPtr;
  }
  
  void
! III_FlushBitstream()
  {
!     assert( PartHoldersInitialized );
!     BF_FlushBitstream( frameData, frameResults );
  }
  
  static unsigned slen1_tab[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
  static unsigned slen2_tab[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
  
  static void
! encodeMainData( int              l3_enc[2][2][576],
  		III_side_info_t  *si,
! 		III_scalefac_t   *scalefac )
  {
!     int i, gr, ch, sfb, window, mode_gr;
!     layer *info = fr_ps->header;
  
-     if ( info->version == 1 )
- 	mode_gr = 2;
-     else
- 	mode_gr = 1;
  
!     for ( gr = 0; gr < mode_gr; gr++ )
! 	for ( ch = 0; ch < stereo; ch++ )
  	    scaleFactorsPH[gr][ch]->part->nrEntries = 0;
  
!     for ( gr = 0; gr < mode_gr; gr++ )
! 	for ( ch = 0; ch < stereo; ch++ )
  	    codedDataPH[gr][ch]->part->nrEntries = 0;
  
!     if ( info->version == 1 )
      {  /* MPEG 1 */
  	for ( gr = 0; gr < 2; gr++ )
  	{
! 	    for ( ch = 0; ch < stereo; ch++ )
  	    {
  		BF_PartHolder **pph = &scaleFactorsPH[gr][ch];		
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
--- 131,171 ----
  
      /* we set this here -- it will be tested in the next loops iteration */
      l3_side->main_data_begin = frameResults->nextBackPtr;
+ 
  }
  
  void
! III_FlushBitstream(void)
  {
!     if (PartHoldersInitialized!=0)
! 		BF_FlushBitstream( frameData, frameResults );
  }
  
  static unsigned slen1_tab[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
  static unsigned slen2_tab[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
  
  static void
! encodeMainData( lame_global_flags *gfp,
! 		int              l3_enc[2][2][576],
  		III_side_info_t  *si,
! 		III_scalefac_t   scalefac[2][2] )
  {
!     int i, gr, ch, sfb, window;
  
  
!     for ( gr = 0; gr < gfp->mode_gr; gr++ )
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	    scaleFactorsPH[gr][ch]->part->nrEntries = 0;
  
!     for ( gr = 0; gr < gfp->mode_gr; gr++ )
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	    codedDataPH[gr][ch]->part->nrEntries = 0;
  
!     if ( gfp->version == 1 )
      {  /* MPEG 1 */
  	for ( gr = 0; gr < 2; gr++ )
  	{
! 	    for ( ch = 0; ch < gfp->stereo; ch++ )
  	    {
  		BF_PartHolder **pph = &scaleFactorsPH[gr][ch];		
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
***************
*** 204,253 ****
  		unsigned slen2 = slen2_tab[ gi->scalefac_compress ];
  		int *ix = &l3_enc[gr][ch][0];
  
! 		if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  		{
  		    if ( gi->mixed_block_flag )
  		    {
  			for ( sfb = 0; sfb < 8; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen1 );
  
  			for ( sfb = 3; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen1 );
  
  			for ( sfb = 6; sfb < 12; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen2 );
  
  		    }
  		    else
  		    {
  			for ( sfb = 0; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen1 );
  
  			for ( sfb = 6; sfb < 12; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen2 );
  		    }
  		}
  		else
  		{
  		    if ( (gr == 0) || (si->scfsi[ch][0] == 0) )
  			for ( sfb = 0; sfb < 6; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen1 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][1] == 0) )
  			for ( sfb = 6; sfb < 11; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen1 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][2] == 0) )
  			for ( sfb = 11; sfb < 16; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen2 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][3] == 0) )
  			for ( sfb = 16; sfb < 21; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen2 );
  		}
  		Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	    } /* for ch */
--- 173,224 ----
  		unsigned slen2 = slen2_tab[ gi->scalefac_compress ];
  		int *ix = &l3_enc[gr][ch][0];
  
! 		if (gi->block_type == SHORT_TYPE)
  		{
+ #ifdef ALLOW_MIXED
  		    if ( gi->mixed_block_flag )
  		    {
  			for ( sfb = 0; sfb < 8; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen1 );
  
  			for ( sfb = 3; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen1 );
  
  			for ( sfb = 6; sfb < 12; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen2 );
  
  		    }
  		    else
+ #endif
  		    {
  			for ( sfb = 0; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen1 );
  
  			for ( sfb = 6; sfb < 12; sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen2 );
  		    }
  		}
  		else
  		{
  		    if ( (gr == 0) || (si->scfsi[ch][0] == 0) )
  			for ( sfb = 0; sfb < 6; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen1 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][1] == 0) )
  			for ( sfb = 6; sfb < 11; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen1 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][2] == 0) )
  			for ( sfb = 11; sfb < 16; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen2 );
  
  		    if ( (gr == 0) || (si->scfsi[ch][3] == 0) )
  			for ( sfb = 16; sfb < 21; sfb++ )
! 			    *pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen2 );
  		}
  		Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	    } /* for ch */
***************
*** 256,277 ****
      else
      {  /* MPEG 2 */
  	gr = 0;
! 	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &scaleFactorsPH[gr][ch];		
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
- 
  	    assert( gi->sfb_partition_table );
  
! 	    if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	    {
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
  		    for ( sfb = 0; sfb < 8; sfb++ )
! 			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], gi->slen[sfb_partition] );
  
  		    for ( sfb = 3, sfb_partition = 1; sfb_partition < 4; sfb_partition++ )
  		    {
--- 227,248 ----
      else
      {  /* MPEG 2 */
  	gr = 0;
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &scaleFactorsPH[gr][ch];		
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
  	    assert( gi->sfb_partition_table );
  
! 	    if (gi->block_type == SHORT_TYPE)
  	    {
+ #ifdef ALLOW_MIXED
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
  		    for ( sfb = 0; sfb < 8; sfb++ )
! 			*pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], gi->slen[sfb_partition] );
  
  		    for ( sfb = 3, sfb_partition = 1; sfb_partition < 4; sfb_partition++ )
  		    {
***************
*** 279,288 ****
  			int slen = gi->slen[ sfb_partition ];
  			for ( i = 0; i < sfbs; i++, sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen );
  		    }
  		}
  		else
  		{
  		    for ( sfb = 0, sfb_partition = 0; sfb_partition < 4; sfb_partition++ )
  		    {
--- 250,260 ----
  			int slen = gi->slen[ sfb_partition ];
  			for ( i = 0; i < sfbs; i++, sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen );
  		    }
  		}
  		else
+ #endif
  		{
  		    for ( sfb = 0, sfb_partition = 0; sfb_partition < 4; sfb_partition++ )
  		    {
***************
*** 290,296 ****
  			int slen = gi->slen[ sfb_partition ];
  			for ( i = 0; i < sfbs; i++, sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac->s[gr][ch][sfb][window], slen );
  		    }
  		}
  	    }
--- 262,268 ----
  			int slen = gi->slen[ sfb_partition ];
  			for ( i = 0; i < sfbs; i++, sfb++ )
  			    for ( window = 0; window < 3; window++ )
! 				*pph = BF_addEntry( *pph,  scalefac[gr][ch].s[sfb][window], slen );
  		    }
  		}
  	    }
***************
*** 301,486 ****
  		    int sfbs = gi->sfb_partition_table[ sfb_partition ];
  		    int slen = gi->slen[ sfb_partition ];
  		    for ( i = 0; i < sfbs; i++, sfb++ )
! 			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen );
  		}
  	    }
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0;
  
! static int encodeSideInfo( III_side_info_t  *si )
  {
!     int gr, ch, scfsi_band, region, window, bits_sent, mode_gr;
!     layer *info = fr_ps->header;
      
!     mode_gr =  (info->version == 1) ? 2 : 1;
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
!     headerPH = BF_addEntry( headerPH, info->version,            1 );
!     headerPH = BF_addEntry( headerPH, 4 - info->lay,            2 );
!     headerPH = BF_addEntry( headerPH, !info->error_protection,  1 );
!     headerPH = BF_addEntry( headerPH, info->bitrate_index,      4 );
!     headerPH = BF_addEntry( headerPH, info->sampling_frequency, 2 );
!     headerPH = BF_addEntry( headerPH, info->padding,            1 );
!     headerPH = BF_addEntry( headerPH, info->extension,          1 );
!     headerPH = BF_addEntry( headerPH, info->mode,               2 );
!     headerPH = BF_addEntry( headerPH, info->mode_ext,           2 );
!     headerPH = BF_addEntry( headerPH, info->copyright,          1 );
!     headerPH = BF_addEntry( headerPH, info->original,           1 );
!     headerPH = BF_addEntry( headerPH, info->emphasis,           2 );
      
      bits_sent = 32;
! 
!     if ( fr_ps->header->error_protection )
!     {
! 	headerPH = BF_addEntry( headerPH, crc, 16 );
! 	bits_sent += 16;
!     }
  
      frameSIPH->part->nrEntries = 0;
  
!     for (ch = 0; ch < stereo; ch++ )
  	channelSIPH[ch]->part->nrEntries = 0;
  
!     for ( gr = 0; gr < mode_gr; gr++ )
! 	for ( ch = 0; ch < stereo; ch++ )
  	    spectrumSIPH[gr][ch]->part->nrEntries = 0;
  
!     if ( info->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
! 	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
! 	for ( ch = 0; ch < stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
! 	    for ( ch = 0; ch < stereo; ch++ )
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
! 		    assert( gi->block_type == 0 );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
! 	if ( stereo == 2 )
  	    bits_sent += 256;
  	else
  	    bits_sent += 136;
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
! 	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
! 	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
! 	if ( stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
-     return bits_sent;
- }
  
! static void
! write_ancillary_data( char *theData, int lengthInBits )
! {
!     /*
!      */
!     int bytesToSend = lengthInBits / 8;
!     int remainingBits = lengthInBits % 8;
!     unsigned wrd;
!     int i;
! 
!     userFrameDataPH->part->nrEntries = 0;
! 
!     for ( i = 0; i < bytesToSend; i++ )
!     {
! 	wrd = theData[i];
! 	userFrameDataPH = BF_addEntry( userFrameDataPH, wrd, 8 );
!     }
!     if ( remainingBits )
!     {
! 	/* right-justify remaining bits */
! 	wrd = theData[bytesToSend] >> (8 - remainingBits);
! 	userFrameDataPH = BF_addEntry( userFrameDataPH, wrd, remainingBits );
      }
!     
  }
  
  /*
--- 273,455 ----
  		    int sfbs = gi->sfb_partition_table[ sfb_partition ];
  		    int slen = gi->slen[ sfb_partition ];
  		    for ( i = 0; i < sfbs; i++, sfb++ )
! 			*pph = BF_addEntry( *pph,  scalefac[gr][ch].l[sfb], slen );
  		}
  	    }
+ 
+ 
+ 
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0; /* (jo) current crc */
! 
! /* (jo) this wrapper function for BF_addEntry() updates also the crc */
! static BF_PartHolder *CRC_BF_addEntry( BF_PartHolder *thePH, u_int value, u_int length )
! {
!    u_int bit = 1 << length;
!    
!    while((bit >>= 1)){
!       crc <<= 1;
!       if (!(crc & 0x10000) ^ !(value & bit))
! 	crc ^= CRC16_POLYNOMIAL;
!    }
!    crc &= 0xffff;   
!    return BF_addEntry(thePH, value, length);
! }
! 
! 
! 
  
! static int encodeSideInfo( lame_global_flags *gfp,III_side_info_t  *si )
  {
!     int gr, ch, scfsi_band, region, window, bits_sent;
      
!     crc = 0xffff; /* (jo) init crc16 for error_protection */
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
!     headerPH = BF_addEntry( headerPH, gfp->version,            1 );
!     headerPH = BF_addEntry( headerPH, 1,                        2 );
!     headerPH = BF_addEntry( headerPH, !gfp->error_protection,     1 );
!     /* (jo) from now on call the CRC_BF_addEntry() wrapper to update crc */
!     headerPH = CRC_BF_addEntry( headerPH, gfp->bitrate_index,      4 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->samplerate_index,   2 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->padding,            1 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->extension,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->mode,               2 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->mode_ext,           2 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->copyright,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->original,           1 );
!     headerPH = CRC_BF_addEntry( headerPH, gfp->emphasis,           2 );
      
      bits_sent = 32;
!    
!     /* (jo) see below for BF_addEntry( headerPH, crc, 16 ); */
  
      frameSIPH->part->nrEntries = 0;
  
!     for (ch = 0; ch < gfp->stereo; ch++ )
  	channelSIPH[ch]->part->nrEntries = 0;
  
!     for ( gr = 0; gr < gfp->mode_gr; gr++ )
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	    spectrumSIPH[gr][ch]->part->nrEntries = 0;
  
!     if ( gfp->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
! 	if ( gfp->stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = CRC_BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
! 	    for ( ch = 0; ch < gfp->stereo; ch++ )
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
! 		    assert( gi->block_type == NORM_TYPE );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = CRC_BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
! 	if ( gfp->stereo == 2 )
  	    bits_sent += 256;
  	else
  	    bits_sent += 136;
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
! 	if ( gfp->stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
! 	for ( ch = 0; ch < gfp->stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
! 	if ( gfp->stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
  
!     if ( gfp->error_protection )
!     {   /* (jo) error_protection: add crc16 information to header */
! 	headerPH = BF_addEntry( headerPH, crc, 16 );
! 	bits_sent += 16;
      }
! 
!     return bits_sent;
  }
  
  /*
***************
*** 501,511 ****
      /*
        userFrameDataPH->part->nrEntries set by call to write_ancillary_data()
      */
! 
      for ( i = 0; i < wordsToSend; i++ )
  	userFrameDataPH = BF_addEntry( userFrameDataPH, 0, 32 );
      if ( remainingBits )
! 	userFrameDataPH = BF_addEntry( userFrameDataPH, 0, remainingBits );    
  }
  
  /*
--- 470,481 ----
      /*
        userFrameDataPH->part->nrEntries set by call to write_ancillary_data()
      */
!     
!     userFrameDataPH->part->nrEntries = 0;
      for ( i = 0; i < wordsToSend; i++ )
  	userFrameDataPH = BF_addEntry( userFrameDataPH, 0, 32 );
      if ( remainingBits )
! 	userFrameDataPH = BF_addEntry( userFrameDataPH, 0, remainingBits );
  }
  
  /*
***************
*** 517,541 ****
  Huffmancodebits( BF_PartHolder **pph, int *ix, gr_info *gi )
  {
      int L3_huffman_coder_count1( BF_PartHolder **pph, struct huffcodetab *h, int v, int w, int x, int y );
-     int bigv_bitcount( int ix[576], gr_info *cod_info );
  
      int region1Start;
      int region2Start;
      int i, bigvalues, count1End;
      int v, w, x, y, bits, cbits, xbits, stuffingBits;
      unsigned int code, ext;
!     struct huffcodetab *h;
!     int bvbits, c1bits, tablezeros, r0, r1, r2, rt, *pr;
      int bitsWritten = 0;
!     int idx = 0;
!     tablezeros = 0;
!     r0 = r1 = r2 = 0;
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
      if ( bigvalues )
      {
! 	if ( !(gi->mixed_block_flag) && gi->window_switching_flag && (gi->block_type == 2) )
  	{ /* Three short blocks */
  	    /*
  	      Within each scalefactor band, data is given for successive
--- 487,509 ----
  Huffmancodebits( BF_PartHolder **pph, int *ix, gr_info *gi )
  {
      int L3_huffman_coder_count1( BF_PartHolder **pph, struct huffcodetab *h, int v, int w, int x, int y );
  
      int region1Start;
      int region2Start;
      int i, bigvalues, count1End;
      int v, w, x, y, bits, cbits, xbits, stuffingBits;
      unsigned int code, ext;
! #ifdef DEBUG
!     int bvbits, c1bits;
! #endif
      int bitsWritten = 0;
! 
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
      if ( bigvalues )
      {
! 	if ( !(gi->mixed_block_flag) && (gi->block_type == SHORT_TYPE) )
  	{ /* Three short blocks */
  	    /*
  	      Within each scalefactor band, data is given for successive
***************
*** 546,552 ****
  	    int sfb, window, line, start, end;
  
  	    I192_3 *ix_s;
- 	    int *scalefac = &sfBandIndex[fr_ps->header->sampling_frequency + (fr_ps->header->version * 3)].s[0];
  	    
  	    ix_s = (I192_3 *) ix;
  	    region1Start = 12;
--- 514,519 ----
***************
*** 555,562 ****
  	    for ( sfb = 0; sfb < 13; sfb++ )
  	    {
  		unsigned tableindex = 100;
! 		start = scalefac[ sfb ];
! 		end   = scalefac[ sfb+1 ];
  
  		if ( start < region1Start )
  		    tableindex = gi->table_select[ 0 ];
--- 522,529 ----
  	    for ( sfb = 0; sfb < 13; sfb++ )
  	    {
  		unsigned tableindex = 100;
! 		start = scalefac_band.s[ sfb ];
! 		end   = scalefac_band.s[ sfb+1 ];
  
  		if ( start < region1Start )
  		    tableindex = gi->table_select[ 0 ];
***************
*** 569,576 ****
  		    {
  			x = (*ix_s)[line][window];
  			y = (*ix_s)[line + 1][window];
- 			assert( idx < 576 );
- 			assert( idx >= 0 );
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
--- 536,541 ----
***************
*** 580,591 ****
  	    }
  	}
  	else
! 	    if ( gi->mixed_block_flag && gi->block_type == 2 )
  	    {  /* Mixed blocks long, short */
  		int sfb, window, line, start, end;
  		unsigned tableindex;
  		I192_3 *ix_s;
- 		int *scalefac = &sfBandIndex[fr_ps->header->sampling_frequency + (fr_ps->header->version * 3)].s[0];
  		
  		ix_s = (I192_3 *) ix;
  
--- 545,556 ----
  	    }
  	}
  	else
! #ifdef ALLOW_MIXED
! 	    if ( gi->mixed_block_flag && gi->block_type == SHORT_TYPE )
  	    {  /* Mixed blocks long, short */
  		int sfb, window, line, start, end;
  		unsigned tableindex;
  		I192_3 *ix_s;
  		
  		ix_s = (I192_3 *) ix;
  
***************
*** 608,615 ****
  
  		for ( sfb = 3; sfb < 13; sfb++ )
  		{
! 		    start = scalefac[ sfb ];
! 		    end   = scalefac[ sfb+1 ];           
  		    
  		    for ( window = 0; window < 3; window++ )
  			for ( line = start; line < end; line += 2 )
--- 573,580 ----
  
  		for ( sfb = 3; sfb < 13; sfb++ )
  		{
! 		    start = scalefac_band.s[ sfb ];
! 		    end   = scalefac_band.s[ sfb+1 ];           
  		    
  		    for ( window = 0; window < 3; window++ )
  			for ( line = start; line < end; line += 2 )
***************
*** 625,632 ****
  
  	    }
  	    else
  	    { /* Long blocks */
- 		int *scalefac = &sfBandIndex[fr_ps->header->sampling_frequency + (fr_ps->header->version * 3)].l[0];
  		unsigned scalefac_index = 100;
  		
  		if ( gi->mixed_block_flag )
--- 590,597 ----
  
  	    }
  	    else
+ #endif
  	    { /* Long blocks */
  		unsigned scalefac_index = 100;
  		
  		if ( gi->mixed_block_flag )
***************
*** 638,649 ****
  		{
  		    scalefac_index = gi->region0_count + 1;
  		    assert( scalefac_index < 23 );
! 		    region1Start = scalefac[ scalefac_index ];
  		    scalefac_index += gi->region1_count + 1;
  		    assert( scalefac_index < 23 );    
! 		    region2Start = scalefac[ scalefac_index ];
! 		    assert( region1Start == gi->address1 );
  		}
  		for ( i = 0; i < bigvalues; i += 2 )
  		{
  		    unsigned tableindex = 100;
--- 603,614 ----
  		{
  		    scalefac_index = gi->region0_count + 1;
  		    assert( scalefac_index < 23 );
! 		    region1Start = scalefac_band.l[ scalefac_index ];
  		    scalefac_index += gi->region1_count + 1;
  		    assert( scalefac_index < 23 );    
! 		    region2Start = scalefac_band.l[ scalefac_index ];
  		}
+ 
  		for ( i = 0; i < bigvalues; i += 2 )
  		{
  		    unsigned tableindex = 100;
***************
*** 651,725 ****
  		    if ( i < region1Start )
  		    {
  			tableindex = gi->table_select[0];
- 			pr = &r0;
  		    }
  		    else
  			if ( i < region2Start )
  			{
  			    tableindex = gi->table_select[1];
- 			    pr = &r1;
  			}
  			else
  			{
  			    tableindex = gi->table_select[2];
- 			    pr = &r2;
  			}
  		    assert( tableindex < 32 );
- 		    h = &ht[ tableindex ];
  		    /* get huffman code */
  		    x = ix[i];
  		    y = ix[i + 1];
  		    if ( tableindex )
  		    {
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
! 			bitsWritten += rt = bits;
! 			*pr += rt;
! 		    }
! 		    else
! 		    {
! 			tablezeros += 1;
! 			*pr = 0;
  		    }
  		}
  	    }
      }
      bvbits = bitsWritten; 
  
      /* 2: Write count1 area */
      assert( (gi->count1table_select < 2) );
-     h = &ht[gi->count1table_select + 32];
      count1End = bigvalues + (gi->count1 * 4);
      assert( count1End <= 576 );
      for ( i = bigvalues; i < count1End; i += 4 )
      {
  	v = ix[i];
  	w = ix[i+1];
  	x = ix[i+2];
  	y = ix[i+3];
! 	bitsWritten += L3_huffman_coder_count1( pph, h, v, w, x, y );
      }
      c1bits = bitsWritten - bvbits;
      if ( (stuffingBits = gi->part2_3_length - gi->part2_length - bitsWritten) )
      {
  	int stuffingWords = stuffingBits / 32;
  	int remainingBits = stuffingBits % 32;
! 	assert( stuffingBits > 0 );
  
  	/*
  	  Due to the nature of the Huffman code
  	  tables, we will pad with ones
  	*/
  	while ( stuffingWords-- )
! 	    *pph = BF_addEntry( *pph, ~0, 32 );
  	if ( remainingBits )
! 	    *pph = BF_addEntry( *pph, ~0, remainingBits );
  	bitsWritten += stuffingBits;
      }
!     assert( bitsWritten == gi->part2_3_length - gi->part2_length );
  #ifdef DEBUG
!     printf( "#### %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ####\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
--- 616,688 ----
  		    if ( i < region1Start )
  		    {
  			tableindex = gi->table_select[0];
  		    }
  		    else
  			if ( i < region2Start )
  			{
  			    tableindex = gi->table_select[1];
  			}
  			else
  			{
  			    tableindex = gi->table_select[2];
  			}
  		    assert( tableindex < 32 );
  		    /* get huffman code */
  		    x = ix[i];
  		    y = ix[i + 1];
+ 
  		    if ( tableindex )
  		    {
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
! 			bitsWritten += bits;
  		    }
  		}
  	    }
      }
+ #ifdef DEBUG
      bvbits = bitsWritten; 
+ #endif
  
      /* 2: Write count1 area */
      assert( (gi->count1table_select < 2) );
      count1End = bigvalues + (gi->count1 * 4);
+ 
      assert( count1End <= 576 );
+ 
      for ( i = bigvalues; i < count1End; i += 4 )
      {
  	v = ix[i];
  	w = ix[i+1];
  	x = ix[i+2];
  	y = ix[i+3];
! 	bitsWritten += L3_huffman_coder_count1( pph, &ht[gi->count1table_select + 32], v, w, x, y );
      }
+ #ifdef DEBUG
      c1bits = bitsWritten - bvbits;
+ #endif
      if ( (stuffingBits = gi->part2_3_length - gi->part2_length - bitsWritten) )
      {
  	int stuffingWords = stuffingBits / 32;
  	int remainingBits = stuffingBits % 32;
! 
!         fprintf(stderr,"opps - adding stuffing bits = %i.\n",stuffingBits);
!         fprintf(stderr,"this should not happen...\n");
  
  	/*
  	  Due to the nature of the Huffman code
  	  tables, we will pad with ones
  	*/
  	while ( stuffingWords-- )
! 	    *pph = BF_addEntry( *pph, ~(u_int)0, 32 );
  	if ( remainingBits )
! 	    *pph = BF_addEntry( *pph, ~(u_int)0, remainingBits );
  	bitsWritten += stuffingBits;
      }
!     assert( bitsWritten == (int)(gi->part2_3_length - gi->part2_length) );
  #ifdef DEBUG
!     fprintf(stderr, "## %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ##\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
***************
*** 746,756 ****
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      
!     p = v + (w << 1) + (x << 2) + (y << 3);
      huffbits = h->table[p];
      len = h->hlen[ p ];
!     *pph = BF_addEntry( *pph,  huffbits, len );
!     totalBits += len;
      if ( v )
      {
  	*pph = BF_addEntry( *pph,  signv, 1 );
--- 709,722 ----
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      
!     /* bug fix from Leonid A. Kulakov 9/1999:*/
!     p = (v << 3) + (w << 2) + (x << 1) + y;  
! 
      huffbits = h->table[p];
      len = h->hlen[ p ];
!     *pph = BF_addEntry(*pph, huffbits, len);
!     totalBits= 0;
! #if 0
      if ( v )
      {
  	*pph = BF_addEntry( *pph,  signv, 1 );
***************
*** 772,778 ****
  	*pph = BF_addEntry( *pph,  signy, 1 );
  	totalBits += 1;
      }
!     return totalBits;
  }
  
  /*
--- 738,769 ----
  	*pph = BF_addEntry( *pph,  signy, 1 );
  	totalBits += 1;
      }
! #endif   
! 
!     p=0;
!     if ( v ) {
! 	p = signv;
! 	++totalBits;
!     }
! 
!     if ( w ){
! 	p = 2*p + signw;
! 	++totalBits;
!     }
! 
!     if ( x ) {
! 	p = 2*p + signx;
! 	++totalBits;
!     }
! 
!     if ( y ) {
! 	p = 2*p + signy;
! 	++totalBits;
!     }
! 
!     *pph = BF_addEntry(*pph, p, totalBits);
! 
!     return totalBits+len;  
  }
  
  /*
***************
*** 781,787 ****
  int
  HuffmanCode( int table_select, int x, int y, unsigned int *code, unsigned int *ext, int *cbits, int *xbits )
  {
!     unsigned signx, signy, linbitsx, linbitsy, linbits, xlen, ylen, idx;
      struct huffcodetab *h;
  
      *cbits = 0;
--- 772,778 ----
  int
  HuffmanCode( int table_select, int x, int y, unsigned int *code, unsigned int *ext, int *cbits, int *xbits )
  {
!     unsigned signx, signy, linbitsx, linbitsy, linbits, idx;
      struct huffcodetab *h;
  
      *cbits = 0;
***************
*** 795,807 ****
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      h = &(ht[table_select]);
-     xlen = h->xlen;
-     ylen = h->ylen;
-     linbits = h->linbits;
-     linbitsx = linbitsy = 0;
  
      if ( table_select > 15 )
      { /* ESC-table is used */
  	if ( x > 14 )
  	{
  	    linbitsx = x - 15;
--- 786,796 ----
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      h = &(ht[table_select]);
  
      if ( table_select > 15 )
      { /* ESC-table is used */
+       linbits = h->xlen;
+       linbitsx = linbitsy = 0;
  	if ( x > 14 )
  	{
  	    linbitsx = x - 15;
***************
*** 814,822 ****
  	    assert( linbitsy <= h->linmax );
  	    y = 15;
  	}
! 	idx = (x * ylen) + y;
  	*code = h->table[idx];
! 	*cbits = h->hlen[ idx ];
  	if ( x > 14 )
  	{
  	    *ext |= linbitsx;
--- 803,811 ----
  	    assert( linbitsy <= h->linmax );
  	    y = 15;
  	}
! 	idx = x * 16 + y;
  	*code = h->table[idx];
!         *cbits = h->hlen[ idx ];
  	if ( x > 14 )
  	{
  	    *ext |= linbitsx;
***************
*** 843,849 ****
      }
      else
      { /* No ESC-words */
! 	idx = (x * ylen) + y;
  	*code = h->table[idx];
  	*cbits += h->hlen[ idx ];
  	if ( x != 0 )
--- 832,838 ----
      }
      else
      { /* No ESC-words */
! 	idx = x * 16 + y;
  	*code = h->table[idx];
  	*cbits += h->hlen[ idx ];
  	if ( x != 0 )
***************
*** 856,862 ****
  	{
  	    *code <<= 1;
  	    *code |= signy;
! 	    *cbits += 1;
  	}
      }
      assert( *cbits <= 32 );
--- 845,851 ----
  	{
  	    *code <<= 1;
  	    *code |= signy;
!             *cbits += 1;
  	}
      }
      assert( *cbits <= 32 );
diff -r -c -N encoder/l3bitstream.h lame3.70/l3bitstream.h
*** encoder/l3bitstream.h	Wed Jan 22 02:43:15 1997
--- lame3.70/l3bitstream.h	Thu Apr  6 12:50:49 2000
***************
*** 2,10 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3bitstream.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
   *
   * $Log: l3bitstream.h,v $
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
--- 2,26 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: l3bitstream.h,v 1.5 2000/03/21 23:02:17 markt Exp $
   *
   * $Log: l3bitstream.h,v $
+  * Revision 1.5  2000/03/21 23:02:17  markt
+  * replaced all "gf." by gfp->
+  *
+  * Revision 1.4  2000/03/14 20:45:04  markt
+  * removed "info" sturct.   Removing fr_ps struct
+  *
+  * Revision 1.3  2000/02/01 11:26:32  takehiro
+  * scalefactor's structure changed
+  *
+  * Revision 1.2  1999/12/03 09:45:30  takehiro
+  * little bit cleanup
+  *
+  * Revision 1.1.1.1  1999/11/24 08:43:09  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
***************
*** 14,34 ****
  #ifndef L3_BITSTREAM_H
  #define L3_BITSTREAM_H
  
! #include "common.h"
! #include "encoder.h"
  
! void III_format_bitstream( int              bitsPerFrame,
! 			   frame_params     *in_fr_ps,
  			   int              l3_enc[2][2][576],
                             III_side_info_t  *l3_side,
! 			   III_scalefac_t   *scalefac,
! 			   Bit_stream_struc *in_bs,
! 			   double           (*xr)[2][576],
! 			   char             *ancillary,
! 			   int              anc_bits );
  
  int HuffmanCode( int table_select, int x, int y, unsigned *code, unsigned int *extword, int *codebits, int *extbits );
! void III_FlushBitstream();
  
  int abs_and_sign( int *x ); /* returns signx and changes *x to abs(*x) */
  
--- 30,46 ----
  #ifndef L3_BITSTREAM_H
  #define L3_BITSTREAM_H
  
! #include "util.h"
  
! void III_format_bitstream( lame_global_flags *gfp,
! 			   int              bitsPerFrame,
  			   int              l3_enc[2][2][576],
                             III_side_info_t  *l3_side,
! 			   III_scalefac_t   scalefac[2][2],
! 			   Bit_stream_struc *in_bs);
  
  int HuffmanCode( int table_select, int x, int y, unsigned *code, unsigned int *extword, int *codebits, int *extbits );
! void III_FlushBitstream(void);
  
  int abs_and_sign( int *x ); /* returns signx and changes *x to abs(*x) */
  
diff -r -c -N encoder/l3psy.c lame3.70/l3psy.c
*** encoder/l3psy.c	Wed Jan 22 02:43:15 1997
--- lame3.70/l3psy.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1033 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: l3psy.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: l3psy.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
-  *                              replace of floats with FLOAT          *
-  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
-  * 3/16/92  Masahiro Iwadare	Modification for Layer III            *
-  * 17/4/93  Masahiro Iwadare    Updated for IS Modification           *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- #include "l3psy.h"
- #include "l3side.h"
- #include <assert.h>
- 
- #define maximum(x,y) ( (x>y) ? x : y )
- #define minimum(x,y) ( (x<y) ? x : y )
- 
- void L3para_read( double sfreq, int numlines[CBANDS], int partition_l[HBLKSIZE],
- 		  double minval[CBANDS], double qthr_l[CBANDS], double norm_l[CBANDS],
- 		  double s3_l[CBANDS][CBANDS], int partition_s[HBLKSIZE_s], double qthr_s[CBANDS_s],
- 		  double norm_s[CBANDS_s], double SNR_s[CBANDS_s],
- 		  int cbw_l[SBMAX_l], int bu_l[SBMAX_l], int bo_l[SBMAX_l],
- 		  double w1_l[SBMAX_l], double w2_l[SBMAX_l],
- 		  int cbw_s[SBMAX_s], int bu_s[SBMAX_s], int bo_s[SBMAX_s],
- 		  double w1_s[SBMAX_s], double w2_s[SBMAX_s] );
- 									
- void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
- 		    double sfreq, double ratio_d[21], double ratio_ds[12][3],
- 		    double *pe, gr_info *cod_info )
- {
-     static double ratio[2][21];
-     static double ratio_s[2][12][3];
-     int blocktype;
-     unsigned int   b, i, j, k;
-     double         r_prime, phi_prime; /* not FLOAT */
-     FLOAT          freq_mult, bval_lo, min_thres, sum_energy;
-     double         tb, temp1,temp2,temp3;
- 
-     /*         nint(); Layer III */
-     double   thr[CBANDS];
- 
- /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
- /* to be remembered for the unpredictability measure.  For "r" and        */
- /* "phi_sav", the first index from the left is the channel select and     */
- /* the second index is the "age" of the data.                             */
- 
- 
-    static FLOAT window_s[BLKSIZE_s] ;
-  static int     new = 0, old = 1, oldest = 0;
-  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
-  static double 	cw[HBLKSIZE], eb[CBANDS];
-  static double 	ctb[CBANDS];
-  static double	SNR_l[CBANDS], SNR_s[CBANDS_s];
-  static int	init_L3;
-  static double	minval[CBANDS],qthr_l[CBANDS],norm_l[CBANDS];
-  static double	qthr_s[CBANDS_s],norm_s[CBANDS_s];
-  static double	nb_1[2][CBANDS], nb_2[2][CBANDS];
-  static double	s3_l[CBANDS][CBANDS]; /* s3_s[CBANDS_s][CBANDS_s]; */
- 
- /* Scale Factor Bands */
-  static int	cbw_l[SBMAX_l],bu_l[SBMAX_l],bo_l[SBMAX_l] ;
-  static int	cbw_s[SBMAX_s],bu_s[SBMAX_s],bo_s[SBMAX_s] ;
-  static double	w1_l[SBMAX_l], w2_l[SBMAX_l];
-  static double	w1_s[SBMAX_s], w2_s[SBMAX_s];
-  static double	en[SBMAX_l],   thm[SBMAX_l] ;
-  static int	blocktype_old[2] ;
-  int	sb,sblock;
-  static int	partition_l[HBLKSIZE],partition_s[HBLKSIZE_s];
- 
- 
- /* The following static variables are constants.                           */
- 
-  static double  nmt = 5.5;
- 
-  static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
-                                920, 1080, 1270,1480,1720,2000,2320, 2700,
-                               3150, 3700, 4400,5300,6400,7700,9500,12000,
-                              15500,25000,30000};
- 
-  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
-                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
- 
- /* The following pointer variables point to large areas of memory         */
- /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
- /* allocation is used in order to avoid stack frame or data area          */
- /* overflow errors that otherwise would have occurred at compile time     */
- /* on the Macintosh computer.                                             */
- 
-  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
-  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
-  static FLOAT	energy_s[3][256];
-  static FLOAT phi_s[3][256] ; /* 256 samples not 129 */
-  FLOAT          *c, *fthr;
-  F32            *snrtmp;
- 
-  static	int	*numlines ;
-  static int     *partition;
-  static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
-  static double  *tmn;
-  static FCB     *s;
-  static FHBLK   *lthr;
-  static F2HBLK  *r, *phi_sav;
- 
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
- 
-  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
-  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
-  nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
-  cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
-  ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
-  bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
-  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
-  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
-  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
-  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
-  c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
-  fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
-  snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
- 
-     assert( lay == 3 );
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
-      numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
-      partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
-      cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
-      rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
-      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
-      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr"); 
-      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
-      s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
-      lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
-      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
-      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
- 
- /*#if 0 */
-      i = sfreq + 0.5;
-      switch(i){
-         case 32000: sfreq_idx = 0; break;
-         case 44100: sfreq_idx = 1; break;
-         case 48000: sfreq_idx = 2; break;
-         default:    printf("error, invalid sampling frequency: %d Hz\n",i);
-         exit(-1);
-      }
-      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
-      read_absthr(absthr, sfreq_idx);
-      switch(lay){
- 	case 1: sync_flush=576; flush=384; syncsize=1024; break;
- 	case 2: sync_flush=480; flush=576; syncsize=1056; break;
- 	case 3: sync_flush=768; flush=576; syncsize=1344; break;
-        default: printf("Bad lay value:(%d)",lay); exit(-1); break;
-      }
- /* #endif */
- 
- /* calculate HANN window coefficients */
- /*   for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0)));*/
-      for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
-      for(i=0;i<BLKSIZE_s;i++)window_s[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE_s));
- /* reset states used in unpredictability measure */
-      for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
-         lthr[0][i] = 60802371420160.0;
-         lthr[1][i] = 60802371420160.0;
-      }
- /*****************************************************************************
-  * Initialization: Compute the following constants for use later             *
-  *    partition[HBLKSIZE] = the partition number associated with each        *
-  *                          frequency line                                   *
-  *    cbval[CBANDS]       = the center (average) bark value of each          *
-  *                          partition                                        *
-  *    numlines[CBANDS]    = the number of frequency lines in each partition  *
-  *    tmn[CBANDS]         = tone masking noise                               *
-  *****************************************************************************/
- /* compute fft frequency multiplicand */
-      freq_mult = sfreq/BLKSIZE;
-  
- /* calculate fft frequency, then bval of each line (use fthr[] as tmp storage)*/
-      for(i=0;i<HBLKSIZE;i++){
-         temp1 = i*freq_mult;
-         j = 1;
-         while(temp1>crit_band[j])j++;
-         fthr[i]=j-1+(temp1-crit_band[j-1])/(crit_band[j]-crit_band[j-1]);
-      }
-      partition[0] = 0;
- /* temp2 is the counter of the number of frequency lines in each partition */
-      temp2 = 1;
-      cbval[0]=fthr[0];
-      bval_lo=fthr[0];
-      for(i=1;i<HBLKSIZE;i++){
-         if((fthr[i]-bval_lo)>0.33){
-            partition[i]=partition[i-1]+1;
-            cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-            cbval[partition[i]] = fthr[i];
-            bval_lo = fthr[i];
-            numlines[partition[i-1]] = temp2;
-            temp2 = 1;
-         }
-         else {
-            partition[i]=partition[i-1];
-            cbval[partition[i]] += fthr[i];
-            temp2++;
-         }
-      }
-      numlines[partition[i-1]] = temp2;
-      cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-  
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
-      for(j=0;j<CBANDS;j++){
-         for(i=0;i<CBANDS;i++){
-            temp1 = (cbval[i] - cbval[j])*1.05;
-            if(temp1>=0.5 && temp1<=2.5){
-               temp2 = temp1 - 0.5;
-               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
-            }
-            else temp2 = 0;
-            temp1 += 0.474;
-            temp3 = 15.811389+7.5*temp1-17.5*sqrt((double) (1.0+temp1*temp1));
-            if(temp3 <= -100) s[i][j] = 0;
-            else {
-               temp3 = (temp2 + temp3)*LN_TO_LOG10;
-               s[i][j] = exp(temp3);
-            }
-         }
-      }
- 
-   /* Calculate Tone Masking Noise values */
-      for(j=0;j<CBANDS;j++){
-         temp1 = 15.5 + cbval[j];
-         tmn[j] = (temp1>24.5) ? temp1 : 24.5;
-   /* Calculate normalization factors for the net spreading functions */
-         rnorm[j] = 0;
-         for(i=0;i<CBANDS;i++){
-            rnorm[j] += s[j][i];
-         }
-      }
-      init++;
-  }
-  
- /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
- 	for ( i=0; i<lay; i++)
-   {
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-   for (j=0; j<syncsize; j++)
-   {
-     if (j < (sync_flush) )
-       savebuf[j] = savebuf[j+flush];
-     else
-       savebuf[j] = *buffer++;
- 
- /**window data with HANN window***********************************************/
-     if (j<BLKSIZE)
-     {
-       wsamp_r[j] = window[j]*((FLOAT) savebuf[j]); 
-       wsamp_i[j] = 0;
-     }
-   }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- 	   temp1 = r[chn][new][j] * cos((double) phi[j])
- 		   - r_prime * cos(phi_prime);
- 	   temp2=r[chn][new][j] * sin((double) phi[j])
- 		   - r_prime * sin(phi_prime);
-            temp3=r[chn][new][j] + fabs(r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*only update data "age" pointers after you are done with the second channel */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-         if(lay==2 || chn==1){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
- /*         tb = -0.434294482*log((double) cb[j])-0.301029996; */
-            tb = -0.43 *log((double) cb[j]) - 0.29 ;
-            if(tb<0.0) tb=0.0; else if(tb>1.0) tb=1.0;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
-            temp1=nb[partition[j]];		 /* preliminary threshold */
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            min_thres = fthr[j];
-            sum_energy = energy[j];
-            for(k=1;k<17;k++){
-               if(min_thres>fthr[j+k]) min_thres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(min_thres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            min_thres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               min_thres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/min_thres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)		/* if(lay==2 && chn==2) MI */
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
- 
- /*************************************************************************/
- /**       LAYER 3                                                        */
- /*************************************************************************/
- 
-    case 3:
- 	if ( init_L3 == 0 )
- 	{
- 	    L3para_read( sfreq,numlines,partition_l,minval,qthr_l,norm_l,s3_l,
- 			 partition_s,qthr_s,norm_s,SNR_s,
- 			 cbw_l,bu_l,bo_l,w1_l,w2_l, cbw_s,bu_s,bo_s,w1_s,w2_s );
- 	    init_L3 ++ ;
- 	}
- 	
- 	for ( j = 0; j < 21; j++ )
- 	    ratio_d[j] = ratio[chn][j];
- 	for ( j = 0; j < 12; j++ )
- 	    for ( i = 0; i < 3; i++ )
- 		ratio_ds[j][i] = ratio_s[chn][j][i];
- 	
- 	if ( chn == 0 )
- 	    if ( new == 0 )
- 	    {
- 		new = 1;
- 		old = 0;
- 		oldest = 1;
- 	    }
- 	    else
- 	    {
- 		new = 0;
- 		old = 1;
- 		oldest = 0;
- 	    }
- 
- 
- /**********************************************************************
- *  Delay signal by sync_flush=768 samples                             *
- **********************************************************************/
- 	
- 	for ( j = 0; j < sync_flush; j++ ) /* for long window samples */
- 	    savebuf[j] = savebuf[j+flush];
- 	
- 	for ( j = sync_flush; j < syncsize; j++ )
- 	    savebuf[j] = *buffer++;
- 	
- 	for ( j = 0; j < BLKSIZE; j++ )
- 	{ /**window data with HANN window**/
- 	    wsamp_r[j] = window[j] * savebuf[j];  
- 	    wsamp_i[j] = 0.0;
- 	}
- 
- 
- /**********************************************************************
- *    compute unpredicatability of first six spectral lines            * 
- **********************************************************************/
- 
- 	fft( wsamp_r, wsamp_i, energy, phi, 1024 );		/**long FFT**/
- 	for ( j = 0; j < 6; j++ )
- 	{	 /* calculate unpredictability measure cw */
- 	    r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
- 	    phi_prime = 2.0 * phi_sav[chn][old][j]-phi_sav[chn][oldest][j];
- 	    r[chn][new][j] = sqrt((double) energy[j]);
- 	    phi_sav[chn][new][j] = phi[j];
- 	    temp1 = r[chn][new][j] * cos((double) phi[j])
- 		- r_prime * cos(phi_prime);
- 	    temp2 = r[chn][new][j] * sin((double) phi[j])
- 		- r_prime * sin(phi_prime);
- 	    temp3=r[chn][new][j] + fabs(r_prime);
- 	    
- 	    if ( temp3 != 0.0 )
- 		cw[j] = sqrt( temp1*temp1+temp2*temp2 ) / temp3;
- 	    else
- 		cw[j] = 0;
- 	}
- 
- 
- /**********************************************************************
- *     compute unpredicatibility of next 200 spectral lines            *
- **********************************************************************/ 
- 	for ( sblock = 0; sblock < 3; sblock++ )
- 	{ /**window data with HANN window**/
- 	    for ( j = 0, k = 128 * (2 + sblock); j < 256; j++, k++ )
- 	    {
- 		wsamp_r[j] = window_s[j]* savebuf[k]; 
- 		wsamp_i[j] = 0.0;
- 	    }							/* short FFT*/
- 	    
- 	    fft( wsamp_r, wsamp_i, &energy_s[sblock][0], &phi_s[sblock][0], 256 );
-         }
-  
-         sblock = 1;
- 
- 	for ( j = 6; j < 206; j += 4 )
- 	{/* calculate unpredictability measure cw */
- 	    double r2, phi2, temp1, temp2, temp3;
- 	    
- 	    k = (j+2) / 4; 
- 	    r_prime = 2.0 * sqrt((double) energy_s[0][k])
- 		- sqrt((double) energy_s[2][k]);
- 	    phi_prime = 2.0 * phi_s[0][k] - phi_s[2][k];
- 	    r2 = sqrt((double) energy_s[1][k]);
- 	    phi2 = phi_s[1][k];
- 	    temp1 = r2 * cos( phi2 ) - r_prime * cos( phi_prime );
- 	    temp2 = r2 * sin( phi2 ) - r_prime * sin( phi_prime );
- 	    temp3 = r2 + fabs( r_prime );
- 	    if ( temp3 != 0.0 )
- 		cw[j] = sqrt( temp1 * temp1 + temp2 * temp2 ) / temp3;
- 	    else
- 		cw[j] = 0.0;
- 	    cw[j+1] = cw[j+2] = cw[j+3] = cw[j];
- 	}
- 
- 
- /**********************************************************************
- *    Set unpredicatiblility of remaining spectral lines to 0.4        *
- **********************************************************************/
- 	for ( j = 206; j < HBLKSIZE; j++ )
- 	    cw[j] = 0.4;
- 	
- 
- 
- /**********************************************************************
- *    Calculate the energy and the unpredictability in the threshold   *
- *    calculation partitions                                           *
- **********************************************************************/
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    eb[b] = 0.0;
- 	    cb[b] = 0.0;
- 	}
- 	for ( j = 0; j < HBLKSIZE; j++ )
- 	{
- 	    int tp = partition_l[j];
- 	    if ( tp >= 0 )
- 	    {
- 		eb[tp] += energy[j];
- 		cb[tp] += cw[j] * energy[j];
- 	    }
- 	}
- 
- 
- /**********************************************************************
- *      convolve the partitioned energy and unpredictability           *
- *      with the spreading function, s3_l[b][k]                        *
- ******************************************************************** */
- 	
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    ecb[b] = 0.0;
- 	    ctb[b] = 0.0;
- 	}
- 	for ( b = 0;b < CBANDS; b++ )
- 	{
- 	    for ( k = 0; k < CBANDS; k++ )
- 	    {
- 		ecb[b] += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
- 		ctb[b] += s3_l[b][k] * cb[k];
- 	    }
- 	}
- 
- 	/* calculate the tonality of each threshold calculation partition */
- 	/* calculate the SNR in each threshhold calculation partition */
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    double cbb,tbb;
- 	    if (ecb[b] != 0.0 )
-                 {
- 		cbb = ctb[b]/ecb[b];
-                 if (cbb <0.01) cbb = 0.01;
- 		cbb = log( cbb);
-                 }
- 	    else
- 		cbb = 0.0 ;
- 	    tbb = -0.299 - 0.43*cbb;  /* conv1=-0.299, conv2=-0.43 */
- 	    tbb = minimum( 1.0, maximum( 0.0, tbb) ) ;  /* 0<tbb<1 */
- 	    SNR_l[b] = maximum( minval[b], 29.0*tbb+6.0*(1.0-tbb) );
- 	}	/* TMN=29.0,NMT=6.0 for all calculation partitions */
- 	
- 	for ( b = 0; b < CBANDS; b++ ) /* calculate the threshold for each partition */
- 	    nb[b] = ecb[b] * norm_l[b] * exp( -SNR_l[b] * LN_TO_LOG10 );
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{ /* pre-echo control */
- 	    double temp_1; /* BUG of IS */
- 	    temp_1 = minimum( nb[b], minimum(2.0*nb_1[chn][b],16.0*nb_2[chn][b]) );
- 	    thr[b] = maximum( qthr_l[b], temp_1 );/* rpelev=2.0, rpelev2=16.0 */
- 	    nb_2[chn][b] = nb_1[chn][b];
- 	    nb_1[chn][b] = nb[b];
- 	}
- 
- 
- 	*pe = 0.0;		/*  calculate percetual entropy */
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    double tp ;
- 	    tp = minimum( 0.0, log((thr[b]+1.0) / (eb[b]+1.0) ) ) ; /*not log*/
- 	    *pe -= numlines[b] * tp ;
- 	}	/* thr[b] -> thr[b]+1.0 : for non sound portition */
- 	
- #define switch_pe  1800
-         blocktype = NORM_TYPE;
- 	
- 
- 	if ( *pe < switch_pe )
- 	{				/* no attack : use long blocks */
- 	    switch( blocktype_old[chn] ) 
- 	    {
- 	      case NORM_TYPE:
- 	      case STOP_TYPE:
- 		blocktype = NORM_TYPE;
- 		break;
-     
- 	      case SHORT_TYPE:
- 		blocktype = STOP_TYPE;
- 		break;
-     
- 	      case START_TYPE:
- 		fprintf( stderr, "Error in block selecting\n" );
- 		abort();
- 		break; /* problem */
- 	    }
- 
- 	    /* threshold calculation (part 2) */
- 	    for ( sb = 0; sb < SBMAX_l; sb++ )
- 	    {
- 		en[sb] = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
- 		thm[sb] = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
- 		for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
- 		{
- 		    en[sb]  += eb[b];
- 		    thm[sb] += thr[b];
- 		}
- 		if ( en[sb] != 0.0 )
- 		    ratio[chn][sb] = thm[sb]/en[sb];
- 		else
- 		    ratio[chn][sb] = 0.0;
- 	    }
- 	}
- 	else 
- 	{
- 	    /* attack : use short blocks */
- 	    blocktype = SHORT_TYPE;
- 	    
- 	    if ( blocktype_old[chn] == NORM_TYPE ) 
- 		blocktype_old[chn] = START_TYPE;
- 	    if ( blocktype_old[chn] == STOP_TYPE )
- 		blocktype_old[chn] = SHORT_TYPE ;
- 	    
- 	    /* threshold calculation for short blocks */
- 	    
- 	    for ( sblock = 0; sblock < 3; sblock++ )
- 	    {
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    eb[b] = 0.0;
- 		    ecb[b] = 0.0;
- 		}
- 		for ( j = 0; j < HBLKSIZE_s; j++ )
- 		    eb[partition_s[j]] += energy_s[sblock][j];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		    for ( k = 0; k < CBANDS_s; k++ )
- 			ecb[b] += s3_l[b][k] * eb[k];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    nb[b] = ecb[b] * norm_l[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
- 		    thr[b] = maximum (qthr_s[b],nb[b]);
- 		}
- 		for ( sb = 0; sb < SBMAX_s; sb++ )
- 		{
- 		    en[sb] = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
- 		    thm[sb] = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
- 		    for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
- 		    {
- 			en[sb] += eb[b];
- 			thm[sb] += thr[b];
- 		    }
- 		    if ( en[sb] != 0.0 )
- 			ratio_s[chn][sb][sblock] = thm[sb]/en[sb];
- 		    else
- 			ratio_s[chn][sb][sblock] = 0.0;
- 		}
- 	    }
- 	} 
- 	
- 	cod_info->block_type = blocktype_old[chn];
- 	blocktype_old[chn] = blocktype;
- 
- 	if ( cod_info->block_type == NORM_TYPE )
- 	    cod_info->window_switching_flag = 0;
- 	else
- 	    cod_info->window_switching_flag = 1;
- 	cod_info->mixed_block_flag = 0;
- 	break;
- 
- 
-   default:
-      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
-  }
- 
- /* These mem_free() calls must correspond with the mem_alloc() calls     */
- /* used at the beginning of this function to simulate "automatic"        */
- /* variables placed on the stack.                                        */
- 
-  mem_free((void **) &grouped_c);
-  mem_free((void **) &grouped_e);
-  mem_free((void **) &nb);
-  mem_free((void **) &cb);
-  mem_free((void **) &ecb);
-  mem_free((void **) &bc);
-  mem_free((void **) &wsamp_r);
-  mem_free((void **) &wsamp_i);
-  mem_free((void **) &phi);
-  mem_free((void **) &energy);
-  mem_free((void **) &c);
-  mem_free((void **) &fthr);
-  mem_free((void **) &snrtmp);
- }
- #ifdef DEBUG
- #undef DEBUG
- #endif
- 
- 
- void L3para_read(double sfreq, int *numlines, int *partition_l, double *minval, double *qthr_l, double *norm_l, double (*s3_l)[63], int *partition_s, double *qthr_s, double *norm_s, double *SNR, int *cbw_l, int *bu_l, int *bo_l, double *w1_l, double *w2_l, int *cbw_s, int *bu_s, int *bo_s, double *w1_s, double *w2_s)
- {
-    double freq_tp;
-    static double bval_l[CBANDS], bval_s[CBANDS];
-    int   cbmax, cbmax_tp;
-    static double s3_s[CBANDS][CBANDS];
- 
-    FILE *fin;
-    char tp[256];
-    int  sbmax ;
-    int  i,j,k,k2,loop, part_max ;
- 
-    fin = OpenTableFile( "psy_data" );
-    if (fin == NULL)
-        exit( 1 );
- 
- /* Read long block data */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
- 	cbmax_tp++;
- #ifdef DEBUG
- 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
- #endif
- 
- 	if (sfreq == freq_tp )
- 	  {
- 	     cbmax = cbmax_tp;
- 	     for(i=0,k2=0;i<cbmax_tp;i++)
- 	       {
- 		fscanf(fin,
- 		  "No=%d #lines=%d minval=%lf qthr=%lf norm=%lf bval=%lf\n",
- 		  &j,&numlines[i],&minval[i],&qthr_l[i],&norm_l[i],&bval_l[i]);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data\"");
- 		   exit(-1);
- 	         }
- 		for(k=0;k<numlines[i];k++)
- 		  partition_l[k2++] = i ;
- #ifdef DEBUG
-      printf("No=%2d #lines=%2d minval=%4.1f qthr=%8.3f norm=%5.3f bval=%8.3f\n",
- 		     i,numlines[i],minval[i],qthr_l[i],norm_l[i],bval_l[i] );
- #endif
- 		}
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<cbmax_tp;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"No=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
- #ifdef DEBUG
- 	printf("freq = %f\n",sfreq);
- #endif
- 	  part_max = cbmax ;
-           for(i=0;i<part_max;i++)
- 	  {
- 	  double tempx,x,tempy,temp;
-             for(j=0;j<part_max;j++)
- 	    {
-              tempx = (bval_l[i] - bval_l[j])*1.05;
-              if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
-                else    tempx = (bval_l[i] - bval_l[j])*1.5;
- /*             if (j>=i) tempx = (bval_l[j] - bval_l[i])*3.0;
-                else    tempx = (bval_l[j] - bval_l[i])*1.5; */
-              if(tempx>=0.5 && tempx<=2.5)
- 	     {
-                temp = tempx - 0.5;
-                x = 8.0 * (temp*temp - 2.0 * temp);
-              }
-              else x = 0.0;
-              tempx += 0.474;
-              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
-              if (tempy <= -60.0) s3_l[i][j] = 0.0;
-              else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
- #ifdef DEBUG_S3
- 	     printf("s[%d][%d]=%f\n",i,j,s3_l[i][j]);
- #endif
- 
- #ifdef DEBUGP
- 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
- 	   minval[i] = bmax[j-1];
- 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
- #endif
-             }
-           }
- 
- 
- /* Read short block data */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
- 	cbmax_tp++;
- #ifdef DEBUG
- 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
- #endif
- 
- 	if (sfreq == freq_tp )
- 	  {
- 	     cbmax = cbmax_tp;
- 	     for(i=0,k2=0;i<cbmax_tp;i++)
- 	       {
- 		fscanf(fin,
- 		  "No=%d #lines=%d qthr=%lf norm=%lf SNR=%lf bval=%lf\n",
- 		   &j,&numlines[i],&qthr_s[i],&norm_s[i],&SNR[i],&bval_s[i]);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data\"");
- 		   exit(-1);
- 	         }
- 		for(k=0;k<numlines[i];k++)
- 		  partition_s[k2++] = i ;
- #ifdef DEBUG
-       printf("No=%2d #lines=%2d qthr=%8.3f norm=%5.3f SNR=%6.3f bval=%8.3f\n",
- 		      i,numlines[i],qthr_s[i],norm_s[i],SNR[i],bval_s[i] );
- #endif
- 		}
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<cbmax_tp;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"No=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
- #ifdef DEBUG_S3
- fpp=fopen("s3_s","w");
- #endif
- 	  part_max = cbmax ;
-           for(i=0;i<part_max;i++)
- 	  {
- 	  double tempx,x,tempy,temp;
-             for(j=0;j<part_max;j++)
- 	    {
-              tempx = (bval_s[i] - bval_s[j])*1.05;
-              if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
-                else    tempx = (bval_s[i] - bval_s[j])*1.5;
-              if(tempx>=0.5 && tempx<=2.5)
- 	     {
-                temp = tempx - 0.5;
-                x = 8.0 * (temp*temp - 2.0 * temp);
-              }
-              else x = 0.0;
-              tempx += 0.474;
-              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
-              if (tempy <= -60.0) s3_s[i][j] = 0.0;
-              else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
- #ifdef DEBUG_S3
- 	     fprintf(fpp,"s3_s[%d][%d]=%f\n",i,j,s3_s[i][j]);
- #endif
- #ifdef DEBUGP
- 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
- 	   minval[i] = bmax[j-1];
- 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
- #endif
-             }
-           }
- #ifdef DEBUG_S3
- 	fclose(fpp);
- #endif
- /* Read long block data for converting threshold calculation 
-    partitions to scale factor bands */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
- 	sbmax++;
- #ifdef DEBUG
- 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
- #endif
- 
- 	if (sfreq == freq_tp)
- 	  {
- 	     for(i=0;i<sbmax;i++)
- 	      {
- 		fscanf(fin,
- 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
- 		  &j,&cbw_l[i],&bu_l[i],&bo_l[i],&w1_l[i],&w2_l[i]);
- 	        if (j!=i)
- 	         { printf("30:please check \"psy_data\"\n");
- 		   exit(-1);
- 	         }
- #ifdef DEBUG
- 		printf(
- 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
- 		  j,cbw_l[i],bu_l[i],bo_l[i],w1_l[i],w2_l[i]);
- #endif
- 	        if (i!=0)
- 		 if ( (bo_l[i] != (bu_l[i]+cbw_l[i])) ||
- 				 (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
- 	         { printf("31:please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	      }
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<sbmax;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"sb=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /* Read short block data for converting threshold calculation 
-    partitions to scale factor bands */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
- 	sbmax++;
- #ifdef DEBUG
- 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
- #endif
- 
- 	if (sfreq == freq_tp)
- 	  {
- 	     for(i=0;i<sbmax;i++)
- 	      {
- 		fscanf(fin,
- 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
- 		  &j,&cbw_s[i],&bu_s[i],&bo_s[i],&w1_s[i],&w2_s[i]);
- 	        if (j!=i)
- 	         { printf("30:please check \"psy_data\"\n");
- 		   exit(-1);
- 	         }
- #ifdef DEBUG
- 		printf(
- 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
- 		  j,cbw_s[i],bu_s[i],bo_s[i],w1_s[i],w2_s[i]);
- #endif
- 	        if (i!=0)
- 		 if ( (bo_s[i] != (bu_s[i]+cbw_s[i])) ||
- 				 (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
- 	         { printf("31:please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	      }
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<sbmax;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"sb=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- }
--- 0 ----
diff -r -c -N encoder/l3psy.h lame3.70/l3psy.h
*** encoder/l3psy.h	Wed Jan 22 02:43:16 1997
--- lame3.70/l3psy.h	Wed Dec 31 17:00:00 1969
***************
*** 1,37 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: l3psy.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: l3psy.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef L3PSY_DOT_H_
- #define L3PSY_DOT_H_
- /* #define CBANDS 63 */
- #define CBANDS_s 42
- #define BLKSIZE_s 256
- #define HBLKSIZE_s 129
- #define TCBMAX_l 63
- #define TCBMAX_s 42
- #define SBMAX_l 21
- #define SBMAX_s 12
- 
- /* #define switch_pe        1800 */
- #define NORM_TYPE       0
- #define START_TYPE      1
- #define SHORT_TYPE      2
- #define STOP_TYPE       3
- 
- /* l3psy.c */
- #include "l3side.h"
- void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
- 					double sfreq, double ratio_d[21], double ratio_ds[12][3],
- 					double *pe, gr_info *cod_info );
- /* void read_absthr(float *absthr, int table); */
- #endif
--- 0 ----
diff -r -c -N encoder/l3side.h lame3.70/l3side.h
*** encoder/l3side.h	Wed Jan 22 02:43:16 1997
--- lame3.70/l3side.h	Thu Apr  6 12:50:49 2000
***************
*** 1,16 ****
  /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: l3side.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: l3side.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
   *   date   programmers                comment                        *
   * 25. 6.92  Toshiyuki Ishino          Ver 1.0                        *
   * 29.10.92  Masahiro Iwadare          Ver 2.0                        *
--- 1,4 ----
***************
*** 20,61 ****
  
  #ifndef L3_SIDE_H
  #define L3_SIDE_H
  
  /* Layer III side information. */
  
! /* #define CBLIMIT_SHORT 12 */
! 
! void l3deco();
! 
! typedef double	D576[576];
  typedef int	I576[576];
! typedef double	D192_3[192][3];
  typedef int	I192_3[192][3];
  
- typedef struct {
- 	unsigned cbl_max;
- 	unsigned cbs_start;
- } III_cb_info;
- 
  
  typedef struct {
! 	double	l[2][2][21];
! 	double	s[2][2][12][3];
! } III_psy_ratio;
! 
! typedef struct {
! 	double	l[2][2][21];
! 	double	s[2][2][12][3];
  } III_psy_xmin;
  
  typedef struct {
! 	double	xr[576];
! 	double	xr_s[3][192];
! 	double	xmin[21];
! 	double	xmin_s[3][192];
! 	int	ix[576];
! 	int	ix_s[3][192];
! 	} III_input3; /* ch */
  
  typedef struct {
  	unsigned part2_3_length;
--- 8,33 ----
  
  #ifndef L3_SIDE_H
  #define L3_SIDE_H
+ #include "encoder.h"
+ #include "machine.h"
  
  /* Layer III side information. */
  
! typedef FLOAT8	D576[576];
  typedef int	I576[576];
! typedef FLOAT8	D192_3[192][3];
  typedef int	I192_3[192][3];
  
  
  typedef struct {
! 	FLOAT8	l[SBPSY_l + 1];
! 	FLOAT8	s[SBPSY_s + 1][3];
  } III_psy_xmin;
  
  typedef struct {
!     III_psy_xmin thm;
!     III_psy_xmin en;
! } III_psy_ratio;
  
  typedef struct {
  	unsigned part2_3_length;
***************
*** 77,86 ****
  	unsigned part2_length;
  	unsigned sfb_lmax;
  	unsigned sfb_smax;
! 	unsigned address1;
! 	unsigned address2;
! 	unsigned address3;
! 	double quantizerStepSize;
  	/* added for LSF */
  	unsigned *sfb_partition_table;
  	unsigned slen[4];
--- 49,55 ----
  	unsigned part2_length;
  	unsigned sfb_lmax;
  	unsigned sfb_smax;
! 	unsigned count1bits;
  	/* added for LSF */
  	unsigned *sfb_partition_table;
  	unsigned slen[4];
***************
*** 92,108 ****
  	int resvDrain;
  	unsigned scfsi[2][4];
  	struct {
! 		struct gr_info_s {
  			gr_info tt;
  			} ch[2];
  		} gr[2];
  	} III_side_info_t;
  
  /* Layer III scale factors. */
! 
  typedef struct {
! 	int l[2][2][22];            /* [cb] */
! 	int s[2][2][13][3];         /* [window][cb] */
! 	} III_scalefac_t;  /* [gr][ch] */
  
  #endif
--- 61,78 ----
  	int resvDrain;
  	unsigned scfsi[2][4];
  	struct {
! 		struct gr_info_ss {
  			gr_info tt;
  			} ch[2];
  		} gr[2];
  	} III_side_info_t;
  
  /* Layer III scale factors. */
! /* note: there are only SBPSY_l=(SBMAX_l-1) and SBPSY_s=(SBMAX_s-1) scalefactors.
!  * Dont know why these would be dimensioned SBMAX_l and SBMAX-s */
  typedef struct {
! 	int l[SBMAX_l];            /* [cb] */
! 	int s[SBMAX_s][3];         /* [window][cb] */
! } III_scalefac_t;  /* [gr][ch] */
  
  #endif
diff -r -c -N encoder/lame.c lame3.70/lame.c
*** encoder/lame.c	Wed Dec 31 17:00:00 1969
--- lame3.70/lame.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,1428 ----
+ /*
+  *	LAME MP3 encoding engine
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #include <assert.h>
+ 
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ #include "lame.h"
+ #include "util.h"
+ #include "timestatus.h"
+ #include "psymodel.h"
+ #include "newmdct.h"
+ #include "quantize.h"
+ #include "quantize-pvt.h"
+ #include "l3bitstream.h"
+ #include "formatBitstream.h"
+ #include "version.h"
+ #include "VbrTag.h"
+ #include "id3tag.h"
+ #include "tables.h"
+ #include "brhist.h"
+ #include "get_audio.h"
+ 
+ #ifdef __riscos__
+ #include "asmstuff.h"
+ #endif
+ 
+ 
+ /* Global variable definitions for lame.c */
+ static Bit_stream_struc   bs;
+ static III_side_info_t l3_side;
+ #define MFSIZE (1152+1152+ENCDELAY-MDCTDELAY)
+ static short int mfbuf[2][MFSIZE];
+ static int mf_size;
+ static int mf_samples_to_encode;
+ 
+ 
+ 
+ /********************************************************************
+  *   initialize internal params based on data in gf
+  *   (globalflags struct filled in by calling program)
+  *
+  ********************************************************************/
+ void lame_init_params(lame_global_flags *gfp)
+ {
+   int i;
+   FLOAT compression_ratio;
+ 
+ 
+   memset(&bs, 0, sizeof(Bit_stream_struc));
+   memset(&l3_side,0x00,sizeof(III_side_info_t));
+ 
+ 
+   gfp->frameNum=0;
+   InitFormatBitStream();
+   if (gfp->num_channels==1) {
+     gfp->mode = MPG_MD_MONO;
+   }
+   gfp->stereo=2;
+   if (gfp->mode == MPG_MD_MONO) gfp->stereo=1;
+ 
+ #ifdef BRHIST
+   if (gfp->silent) {
+     disp_brhist=0;  /* turn of VBR historgram */
+   }
+   if (!gfp->VBR) {
+     disp_brhist=0;  /* turn of VBR historgram */
+   }
+ #endif
+ 
+   /* set the output sampling rate, and resample options if necessary
+      samplerate = input sample rate
+      resamplerate = ouput sample rate
+   */
+   if (gfp->out_samplerate==0) {
+     /* user did not specify output sample rate */
+     gfp->out_samplerate=gfp->in_samplerate;   /* default */
+ 
+ 
+     /* if resamplerate is not valid, find a valid value */
+     if (gfp->out_samplerate>=48000) gfp->out_samplerate=48000;
+     else if (gfp->out_samplerate>=44100) gfp->out_samplerate=44100;
+     else if (gfp->out_samplerate>=32000) gfp->out_samplerate=32000;
+     else if (gfp->out_samplerate>=24000) gfp->out_samplerate=24000;
+     else if (gfp->out_samplerate>=22050) gfp->out_samplerate=22050;
+     else gfp->out_samplerate=16000;
+ 
+ 
+     if (gfp->brate>0) {
+       /* check if user specified bitrate requires downsampling */
+       compression_ratio = gfp->out_samplerate*16*gfp->stereo/(1000.0*gfp->brate);
+       if (!gfp->VBR && compression_ratio > 13 ) {
+ 	/* automatic downsample, if possible */
+ 	gfp->out_samplerate = (10*1000.0*gfp->brate)/(16*gfp->stereo);
+ 	if (gfp->out_samplerate<=16000) gfp->out_samplerate=16000;
+ 	else if (gfp->out_samplerate<=22050) gfp->out_samplerate=22050;
+ 	else if (gfp->out_samplerate<=24000) gfp->out_samplerate=24000;
+ 	else if (gfp->out_samplerate<=32000) gfp->out_samplerate=32000;
+ 	else if (gfp->out_samplerate<=44100) gfp->out_samplerate=44100;
+ 	else gfp->out_samplerate=48000;
+       }
+     }
+   }
+ 
+   gfp->mode_gr = (gfp->out_samplerate <= 24000) ? 1 : 2;  /* mode_gr = 2 */
+   gfp->encoder_delay = ENCDELAY;
+   gfp->framesize = gfp->mode_gr*576;
+ 
+   if (gfp->brate==0) { /* user didn't specify a bitrate, use default */
+     gfp->brate=128;
+     if (gfp->mode_gr==1) gfp->brate=64;
+   }
+ 
+ 
+   gfp->resample_ratio=1;
+   if (gfp->out_samplerate != gfp->in_samplerate) gfp->resample_ratio = (FLOAT)gfp->in_samplerate/(FLOAT)gfp->out_samplerate;
+ 
+   /* estimate total frames.  must be done after setting sampling rate so
+    * we know the framesize.  */
+   gfp->totalframes=0;
+   gfp->totalframes = 2+ gfp->num_samples/(gfp->resample_ratio*gfp->framesize);
+ 
+ 
+ 
+   /* 44.1kHz at 56kbs/channel: compression factor of 12.6
+      44.1kHz at 64kbs/channel: compression factor of 11.025
+      44.1kHz at 80kbs/channel: compression factor of 8.82
+      22.05kHz at 24kbs:  14.7
+      22.05kHz at 32kbs:  11.025
+      22.05kHz at 40kbs:  8.82
+      16kHz at 16kbs:  16.0
+      16kHz at 24kbs:  10.7
+ 
+      compression_ratio
+         11                                .70?
+         12                   sox resample .66
+         14.7                 sox resample .45
+ 
+   */
+   if (gfp->brate >= 320) gfp->VBR=0;  /* dont bother with VBR at 320kbs */
+   compression_ratio = gfp->out_samplerate*16*gfp->stereo/(1000.0*gfp->brate);
+ 
+ 
+   /* for VBR, take a guess at the compression_ratio */
+   /* VBR_q           compression       like
+      0                4.4             320kbs
+      1                5.4             256kbs
+      3                7.4             192kbs
+      4                8.8             160kbs
+      6                10.4            128kbs
+   */
+   if (gfp->VBR && compression_ratio>11) {
+     compression_ratio = 4.4 + gfp->VBR_q;
+   }
+ 
+ 
+   /* At higher quality (lower compression) use STEREO instead of JSTEREO.
+    * (unless the user explicitly specified a mode ) */
+   if ( (!gfp->mode_fixed) && (gfp->mode !=MPG_MD_MONO)) {
+     if (compression_ratio < 9 ) {
+       gfp->mode = MPG_MD_STEREO;
+     }
+   }
+ 
+ 
+ 
+   /****************************************************************/
+   /* if a filter has not been enabled, see if we should add one: */
+   /****************************************************************/
+   if (gfp->lowpassfreq == 0) {
+     /* If the user has not selected their own filter, add a lowpass
+      * filter based on the compression ratio.  Formula based on
+           44.1   /160    4.4x
+           44.1   /128    5.5x      keep all bands
+           44.1   /96kbs  7.3x      keep band 28
+           44.1   /80kbs  8.8x      keep band 25
+           44.1khz/64kbs  11x       keep band 21  22?
+ 
+ 	  16khz/24kbs  10.7x       keep band 21
+ 	  22kHz/32kbs  11x         keep band ?
+ 	  22kHz/24kbs  14.7x       keep band 16
+           16    16     16x         keep band 14
+     */
+ 
+ 
+     /* Should we use some lowpass filters? */
+     int band = 1+floor(.5 + 14-18*log(compression_ratio/16.0));
+     if (band < 31) {
+       gfp->lowpass1 = band/31.0;
+       gfp->lowpass2 = band/31.0;
+     }
+   }
+ 
+   /****************************************************************/
+   /* apply user driven filters*/
+   /****************************************************************/
+   if ( gfp->highpassfreq > 0 ) {
+     gfp->highpass1 = 2.0*gfp->highpassfreq/gfp->out_samplerate; /* will always be >=0 */
+     if ( gfp->highpasswidth >= 0 ) {
+       gfp->highpass2 = 2.0*(gfp->highpassfreq+gfp->highpasswidth)/gfp->out_samplerate;
+     } else {
+       /* 15% above on default */
+       /* gfp->highpass2 = 1.15*2.0*gfp->highpassfreq/gfp->out_samplerate;  */
+       gfp->highpass2 = 1.00*2.0*gfp->highpassfreq/gfp->out_samplerate; 
+     }
+     gfp->highpass1 = Min( 1, gfp->highpass1 );
+     gfp->highpass2 = Min( 1, gfp->highpass2 );
+   }
+ 
+   if ( gfp->lowpassfreq > 0 ) {
+     gfp->lowpass2 = 2.0*gfp->lowpassfreq/gfp->out_samplerate; /* will always be >=0 */
+     if ( gfp->lowpasswidth >= 0 ) {
+       gfp->lowpass1 = 2.0*(gfp->lowpassfreq-gfp->lowpasswidth)/gfp->out_samplerate;
+       if ( gfp->lowpass1 < 0 ) { /* has to be >= 0 */
+ 	gfp->lowpass1 = 0;
+       }
+     } else {
+       /* 15% below on default */
+       /* gfp->lowpass1 = 0.85*2.0*gfp->lowpassfreq/gfp->out_samplerate;  */
+       gfp->lowpass1 = 1.00*2.0*gfp->lowpassfreq/gfp->out_samplerate;
+     }
+     gfp->lowpass1 = Min( 1, gfp->lowpass1 );
+     gfp->lowpass2 = Min( 1, gfp->lowpass2 );
+   }
+ 
+ 
+   /***************************************************************/
+   /* compute info needed for polyphase filter                    */
+   /***************************************************************/
+   if (gfp->filter_type==0) {
+     int band,maxband,minband;
+     FLOAT8 amp,freq;
+     if (gfp->lowpass1 > 0) {
+       minband=999;
+       maxband=-1;
+       for (band=0;  band <=31 ; ++band) { 
+ 	freq = band/31.0;
+ 	amp = 1;
+ 	/* this band and above will be zeroed: */
+ 	if (freq >= gfp->lowpass2) {
+ 	  gfp->lowpass_band= Min(gfp->lowpass_band,band);
+ 	  amp=0;
+ 	}
+ 	if (gfp->lowpass1 < freq && freq < gfp->lowpass2) {
+           minband = Min(minband,band);
+           maxband = Max(maxband,band);
+ 	  amp = cos((PI/2)*(gfp->lowpass1-freq)/(gfp->lowpass2-gfp->lowpass1));
+ 	}
+ 	/* printf("lowpass band=%i  amp=%f \n",band,amp);*/
+       }
+       /* compute the *actual* transition band implemented by the polyphase filter */
+       if (minband==999) gfp->lowpass1 = (gfp->lowpass_band-.75)/31.0;
+       else gfp->lowpass1 = (minband-.75)/31.0;
+       gfp->lowpass2 = gfp->lowpass_band/31.0;
+     }
+ 
+     /* make sure highpass filter is within 90% of whan the effective highpass
+      * frequency will be */
+     if (gfp->highpass2 > 0) 
+       if (gfp->highpass2 <  .9*(.75/31.0) ) {
+ 	gfp->highpass1=0; gfp->highpass2=0;
+ 	fprintf(stderr,"Warning: highpass filter disabled.  highpass frequency to small\n");
+       }
+     
+ 
+     if (gfp->highpass2 > 0) {
+       minband=999;
+       maxband=-1;
+       for (band=0;  band <=31; ++band) { 
+ 	freq = band/31.0;
+ 	amp = 1;
+ 	/* this band and below will be zereod */
+ 	if (freq <= gfp->highpass1) {
+ 	  gfp->highpass_band = Max(gfp->highpass_band,band);
+ 	  amp=0;
+ 	}
+ 	if (gfp->highpass1 < freq && freq < gfp->highpass2) {
+           minband = Min(minband,band);
+           maxband = Max(maxband,band);
+ 	  amp = cos((PI/2)*(gfp->highpass2-freq)/(gfp->highpass2-gfp->highpass1));
+ 	}
+ 	/*	printf("highpass band=%i  amp=%f \n",band,amp);*/
+       }
+       /* compute the *actual* transition band implemented by the polyphase filter */
+       gfp->highpass1 = gfp->highpass_band/31.0;
+       if (maxband==-1) gfp->highpass2 = (gfp->highpass_band+.75)/31.0;
+       else gfp->highpass2 = (maxband+.75)/31.0;
+     }
+     /*
+     printf("lowpass band with amp=0:  %i \n",gfp->lowpass_band);
+     printf("highpass band with amp=0:  %i \n",gfp->highpass_band);
+     */
+   }
+ 
+ 
+ 
+   /***************************************************************/
+   /* compute info needed for FIR filter */
+   /***************************************************************/
+   if (gfp->filter_type==1) {
+   }
+ 
+ 
+ 
+ 
+   gfp->mode_ext=MPG_MD_LR_LR;
+   gfp->stereo = (gfp->mode == MPG_MD_MONO) ? 1 : 2;
+ 
+ 
+   gfp->samplerate_index = SmpFrqIndex((long)gfp->out_samplerate, &gfp->version);
+   if( gfp->samplerate_index < 0) {
+     display_bitrates(stderr);
+     exit(1);
+   }
+   if( (gfp->bitrate_index = BitrateIndex(gfp->brate, gfp->version,gfp->out_samplerate)) < 0) {
+     display_bitrates(stderr);
+     exit(1);
+   }
+ 
+ 
+   /* choose a min/max bitrate for VBR */
+   if (gfp->VBR) {
+     /* if the user didn't specify VBR_max_bitrate: */
+     if (0==gfp->VBR_max_bitrate_kbps) {
+       /* default max bitrate is 256kbs */
+       /* we do not normally allow 320bps frams with VBR, unless: */
+       gfp->VBR_max_bitrate=13;   /* default: allow 256kbs */
+       if (gfp->VBR_min_bitrate_kbps>=256) gfp->VBR_max_bitrate=14;
+       if (gfp->VBR_q == 0) gfp->VBR_max_bitrate=14;   /* allow 320kbs */
+       if (gfp->VBR_q >= 4) gfp->VBR_max_bitrate=12;   /* max = 224kbs */
+       if (gfp->VBR_q >= 8) gfp->VBR_max_bitrate=9;    /* low quality, max = 128kbs */
+     }else{
+       if( (gfp->VBR_max_bitrate  = BitrateIndex(gfp->VBR_max_bitrate_kbps, gfp->version,gfp->out_samplerate)) < 0) {
+ 	display_bitrates(stderr);
+ 	exit(1);
+       }
+     }
+     if (0==gfp->VBR_min_bitrate_kbps) {
+       gfp->VBR_min_bitrate=1;  /* 32 kbps */
+     }else{
+       if( (gfp->VBR_min_bitrate  = BitrateIndex(gfp->VBR_min_bitrate_kbps, gfp->version,gfp->out_samplerate)) < 0) {
+ 	display_bitrates(stderr);
+ 	exit(1);
+       }
+     }
+ 
+   }
+ 
+ 
+   if (gfp->VBR) gfp->quality=Min(gfp->quality,2);    /* always use quality <=2  with VBR */
+   /* dont allow forced mid/side stereo for mono output */
+   if (gfp->mode == MPG_MD_MONO) gfp->force_ms=0;
+ 
+ 
+   /* Do not write VBR tag if VBR flag is not specified */
+   if (gfp->VBR==0) gfp->bWriteVbrTag=0;
+ 
+   /* some file options not allowed if output is: not specified or stdout */
+ 
+   if (gfp->outPath!=NULL && gfp->outPath[0]=='-' ) {
+     gfp->bWriteVbrTag=0; /* turn off VBR tag */
+   }
+ 
+   if (gfp->outPath==NULL || gfp->outPath[0]=='-' ) {
+     id3tag.used=0;         /* turn of id3 tagging */
+   }
+ 
+ 
+ 
+   if (gfp->gtkflag) {
+     gfp->bWriteVbrTag=0;  /* disable Xing VBR tag */
+   }
+ 
+   init_bit_stream_w(&bs);
+ 
+ 
+ 
+   /* set internal feature flags.  USER should not access these since
+    * some combinations will produce strange results */
+ 
+   /* no psymodel, no noise shaping */
+   if (gfp->quality==9) {
+     gfp->filter_type=0;
+     gfp->psymodel=0;
+     gfp->quantization=0;
+     gfp->noise_shaping=0;
+     gfp->noise_shaping_stop=0;
+     gfp->use_best_huffman=0;
+   }
+ 
+   if (gfp->quality==8) gfp->quality=7;
+ 
+   /* use psymodel (for short block and m/s switching), but no noise shapping */
+   if (gfp->quality==7) {
+     gfp->filter_type=0;
+     gfp->psymodel=1;
+     gfp->quantization=0;
+     gfp->noise_shaping=0;
+     gfp->noise_shaping_stop=0;
+     gfp->use_best_huffman=0;
+   }
+ 
+   if (gfp->quality==6) gfp->quality=5;
+ 
+   if (gfp->quality==5) {
+     /* the default */
+     gfp->filter_type=0;
+     gfp->psymodel=1;
+     gfp->quantization=0;
+     gfp->noise_shaping=1;
+     gfp->noise_shaping_stop=0;
+     gfp->use_best_huffman=0;
+   }
+ 
+   if (gfp->quality==4) gfp->quality=2;
+   if (gfp->quality==3) gfp->quality=2;
+ 
+   if (gfp->quality==2) {
+     gfp->filter_type=0;
+     gfp->psymodel=1;
+     gfp->quantization=1;
+     gfp->noise_shaping=1;
+     gfp->noise_shaping_stop=0;
+     gfp->use_best_huffman=1;
+   }
+ 
+   if (gfp->quality==1) {
+     gfp->filter_type=0;
+     gfp->psymodel=1;
+     gfp->quantization=1;
+     gfp->noise_shaping=1;
+     gfp->noise_shaping_stop=1;
+     gfp->use_best_huffman=1;
+   }
+ 
+   if (gfp->quality==0) {
+     /* 0..1 quality */
+     gfp->filter_type=1;         /* not yet coded */
+     gfp->psymodel=1;
+     gfp->quantization=1;
+     gfp->noise_shaping=3;       /* not yet coded */
+     gfp->noise_shaping_stop=2;  /* not yet coded */
+     gfp->use_best_huffman=2;   /* not yet coded */
+     exit(-99);
+   }
+ 
+ 
+   for (i = 0; i < SBMAX_l + 1; i++) {
+     scalefac_band.l[i] =
+       sfBandIndex[gfp->samplerate_index + (gfp->version * 3)].l[i];
+   }
+   for (i = 0; i < SBMAX_s + 1; i++) {
+     scalefac_band.s[i] =
+       sfBandIndex[gfp->samplerate_index + (gfp->version * 3)].s[i];
+   }
+ 
+ 
+ 
+   if (gfp->bWriteVbrTag)
+     {
+       /* Write initial VBR Header to bitstream */
+       InitVbrTag(&bs,1-gfp->version,gfp->mode,gfp->samplerate_index);
+     }
+ 
+ #ifdef HAVEGTK
+   gtkflag=gfp->gtkflag;
+ #endif
+ 
+ #ifdef BRHIST
+   if (gfp->VBR) {
+     if (disp_brhist)
+       brhist_init(gfp,1, 14);
+   } else
+     disp_brhist = 0;
+ #endif
+   return;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+  *
+  * print_config
+  *
+  * PURPOSE:  Prints the encoding parameters used
+  *
+  ************************************************************************/
+ void lame_print_config(lame_global_flags *gfp)
+ {
+   static const char *mode_names[4] = { "stereo", "j-stereo", "dual-ch", "single-ch" };
+   FLOAT out_samplerate=gfp->out_samplerate/1000.0;
+   FLOAT in_samplerate = gfp->resample_ratio*out_samplerate;
+   FLOAT compression=
+     (FLOAT)(gfp->stereo*16*out_samplerate)/(FLOAT)(gfp->brate);
+ 
+   lame_print_version(stderr);
+   if (gfp->num_channels==2 && gfp->stereo==1) {
+     fprintf(stderr, "Autoconverting from stereo to mono. Setting encoding to mono mode.\n");
+   }
+   if (gfp->resample_ratio!=1) {
+     fprintf(stderr,"Resampling:  input=%ikHz  output=%ikHz\n",
+ 	    (int)in_samplerate,(int)out_samplerate);
+   }
+   if (gfp->highpass2>0.0)
+     fprintf(stderr, "Using polyphase highpass filter, transition band: %.0f Hz -  %.0f Hz\n",
+ 	    gfp->highpass1*out_samplerate*500,
+ 	    gfp->highpass2*out_samplerate*500);
+   if (gfp->lowpass1>0.0)
+     fprintf(stderr, "Using polyphase lowpass filter,  transition band:  %.0f Hz - %.0f Hz\n",
+ 	    gfp->lowpass1*out_samplerate*500,
+ 	    gfp->lowpass2*out_samplerate*500);
+ 
+   if (gfp->gtkflag) {
+     fprintf(stderr, "Analyzing %s \n",gfp->inPath);
+   }
+   else {
+     fprintf(stderr, "Encoding %s to %s\n",
+ 	    (strcmp(gfp->inPath, "-")? gfp->inPath : "stdin"),
+ 	    (strcmp(gfp->outPath, "-")? gfp->outPath : "stdout"));
+     if (gfp->VBR)
+       fprintf(stderr, "Encoding as %.1fkHz VBR(q=%i) %s MPEG%i LayerIII  qval=%i\n",
+ 	      gfp->out_samplerate/1000.0,
+ 	      gfp->VBR_q,mode_names[gfp->mode],2-gfp->version,gfp->quality);
+     else
+       fprintf(stderr, "Encoding as %.1f kHz %d kbps %s MPEG%i LayerIII (%4.1fx)  qval=%i\n",
+ 	      gfp->out_samplerate/1000.0,gfp->brate,
+ 	      mode_names[gfp->mode],2-gfp->version,compression,gfp->quality);
+   }
+   fflush(stderr);
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * encodeframe()           Layer 3
+ *
+ * encode a single frame
+ *
+ ************************************************************************
+ lame_encode_frame()
+ 
+ 
+                        gr 0            gr 1
+ inbuf:           |--------------|---------------|-------------|
+ MDCT output:  |--------------|---------------|-------------|
+ 
+ FFT's                    <---------1024---------->
+                                          <---------1024-------->
+ 
+ 
+ 
+     inbuf = buffer of PCM data size=MP3 framesize
+     encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY
+     so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]
+ 
+     psy-model FFT has a 1 granule day, so we feed it data for the next granule.
+     FFT is centered over granule:  224+576+224
+     So FFT starts at:   576-224-MDCTDELAY
+ 
+     MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY
+     MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)
+ 
+     FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET
+ 
+ */
+ int lame_encode_frame(lame_global_flags *gfp,
+ short int inbuf_l[],short int inbuf_r[],
+ int mf_size,char *mp3buf, int mp3buf_size)
+ {
+   static unsigned long frameBits;
+   static unsigned long bitsPerSlot;
+   static FLOAT8 frac_SpF;
+   static FLOAT8 slot_lag;
+   static unsigned long sentBits = 0;
+   FLOAT8 xr[2][2][576];
+   int l3_enc[2][2][576];
+   int mp3count;
+   III_psy_ratio masking_ratio[2][2];    /*LR ratios */
+   III_psy_ratio masking_MS_ratio[2][2]; /*MS ratios */
+   III_psy_ratio (*masking)[2][2];  /*LR ratios and MS ratios*/
+   III_scalefac_t scalefac[2][2];
+   short int *inbuf[2];
+ 
+   typedef FLOAT8 pedata[2][2];
+   pedata pe,pe_MS;
+   pedata *pe_use;
+ 
+   int ch,gr,mean_bits;
+   int bitsPerFrame;
+ 
+   int check_ms_stereo;
+   static FLOAT8 ms_ratio[2]={0,0};
+   FLOAT8 ms_ratio_next=0;
+   FLOAT8 ms_ratio_prev=0;
+   static FLOAT8 ms_ener_ratio[2]={0,0};
+ 
+   memset((char *) masking_ratio, 0, sizeof(masking_ratio));
+   memset((char *) masking_MS_ratio, 0, sizeof(masking_MS_ratio));
+   memset((char *) scalefac, 0, sizeof(scalefac));
+   inbuf[0]=inbuf_l;
+   inbuf[1]=inbuf_r;
+ 
+   gfp->mode_ext = MPG_MD_LR_LR;
+ 
+   if (gfp->frameNum==0 )  {
+     /* Figure average number of 'slots' per frame. */
+     FLOAT8 avg_slots_per_frame;
+     FLOAT8 sampfreq =   gfp->out_samplerate/1000.0;
+     int bit_rate = gfp->brate;
+     sentBits = 0;
+     bitsPerSlot = 8;
+     avg_slots_per_frame = (bit_rate*gfp->framesize) /
+            (sampfreq* bitsPerSlot);
+     /* -f fast-math option causes some strange rounding here, be carefull: */
+     frac_SpF  = avg_slots_per_frame - floor(avg_slots_per_frame + 1e-9);
+     if (fabs(frac_SpF) < 1e-9) frac_SpF = 0;
+ 
+     slot_lag  = -frac_SpF;
+     gfp->padding = 1;
+     if (frac_SpF==0) gfp->padding = 0;
+     /* check FFT will not use a negative starting offset */
+     assert(576>=FFTOFFSET);
+     /* check if we have enough data for FFT */
+     assert(mf_size>=(BLKSIZE+gfp->framesize-FFTOFFSET));
+   }
+ 
+ 
+   /********************** padding *****************************/
+   switch (gfp->padding_type) {
+   case 0:
+     gfp->padding=0;
+     break;
+   case 1:
+     gfp->padding=1;
+     break;
+   case 2:
+   default:
+     if (gfp->VBR) {
+       gfp->padding=0;
+     } else {
+       if (gfp->disable_reservoir) {
+ 	gfp->padding = 0;
+ 	/* if the user specified --nores, dont very gfp->padding either */
+ 	/* tiny changes in frac_SpF rounding will cause file differences */
+       }else{
+ 	if (frac_SpF != 0) {
+ 	  if (slot_lag > (frac_SpF-1.0) ) {
+ 	    slot_lag -= frac_SpF;
+ 	    gfp->padding = 0;
+ 	  }
+ 	  else {
+ 	    gfp->padding = 1;
+ 	    slot_lag += (1-frac_SpF);
+ 	  }
+ 	}
+       }
+     }
+   }
+ 
+ 
+   /********************** status display  *****************************/
+   if (!gfp->gtkflag && !gfp->silent) {
+     int mod = gfp->version == 0 ? 200 : 50;
+     if (gfp->frameNum%mod==0) {
+       timestatus(gfp->out_samplerate,gfp->frameNum,gfp->totalframes,gfp->framesize);
+ #ifdef BRHIST
+       if (disp_brhist)
+ 	{
+ 	  brhist_add_count();
+ 	  brhist_disp();
+ 	}
+ #endif
+     }
+   }
+ 
+ 
+   if (gfp->psymodel) {
+     /* psychoacoustic model
+      * psy model has a 1 granule (576) delay that we must compensate for
+      * (mt 6/99).
+      */
+     short int *bufp[2];  /* address of beginning of left & right granule */
+     int blocktype[2];
+ 
+     ms_ratio_prev=ms_ratio[gfp->mode_gr-1];
+     for (gr=0; gr < gfp->mode_gr ; gr++) {
+ 
+       for ( ch = 0; ch < gfp->stereo; ch++ )
+ 	bufp[ch] = &inbuf[ch][576 + gr*576-FFTOFFSET];
+ 
+       L3psycho_anal( gfp,bufp, gr, 
+ 		     &ms_ratio[gr],&ms_ratio_next,&ms_ener_ratio[gr],
+ 		     masking_ratio, masking_MS_ratio,
+ 		     pe[gr],pe_MS[gr],blocktype);
+ 
+       for ( ch = 0; ch < gfp->stereo; ch++ )
+ 	l3_side.gr[gr].ch[ch].tt.block_type=blocktype[ch];
+ 
+     }
+   }else{
+     for (gr=0; gr < gfp->mode_gr ; gr++)
+       for ( ch = 0; ch < gfp->stereo; ch++ ) {
+ 	l3_side.gr[gr].ch[ch].tt.block_type=NORM_TYPE;
+ 	pe[gr][ch]=700;
+       }
+   }
+ 
+ 
+   /* block type flags */
+   for( gr = 0; gr < gfp->mode_gr; gr++ ) {
+     for ( ch = 0; ch < gfp->stereo; ch++ ) {
+       gr_info *cod_info = &l3_side.gr[gr].ch[ch].tt;
+       cod_info->mixed_block_flag = 0;     /* never used by this model */
+       if (cod_info->block_type == NORM_TYPE )
+ 	cod_info->window_switching_flag = 0;
+       else
+ 	cod_info->window_switching_flag = 1;
+     }
+   }
+ 
+   /* polyphase filtering / mdct */
+   mdct_sub48(gfp,inbuf[0], inbuf[1], xr, &l3_side);
+ 
+   /* use m/s gfp->stereo? */
+   check_ms_stereo =  (gfp->mode == MPG_MD_JOINT_STEREO);
+   if (check_ms_stereo) {
+     /* make sure block type is the same in each channel */
+     check_ms_stereo =
+       (l3_side.gr[0].ch[0].tt.block_type==l3_side.gr[0].ch[1].tt.block_type) &&
+       (l3_side.gr[1].ch[0].tt.block_type==l3_side.gr[1].ch[1].tt.block_type);
+   }
+   if (check_ms_stereo) {
+     /* ms_ratio = is like the ratio of side_energy/total_energy */
+     FLOAT8 ms_ratio_ave,ms_ener_ratio_ave;
+     /*     ms_ratio_ave = .5*(ms_ratio[0] + ms_ratio[1]);*/
+     ms_ratio_ave = .25*(ms_ratio[0] + ms_ratio[1]+
+ 			 ms_ratio_prev + ms_ratio_next);
+     ms_ener_ratio_ave = .5*(ms_ener_ratio[0]+ms_ener_ratio[1]);
+     if ( ms_ratio_ave <.35 /*&& ms_ener_ratio_ave<.75*/ ) gfp->mode_ext = MPG_MD_MS_LR;
+   }
+   if (gfp->force_ms) gfp->mode_ext = MPG_MD_MS_LR;
+ 
+ 
+ #ifdef HAVEGTK
+   if (gfp->gtkflag) {
+     int j;
+     for ( gr = 0; gr < gfp->mode_gr; gr++ ) {
+       for ( ch = 0; ch < gfp->stereo; ch++ ) {
+ 	pinfo->ms_ratio[gr]=ms_ratio[gr];
+ 	pinfo->ms_ener_ratio[gr]=ms_ener_ratio[gr];
+ 	pinfo->blocktype[gr][ch]=
+ 	  l3_side.gr[gr].ch[ch].tt.block_type;
+ 	for ( j = 0; j < 576; j++ ) pinfo->xr[gr][ch][j]=xr[gr][ch][j];
+ 	/* if MS stereo, switch to MS psy data */
+ 	if (gfp->mode_ext==MPG_MD_MS_LR) {
+ 	  pinfo->pe[gr][ch]=pinfo->pe[gr][ch+2];
+ 	  pinfo->ers[gr][ch]=pinfo->ers[gr][ch+2];
+ 	  memcpy(pinfo->energy[gr][ch],pinfo->energy[gr][ch+2],
+ 		 sizeof(pinfo->energy[gr][ch]));
+ 	}
+       }
+     }
+   }
+ #endif
+ 
+ 
+ 
+ 
+   /* bit and noise allocation */
+   if (MPG_MD_MS_LR == gfp->mode_ext) {
+     masking = &masking_MS_ratio;    /* use MS masking */
+     pe_use=&pe_MS;
+   } else {
+     masking = &masking_ratio;    /* use LR masking */
+     pe_use=&pe;
+   }
+ 
+ 
+   /*
+   VBR_iteration_loop_new( gfp,*pe_use, ms_ratio, xr, masking, &l3_side, l3_enc,
+   	  &scalefac);
+   */
+ 
+ 
+   if (gfp->VBR) {
+     VBR_iteration_loop( gfp,*pe_use, ms_ratio, xr, *masking, &l3_side, l3_enc,
+ 			scalefac);
+   }else{
+     iteration_loop( gfp,*pe_use, ms_ratio, xr, *masking, &l3_side, l3_enc,
+ 		    scalefac);
+   }
+ 
+ 
+ 
+ 
+ #ifdef BRHIST
+   brhist_temp[gfp->bitrate_index]++;
+ #endif
+ 
+ 
+   /*  write the frame to the bitstream  */
+   getframebits(gfp,&bitsPerFrame,&mean_bits);
+   III_format_bitstream( gfp,bitsPerFrame, l3_enc, &l3_side,
+ 			scalefac, &bs);
+ 
+ 
+   frameBits = bs.totbit - sentBits;
+ 
+ 
+   if ( frameBits % bitsPerSlot )   /* a program failure */
+     fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
+ 	     frameBits, frameBits/bitsPerSlot,
+ 	     frameBits%bitsPerSlot );
+   sentBits += frameBits;
+ 
+   /* copy mp3 bit buffer into array */
+   mp3count = copy_buffer(mp3buf,mp3buf_size,&bs);
+ 
+   if (gfp->bWriteVbrTag) AddVbrFrame((int)(sentBits/8));
+ 
+ #ifdef HAVEGTK
+   if (gfp->gtkflag) {
+     int j;
+     for ( ch = 0; ch < gfp->stereo; ch++ ) {
+       for ( j = 0; j < FFTOFFSET; j++ )
+ 	pinfo->pcmdata[ch][j] = pinfo->pcmdata[ch][j+gfp->framesize];
+       for ( j = FFTOFFSET; j < 1600; j++ ) {
+ 	pinfo->pcmdata[ch][j] = inbuf[ch][j-FFTOFFSET];
+       }
+     }
+   }
+ #endif
+   gfp->frameNum++;
+ 
+   return mp3count;
+ }
+ 
+ 
+ 
+ int fill_buffer_resample(lame_global_flags *gfp,short int *outbuf,int desired_len,
+         short int *inbuf,int len,int *num_used,int ch) {
+ 
+   static FLOAT8 itime[2];
+ #define OLDBUFSIZE 5
+   static short int inbuf_old[2][OLDBUFSIZE];
+   static int init[2]={0,0};
+   int i,j=0,k,linear,value;
+ 
+   if (gfp->frameNum==0 && !init[ch]) {
+     init[ch]=1;
+     itime[ch]=0;
+     memset((char *) inbuf_old[ch], 0, sizeof(short int)*OLDBUFSIZE);
+   }
+   if (gfp->frameNum!=0) init[ch]=0; /* reset, for next time framenum=0 */
+ 
+ 
+   /* if downsampling by an integer multiple, use linear resampling,
+    * otherwise use quadratic */
+   linear = ( fabs(gfp->resample_ratio - floor(.5+gfp->resample_ratio)) < .0001 );
+ 
+   /* time of j'th element in inbuf = itime + j/ifreq; */
+   /* time of k'th element in outbuf   =  j/ofreq */
+   for (k=0;k<desired_len;k++) {
+     int y0,y1,y2,y3;
+     FLOAT8 x0,x1,x2,x3;
+     FLOAT8 time0;
+ 
+     time0 = k*gfp->resample_ratio;       /* time of k'th output sample */
+     j = floor( time0 -itime[ch]  );
+     /* itime[ch] + j;    */            /* time of j'th input sample */
+     if (j+2 >= len) break;             /* not enough data in input buffer */
+ 
+     x1 = time0-(itime[ch]+j);
+     x2 = x1-1;
+     y1 = (j<0) ? inbuf_old[ch][OLDBUFSIZE+j] : inbuf[j];
+     y2 = ((1+j)<0) ? inbuf_old[ch][OLDBUFSIZE+1+j] : inbuf[1+j];
+ 
+     /* linear resample */
+     if (linear) {
+       outbuf[k] = floor(.5 +  (y2*x1-y1*x2) );
+     } else {
+       /* quadratic */
+       x0 = x1+1;
+       x3 = x1-2;
+       y0 = ((j-1)<0) ? inbuf_old[ch][OLDBUFSIZE+(j-1)] : inbuf[j-1];
+       y3 = ((j+2)<0) ? inbuf_old[ch][OLDBUFSIZE+(j+2)] : inbuf[j+2];
+       value = floor(.5 +
+ 			-y0*x1*x2*x3/6 + y1*x0*x2*x3/2 - y2*x0*x1*x3/2 +y3*x0*x1*x2/6
+ 			);
+       if (value > 32767) outbuf[k]=32767;
+       else if (value < -32767) outbuf[k]=-32767;
+       else outbuf[k]=value;
+ 
+       /*
+       printf("k=%i  new=%i   [ %i %i %i %i ]\n",k,outbuf[k],
+ 	     y0,y1,y2,y3);
+       */
+     }
+   }
+ 
+ 
+   /* k = number of samples added to outbuf */
+   /* last k sample used data from j,j+1, or j+1 overflowed buffer */
+   /* remove num_used samples from inbuf: */
+   *num_used = Min(len,j+2);
+   itime[ch] += *num_used - k*gfp->resample_ratio;
+   for (i=0;i<OLDBUFSIZE;i++)
+     inbuf_old[ch][i]=inbuf[*num_used + i -OLDBUFSIZE];
+   return k;
+ }
+ 
+ 
+ 
+ 
+ int fill_buffer(lame_global_flags *gfp,short int *outbuf,int desired_len,short int *inbuf,int len) {
+   int j;
+   j=Min(desired_len,len);
+   memcpy( (char *) outbuf,(char *)inbuf,sizeof(short int)*j);
+   return j;
+ }
+ 
+ 
+ 
+ 
+ /*
+  * THE MAIN LAME ENCODING INTERFACE
+  * mt 3/00
+  *
+  * input pcm data, output (maybe) mp3 frames.
+  * This routine handles all buffering, resampling and filtering for you.
+  * The required mp3buffer_size can be computed from num_samples,
+  * samplerate and encoding rate, but here is a worst case estimate:
+  *
+  * mp3buffer_size in bytes = 1.25*num_samples + 7200
+  *
+  * return code = number of bytes output in mp3buffer.  can be 0
+ */
+ int lame_encode_buffer(lame_global_flags *gfp,
+    short int buffer_l[], short int buffer_r[],int nsamples,
+    char *mp3buf, int mp3buf_size)
+ {
+   static int frame_buffered=0;
+   int mp3size=0,ret,i,ch,mf_needed;
+ 
+   short int *in_buffer[2];
+   in_buffer[0] = buffer_l;
+   in_buffer[1] = buffer_r;
+ 
+   /* some sanity checks */
+   assert(ENCDELAY>=MDCTDELAY);
+   assert(BLKSIZE-FFTOFFSET >= 0);
+   mf_needed = BLKSIZE+gfp->framesize-FFTOFFSET;
+   assert(MFSIZE>=mf_needed);
+ 
+   /* The reason for
+    *       int mf_samples_to_encode = ENCDELAY + 288;
+    * ENCDELAY = internal encoder delay.  And then we have to add 288
+    * because of the 50% MDCT overlap.  A 576 MDCT granule decodes to
+    * 1152 samples.  To synthesize the 576 samples centered under this granule
+    * we need the previous granule for the first 288 samples (no problem), and
+    * the next granule for the next 288 samples (not possible if this is last
+    * granule).  So we need to pad with 288 samples to make sure we can
+    * encode the 576 samples we are interested in.
+    */
+   if (gfp->frameNum==0 && !frame_buffered) {
+     memset((char *) mfbuf, 0, sizeof(mfbuf));
+     frame_buffered=1;
+     mf_samples_to_encode = ENCDELAY+288;
+     mf_size=ENCDELAY-MDCTDELAY;  /* we pad input with this many 0's */
+   }
+   if (gfp->frameNum==1) {
+     /* reset, for the next time frameNum==0 */
+     frame_buffered=0;
+   }
+ 
+   if (gfp->num_channels==2  && gfp->stereo==1) {
+     /* downsample to mono */
+     for (i=0; i<nsamples; ++i) {
+       in_buffer[0][i]=((int)in_buffer[0][i]+(int)in_buffer[1][i])/2;
+       in_buffer[1][i]=0;
+     }
+   }
+ 
+ 
+   while (nsamples > 0) {
+     int n_in=0;
+     int n_out=0;
+     /* copy in new samples */
+     for (ch=0; ch<gfp->stereo; ch++) {
+       if (gfp->resample_ratio!=1)  {
+ 	n_out=fill_buffer_resample(gfp,&mfbuf[ch][mf_size],gfp->framesize,
+ 					  in_buffer[ch],nsamples,&n_in,ch);
+       } else {
+ 	n_out=fill_buffer(gfp,&mfbuf[ch][mf_size],gfp->framesize,in_buffer[ch],nsamples);
+ 	n_in = n_out;
+       }
+       in_buffer[ch] += n_in;
+     }
+ 
+ 
+     nsamples -= n_in;
+     mf_size += n_out;
+     assert(mf_size<=MFSIZE);
+     mf_samples_to_encode += n_out;
+ 
+     if (mf_size >= mf_needed) {
+       /* encode the frame */
+       ret = lame_encode_frame(gfp,mfbuf[0],mfbuf[1],mf_size,mp3buf,mp3buf_size);
+       if (ret == -1) {
+ 	/* fatel error: mp3buffer was too small */
+ 	return -1;
+       }
+       mp3buf += ret;
+       mp3size += ret;
+ 
+       /* shift out old samples */
+       mf_size -= gfp->framesize;
+       mf_samples_to_encode -= gfp->framesize;
+       for (ch=0; ch<gfp->stereo; ch++)
+ 	for (i=0; i<mf_size; i++)
+ 	  mfbuf[ch][i]=mfbuf[ch][i+gfp->framesize];
+     }
+   }
+   assert(nsamples==0);
+   return mp3size;
+ }
+ 
+ 
+ 
+ 
+ int lame_encode_buffer_interleaved(lame_global_flags *gfp,
+    short int buffer[], int nsamples, char *mp3buf, int mp3buf_size)
+ {
+   static int frame_buffered=0;
+   int mp3size=0,ret,i,ch,mf_needed;
+ 
+   /* some sanity checks */
+   assert(ENCDELAY>=MDCTDELAY);
+   assert(BLKSIZE-FFTOFFSET >= 0);
+   mf_needed = BLKSIZE+gfp->framesize-FFTOFFSET;
+   assert(MFSIZE>=mf_needed);
+ 
+   if (gfp->num_channels == 1) {
+     return lame_encode_buffer(gfp,buffer, NULL ,nsamples,mp3buf,mp3buf_size);
+   }
+ 
+   if (gfp->resample_ratio!=1)  {
+     short int *buffer_l;
+     short int *buffer_r;
+     buffer_l=malloc(sizeof(short int)*nsamples);
+     buffer_r=malloc(sizeof(short int)*nsamples);
+     if (buffer_l == NULL || buffer_r == NULL) {
+       return -1;
+     }
+     for (i=0; i<nsamples; i++) {
+       buffer_l[i]=buffer[2*i];
+       buffer_r[i]=buffer[2*i+1];
+     }
+     ret = lame_encode_buffer(gfp,buffer_l,buffer_r,nsamples,mp3buf,mp3buf_size);
+     free(buffer_l);
+     free(buffer_r);
+     return ret;
+   }
+ 
+ 
+   if (gfp->frameNum==0 && !frame_buffered) {
+     memset((char *) mfbuf, 0, sizeof(mfbuf));
+     frame_buffered=1;
+     mf_samples_to_encode = ENCDELAY+288;
+     mf_size=ENCDELAY-MDCTDELAY;  /* we pad input with this many 0's */
+   }
+   if (gfp->frameNum==1) {
+     /* reset, for the next time frameNum==0 */
+     frame_buffered=0;
+   }
+ 
+   if (gfp->num_channels==2  && gfp->stereo==1) {
+     /* downsample to mono */
+     for (i=0; i<nsamples; ++i) {
+       buffer[2*i]=((int)buffer[2*i]+(int)buffer[2*i+1])/2;
+       buffer[2*i+1]=0;
+     }
+   }
+ 
+ 
+   while (nsamples > 0) {
+     int n_out;
+     /* copy in new samples */
+     n_out = Min(gfp->framesize,nsamples);
+     for (i=0; i<n_out; ++i) {
+       mfbuf[0][mf_size+i]=buffer[2*i];
+       mfbuf[1][mf_size+i]=buffer[2*i+1];
+     }
+     buffer += 2*n_out;
+ 
+     nsamples -= n_out;
+     mf_size += n_out;
+     assert(mf_size<=MFSIZE);
+     mf_samples_to_encode += n_out;
+ 
+     if (mf_size >= mf_needed) {
+       /* encode the frame */
+       ret = lame_encode_frame(gfp,mfbuf[0],mfbuf[1],mf_size,mp3buf,mp3buf_size);
+       if (ret == -1) {
+ 	/* fatel error: mp3buffer was too small */
+ 	return -1;
+       }
+       mp3buf += ret;
+       mp3size += ret;
+ 
+       /* shift out old samples */
+       mf_size -= gfp->framesize;
+       mf_samples_to_encode -= gfp->framesize;
+       for (ch=0; ch<gfp->stereo; ch++)
+ 	for (i=0; i<mf_size; i++)
+ 	  mfbuf[ch][i]=mfbuf[ch][i+gfp->framesize];
+     }
+   }
+   assert(nsamples==0);
+   return mp3size;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /* old LAME interface */
+ /* With this interface, it is the users responsibilty to keep track of the
+  * buffered, unencoded samples.  Thus mf_samples_to_encode is not incremented.
+  *
+  * lame_encode() is also used to flush the PCM input buffer by
+  * lame_encode_finish()
+  */
+ int lame_encode(lame_global_flags *gfp, short int in_buffer[2][1152],char *mp3buf,int size){
+   int imp3,save;
+   save = mf_samples_to_encode;
+   imp3= lame_encode_buffer(gfp,in_buffer[0],in_buffer[1],576*gfp->mode_gr,
+         mp3buf,size);
+   mf_samples_to_encode = save;
+   return imp3;
+ }
+ 
+ 
+ 
+ 
+ /* initialize mp3 encoder */
+ void lame_init(lame_global_flags *gfp)
+ {
+ 
+   /*
+    *  Disable floating point exepctions
+    */
+ #ifdef __FreeBSD__
+ # include <floatingpoint.h>
+   {
+   /* seet floating point mask to the Linux default */
+   fp_except_t mask;
+   mask=fpgetmask();
+   /* if bit is set, we get SIGFPE on that error! */
+   fpsetmask(mask & ~(FP_X_INV|FP_X_DZ));
+   /*  fprintf(stderr,"FreeBSD mask is 0x%x\n",mask); */
+   }
+ #endif
+ #if defined(__riscos__) && !defined(ABORTFP)
+   /* Disable FPE's under RISC OS */
+   /* if bit is set, we disable trapping that error! */
+   /*   _FPE_IVO : invalid operation */
+   /*   _FPE_DVZ : divide by zero */
+   /*   _FPE_OFL : overflow */
+   /*   _FPE_UFL : underflow */
+   /*   _FPE_INX : inexact */
+   DisableFPETraps( _FPE_IVO | _FPE_DVZ | _FPE_OFL );
+ #endif
+ 
+ 
+   /*
+    *  Debugging stuff
+    *  The default is to ignore FPE's, unless compiled with -DABORTFP
+    *  so add code below to ENABLE FPE's.
+    */
+ 
+ #if defined(ABORTFP) && !defined(__riscos__)
+ #if defined(_MSC_VER)
+   {
+ 	#include <float.h>
+ 	unsigned int mask;
+ 	mask=_controlfp( 0, 0 );
+ 	mask&=~(_EM_OVERFLOW|_EM_UNDERFLOW|_EM_ZERODIVIDE|_EM_INVALID);
+ 	mask=_controlfp( mask, _MCW_EM );
+ 	}
+ #elif defined(__CYGWIN__)
+ #  define _FPU_GETCW(cw) __asm__ ("fnstcw %0" : "=m" (*&cw))
+ #  define _FPU_SETCW(cw) __asm__ ("fldcw %0" : : "m" (*&cw))
+ 
+ #  define _EM_INEXACT     0x00000001 /* inexact (precision) */
+ #  define _EM_UNDERFLOW   0x00000002 /* underflow */
+ #  define _EM_OVERFLOW    0x00000004 /* overflow */
+ #  define _EM_ZERODIVIDE  0x00000008 /* zero divide */
+ #  define _EM_INVALID     0x00000010 /* invalid */
+   {
+     unsigned int mask;
+     _FPU_GETCW(mask);
+     /* Set the FPU control word to abort on most FPEs */
+     mask &= ~(_EM_UNDERFLOW | _EM_OVERFLOW | _EM_ZERODIVIDE | _EM_INVALID);
+     _FPU_SETCW(mask);
+   }
+ # else
+   {
+ #  include <fpu_control.h>
+ #ifndef _FPU_GETCW
+ #define _FPU_GETCW(cw) __asm__ ("fnstcw %0" : "=m" (*&cw))
+ #endif
+ #ifndef _FPU_SETCW
+ #define _FPU_SETCW(cw) __asm__ ("fldcw %0" : : "m" (*&cw))
+ #endif
+     unsigned int mask;
+     _FPU_GETCW(mask);
+     /* Set the Linux mask to abort on most FPE's */
+     /* if bit is set, we _mask_ SIGFPE on that error! */
+     /*  mask &= ~( _FPU_MASK_IM | _FPU_MASK_ZM | _FPU_MASK_OM | _FPU_MASK_UM );*/
+     mask &= ~( _FPU_MASK_IM | _FPU_MASK_ZM | _FPU_MASK_OM );
+     _FPU_SETCW(mask);
+   }
+ #endif
+ #endif /* ABORTFP && !__riscos__ */
+ 
+ 
+ 
+   /* Global flags.  set defaults here */
+   gfp->allow_diff_short=0;
+   gfp->ATHonly=0;
+   gfp->noATH=0;
+   gfp->bWriteVbrTag=1;
+   gfp->cwlimit=0;
+   gfp->disable_reservoir=0;
+   gfp->experimentalX = 0;
+   gfp->experimentalY = 0;
+   gfp->experimentalZ = 0;
+   gfp->frameNum=0;
+   gfp->gtkflag=0;
+   gfp->quality=5;
+   gfp->input_format=sf_unknown;
+ 
+   gfp->filter_type=0;
+   gfp->lowpassfreq=0;
+   gfp->highpassfreq=0;
+   gfp->lowpasswidth=-1;
+   gfp->highpasswidth=-1;
+   gfp->lowpass1=0;
+   gfp->lowpass2=0;
+   gfp->highpass1=0;
+   gfp->highpass2=0;
+   gfp->lowpass_band=32;
+   gfp->highpass_band=-1;
+ 
+   gfp->no_short_blocks=0;
+   gfp->resample_ratio=1;
+   gfp->padding_type=2;
+   gfp->padding=0;
+   gfp->swapbytes=0;
+   gfp->silent=0;
+   gfp->totalframes=0;
+   gfp->VBR=0;
+   gfp->VBR_q=4;
+   gfp->VBR_min_bitrate_kbps=0;
+   gfp->VBR_max_bitrate_kbps=0;
+   gfp->VBR_min_bitrate=1;
+   gfp->VBR_max_bitrate=13;
+ 
+ 
+   gfp->version = 1;   /* =1   Default: MPEG-1 */
+   gfp->mode = MPG_MD_JOINT_STEREO;
+   gfp->mode_fixed=0;
+   gfp->force_ms=0;
+   gfp->brate=0;
+   gfp->copyright=0;
+   gfp->original=1;
+   gfp->extension=0;
+   gfp->error_protection=0;
+   gfp->emphasis=0;
+   gfp->in_samplerate=1000*44.1;
+   gfp->out_samplerate=0;
+   gfp->num_channels=2;
+   gfp->num_samples=MAX_U_32_NUM;
+ 
+   gfp->inPath=NULL;
+   gfp->outPath=NULL;
+   id3tag.used=0;
+ 
+ }
+ 
+ 
+ 
+ /*****************************************************************/
+ /* flush internal mp3 buffers,                                   */
+ /*****************************************************************/
+ int lame_encode_finish(lame_global_flags *gfp,char *mp3buffer, int mp3buffer_size)
+ {
+   int imp3,mp3count,mp3buffer_size_remaining;
+   short int buffer[2][1152];
+   memset((char *)buffer,0,sizeof(buffer));
+   mp3count = 0;
+ 
+   while (mf_samples_to_encode > 0) {
+ 
+     mp3buffer_size_remaining = mp3buffer_size - mp3count;
+     /* if user specifed buffer size = 0, dont check size */
+     if (mp3buffer_size == 0) mp3buffer_size_remaining=0;  
+     imp3=lame_encode(gfp,buffer,mp3buffer,mp3buffer_size_remaining);
+ 
+     if (imp3 == -1) {
+       /* fatel error: mp3buffer too small */
+       desalloc_buffer(&bs);    /* Deallocate all buffers */
+       return -1;
+     }
+     mp3buffer += imp3;
+     mp3count += imp3;
+     mf_samples_to_encode -= gfp->framesize;
+   }
+ 
+ 
+   gfp->frameNum--;
+   if (!gfp->gtkflag && !gfp->silent) {
+       timestatus(gfp->out_samplerate,gfp->frameNum,gfp->totalframes,gfp->framesize);
+ #ifdef BRHIST
+       if (disp_brhist)
+ 	{
+ 	  brhist_add_count();
+ 	  brhist_disp();
+ 	  brhist_disp_total(gfp);
+ 	}
+ #endif
+       fprintf(stderr,"\n");
+       fflush(stderr);
+   }
+ 
+ 
+   III_FlushBitstream();
+   mp3buffer_size_remaining = mp3buffer_size - mp3count;
+   /* if user specifed buffer size = 0, dont check size */
+   if (mp3buffer_size == 0) mp3buffer_size_remaining=0;  
+ 
+   imp3= copy_buffer(mp3buffer,mp3buffer_size_remaining,&bs);
+   if (imp3 == -1) {
+     /* fatel error: mp3buffer too small */
+     desalloc_buffer(&bs);    /* Deallocate all buffers */
+     return -1;
+   }
+ 
+   mp3count += imp3;
+   desalloc_buffer(&bs);    /* Deallocate all buffers */
+   return mp3count;
+ }
+ 
+ 
+ /*****************************************************************/
+ /* write VBR Xing header, and ID3 tag, if asked for               */
+ /*****************************************************************/
+ void lame_mp3_tags(lame_global_flags *gfp)
+ {
+   if (gfp->bWriteVbrTag)
+     {
+       /* Calculate relative quality of VBR stream
+        * 0=best, 100=worst */
+       int nQuality=gfp->VBR_q*100/9;
+       /* Write Xing header again */
+       PutVbrTag(gfp->outPath,nQuality,1-gfp->version);
+     }
+ 
+ 
+   /* write an ID3 tag  */
+   if(id3tag.used) {
+     id3_buildtag(&id3tag);
+     id3_writetag(gfp->outPath, &id3tag);
+   }
+ }
+ 
+ 
+ void lame_version(lame_global_flags *gfp,char *ostring) {
+   strncpy(ostring,get_lame_version(),20);
+ }
+ 
diff -r -c -N encoder/lame.dsp lame3.70/lame.dsp
*** encoder/lame.dsp	Wed Dec 31 17:00:00 1969
--- lame3.70/lame.dsp	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,336 ----
+ # Microsoft Developer Studio Project File - Name="lame" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Console Application" 0x0103
+ 
+ CFG=lame - Win32 Debug GTK
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak" CFG="lame - Win32 Debug GTK"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "lame - Win32 Release" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug GTK" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Release GTK" (based on\
+  "Win32 (x86) Console Application")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "lame - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Ox /Ot /Og /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "LAMEPARSE" /D "HAVEMPGLIB" /D "LAMESNDFILE"  /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /W3 /Gm /GX /Zi /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "lame___W"
+ # PROP BASE Intermediate_Dir "lame___W"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "DebugGTK"
+ # PROP Intermediate_Dir "DebugGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS"  /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /W3 /Gm /GX /Zi /Od /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "LAMESNDFILE" /D "HAVEMPGLIB" /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Release GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "lame___0"
+ # PROP BASE Intermediate_Dir "lame___0"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "ReleaseGTK"
+ # PROP Intermediate_Dir "ReleaseGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS"  /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "LAMEPARSE" /D "HAVEMPGLIB" /D "LAMESNDFILE" /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /profile /map /machine:I386 /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "lame - Win32 Release"
+ # Name "lame - Win32 Debug"
+ # Name "lame - Win32 Debug GTK"
+ # Name "lame - Win32 Release GTK"
+ # Begin Source File
+ 
+ SOURCE=.\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fft.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fft.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\get_audio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\get_audio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\id3tag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\id3tag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\lame.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\lame.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\machine.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\main.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\newmdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\newmdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\parse.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\psymodel.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\psymodel.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\quantize-pvt.c"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\quantize-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\quantize.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\quantize.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tables.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\takehiro.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\timestatus.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\timestatus.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\util.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\util.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\vbrquantize.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\WinGTK.txt
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/lame.dsw lame3.70/lame.dsw
*** encoder/lame.dsw	Wed Dec 31 17:00:00 1969
--- lame3.70/lame.dsw	Wed Nov 24 01:43:20 1999
***************
*** 0 ****
--- 1,44 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "lame"=.\lame.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+     Begin Project Dependency
+     Project_Dep_Name mpglib
+     End Project Dependency
+ }}}
+ 
+ ###############################################################################
+ 
+ Project: "mpglib"=.\mpglib\mpglib.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/lame.h lame3.70/lame.h
*** encoder/lame.h	Wed Dec 31 17:00:00 1969
--- lame3.70/lame.h	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,336 ----
+ /*
+  *	Interface to MP3 LAME encoding engine
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ #ifndef LAME_H_INCLUDE
+ #define LAME_H_INCLUDE
+ #include <stdio.h>
+ 
+ /* maximum size of mp3buffer needed if you encode at most 1152 samples for
+    each call to lame_encode_buffer.  see lame_encode_buffer() below  */
+ #define LAME_MAXMP3BUFFER 16384
+ 
+ 
+ typedef enum sound_file_format_e {
+ 	sf_unknown, sf_wave, sf_aiff, sf_mp3, sf_raw
+ } sound_file_format;
+ 
+ 
+ /***********************************************************************
+ *
+ *  Global Variables.  
+ *
+ *  substantiated in lame.c
+ *
+ *  Initilized and default values set by gf=lame_init()
+ *  gf is a pointer to this struct, which the user may use to 
+ *  override any of the default values
+ *
+ *  a call to lame_set_params() is also needed
+ *
+ ***********************************************************************/
+ typedef struct  {
+   /* input file description */
+   unsigned long num_samples;  /* number of samples. default=2^32-1    */
+   int num_channels;           /* input number of channels. default=2  */
+   int in_samplerate;          /* input_samp_rate. default=44.1kHz     */
+   int out_samplerate;         /* output_samp_rate. (usually determined automatically)   */ 
+ 
+ 
+   /* general control params */
+   int gtkflag;                /* run frame analyzer?       */
+   int bWriteVbrTag;           /* add Xing VBR tag?         */
+   int quality;                /* quality setting 0=best,  9=worst  */
+   int silent;                 /* disable some status output */
+   int mode;                       /* 0,1,2,3 stereo,jstereo,dual channel,mono */
+   int mode_fixed;                 /* use specified the mode, do not use lame's opinion of the best mode */
+   int force_ms;                   /* force M/S mode.  requires mode=1 */
+   int brate;                      /* bitrate */
+ 
+   /* frame params */
+   int copyright;                  /* mark as copyright. default=0 */
+   int original;                   /* mark as original. default=1 */
+   int error_protection;           /* use 2 bytes per frame for a CRC checksum. default=0*/
+   int padding_type;               /* 0=no padding, 1=always pad, 2=adjust padding */
+   int extension;                  /* the MP3 'private extension' bit.  meaningless */
+ 
+   /* quantization/noise shaping */
+   int disable_reservoir;          /* use bit reservoir? */
+   int experimentalX;            
+   int experimentalY;
+   int experimentalZ;
+ 
+   /* VBR control */
+   int VBR;
+   int VBR_q;
+   int VBR_min_bitrate_kbps;
+   int VBR_max_bitrate_kbps;
+ 
+ 
+   /* resampling and filtering */
+   int lowpassfreq;                /* freq in Hz. 0=lame choses. -1=no filter */
+   int highpassfreq;               /* freq in Hz. 0=lame choses. -1=no filter */
+   int lowpasswidth;               /* freq width of filter, in Hz (default=15%)*/
+   int highpasswidth;              /* freq width of filter, in Hz (default=15%)*/
+ 
+ 
+   /* input file reading - not used if calling program does the i/o */
+   sound_file_format input_format;   
+   int swapbytes;              /* force byte swapping   default=0*/
+   char *inPath;               /* name of input file */
+   char *outPath;              /* name of output file. */
+   /* Note: outPath must be set if you want Xing VBR or id3 tags
+    * written */
+ 
+ 
+   /* psycho acoustics and other aguments which you should not change 
+    * unless you know what you are doing  */
+   int ATHonly;                    /* only use ATH */
+   int noATH;                      /* disable ATH */
+   float cwlimit;                  /* predictability limit */
+   int allow_diff_short;       /* allow blocktypes to differ between channels ? */
+   int no_short_blocks;        /* disable short blocks       */
+   int emphasis;                   /* obsolete */
+ 
+ 
+ 
+   /********************************************************************/
+   /* internal variables NOT set by calling program, and should not be */
+   /* modified by the calling program                                  */
+   /********************************************************************/
+   long int frameNum;              /* frame counter */
+   long totalframes;               /* frames: 0..totalframes-1 (estimate)*/
+   int encoder_delay;
+   int framesize;                  
+   int version;                    /* 0=MPEG2  1=MPEG1 */
+   int padding;                    /* padding for the current frame? */
+   int mode_gr;                    /* granules per frame */
+   int stereo;                     /* number of channels */
+   int VBR_min_bitrate;            /* min bitrate index */
+   int VBR_max_bitrate;            /* max bitrate index */
+   float resample_ratio;           /* input_samp_rate/output_samp_rate */
+   int bitrate_index;
+   int samplerate_index;
+   int mode_ext;
+ 
+   /* lowpass and highpass filter control */
+   float lowpass1,lowpass2;        /* normalized frequency bounds of passband */
+   float highpass1,highpass2;      /* normalized frequency bounds of passband */
+                                   
+   /* polyphase filter (filter_type=0)  */
+   int lowpass_band;          /* zero bands >= lowpass_band in the polyphase filterbank */
+   int highpass_band;         /* zero bands <= highpass_band */
+ 
+ 
+ 
+   int filter_type;          /* 0=polyphase filter, 1= FIR filter 2=MDCT filter(bad)*/
+   int quantization;         /* 0 = ISO formual,  1=best amplitude */
+   int noise_shaping;        /* 0 = none 
+                                1 = ISO AAC model
+                                2 = allow scalefac_select=1  
+                              */
+ 
+   int noise_shaping_stop;   /* 0 = stop at over=0, all scalefacs amplified or
+                                    a scalefac has reached max value
+                                1 = stop when all scalefacs amplified or        
+                                    a scalefac has reached max value
+                                2 = stop when all scalefacs amplified 
+ 			    */
+ 
+   int psymodel;             /* 0 = none   1=gpsycho */
+   int use_best_huffman;     /* 0 = no.  1=outside loop  2=inside loop(slow) */
+ 
+ 
+ } lame_global_flags;
+ 
+ 
+ 
+ 
+ 
+ 
+ /*
+ 
+ The LAME API
+ 
+  */
+ 
+ 
+ /* REQUIRED: initialize the encoder.  sets default for all encoder paramters,
+  * returns pointer to encoder parameters listed above 
+  */
+ void lame_init(lame_global_flags *);
+ 
+ 
+ 
+ 
+ /*********************************************************************
+  * command line argument parsing & option setting.  Only supported
+  * if libmp3lame compiled with LAMEPARSE defined 
+  *********************************************************************/
+ /* OPTIONAL: call this to print an error with a brief command line usage guide and quit 
+  * only supported if libmp3lame compiled with LAMEPARSE defined.  
+  */
+ void lame_usage(lame_global_flags *, char *);
+ 
+ /* OPTIONAL: call this to print a command line interface usage guide and quit   */
+ void lame_help(lame_global_flags *, char *);
+ 
+ /* OPTIONAL: get the version number, in a string. of the form:  "3.63 (beta)" or 
+    just "3.63".  Max allows length is 20 characters  */
+ void lame_version(lame_global_flags *, char *);
+ 
+ 
+ /* OPTIONAL: set internal options via command line argument parsing 
+  * You can skip this call if you like the default values, or if
+  * set the encoder parameters your self 
+  */
+ void lame_parse_args(lame_global_flags *, int argc, char **argv);
+ 
+ 
+ 
+ 
+ 
+ /* REQUIRED:  sets more internal configuration based on data provided
+  * above
+  */
+ void lame_init_params(lame_global_flags *);
+ 
+ 
+ /* OPTONAL:  print internal lame configuration on stderr*/
+ void lame_print_config(lame_global_flags *);
+ 
+ 
+ 
+ 
+ /* input pcm data, output (maybe) mp3 frames.
+  * This routine handles all buffering, resampling and filtering for you.
+  * 
+  * leftpcm[]       array of 16bit pcm data, left channel
+  * rightpcm[]      array of 16bit pcm data, right channel
+  * num_samples     number of samples in leftpcm[] and rightpcm[] (if stereo)
+  * mp3buffer       pointer to buffer where mp3 output is written
+  * mp3buffer_size  size of mp3buffer, in bytes
+  * return code     number of bytes output in mp3buffer.  can be 0 
+  *                 if return code = -1:  mp3buffer was too small
+  *
+  * The required mp3buffer_size can be computed from num_samples, 
+  * samplerate and encoding rate, but here is a worst case estimate:
+  *
+  * mp3buffer_size in bytes = 1.25*num_samples + 7200
+  *
+  * I think a tighter bound could be:  (mt, March 2000)
+  * MPEG1:
+  *    num_samples*(bitrate/8)/samplerate + 4*1152*(bitrate/8)/samplerate + 512
+  * MPEG2:
+  *    num_samples*(bitrate/8)/samplerate + 4*576*(bitrate/8)/samplerate + 256
+  *
+  * but test first if you use that!
+  *
+  * set mp3buffer_size = 0 and LAME will not check if mp3buffer_size is
+  * large enough.
+  *
+  * NOTE: if gfp->num_channels=2, but gfp->mode = 3 (mono), the L & R channels
+  * will be averaged into the L channel before encoding only the L channel
+  * This will overwrite the data in leftpcm[] and rightpcm[].
+  * 
+ */
+ int lame_encode_buffer(lame_global_flags *,short int leftpcm[], short int rightpcm[],int num_samples,
+ char *mp3buffer,int  mp3buffer_size);
+ 
+ /* as above, but input has L & R channel data interleaved.  Note: 
+  * num_samples = number of samples in the L (or R)
+  * channel, not the total number of samples in pcm[]  
+  */
+ int lame_encode_buffer_interleaved(lame_global_flags *,short int pcm[], 
+ int num_samples, char *mp3buffer,int  mp3buffer_size);
+ 
+ 
+ 
+ /* input 1 pcm frame, output (maybe) 1 mp3 frame.  
+  * return code = number of bytes output in mp3buffer.  can be 0 
+  * NOTE: this interface is outdated, please use lame_encode_buffer() instead 
+  * declair mp3buffer with:  char mp3buffer[LAME_MAXMP3BUFFER] 
+  * if return code = -1:  mp3buffer was too small 
+  */
+ int lame_encode(lame_global_flags *,short int Buffer[2][1152],char *mp3buffer,int mp3buffer_size);
+ 
+ 
+ 
+ /* REQUIRED:  lame_encode_finish will flush the buffers and may return a 
+  * final few mp3 frames.  mp3buffer should be at least 7200 bytes.
+  *
+  * return code = number of bytes output to mp3buffer.  can be 0
+  */
+ int lame_encode_finish(lame_global_flags *,char *mp3buffer, int size);
+ 
+ 
+ /* OPTIONAL:  lame_mp3_tags will append id3 and Xing VBR tags to
+ the mp3 file with name given by gf->outPath.  These calls open the file,
+ write tags, and close the file, so make sure the the encoding is finished
+ before calling these routines.  
+ Note: if VBR and id3 tags are turned off by the user, or turned off
+ by LAME because the output is not a regular file, this call does nothing
+ */
+ void lame_mp3_tags(lame_global_flags *);
+ 
+ 
+ 
+ 
+ /*********************************************************************
+  * lame file i/o.  Only supported
+  * if libmp3lame compiled with LAMESNDFILE or LIBSNDFILE
+  *********************************************************************/
+ /* OPTIONAL: open the input file, and parse headers if possible 
+  * you can skip this call if you will do your own PCM input 
+  */
+ void lame_init_infile(lame_global_flags *);
+ 
+ /* OPTIONAL:  read one frame of PCM data from audio input file opened by 
+  * lame_init_infile.  Input file can be wav, aiff, raw pcm, anything
+  * supported by libsndfile, or an mp3 file
+  */
+ int lame_readframe(lame_global_flags *,short int Buffer[2][1152]);
+ 
+ /* OPTIONAL: close the sound input file if lame_init_infile() was used */
+ void lame_close_infile(lame_global_flags *);
+ 
+ 
+ 
+ 
+ 
+ /*********************************************************************
+  * a simple interface to mpglib, part of mpg123, is also included if
+  * libmp3lame is compiled with HAVEMPGLIB
+  * input 1 mp3 frame, output (maybe) 1 pcm frame.   
+  * lame_decode return code:  -1: error.  0: need more data.  n>0: size of pcm output
+  *********************************************************************/
+ int lame_decode_init(void);
+ int lame_decode(char *mp3buf,int len,short pcm_l[],short pcm_r[]);
+ /* read mp3 file until mpglib returns one frame of PCM data */
+ #ifdef AMIGA_MPEGA
+ int lame_decode_initfile(const char *fullname,int *stereo,int *samp,int *bitrate, unsigned long *nsamp);
+ int lame_decode_fromfile(FILE *fd,short int pcm_l[], short int pcm_r[]);
+ #else
+ int lame_decode_initfile(FILE *fd,int *stereo,int *samp,int *bitrate, unsigned long *nsamp);
+ int lame_decode_fromfile(FILE *fd,short int pcm_l[],short int pcm_r[]);
+ #endif
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/libmp3lame/CVS/Entries lame3.70/libmp3lame/CVS/Entries
*** encoder/libmp3lame/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/libmp3lame/CVS/Entries	Thu Apr  6 12:50:37 2000
***************
*** 0 ****
--- 1 ----
+ D
diff -r -c -N encoder/libmp3lame/CVS/Repository lame3.70/libmp3lame/CVS/Repository
*** encoder/libmp3lame/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/libmp3lame/CVS/Repository	Thu Apr  6 12:50:37 2000
***************
*** 0 ****
--- 1 ----
+ lame/libmp3lame
diff -r -c -N encoder/libmp3lame/CVS/Root lame3.70/libmp3lame/CVS/Root
*** encoder/libmp3lame/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/libmp3lame/CVS/Root	Thu Apr  6 12:50:37 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/libmp3lame/CVS/Tag lame3.70/libmp3lame/CVS/Tag
*** encoder/libmp3lame/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/libmp3lame/CVS/Tag	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/loop-pvt.h lame3.70/loop-pvt.h
*** encoder/loop-pvt.h	Wed Jan 22 02:43:16 1997
--- lame3.70/loop-pvt.h	Wed Dec 31 17:00:00 1969
***************
*** 1,119 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop-pvt.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * Private interface declarations for loop.c
-  *
-  * $Log: loop-pvt.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef LOOP_PVT_H
- #define LOOP_PVT_H
- 
- /*
-   Revision History:
- 
-   Date        Programmer                Comment
-   ==========  ========================= ===============================
-   1995/10/01  mc@fivebats.com           created
- 
- */
- 
- int outer_loop( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
-                 int max_bits,
-                 III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
-                 int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
- 		frame_params *fr_ps,
-                 III_scalefac_t *scalefac, /* scalefactors */
-                 int gr,
-                 int ch,
- 		III_side_info_t *l3_side );
- 
- int part2_length( III_scalefac_t *scalefac,
- 		  frame_params *fr_ps,
- 		  int gr,
- 		  int ch,
- 		  III_side_info_t *si );
- 
- int quantanf_init( double xr[576] );
- 
- int inner_loop( double xr[2][2][576],
-                 int l3_enc[2][2][576],
-                 int max_bits,
-                 gr_info *cod_info,
-                 int gr,
-                 int ch );
- void calc_xmin( double xr[2][2][576],
-                III_psy_ratio *ratio,
-                gr_info *cod_info,
-                III_psy_xmin *l3_xmin,
-                int gr,
-                int ch );
- double xr_max( double xr[576],
-                unsigned int begin,
-                unsigned int end );
- 
- void calc_scfsi( double  xr[576],
-                  III_side_info_t *l3_side,
-                  III_psy_xmin  *l3_xmin,
-                  int ch,
-                  int gr );
- 
- void gr_deco( gr_info *cod_info );
- 
- 
- int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table);
- int bigv_bitcount( int ix[576], gr_info *cod_info );
- int choose_table( int max);
- void bigv_tab_select( int ix[576], gr_info *cod_info );
- void subdivide( gr_info *cod_info );
- int count1_bitcount( int ix[576], gr_info *cod_info );
- void  calc_runlen( int ix[576],
-                    gr_info *cod_info );
- int scale_bitcount( III_scalefac_t *scalefac,
-                     gr_info *cod_info,
-                     int gr,
-                     int ch );
- void calc_noise( double xr[576],
-                  int ix[576],
-                  gr_info *cod_info,
-                  double xfsf[4][CBLIMIT] );
- 
- 
- int loop_break( III_scalefac_t *scalefac,
-                 gr_info *cod_info,
-                 int gr,
-                 int ch );
- void preemphasis( double xr[576],
-                   double xfsf[4][CBLIMIT],
-                   III_psy_xmin  *l3_xmin,
-                   int gr,
-                   int ch,
- 		  III_side_info_t *l3_side );
- int amp_scalefac_bands( double xr[576],
-                         double xfsf[4][CBLIMIT],
-                         III_psy_xmin  *l3_xmin,
- 			III_side_info_t *l3_side,
-                         III_scalefac_t *scalefac,
-                         int gr,
-                         int ch,
- 			int iteration );
- void quantize( double xr[576],
-                int  ix[576],
-                gr_info *cod_info );
- int ix_max( int ix[576],
-             unsigned int begin,
-             unsigned int end );
- 
- 
- int
- new_choose_table( int ix[576],
- 		  unsigned int begin,
- 		  unsigned int end );
- #endif
--- 0 ----
diff -r -c -N encoder/loop.c lame3.70/loop.c
*** encoder/loop.c	Wed Jan 22 02:43:16 1997
--- lame3.70/loop.c	Wed Dec 31 17:00:00 1969
***************
*** 1,2220 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: loop.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *25. 6.92  Toshiyuki Ishino           Ver 1.0                        *
-  *29.10.92  Masahiro Iwadare           Ver 2.0                        *
-  *17. 4.93  Masahiro Iwadare           Updated for IS Modification    *
-  *04.11.93  Seymour Shlien             Speed up inner loop            *
-  *09.09.95  mc@fivebats.com            Several changes for updated IS,*
-  *                                     and some MPEG2-LSF support     *
-  *20.12.96  seymour.shlien@crc.doc.ca  Fixed some bugs and improved   *
-  *                                     the appearance                 *
-  *********************************************************************/ 
- 
- #include <stdio.h>
- #include <stdlib.h>
- #include <math.h>
- #include <assert.h>
- #include "l3side.h"
- #include "loop.h"
- #include "huffman.h"
- #include "l3bitstream.h"
- #include "reservoir.h"
- #include "loop-pvt.h"
- 
- /* #define DEBUG */
- /* #define DEBUGSC */
- /* #define PERFORM 3 */
- /* If PERFORM is defined to some number, then a file encode.log
-    is preduced showing the intermediate results produced by the
-    outer_loop code for the frame number = PERFORM.
- */
- #define BIN_SEARCH 
- /* for speeding up the iteration_loop algorithm */
- 
- #ifdef PERFORM
- FILE *log_output;
- extern int frameNum;
- float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
-                              ,int block_type,int gr,int ch);
- #endif
- 
- /* New SS 20-12-96 */
- #ifdef BIN_SEARCH 
- int bin_search_StepSize(int desired_rate, double start, int ix[576],
-            double xrs[576], gr_info * cod_info);
- int count_bits();
- float worst_xfsf_to_xmin_ratio();
- #endif
- 
- 
- /*
-   Here are MPEG1 Table B.8 and MPEG2 Table B.1
-   -- Layer III scalefactor bands.
-   Index into this using a method such as:
-     idx  = fr_ps->header->sampling_frequency
-            + (fr_ps->header->version * 3)
- */
- 
- struct scalefac_struct sfBandIndex[6] =
- {
- 
-   { /* Table B.2.b: 22.05 kHz */
-     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
-     {0,4,8,12,18,24,32,42,56,74,100,132,174,192}
-   },
-   { /* Table B.2.c: 24 kHz */
-     {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
-     {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
-   },
-   { /* Table B.2.a: 16 kHz */
-     {0,6,12,18,24,30,36,44,45,66,80,96,116,140,168,200,238,248,336,396,464,522,576},
-     {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
-   },
-   { /* Table B.8.b: 44.1 kHz */
-     {0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
-     {0,4,8,12,16,22,30,40,52,66,84,106,136,192}
-   },
-   { /* Table B.8.c: 48 kHz */
-     {0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
-     {0,4,8,12,16,22,28,38,50,64,80,100,126,192}
-   },
-   { /* Table B.8.a: 32 kHz */
-     {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
-     {0,4,8,12,16,22,30,42,58,78,104,138,180,192}
-   }
- };
- 
- /*
-   The following table is used to implement the scalefactor
-   partitioning for MPEG2 as described in section
-   2.4.3.2 of the IS. The indexing corresponds to the
-   way the tables are presented in the IS:
- 
-   [table_number][row_in_table][column of nr_of_sfb]
- */
- static unsigned nr_of_sfb_block[6][3][4] =
- {
-   {
-     {6, 5, 5, 5},
-     {9, 9, 9, 9},
-     {6, 9, 9, 9}
-   },
-   {
-     {6, 5, 7, 3},
-     {9, 9, 12, 6},
-     {6, 9, 12, 6}
-   },
-   {
-     {11, 10, 0, 0},
-     {18, 18, 0, 0},
-     {15,18,0,0}
-   },
-   {
-     {7, 7, 7, 0},
-     {12, 12, 12, 0},
-     {6, 15, 12, 0}
-   },
-   {
-     {6, 6, 6, 3},
-     {12, 9, 9, 6},
-     {6, 12, 9, 6}
-   },
-   {
-     {8, 8, 5, 0},
-     {15,12,9,0},
-     {6,18,9,0}
-   }
- };
- 
- /*
-   table of largest scalefactors for MPEG2
- */
- static unsigned max_sfac_tab[6][4] =
- {
-     {4, 4, 3, 3},
-     {4, 4, 3, 0},
-     {3, 2, 0, 0},
-     {4, 5, 5, 0},
-     {3, 3, 3, 0},
-     {2, 2, 0, 0}
- };
- 
- /* Table B.6: layer3 preemphasis */
- int  pretab[21] =
- {
-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-     1, 1, 1, 1, 2, 2, 3, 3, 3, 2
- };
- 
- /* This is the scfsi_band table from 2.4.2.7 of the IS */
- int scfsi_band_long[5] = { 0, 6, 11, 16, 21 };
- 
- int *scalefac_band_long  = &sfBandIndex[3].l[0];
- int *scalefac_band_short = &sfBandIndex[3].s[0];
- 
- 
- 
- /************************************************************************/
- /*  iteration_loop()                                                    */
- /************************************************************************/
- void
- iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
- 		III_side_info_t *l3_side, int l3_enc[2][2][576],
- 		int mean_bits, int stereo, double xr_dec[2][2][576],
- 		III_scalefac_t *scalefac, frame_params *fr_ps,
- 		int ancillary_pad, int bitsPerFrame ) 
- {
-     static int firstcall = 1;
-     III_psy_xmin l3_xmin;
-     gr_info *cod_info;
-     layer *info;
-     int *main_data_begin;
- 
-     int max_bits;
-     int ch, gr, sfb, i, mode_gr;
-     static int huffman_read_flag = 0; 
- 
-     double xr[2][2][576];
-     I576  *ix;
- 
-     main_data_begin = &l3_side->main_data_begin;
-     l3_side->resvDrain = 0;
- 
-     if ( firstcall )
-     {
- 	*main_data_begin = 0;
- 	firstcall = 0;
- #ifdef PERFORM
- 	log_output = fopen("encode.log","w");
- #endif
-     }
- 
-     info = fr_ps->header;
-     mode_gr = (info->version == 1) ? 2 : 1;
- 
-     scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
-     scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
- 
-     /* reading huffman code table */
-     if (huffman_read_flag == 0) {
-         FILE *fi = OpenTableFile( "huffcode" );
-         if ( fi == NULL )
-             exit( EXIT_FAILURE );
-         read_huffcodetab( fi );
-         huffman_read_flag++;
-         fclose( fi );
-     }
- 
- 
-     for ( gr = 0; gr < mode_gr; gr++ )
-     {
-         for ( ch = 0; ch < stereo; ch++ )
- 	{
-             for ( i = 0; i < 576; i++ ) 
-                 xr[gr][ch][i] = xr_org[gr][ch][i];
- 	}
-     }
- 
-     ResvFrameBegin( fr_ps, l3_side, mean_bits, bitsPerFrame );
- 
-     for ( gr = 0; gr < mode_gr; gr++ )
-     {
-         for ( ch = 0; ch < stereo; ch++ )
-         {
-             ix = (I576 *) l3_enc[gr][ch];
-             cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
-             gr_deco(cod_info);
-             calc_xmin( xr, ratio, cod_info, &l3_xmin, gr, ch );
- 	    
- #ifdef DEBUG
-             printf( "----- start gr[%d] ch[%1d] : block_type=%1d, window_switching_flag=%1d (loop)\n",
-                     gr,ch, cod_info->block_type, cod_info->window_switching_flag ); 
- #endif
- 	    
-             if ( info->version == 1 )
-                 calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr );
- 	    
-             /* calculation of number of available bit( per granule ) */
- 	    max_bits = ResvMaxBits( fr_ps, l3_side, &pe[gr][ch], mean_bits );
- #ifdef DEBUG
-             printf( " max_bits = %d, mean_bits = %d (iteration_loop)\n", max_bits, mean_bits ); 
- #endif
- 	    
-             /* reset of iteration variables */
- 	    
-             for ( sfb = 0; sfb < 21; sfb++ )
-                 scalefac->l[gr][ch][sfb] = 0;
-             for ( sfb = 0; sfb < 13; sfb++ )
-                 for ( i = 0; i < 3; i++ )
-                     scalefac->s[gr][ch][sfb][i] = 0;
- 
- 	    for ( i = 0; i < 4; i++ )
- 		cod_info->slen[i] = 0;
- 	    cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
- 
-             cod_info->part2_3_length    = 0;
-             cod_info->big_values        = 0;
-             cod_info->count1            = 0;
-             cod_info->scalefac_compress = 0;
-             cod_info->table_select[0]   = 0;
-             cod_info->table_select[1]   = 0;
-             cod_info->table_select[2]   = 0;
-             cod_info->subblock_gain[0]  = 0;
-             cod_info->subblock_gain[1]  = 0;
-             cod_info->subblock_gain[2]  = 0;
-             cod_info->region0_count     = 0;
-             cod_info->region1_count     = 0;
-             cod_info->part2_length      = 0;
-             cod_info->preflag           = 0;
-             cod_info->scalefac_scale    = 0;
-             cod_info->quantizerStepSize = 0.0;
-             cod_info->count1table_select= 0;
-             
-             /* all spectral values zero ? */
-             if ( fabs(xr_max(xr[gr][ch], 0, 576)) != 0.0 )
-             {
-                 cod_info->quantizerStepSize =
- 			 (double) quantanf_init( xr[gr][ch] );
-                 cod_info->part2_3_length = outer_loop( xr, max_bits, &l3_xmin,
-                                                        l3_enc, fr_ps, scalefac,
-                                                        gr, ch, l3_side );
-             }
- 	    ResvAdjust( fr_ps, cod_info, l3_side, mean_bits );
- 
- 	    cod_info->global_gain = nint( cod_info->quantizerStepSize + 210.0 );
- 	    assert( cod_info->global_gain < 256 );
-         } /* for ch */
-     } /* for gr */
-     ResvFrameEnd( fr_ps, l3_side, mean_bits );
- }
- 
- 
- 
- /************************************************************************/
- /*  quantanf_init                                                       */
- /************************************************************************/
- int quantanf_init( double xr[576] )
- /* Function: Calculate the first quantization step quantanf.       */
- {
-     int i, tp = 0;
-     double system_const, minlimit;
-     double sfm = 0.0, sum1 = 0.0, sum2 = 0.0;
-     
-     system_const = 8.0;
-     minlimit = -100.0;
- 
-     for ( i = 0; i < 576; i++ )
-     {
-         if ( xr[i] != 0 )
- 	{
-             double tpd = xr[i] * xr[i];
-             sum1 += log( tpd );
-             sum2 += tpd;
-         }
-     }
-     if ( sum2 != 0.0 )
-     {
-         sfm = exp( sum1 / 576.0 ) / (sum2 / 576.0);
-         tp = nint( system_const * log(sfm) );
- 	if ( tp < minlimit )
- 	    tp = minlimit;
- #ifdef DEBUG
-         printf(" quantanf = %d (quantanf_init)\n",tp );
- #endif
-     }
-       return(tp-70.0); /* SS 19-12-96. Starting value of
-                           global_gain or quantizerStepSize 
-                           has to be reduced for iteration_loop
-                        */
- }
- 
- 
- 
- 
- 
- /************************************************************************/
- /*  outer_loop                                                          */
- /************************************************************************/
- /*  Function: The outer iteration loop controls the masking conditions  */
- /*  of all scalefactorbands. It computes the best scalefac and          */
- /*  global gain. This module calls the inner iteration loop             */
- /************************************************************************/
- int outer_loop(
-     double xr[2][2][576],     /*  magnitudes of the spectral values */
-     int max_bits,
-     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
-     int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
-     frame_params *fr_ps,
-     III_scalefac_t *scalefac, /* scalefactors */
-     int gr, int ch, III_side_info_t *l3_side )
- {
-     int status ;
-     int scalesave_l[CBLIMIT], scalesave_s[CBLIMIT][3];
-     int sfb, bits, huff_bits, save_preflag, save_compress;
-     double xfsf[4][CBLIMIT];
-     int i, over, iteration;
-     float max_ratio;
- 
- 
- /* D576 *xrs; */ /* to eliminate warning messages from gcc compiler */
- /* I576 *ix; */  /* replace this code with below. S. Shlien 15-1-97 */
- 
-   double *xrs; 
-   int *ix;  
-   gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
- /* xrs = (D576 *) &xr[gr][ch][0]; */ 
- /* ix  = (I576 *) l3_enc[gr][ch]; */
-  
- 
- xrs = (double *) &(xr[gr][ch][0]); 
- ix  = (int *) &(l3_enc[gr][ch][0]);
- 
- 
-     iteration = 0;
- #ifdef PERFORM
-     if(frameNum == PERFORM)
-     fprintf(log_output,"\n\nframe = %d ch = %d gr= %d\n",frameNum,ch,gr);
- #endif
-     do 
-     {
- 	iteration += 1;
- 	cod_info->part2_length = part2_length( scalefac, fr_ps, gr, ch, l3_side );
-         huff_bits = max_bits - cod_info->part2_length;
- 
- #ifdef BIN_SEARCH
- 	if(iteration == 1)
-         {
-        bin_search_StepSize(max_bits,cod_info->quantizerStepSize,
-           ix,xrs,cod_info); /* speeds things up a bit */
-         }
- #endif
- #ifdef PERFORM
- 	if(frameNum==PERFORM)
-           fprintf(log_output,"\n    Interim Results %d\n\n",iteration);
-         bits = test_inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch,
-          xfsf,l3_xmin);
- #else
-         bits = inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch );
- #endif
- 
-         calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf ); /* distortion calculation */
- 
-         for ( sfb = 0; sfb < CBLIMIT; sfb++ ) /* save scaling factors */
-             scalesave_l[sfb] = scalefac->l[gr][ch][sfb];
- 
-         for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
-             for ( i = 0; i < 3; i++ )
-                 scalesave_s[sfb][i] = scalefac->s[gr][ch][sfb][i];
-         
-         save_preflag  = cod_info->preflag;
-         save_compress = cod_info->scalefac_compress;
- 
-         preemphasis( &xr[gr][ch][0], xfsf, l3_xmin, gr, ch, l3_side );
- 
- 
- 
- #ifdef PERFORM 
-     if(frameNum == PERFORM)  
-     {
-     fprintf(log_output,"\nbits = %d  huff_bits= %d ", bits,huff_bits);
-     fprintf(log_output," max_bits = %d\n",max_bits);
-     fprintf(log_output,"Stepsize = %f ",cod_info->quantizerStepSize);
-     fprintf(log_output," scale_bits    = %d \n", cod_info->part2_length );  
-     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
-     /*if (gr==0 && ch==0)
-       print_quantized_values(log_output,l3_enc[gr][ch] ,cod_info);*/
-     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
-     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fprintf(log_output,"\n\n");
-     fflush(log_output);
-     }
- #endif
-         over = amp_scalefac_bands( &xr[gr][ch][0], xfsf, l3_xmin,
-                                    l3_side, scalefac, gr, ch, iteration );
- 
- #if 1
-         if ( (status = loop_break(scalefac, cod_info, gr, ch)) == 0 )
- 	{
- 	    if ( fr_ps->header->version == 1 )
- 		status = scale_bitcount( scalefac, cod_info, gr, ch );
- 	    else
- 		status = scale_bitcount_lsf( scalefac, cod_info, gr, ch );
- 	}
- #else
-         status = loop_break( scalefac, cod_info, gr, ch );
- 	if ( fr_ps->header->version == 1 )
- 	    status += scale_bitcount( scalefac, cod_info, gr, ch );
- 	else
- 	    status += scale_bitcount_lsf( scalefac, cod_info, gr, ch );
- #endif
- 
-     }
-     while ( (status == 0) && (over > 0) );
- 
-     cod_info->preflag = save_preflag;
-     cod_info->scalefac_compress = save_compress;
- 
-     for ( sfb = 0; sfb < 21; sfb++ )
-         scalefac->l[gr][ch][sfb] = scalesave_l[sfb];    
- 
-     for ( i = 0; i < 3; i++ )
-         for ( sfb = 0; sfb < 12; sfb++ )
-             scalefac->s[gr][ch][sfb][i] = scalesave_s[sfb][i];    
- 
-     cod_info->part2_length   = part2_length( scalefac, fr_ps, gr, ch, l3_side );
-     cod_info->part2_3_length = cod_info->part2_length + bits;
- 
- #ifdef PERFORM 
-     if(frameNum == PERFORM)
-     {
-     fprintf(log_output,"\n  Final Results\n");
-     fprintf(log_output,"bits = %d  huff_bits= %d", bits,huff_bits);
-     fprintf(log_output," max_bits = %d\n",max_bits);
-     fprintf(log_output," Stepsize = %f ",cod_info->quantizerStepSize);
-     fprintf(log_output, " scale_bits    = %d \n", cod_info->part2_length );  
-     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
-     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
-     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fflush(log_output);
-     }
- #endif    
-     return cod_info->part2_3_length;
- }
- 
- 
- 
- 
- /***************************************************************************/ 
- /*         inner_loop                                                      */ 
- /***************************************************************************/ 
- /* The code selects the best quantizerStepSize for a particular set
- /* of scalefacs                                                            */
-  
- int
- inner_loop( double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
- 	    gr_info *cod_info, int gr, int ch )
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
- 
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
- 
-         calc_runlen( ix, cod_info );  /*rzero,count1,big_values*/
-         bits = c1bits = count1_bitcount( ix, cod_info );  /*count1_table selection*/
-         subdivide( cod_info );  /* bigvalues sfb division */
-         bigv_tab_select( ix, cod_info );  /* codebook selection*/
-         bits += bvbits = bigv_bitcount( ix, cod_info );  /* bit count */
- 
- #ifdef PERFORM
-         if(frameNum == PERFORM)
- 	fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-            cod_info->quantizerStepSize,bits,max_bits);
- #endif
- 
-     }
-     while ( bits > max_bits );
- 
-     return bits;
- }
- 
- 
- 
- /***************************************************************************/ 
- /*        calc_scfsi                                                       */ 
- /***************************************************************************/ 
- /* calculation of the scalefactor select information ( scfsi )        */
- 
- void calc_scfsi( double  xr[576], III_side_info_t *l3_side,
- 	    III_psy_xmin *l3_xmin, int ch, int gr )
- {
-     static int en_tot[2][2]; /* ch,gr */
-     static int en[2][2][21];
-     static int xm[2][2][21];
-     static int xrmax[2][2];
- 
-     int en_tot_krit        = 10;
-     int en_dif_krit        = 100;
-     int en_scfsi_band_krit = 10;
-     int xm_scfsi_band_krit = 10;
- 
-     int scfsi_band;
-     unsigned scfsi_set;
- 
-     int sfb, start, end, i;
-     int condition = 0;
-     double temp, log2 = log( 2.0 );
-     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
-     xrmax[gr][ch] = xr_max( xr, 0, 576 );
-     scfsi_set = 0;
- 
-     /* the total energy of the granule */    
-     for ( temp = 0.0, i = 0; i < 576; i++ )
-         temp += xr[i] * xr[i];
-     if ( temp == 0.0 )
-         en_tot[gr][ch] = 0.0;
-     else
-         en_tot[gr][ch] = log( temp ) / log2 ;
- 
-     /* the energy of each scalefactor band, en */
-     /* the allowed distortion of each scalefactor band, xm */
- 
-     if ( cod_info->window_switching_flag == 0 ||
-          cod_info->block_type != 2 )
-         for ( sfb = 0; sfb < 21; sfb++ )
-         {
-             start = scalefac_band_long[ sfb ];
-             end   = scalefac_band_long[ sfb+1 ];
- 
-             for ( temp = 0.0, i = start; i < end; i++ )
-                 temp += xr[i] * xr[i];
-             if ( temp == 0.0 )
-                 en[gr][ch][sfb] = 0.0;
-             else
-                 en[gr][ch][sfb] = log( temp )/ log2;
- 
-             if ( l3_xmin->l[gr][ch][sfb] == 0.0 )
-                 xm[gr][ch][sfb] = 0.0;
-             else
-                 xm[gr][ch][sfb] = log( l3_xmin->l[gr][ch][sfb] ) / log2;
-         }
-     if ( gr == 1 )
-     {
-         int gr2, tp;
- 
-         for ( gr2 = 0; gr2 < 2; gr2++ )
-         {
-             /* The spectral values are not all zero */
-             if ( xrmax[ch][gr2] != 0.0 )
-                 condition++;
-             /* None of the granules contains short blocks */
-             if ( (cod_info->window_switching_flag == 0) ||
-                  (cod_info->block_type != 2) )
-                 condition++;
-         }
-         if ( abs(en_tot[0] - en_tot[1]) < en_tot_krit )
-             condition++;
-         for ( tp = 0, sfb = 0; sfb < 21; sfb++ ) 
-             tp += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-         if ( tp < en_dif_krit ) 
-             condition++;
- 
-         if ( condition == 6 )
-         {
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-             {
-                 int sum0 = 0, sum1 = 0;
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-                 start = scfsi_band_long[scfsi_band];
-                 end   = scfsi_band_long[scfsi_band+1];
-                 for ( sfb = start; sfb < end; sfb++ )
-                 { 
-                     sum0 += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-                     sum1 += abs( xm[ch][0][sfb] - xm[ch][1][sfb] );
-                 }
- 
-                 if ( sum0 < en_scfsi_band_krit && sum1 < xm_scfsi_band_krit )
- 		{
-                     l3_side->scfsi[ch][scfsi_band] = 1;
- 		    scfsi_set |= (1 << scfsi_band);
- 		}
-                 else
-                     l3_side->scfsi[ch][scfsi_band] = 0;
-             } /* for scfsi_band */
- #ifdef DEBUG
- 	    fprintf( stderr, "calc_scfsi: scfsi_set = 0x%02x\n", scfsi_set );
- #endif
-         } /* if condition == 6 */
-         else
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-     } /* if gr == 1 */
- }
- 
- 
- 
- /***************************************************************************/ 
- /*        part2_length                                                     */ 
- /***************************************************************************/ 
- 
- /* calculates the number of bits needed to encode the scalefacs in the     */
- /* main data block                                                         */
- 
- int part2_length( III_scalefac_t *scalefac, frame_params *fr_ps,
- 	      int gr, int ch, III_side_info_t *si )
- {
-     int slen1, slen2, slen3, slen4, bits, sfb, window, partition;
-     gr_info *gi = &si->gr[gr].ch[ch].tt;
- 
-     bits = 0;
-     if ( fr_ps->header->version == 1 )
-     {
- 	static int slen1_tab[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
- 	static int slen2_tab[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
- 
- 	slen1 = slen1_tab[ gi->scalefac_compress ];
- 	slen2 = slen2_tab[ gi->scalefac_compress ];
- 
- 	if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
- 	{
- 	    if ( gi->mixed_block_flag )
- 	    {
- 		bits += (8 * slen1) + (9 * slen1) + (18 * slen2);
- 	    }
- 	    else
- 	    {
- 		bits += (18 * slen1) + (18 * slen2);
- 	    }
- 	}
- 	else
- 	{
- 	    if ( (gr == 0) || (si->scfsi[ch][0] == 0) )
- 		bits += (6 * slen1);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][1] == 0) )
- 		/*  bits += (6 * slen1);  This is wrong SS 19-12-96 */
- 		bits += (5 * slen1);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][2] == 0) )
- 		/*  bits += (6 * slen1);   This is wrong SS 19-12-96 */
- 		bits += (5 * slen2);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][3] == 0) )
- 		/* bits += (6 * slen1);   This is wrong SS 19-12-96 */
- 		bits += (5 * slen2);
- 	}
-     }
-     else
-     {   /* MPEG 2 */
- 	assert( gi->sfb_partition_table );
- 	for ( partition = 0; partition < 4; partition++ )
- 	    bits += gi->slen[partition] * gi->sfb_partition_table[partition];
-     }
-     return bits;
- }
- 
- 
- 
- /*************************************************************************/
- /*            scale_bitcount                                             */
- /*************************************************************************/
- 
- /* Also calculates the number of bits necessary to code the scalefactors. */
- 
- int scale_bitcount( III_scalefac_t *scalefac, gr_info *cod_info,
- 		int gr, int ch )
- {
-     int i, k, sfb, max_slen1 = 0, max_slen2 = 0, /*a, b, */ ep = 2;
- 
-     static int slen1[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
-     static int slen2[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
-     static int pow2[5]   = { 1, 2, 4, 8, 16 };
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-     {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
-             /* a = 18; b = 18;  */
-             for ( i = 0; i < 3; i++ )
-             {
-                 for ( sfb = 0; sfb < 6; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
-                         max_slen1 = scalefac->s[gr][ch][sfb][i];
-                 for (sfb = 6; sfb < 12; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
-                         max_slen2 = scalefac->s[gr][ch][sfb][i];
-             }
-         }
-         else
-         {/* mixed_block_flag = 1 */
-             /* a = 17; b = 18;  */
-             for ( sfb = 0; sfb < 8; sfb++ )
-                 if ( scalefac->l[gr][ch][sfb] > max_slen1 )
-                     max_slen1 = scalefac->l[gr][ch][sfb];
-             for ( i = 0; i < 3; i++ )
-             {
-                 for ( sfb = 3; sfb < 6; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
-                         max_slen1 = scalefac->s[gr][ch][sfb][i];
-                 for ( sfb = 6; sfb < 12; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
-                         max_slen2 = scalefac->s[gr][ch][sfb][i];
-             }
-         }
-     }
-     else
-     { /* block_type == 1,2,or 3 */
-         /* a = 11; b = 10;   */
-         for ( sfb = 0; sfb < 11; sfb++ )
-             if ( scalefac->l[gr][ch][sfb] > max_slen1 )
-                 max_slen1 = scalefac->l[gr][ch][sfb];
-         for ( sfb = 11; sfb < 21; sfb++ )
-             if ( scalefac->l[gr][ch][sfb] > max_slen2 )
-                 max_slen2 = scalefac->l[gr][ch][sfb];
-     }
- 
-     for ( k = 0; k < 16; k++ )
-     {
-         if ( (max_slen1 < pow2[slen1[k]]) && (max_slen2 < pow2[slen2[k]]) )
-         { 
-             ep = 0;
-             break;
-         } 
-     }
- 
-     if ( ep == 0 )
-         cod_info->scalefac_compress = k;
- #ifdef DEBUG
-     if ( ep != 0 ) 
-         printf( "---WARNING !! Amplification of some bands over limits\n" );
- #endif
-     return ep;
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            scale_bitcount_lsf                                         */
- /*************************************************************************/
- 
- /* Also counts the number of bits to encode the scalefacs but for MPEG 2 */ 
- /* Lower sampling frequencies  (24, 22.05 and 16 kHz.)                   */
-  
- /*  This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,     */
- /* "Audio Decoding Layer III"                                            */
- 
- int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info,
- 		    int gr, int ch )
- {
-     int table_number, row_in_table, partition, nr_sfb, window, over;
-     int i, k, sfb, max_sfac[ 4 ];
-     unsigned *partition_table;
- 
-     /*
-       Set partition table. Note that should try to use table one,
-       but do not yet...
-     */
-     if ( cod_info->preflag )
- 	table_number = 2;
-     else
- 	table_number = 0;
- 
-     for ( i = 0; i < 4; i++ )
- 	max_sfac[i] = 0;
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-     {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
- 	    row_in_table = 1;
- 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	    for ( sfb = 0, partition = 0; partition < 4; partition++ )
- 	    {
- 		nr_sfb = partition_table[ partition ] / 3;
- 		for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		    for ( window = 0; window < 3; window++ )
- 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
- 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
- 	    }
-         }
-         else
-         {/* mixed_block_flag = 1 */
- 	    row_in_table = 2;
- 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	    partition = 0;
- 	    nr_sfb = partition_table[ partition ];
- 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
- 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
- 	    
- 	    for ( sfb = 0, partition = 1; partition < 4; partition++ )
- 	    {
- 		nr_sfb = partition_table[ partition ] / 3;
- 		for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		    for ( window = 0; window < 3; window++ )
- 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
- 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
- 	    }
-         }
-     }
-     else
-     {
- 	row_in_table = 0;
- 	partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	partition = 0;
- 	for ( sfb = 0, partition = 0; partition < 4; partition++ )
- 	{
- 	    nr_sfb = partition_table[ partition ];
- 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
- 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
- 	}
-     }
- 
-     for ( over = 0, partition = 0; partition < 4; partition++ )
-     {
- 	if ( max_sfac[partition] > max_sfac_tab[table_number][partition] )
- 	    over++;
-     }
-     if ( !over )
-     {
- 	/*
- 	  Since no bands have been over-amplified, we can set scalefac_compress
- 	  and slen[] for the formatter
- 	*/
- 	static int log2tab[] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 };
- 
- 	unsigned slen1, slen2, slen3, slen4;
- 
-         cod_info->sfb_partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	for ( partition = 0; partition < 4; partition++ )
- 	    cod_info->slen[partition] = log2tab[max_sfac[partition]];
- 
- 	/* set scalefac_compress */
- 	slen1 = cod_info->slen[ 0 ];
- 	slen2 = cod_info->slen[ 1 ];
- 	slen3 = cod_info->slen[ 2 ];
- 	slen4 = cod_info->slen[ 3 ];
- 
- 	switch ( table_number )
- 	{
- 	  case 0:
- 	    cod_info->scalefac_compress = (((slen1 * 5) + slen2) << 4)
- 		+ (slen3 << 2)
- 		+ slen4;
- 	    break;
- 
- 	  case 1:
- 	    cod_info->scalefac_compress = 400
- 		+ (((slen1 * 5) + slen2) << 2)
- 		+ slen3;
- 	    break;
- 
- 	  case 2:
- 	    cod_info->scalefac_compress = 500 + (slen1 * 3) + slen2;
- 	    break;
- 
- 	  default:
- 	    fprintf( stderr, "intensity stereo not implemented yet\n" );
- 	    exit( EXIT_FAILURE );
- 	    break;
- 	}
-     }
- #ifdef DEBUG
-     if ( over ) 
-         printf( "---WARNING !! Amplification of some bands over limits\n" );
- #endif
-     return over;
- }
- 
- 
- /*************************************************************************/
- /*            calc_noise                                                 */
- /*************************************************************************/
- 
- /*   Function: Calculate the distortion introduced by the quantization   */
- /*   in each scale factor band.                                          */
- 
- void calc_noise( double xr[576], int ix[576], gr_info *cod_info,
- 	    double xfsf[4][CBLIMIT] )
- {
-     int start, end, sfb, l, i;
-     double sum,step,bw;
- 
-     D192_3 *xr_s;
-     I192_3 *ix_s;
- 
-     xr_s = (D192_3 *) xr;
-     ix_s = (I192_3 *) ix;
- 
-     step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 );
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
-         start = scalefac_band_long[ sfb ];
-         end   = scalefac_band_long[ sfb+1 ];
- 	bw = end - start;
- 
-         for ( sum = 0.0, l = start; l < end; l++ )
-         {
-             double temp;
-             temp = fabs( xr[l] ) - pow( (double) ix[l], 4.0 / 3.0 ) * step;
-             sum += temp * temp; 
-         }
-         xfsf[0][sfb] = sum / bw;
-     }
- 
-     for ( i = 0; i < 3; i++ )
-     {
-         step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 ); /* subblock_gain ? */
-         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-         {
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
- 	    bw = end - start;
-             
-             for ( sum = 0.0, l = start; l < end; l++ )
-             {
-                 double temp;
-                 temp = fabs( (*xr_s)[l][i] ) - pow( (double) (*ix_s)[l][i], 4.0 / 3.0 ) * step;
-                 sum += temp * temp;
-             }       
-             xfsf[i+1][sfb] = sum / bw;
-         }
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            calc_xmin                                                  */
- /*************************************************************************/
- 
- /*
-   Calculate the allowed distortion for each scalefactor band,
-   as determined by the psychoacoustic model.
-   xmin(sb) = ratio(sb) * en(sb) / bw(sb)
- */
- 
- void calc_xmin( double xr[2][2][576], III_psy_ratio *ratio,
- 	   gr_info *cod_info, III_psy_xmin *l3_xmin,
- 	   int gr, int ch )
- {
-     int start, end, sfb, l, b;
-     double en, bw;
- 
-     D192_3 *xr_s;
- 
-     xr_s = (D192_3 *) xr[gr][ch] ;
- 
-     for ( sfb = cod_info->sfb_smax; sfb < SFB_SMAX - 1; sfb++ )
-     {
-         start = scalefac_band_short[ sfb ];
-         end   = scalefac_band_short[ sfb + 1 ];
- 	bw = end - start;
-         for ( b = 0; b < 3; b++ )
-         {
-             for ( en = 0.0, l = start; l < end; l++ )
-                 en += (*xr_s)[l][b] * (*xr_s)[l][b];
-             l3_xmin->s[gr][ch][sfb][b] = ratio->s[gr][ch][sfb][b] * en / bw;
-         }
-     }
- 
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
-         start = scalefac_band_long[ sfb ];
-         end   = scalefac_band_long[ sfb+1 ];
- 	bw = end - start;
- 
-         for ( en = 0.0, l = start; l < end; l++ )
-             en += xr[gr][ch][l] * xr[gr][ch][l];
-         l3_xmin->l[gr][ch][sfb] = ratio->l[gr][ch][sfb] * en / bw;
-     }
- }
- 
- 
- 
- /*************************************************************************/
- /*            loop_break                                                 */
- /*************************************************************************/
- 
- /*  Function: Returns zero if there is a scalefac which has not been
-     amplified. Otherwise it returns one. 
- */
- 
- int loop_break( III_scalefac_t *scalefac, gr_info *cod_info,
- 	    int gr, int ch )
- {
-     int i, sfb, temp = 1;
- 
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-         if ( scalefac->l[gr][ch][sfb] == 0 )
-             temp = 0;
- 
-     for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-         for ( i = 0; i < 3; i++ )
-             if ( scalefac->s[gr][ch][sfb][i] == 0 )
-                 temp = 0;
- #ifdef DEBUG
-     if ( temp != 0 )
-         printf( "---WARNING !! All scalefactor bands amplified\n" );
- #endif
-     return temp;
- }
- 
- 
- 
- /*************************************************************************/
- /*            preemphasis                                                */
- /*************************************************************************/
- 
- /*
-   See ISO 11172-3  section  C.1.5.4.3.4
- */
- 
- void preemphasis( double xr[576], double xfsf[4][CBLIMIT],
- 	     III_psy_xmin  *l3_xmin,
- 	     int gr, int ch, III_side_info_t *l3_side )
- {
-     int i, sfb, start, end, scfsi_band, over;
-     double ifqstep;
-     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
-     if ( gr == 1 )
-     {
- 	/*
- 	  If the second granule is being coded and scfsi is active in
- 	  at least one scfsi_band, the preemphasis in the second granule
- 	  is set equal to the setting in the first granule
- 	*/
- 	for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		cod_info->preflag = l3_side->gr[0].ch[ch].tt.preflag;
- 		return;
- 	    }
- 	
-     }
- 
-     /*
-       Preemphasis is switched on if in all the upper four scalefactor
-       bands the actual distortion exceeds the threshold after the
-       first call of the inner loop
-     */
-     if ( cod_info->block_type != 2 && cod_info->preflag == 0 )
-     {	
- 	over = 0;
- 	for ( sfb = 17; sfb < 21; sfb++ )
- 	    if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
- 		over++;
- 
- 	if (over == 4 )
- 	{
- 	    cod_info->preflag = 1;
- 	    ifqstep = ( cod_info->scalefac_scale == 0 ) ? sqrt(2.)
- 		: pow( 2.0, (0.5 * (1.0 + (double) cod_info->scalefac_scale)) );
- 
- 	    for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
- 	    {
- 		l3_xmin->l[gr][ch][sfb] *= pow( ifqstep, 2.0 * (double) pretab[sfb] );
- 		start = scalefac_band_long[ sfb ];
- 		end   = scalefac_band_long[ sfb+1 ];
- 		for( i = start; i < end; i++ )
- 		    xr[i] *= pow( ifqstep, (double) pretab[sfb] );
- 	    }
- 	}
-     }
- }
- 
- 
- /*************************************************************************/
- /*            amp_scalefac_bands                                         */
- /*************************************************************************/
- 
- /* 
-   Amplify the scalefactor bands that violate the masking threshold.
-   See ISO 11172-3 Section C.1.5.4.3.5
- */
- 
- int amp_scalefac_bands( double xr[576], double xfsf[4][CBLIMIT],
- 		    III_psy_xmin *l3_xmin, III_side_info_t *l3_side,
- 		    III_scalefac_t *scalefac,
- 		    int gr, int ch, int iteration )
- {
-     int start, end, l, sfb, i, scfsi_band, over = 0;
-     double ifqstep, ifqstep2;
-     D192_3 *xr_s;
-     gr_info *cod_info, *gr0;
-     int copySF, preventSF;
-     cod_info = &l3_side->gr[gr].ch[ch].tt;
-     gr0      = &l3_side->gr[0].ch[ch].tt;
- 
-     xr_s = (D192_3 *) xr;
-     copySF = 0;
-     preventSF = 0;
- 
-     if ( cod_info->scalefac_scale == 0 )
- 	ifqstep = sqrt( 2.0 );
-     else
- 	ifqstep = pow( 2.0, 0.5 * (1.0 + (double) cod_info->scalefac_scale) );
- 
-     if ( gr == 1 )
-     {
- 	/*
- 	  If the second granule is being coded and scfsi is active in at
- 	  least one scfsi_band...
- 	*/
- 	for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		/*
- 		  a) ifqstep has to be set similar to the
- 		   first granule...
- 		*/
- 		if ( gr0->scalefac_scale == 0 )
- 		    ifqstep = sqrt( 2.0 );
- 		else
- 		    ifqstep = pow( 2.0, 0.5 * (1.0 + (double) gr0->scalefac_scale) );
- 
- 		if ( iteration == 1 )
- 		{
- 		    /*
- 		      b) If it is the first iteration, the scalefactors
- 		      of scalefactor bands in which scfsi is enabled
- 		      must be taken from the first granule
- 		    */  
- 		    copySF = 1;
- 		}
- 		else
- 		{
- 		    /*
- 		      c) If it is not the first iteration, the amplification
- 		      must be prevented for scalefactor bands in which
- 		      scfsi is enabled
- 		    */
- 		    preventSF = 1;
- 		}
- 		break;
- 	    }
- 	
-     }
- 
-     ifqstep2 = ifqstep * ifqstep;
-     scfsi_band = 0;
-     
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
- 	if ( copySF || preventSF )
- 	{
- 	    if ( sfb == scfsi_band_long[scfsi_band + 1] )
- 		scfsi_band += 1;
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		if ( copySF )
- 		    scalefac->l[gr][ch][sfb] = scalefac->l[0][ch][sfb];
- 		continue;
- 	    }
- 	}	    
- 	if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
- 	{
- 	    over++;
- 	    l3_xmin->l[gr][ch][sfb] *= ifqstep2;
- 	    scalefac->l[gr][ch][sfb]++;
- 	    start = scalefac_band_long[sfb];
- 	    end   = scalefac_band_long[sfb+1];
- 	    for ( l = start; l < end; l++ )
- 		xr[l] *= ifqstep;
- 	}
-     }
- 
-     /*
-       Note that scfsi is not enabled for frames containing
-       short blocks
-     */
-     for ( i = 0; i < 3; i++ )
-         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-             if ( xfsf[i+1][sfb] > l3_xmin->s[gr][ch][sfb][i] )
-             {
-                 over++;
-                 l3_xmin->s[gr][ch][sfb][i] *= ifqstep2;
-                 scalefac->s[gr][ch][sfb][i]++;
- #ifdef DEBUGSC
-                 printf( "cod_info->scalefac[%d][%d] = %d (amp_scale)\n",
-                         i,sfb,scalefac->s[gr][ch][sfb][i] );
- #endif
-                 start = scalefac_band_short[sfb];
-                 end   = scalefac_band_short[sfb+1];
-                 for ( l = start; l < end; l++ )
-                     (*xr_s)[l][i] *= ifqstep;
-             }
-     return over;
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            quantize                                                   */
- /*************************************************************************/
- 
- /*
-   Function: Quantization of the vector xr ( -> ix)
- */
- 
- void quantize( double xr[576], int ix[576], gr_info *cod_info )
- {
-     int i, b, l_end, s_start;
-     double step, quantizerStepSize;
- 
-     D192_3 *xr_s;
-     I192_3 *ix_s;
- 
-     xr_s = (D192_3 *) xr;
-     ix_s = (I192_3 *) ix;
- 
-     quantizerStepSize = (double) cod_info->quantizerStepSize;
- 
-     for ( i = 0; i < 576; i++ )
- 	ix[i] = 0;
- 
-     if ( cod_info->quantizerStepSize == 0.0 )
- 	step = 1.0;
-     else
- 	step = pow ( 2.0, quantizerStepSize * 0.25 );
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
- 	if ( cod_info->mixed_block_flag == 0 )
- 	{
- 	    l_end = 0;
- 	    s_start = 0;
- 	}
- 	else
- 	{
- 	    l_end = 18 * 2;
- 	    s_start = 6 * 2;
- 	}
-     else
-     {
- 	l_end = 576;
- 	s_start = 192;
-     }
- 
-     for ( i = 0; i < l_end; i++ )
- 	ix[i] = nint( pow(fabs(xr[i]) / step, 0.75) - 0.0946 );
-     
-     if ( s_start < 192 )
- 	for ( b = 0; b < 3; b++ )
- 	{
- 	    step = pow( 2.0, (quantizerStepSize + 8.0 * (double) cod_info->subblock_gain[b]) * 0.25 );
- 	    for ( i = s_start; i < 192; i++ )
- 		(*ix_s)[i][b] = nint( pow(fabs((*xr_s)[i][b]) / step, 0.75) - 0.0946 );
- 	}
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            ix_max                                                     */
- /*************************************************************************/
- 
- /*
-   Function: Calculate the maximum of ix from 0 to 575
- */
- 
- int ix_max( int ix[576], unsigned int begin, unsigned int end )
- {
-     int i, max = 0;
- 
-     for ( i = begin; i < end; i++ )
-     {
-         int x = abs( ix[i] );
-         if ( x > max )
-             max = x;
-     }
-     return max;
- }
- 
- 
- /*************************************************************************/
- /*            xr_max                                                     */
- /*************************************************************************/
- 
- /*
-   Function: Calculate the maximum of xr[576]  from 0 to 575
- */
- 
- double xr_max( double xr[576], unsigned int begin, unsigned int end )
- {
-     int i;
-     double max = 0.0, temp;
- 
-     for ( i = begin; i < end; i++ )
-         if( (temp = fabs(xr[i])) > max )
- 	    max = temp;
-     return max;
- }
- 
- 
- 
- /*        Noiseless coding  -- Huffman coding   */
- 
- 
- /*************************************************************************/
- /*            calc_runlen                                                */
- /*************************************************************************/
- 
- /*
- Function: Calculation of rzero, count1, big_values
- (Partitions ix into big values, quadruples and zeros).
- */
- 
- void calc_runlen( int ix[576], gr_info *cod_info )
- {
-     int i;
-     int rzero = 0; 
- 
-     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
-     {  /* short blocks */
-         cod_info->count1 = 0;
-         cod_info->big_values = 288;
-     }
-     else
-     {
-         for ( i = 576; i > 1; i -= 2 )
-             if ( ix[i-1] == 0 && ix[i-2] == 0 )
-                 rzero++;
-             else
-                 break;
-         
-         cod_info->count1 = 0 ;
-         for ( ; i > 3; i -= 4 )
-             if ( abs(ix[i-1]) <= 1
-               && abs(ix[i-2]) <= 1
-               && abs(ix[i-3]) <= 1
-               && abs(ix[i-4]) <= 1 )
-                 cod_info->count1++;
-             else
-                 break;
-         
-         cod_info->big_values = i/2;
-     }
-     assert( (2 * rzero + 4 * cod_info->count1 + 2 * cod_info->big_values) == 576 );
- }
- 
- 
- 
- /*************************************************************************/
- /*            count1_bitcount                                            */
- /*************************************************************************/
- 
- /*
-   Determines the number of bits to encode the quadruples.
- */
- 
- int count1_bitcount( int ix[ 576 ], gr_info *cod_info )
- {
-     int abs_and_sign( int *x );
- 
-     int p, i, k, bitsum_count1;
-     int v, w, x, y, signbits;
-     int sum0 = 0, sum1 = 0;
- 
-     for ( i = cod_info->big_values * 2, k = 0; k < cod_info->count1; i += 4, k++ )
-     {
-         v = ix[ i ];
-         w = ix[ i + 1 ];
-         x = ix[ i + 2 ];
-         y = ix[ i + 3 ];
-         
-         abs_and_sign( &v );
-         abs_and_sign( &w );
-         abs_and_sign( &x );
-         abs_and_sign( &y );
- 
-         p = v + (w << 1) + (x << 2) + (y << 3);
-         
-         signbits = 0;
- 
-         if ( v != 0 )
-             signbits += 1;
-         if ( w != 0 )
-             signbits += 1;
-         if ( x != 0 )
-             signbits += 1;
-         if ( y != 0 )
-             signbits += 1;
- 
-         sum0 += signbits;
-         sum1 += signbits;
- 
-         sum0 += ht[ 32 ].hlen[ p ];
-         sum1 += ht[ 33 ].hlen[ p ];
-     }
- 
-     if ( sum0 < sum1 )
-     {
-         bitsum_count1 = sum0;
-         cod_info->count1table_select = 0;
-     }
-     else
-     {
-         bitsum_count1 = sum1;
-         cod_info->count1table_select = 1;
-     }
-     return( bitsum_count1 );
- }
- 
- 
- 
- 
- 
- struct
- {
-     unsigned region0_count;
-     unsigned region1_count;
- } subdv_table[ 23 ] =
- {
- {0, 0}, /* 0 bands */
- {0, 0}, /* 1 bands */
- {0, 0}, /* 2 bands */
- {0, 0}, /* 3 bands */
- {0, 0}, /* 4 bands */
- {0, 1}, /* 5 bands */
- {1, 1}, /* 6 bands */
- {1, 1}, /* 7 bands */
- {1, 2}, /* 8 bands */
- {2, 2}, /* 9 bands */
- {2, 3}, /* 10 bands */
- {2, 3}, /* 11 bands */
- {3, 4}, /* 12 bands */
- {3, 4}, /* 13 bands */
- {3, 4}, /* 14 bands */
- {4, 5}, /* 15 bands */
- {4, 5}, /* 16 bands */
- {4, 6}, /* 17 bands */
- {5, 6}, /* 18 bands */
- {5, 6}, /* 19 bands */
- {5, 7}, /* 20 bands */
- {6, 7}, /* 21 bands */
- {6, 7}, /* 22 bands */
- };
- 
- 
- 
- 
- /*************************************************************************/
- /*            subdivide                                                  */
- /*************************************************************************/
- 
- /* presumable subdivides the bigvalue region which will
-    use separate Huffman tables.
- */
- 
- void subdivide( gr_info *cod_info )
- {
-     int scfb_anz = 0;
-     int bigvalues_region;
-     
-     if ( cod_info->big_values == 0 )
-     { /* no big_values region */
-         cod_info->region0_count = 0;
-         cod_info->region1_count = 0;
-     }
-     else
-     {
-         bigvalues_region = 2 * cod_info->big_values;
- 
-         if ( (cod_info->window_switching_flag == 0) )
-         { /* long blocks */
-             int thiscount, index;
-             /* Calculate scfb_anz */
-             while ( scalefac_band_long[scfb_anz] < bigvalues_region )
-                 scfb_anz++;
-             assert( scfb_anz < 23 );
- 
-             cod_info->region0_count = subdv_table[scfb_anz].region0_count;
-             thiscount = cod_info->region0_count;
-             index = thiscount + 1;
-             while ( thiscount && (scalefac_band_long[index] > bigvalues_region) )
-             {
-                 thiscount -= 1;
-                 index -= 1;
-             }
-             cod_info->region0_count = thiscount;
- 
-             cod_info->region1_count = subdv_table[scfb_anz].region1_count;
-             index = cod_info->region0_count + cod_info->region1_count + 2;
-             thiscount = cod_info->region1_count;
-             while ( thiscount && (scalefac_band_long[index] > bigvalues_region) )
-             {
-                 thiscount -= 1;
-                 index -= 1;
-             }
-             cod_info->region1_count = thiscount;
-             cod_info->address1 = scalefac_band_long[cod_info->region0_count+1];
-             cod_info->address2 = scalefac_band_long[cod_info->region0_count
-                                                     + cod_info->region1_count + 2 ];
-             cod_info->address3 = bigvalues_region;
-         }
-         else
-         {
-             if ( (cod_info->block_type == 2) && (cod_info->mixed_block_flag == 0) )
-             { 
-                 cod_info->region0_count =  8;
-                 cod_info->region1_count =  36;
-                 cod_info->address1 = 36;
-                 cod_info->address2 = bigvalues_region;
-                 cod_info->address3 = 0;  
-             }
-             else
-             {
-                 cod_info->region0_count = 7;
-                 cod_info->region1_count = 13;
-                 cod_info->address1 = scalefac_band_long[cod_info->region0_count+1];
-                 cod_info->address2 = bigvalues_region;
-                 cod_info->address3 = 0;
-             }
-         }
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            bigv_tab_select                                            */
- /*************************************************************************/
- 
- /*
- /*  Function: Select huffman code tables for bigvalues regions 
- */
- 
- void bigv_tab_select( int ix[576], gr_info *cod_info )
- {
-     /* int max; */
- 
-     cod_info->table_select[0] = 0;
-     cod_info->table_select[1] = 0;
-     cod_info->table_select[2] = 0;
-     
-     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
-     {
-         /*
-           Within each scalefactor band, data is given for successive
-           time windows, beginning with window 0 and ending with window 2.
-           Within each window, the quantized values are then arranged in
-           order of increasing frequency...
-           */
-         int sfb, window, line, start, end, max1, max2, x, y;
-         int region1Start;
-         int *pmax;
- 
-         region1Start = 12;
-         max1 = max2 = 0;
- 
-         for ( sfb = 0; sfb < 13; sfb++ )
-         {
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
-             
-             if ( start < region1Start )
-                 pmax = &max1;
-             else
-                 pmax = &max2;
-             
-             for ( window = 0; window < 3; window++ )
-                 for ( line = start; line < end; line += 2 )
-                 {
-                     assert( line >= 0 );
-                     assert( line < 576 );
-                     x = abs( ix[ (line * 3) + window ] );
-                     y = abs( ix[ ((line + 1) * 3) + window ]);
-                     *pmax = *pmax > x ? *pmax : x;
-                     *pmax = *pmax > y ? *pmax : y;
-                 }
-         }
-         cod_info->table_select[0] = choose_table( max1 );
-         cod_info->table_select[1] = choose_table( max2 );
-     }
-     else
-     {
-         if ( cod_info->address1 > 0 )
-             cod_info->table_select[0] = new_choose_table( ix, 0, cod_info->address1 );
- 
-         if ( cod_info->address2 > cod_info->address1 )
-             cod_info->table_select[1] = new_choose_table( ix, cod_info->address1, cod_info->address2 );
- 
-         if ( cod_info->big_values * 2 > cod_info->address2 )
-             cod_info->table_select[2] = new_choose_table( ix, cod_info->address2, cod_info->big_values * 2 );
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            new_choose table                                           */
- /*************************************************************************/
- 
- /*
-   Choose the Huffman table that will encode ix[begin..end] with
-   the fewest bits.
- 
-   Note: This code contains knowledge about the sizes and characteristics
-   of the Huffman tables as defined in the IS (Table B.7), and will not work
-   with any arbitrary tables.
- */
- 
- int new_choose_table( int ix[576], unsigned int begin, unsigned int end )
- {
-     int i, max;
-     int choice[ 2 ];
-     int sum[ 2 ];
- 
-     max = ix_max( ix, begin, end );
- 
-     if ( max == 0 )
-         return 0;
-     
-     max = abs( max );
- 
-     choice[ 0 ] = 0;
-     choice[ 1 ] = 0;
- 
-     if ( max < 15 )
-     {
- 	/* try tables with no linbits */
-         for ( i = 0; i < 14; i++ )
-             if ( ht[i].xlen > max )
- 	    {
- 		choice[ 0 ] = i;
-                 break;
- 	    }
- 	assert( choice[0] );
- 
- 	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
- 
- 	switch ( choice[0] )
- 	{
- 	  case 2:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 3 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 3;
- 	    break;
- 
- 	  case 5:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 6 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 6;
- 	    break;
- 
- 	  case 7:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 8 );
- 	    if ( sum[1] <= sum[0] )
- 	    {
- 		choice[ 0 ] = 8;
- 		sum[ 0 ] = sum[ 1 ];
- 	    }
- 	    sum[ 1 ] = count_bit( ix, begin, end, 9 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 9;
- 	    break;
- 
- 	  case 10:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 11 );
- 	    if ( sum[1] <= sum[0] )
- 	    {
- 		choice[ 0 ] = 11;
- 		sum[ 0 ] = sum[ 1 ];
- 	    }
- 	    sum[ 1 ] = count_bit( ix, begin, end, 12 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 12;
- 	    break;
- 
- 	  case 13:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 15 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 15;
- 	    break;
- 
- 	  default:
- 	    break;
- 	}
-     }
-     else
-     {
- 	/* try tables with linbits */
- 	max -= 15;
- 	
- 	for ( i = 15; i < 24; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice[ 0 ] = i;
- 		break;
- 	    }
- 	}
- 	for ( i = 24; i < 32; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice[ 1 ] = i;
- 		break;
- 	    }
- 	}
- 	assert( choice[0] );
- 	assert( choice[1] );
- 	
- 	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
- 	sum[ 1 ] = count_bit( ix, begin, end, choice[1] );
- 	if ( sum[1] < sum[0] )
- 	    choice[ 0 ] = choice[ 1 ];
-     }
-     return choice[ 0 ];
- }
- 
- 
- 
- /*************************************************************************/
- /*            choose table                                               */
- /*************************************************************************/
- 
- int choose_table( int max )
- {
-     int  i, choice;
- 
-     if ( max == 0 )
-         return 0;
-     
-     max = abs( max );    
-     choice = 0;
- 
-     if ( max < 15 )
-     {
-         for ( i = 0; i < 15; i++ )
-         {
-             if ( ht[i].xlen > max )
-             {
- 		choice = i;
- 		break;
-             }
-         }
-     }
-     else
-     {	
- 	max -= 15;
- 	for (i = 15; i < 32; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice = i;
- 		break;
- 	    }
- 	}
-     }
-     assert( choice );
-     return choice;
- }
- 
- 
- /*************************************************************************/
- /*            bigv_bitcount                                              */
- /*************************************************************************/
- 
- /*
- Function: Count the number of bits necessary to code the bigvalues region.
- */
- 
- int bigv_bitcount( int ix[576], gr_info *gi )
- {
-     int bits = 0;
-     
-     if ( gi->window_switching_flag && gi->block_type == 2 )
-     {
-         /*
-           Within each scalefactor band, data is given for successive
-           time windows, beginning with window 0 and ending with window 2.
-           Within each window, the quantized values are then arranged in
-           order of increasing frequency...
-           */
-         int sfb, window, line, start, end;
-         I192_3 *ix_s;
- 
-         if ( gi->mixed_block_flag )
-         {
-             unsigned int table;
- 
-             if ( (table = gi->table_select[0]) != 0 )
-                 bits += count_bit( ix, 0, gi->address1, table );
-             sfb = 2;
-         }
-         else
-             sfb = 0;
- 
-         ix_s = (I192_3 *) &ix[0];
- 
-         for ( ; sfb < 13; sfb++ )
-         {
-             unsigned tableindex = 100;
- 
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
- 
-             if ( start < 12 )
-                 tableindex = gi->table_select[ 0 ];
-             else
-                 tableindex = gi->table_select[ 1 ];
-             assert( tableindex < 32 );
- 
-             for ( window = 0; window < 3; window++ )
-                 for ( line = start; line < end; line += 2 )
-                 {
-                     unsigned int code, ext;
-                     int cbits, xbits;
-                     int x = (*ix_s)[line][window];
-                     int y = (*ix_s)[line + 1][window];
-                     bits += HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
-                 }
-         }
-     }
-     else
-     {
-         unsigned int table;
-         
-         if( (table=gi->table_select[0]) != 0 )  /* region0 */ 
-             bits += count_bit(ix, 0, gi->address1, table );
-         if( (table=gi->table_select[1]) != 0 )  /* region1 */ 
-             bits += count_bit(ix, gi->address1, gi->address2, table );
-         if( (table=gi->table_select[2]) != 0 )  /* region2 */ 
-             bits += count_bit(ix, gi->address2, gi->address3, table );
-     }
-     return bits;
- }
- 
- 
- 
- /*************************************************************************/
- /*            count_bit                                                  */
- /*************************************************************************/
- 
- /*
-  Function: Count the number of bits necessary to code the subregion. 
- */
- 
- int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table )
- {
-     int i, sum;
- 
-     sum = 0;
-     for ( i = start; i < end; i += 2 )
-     {
-         unsigned int code, ext;
-         int cbits, xbits;
-         sum += HuffmanCode( table, ix[i], ix[i+1], &code, &ext, &cbits, &xbits );
-     }
-     return sum;
- }
- 
- 
- 
- #ifndef HAVE_NINT
- int
- nint( double in )
- {
-     int    temp;
- 
-     if( in < 0 )  temp = (int)(in - 0.5);
-     else    temp = (int)(in + 0.5);
- 
-     return(temp);
- }
- 
- double
- aint(double in) {
- 	return((long) in);
- }
- #endif
- 
- 
- 
- /*
-   Seymour's comment:  Jan 8 1995
-   When mixed_block_flag is set, the low subbands 0-1 undergo the long
-   window transform and are each split into 18 frequency lines, while
-   the remaining 30 subbands undergo the short window transform and are
-   each split into 6 frequency lines. A problem now arises, as neither
-   the short or long scale factor bands apply to this mixed spectrum.
-   The standard resolves this situation by using the first 8 long scale
-   factor bands for the low spectrum and the short scale factor bands
-   in the range of 3 to 11 (inclusive) for the remaining frequency lines.
-   These scale factor bands do not match exactly to the 0-1 subbands
-   for all sampling frequencies (32,44.1 and 48 kHz); however they
-   were designed so that there would not be a frequency gap or overlap
-   at the switch over point. (Note multiply short frequency lines by 3
-   to account for wider frequency line.) 
-   */
- 
- 
- 
- /*************************************************************************/
- /*            gr_deco                                                    */
- /*************************************************************************/
- 
- void gr_deco( gr_info *cod_info )
- {
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-         if ( cod_info->mixed_block_flag == 0 )
-         {
-             cod_info->sfb_lmax = 0; /* No sb*/
-             cod_info->sfb_smax = 0;
-         }
-         else
-         {
-             cod_info->sfb_lmax = 8;
-             cod_info->sfb_smax = 3;
-         }
-     else
-     {
-         cod_info->sfb_lmax = SFB_LMAX - 1;
-         cod_info->sfb_smax = SFB_SMAX - 1;    /* No sb */
-     }
- }
- 
- 
- 
- 
- 
- 
- 
- 
- /* The following optional code written by Seymour Shlien
-    will speed up the outer_loop code which is called
-    by iteration_loop. When BIN_SEARCH is defined, the
-    outer_loop function precedes the call to the function inner_loop
-    with a call to bin_search gain defined below, which
-    returns a good starting quantizerStepSize.
- */
- 
- #if defined(BIN_SEARCH) || defined(PERFORM) 
- int count_bits(ix,cod_info)  
- int  *ix; /*  I576  *ix; */
- gr_info *cod_info;
- {
- int bits,max;
-   calc_runlen(ix,cod_info);		/*rzero,count1,big_values*/
-   max = ix_max( ix, 0,576);
-   if(max > 8192) return 100000;         /* report unsuitable quantizer */
-   bits = count1_bitcount(ix, cod_info); /*count1_table selection*/
-   subdivide(cod_info);			/* bigvalues sfb division */
-   bigv_tab_select(ix,cod_info);		/* codebook selection*/
-   bits += bigv_bitcount(ix,cod_info);	/* bit count */
- /* printf("\nglobal_gain = %f  bits= %d ",cod_info->quantizerStepSize,bits);*/
- return bits;
- }
- #endif
- 
- 
- #ifdef BIN_SEARCH
- 
- int bin_search_StepSize(int desired_rate, double start, int *ix,
-            double xrs[576], gr_info * cod_info)
- {
- double top,bot,next,last;
- int bit;
- top = start;
- bot = 200;
- next = start;
- do
-   {
-   last = next;
-   next = aint((top+bot)/2.0);
-   cod_info->quantizerStepSize = next;
-   quantize(xrs,ix,cod_info);
-   bit = count_bits(ix,cod_info);
-   if (bit>desired_rate) top = next;
-   else bot = next;
- /*  printf("\n%f %f %f %d %d",next, top,bot,bit,desired_rate);*/
-   }
-   while ((bit != desired_rate) && fabs(last - next) > 1.0);
- return next;
- }
- 
- #endif
- 
- 
- 
- 
- #ifdef PERFORM
- 
- /* The following code is used for exposing some problems with
-    the outer_loop code. PERFORM should be defined to the
-    frame number you wish to have additional output recorded
-    in the file encode.log  - Seymour Shlien 14-Jan-97
- */
- 
- /*
- float worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,block_type,gr,ch)
- double xfsf[4][CBLIMIT];
- III_psy_xmin *l3_xmin;
- int block_type,gr,ch;
- */
- float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
-                              ,int block_type,int gr,int ch)
- 
- {
- float ratio,maxratio;
- int i,j;
- maxratio =-100.0;
- if (block_type != 2)
-   for(i=0;i<21;i++)
-     {
-     ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
-     if (ratio > maxratio) maxratio = ratio;
-     }
- else
-   {
-   for(j=0;j<3;j++)
- /* for(i = cod_info->sfb_smax; i <SFB_SMAX; i++) */
-      for(i = 0; i <11; i++)
-     {
-     ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
-     if (ratio > maxratio) maxratio = ratio;
-     }
-   }
- return maxratio;
- }
-  
- 
- print_ratios(handle_out,l3_xmin,xfsf,block_type,gr,ch)
- FILE *handle_out;
- double xfsf[4][CBLIMIT];
- III_psy_xmin *l3_xmin;
- int gr,ch;
- int block_type;
- {
- float ratio;
- int i,j;
- if(block_type !=2)
-  for (i=0;i<21;i++)
-   {
-    ratio = 100.0; /* signals undefined value in output */
-    if(l3_xmin->l[gr][ch][i] >1.0e-20)
-      ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
-    fprintf(handle_out,"%6.2f ",ratio);
-    if(i%5==4) fprintf(handle_out,"\n");
-   }
- else
-   
-   for(j=0;j<3;j++)
-    { fprintf(handle_out,"\n  block %d\n",j);
-      for(i = 0; i <11; i++)
-       {
-       ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
-       fprintf(handle_out,"%6.2f ",ratio);
-       if(i%5==4) fprintf(handle_out,"\n");
-       }
-    }
- fprintf(handle_out,"\n");
- }
- 
- 
- print_scalefacs(handle_out,scalefac,block_type,gr,ch)
- FILE *handle_out;
- III_scalefac_t *scalefac;
- int gr,ch;
- int block_type;
- {
- int sfb,j;
- 
- if(block_type !=2)
-  for ( sfb = 0; sfb < 21; sfb++ )
-    {
-    fprintf(handle_out,"%6d ", scalefac->l[gr][ch][sfb]);    
-    if(sfb%5==4) fprintf(handle_out,"\n");
-    }
- else
-  for (j=0;j<3;j++)
-   {
-   fprintf(handle_out,"\n block %d\n",j);
-   for (sfb=0;sfb<11;sfb++)
-    {
-    fprintf(handle_out,"%6d ",scalefac->s[gr][ch][sfb][j]);
-    if(sfb%5==4) fprintf(handle_out,"\n");
-    }
-   }
- fprintf(handle_out,"\n");
- }
- 
- 
- print_quantized_values(FILE *handle, int ix[576], gr_info *cod_info)
- {
- int sfb,start,end,i,bw;
- for (sfb=0;sfb<cod_info->sfb_lmax;sfb++)
-   {
-   start = scalefac_band_long[sfb];
-   end = scalefac_band_long[sfb+1];
-   bw = end - start;
-   fprintf(handle,"scalefac band %d from %d to %d\n",sfb,start,end);
-   for (i=0;i<bw;i++)
-     {
-     fprintf(handle,"%8d",ix[start+i]);
-     if(i%5==4) fprintf(handle,"\n");
-     }
-   fprintf(handle,"\n");
-   }
- }
- 
- 
- test_inner_loop(double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
-             gr_info *cod_info, int gr, int ch, double xfsf[4][CBLIMIT], 
-             III_psy_xmin  *l3_xmin) 
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
-  
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }  
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
-  
-     bits = count_bits(ix,cod_info);       
- 
-         if(frameNum == PERFORM)
-         {
-           fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-             cod_info->quantizerStepSize,bits,max_bits);
-           calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf );
-                                              /* distortion calculation */
-           print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-           fprintf(log_output,"\n\n");
-           }
- 
-     }
-     while ( bits > max_bits );
-  
-     return bits;
- }
-  
- #endif PERFORM 
--- 0 ----
diff -r -c -N encoder/loop.h lame3.70/loop.h
*** encoder/loop.h	Wed Jan 22 02:43:16 1997
--- lame3.70/loop.h	Wed Dec 31 17:00:00 1969
***************
*** 1,90 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: loop.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef LOOP_DOT_H
- #define LOOP_DOT_H
- #include "common.h"
- #include "l3side.h"
- 
- /**********************************************************************
-  *   date   programmers                comment                        *
-  * 25. 6.92  Toshiyuki Ishino          Ver 1.0                        *
-  * 29.10.92  Masahiro Iwadare          Ver 2.0                        *
-  * 17. 4.93  Masahiro Iwadare          Updated for IS Modification    *
-  *                                                                    *
-  *********************************************************************/
- 
- extern int cont_flag;
- 
- #define e              2.71828182845
- 
- /*#define SBLIMIT       32*/
- #define CBLIMIT       21
- 
- #define SFB_LMAX 22
- #define SFB_SMAX 13
- 
- extern int pretab[];
- 
- struct scalefac_struct
- {
-    int l[23];
-    int s[14];
- };
- 
- extern struct scalefac_struct sfBandIndex[];  /* Table B.8 -- in loop.c */
- 
- 
- void iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
- 		     III_side_info_t *l3_side, int l3_enc[2][2][576], int mean_bits,
- 		     int stereo, double xr_dec[2][2][576],
- 		     III_scalefac_t *scalefac, frame_params *fr_ps,
- 		     int ancillary_pad, int bitsPerFrame );
- 
- 
- int nint( double in );
- 
- /* #define PI 3.1415926535 */
- #define maximum(A,B) ( (A) > (B) ? (A) : (B) )
- #define minimum(A,B) ( (A) < (B) ? (A) : (B) )
- #define signum( A ) ( (A) > 0 ? 1 : -1 )
- 
- /* GLOBALE VARIABLE */
- 
- /*extern FILE     *debp;
- extern FILE     *huffcp,*huffdp;
- extern FILE     *musicin,*cod_music;*/
- 
- /* Beachte:Partitonen nur fuer 48 kHz */
- /* andere ev. fehlerhaft  */
- 
- /* static int     scalefac_band_long[22];
-   static int     scalefac_band_short[13];
- */
- /*static int     huffman_tab_quad[2][16][2];
- extern int     bigv_cod_tab[17][2][16][16];
- extern int     bigv_dec_tab[17][512][5];
- extern int     bigv_root_node[17];
- extern int     count1_root_node[2];*/
- /* extern int     cod_tab_info[2][31]; */
- 
- 
- 
- 
- /* in max spalte war um 1 zuviel */
- /* [0][i] : maximalwert der Tabelle mit index i
-    [1][i] : anzahl der linbits der TAb. i        */
- 
- extern int bit_buffer[50000];
- 
- #endif
--- 0 ----
diff -r -c -N encoder/machine.h lame3.70/machine.h
*** encoder/machine.h	Wed Dec 31 17:00:00 1969
--- lame3.70/machine.h	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,112 ----
+ /*
+  *	Machine dependent defines/includes for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #ifndef MACHINE_H_INCLUDED
+ #define MACHINE_H_INCLUDED
+ 
+ #include        <stdio.h>
+ #include        <string.h>
+ #include        <math.h>
+ #include        <stdlib.h>
+ #include		<ctype.h>
+ #include		<signal.h>
+ #include		<sys/types.h>
+ #include		<sys/stat.h>
+ #include		<fcntl.h>
+ #include		<errno.h>
+ 
+ 
+ /* three different types of pow() functions:  
+    1. table lookup   
+    2. pow()
+    3. exp()   on some machines this is claimed to be faster than pow()
+ */
+ 
+ 
+ #define POW20(x)  pow20[x]
+ /*
+ #define POW20(x)  pow(2.0,((double)(x)-210)*.25)
+ #define POW20(x)  exp( ((double)(x)-210)*(.25*LOG2) )
+ */
+ 
+ #define IPOW20(x)  ipow20[x]
+ /*
+ #define IPOW20(x)  exp( -((double)(x)-210)*.1875*LOG2 ) 
+ #define IPOW20(x)  pow(2.0,-((double)(x)-210)*.1875)
+ */
+ 
+ 
+ 
+ #if ( defined(_MSC_VER) && !defined(INLINE))
+ #	define INLINE _inline
+ #elif defined(__SASC) || defined(__GNUC__)
+ #	define INLINE __inline
+ #else
+ #	define INLINE
+ #endif
+ 
+ #if ( defined(_MSC_VER))
+ #	pragma warning( disable : 4244 )
+ #	pragma warning( disable : 4305 )
+ #endif
+ 
+ #if ( defined(_MSC_VER) || defined(__BORLANDC__) )
+ #	define WIN32_LEAN_AND_MEAN
+ #	include <windows.h>
+ #else
+ 	typedef float FLOAT;
+ #endif
+ 
+ 
+ /* MH: the x86 asm quantization routines in quantize-pvt.c
+    are designed to work only with 8-byte doubles or 4-byte
+    floats. if you use a different type (e.g. 10-byte extended
+    precision long doubles, as supported by ICL), you will need
+    to disable the ASM routines (or fix them :) */
+ 
+ #define FLOAT8_is_double
+ typedef double FLOAT8;  
+ 
+ /*#define FLOAT8_is_float*/
+ /*typedef float FLOAT8;  */
+ 
+ 
+ 
+ 
+ #if defined _WIN32 && !defined __CYGWIN__
+ 	typedef unsigned long	u_long;
+ 	typedef unsigned int	u_int;
+ 	typedef unsigned short	u_short;
+ 	typedef unsigned char	u_char;
+ #elif defined __DECALPHA__
+ #       do nothing
+ #elif !defined __GNUC__ || defined __STRICT_ANSI__
+ 	typedef unsigned long	u_long;
+ 	typedef unsigned int	u_int;
+ 	typedef unsigned short	u_short;
+ 	typedef unsigned char	u_char;
+ #endif
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/main.c lame3.70/main.c
*** encoder/main.c	Wed Dec 31 17:00:00 1969
--- lame3.70/main.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,142 ----
+ #include <stdlib.h>
+ #include <string.h>
+ #include <stdio.h>
+ #include <fcntl.h>
+ #ifdef _WIN32
+ /* needed to set stdout to binary */
+ #include <io.h>
+ #endif
+ #include "lame.h"
+ 
+ 
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ 
+ #ifdef __riscos__
+ #include "asmstuff.h"
+ #endif
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * main
+ *
+ * PURPOSE:  MPEG-1,2 Layer III encoder with GPSYCHO
+ * psychoacoustic model.
+ *
+ ************************************************************************/
+ 
+ 
+ int main(int argc, char **argv)
+ {
+ 
+   char mp3buffer[LAME_MAXMP3BUFFER];
+   short int Buffer[2][1152];
+   int iread,imp3;
+   lame_global_flags gf;
+   FILE *outf;
+ #ifdef __riscos__
+   int i;
+ #endif
+ 
+ 
+   lame_init(&gf);                  /* initialize libmp3lame */
+   if(argc==1) lame_usage(&gf,argv[0]);  /* no command-line args, print usage, exit  */
+ 
+   /* parse the command line arguments, setting various flags in the
+    * struct 'gf'.  If you want to parse your own arguments,
+    * or call libmp3lame from a program which uses a GUI to set arguments,
+    * skip this call and set the values of interest in the gf struct.
+    * (see lame.h for documentation about these parameters)
+    */
+   lame_parse_args(&gf,argc, argv);
+ 
+   if (!gf.gtkflag) {
+     /* open the MP3 output file */
+     if (!strcmp(gf.outPath, "-")) {
+ #ifdef __EMX__
+       _fsetmode(stdout,"b");
+ #elif (defined  __BORLANDC__)
+       setmode(_fileno(stdout), O_BINARY);
+ #elif (defined  __CYGWIN__)
+       setmode(fileno(stdout), _O_BINARY);
+ #elif (defined _WIN32)
+       _setmode(_fileno(stdout), _O_BINARY);
+ #endif
+       outf = stdout;
+     } else {
+       if ((outf = fopen(gf.outPath, "wb")) == NULL) {
+ 	fprintf(stderr,"Could not create \"%s\".\n", gf.outPath);
+ 	exit(1);
+       }
+     }
+ #ifdef __riscos__
+     /* Assign correct file type */
+     for (i = 0; gf.outPath[i]; i++)
+       if (gf.outPath[i] == '.') gf.outPath[i] = '/';
+     SetFiletype(gf.outPath, 0x1ad);
+ #endif
+   }
+ 
+ 
+   /* open the wav/aiff/raw pcm or mp3 input file.  This call will
+    * open the file with name gf.inFile, try to parse the headers and
+    * set gf.samplerate, gf.num_channels, gf.num_samples.
+    * if you want to do your own file input, skip this call and set
+    * these values yourself.
+    */
+   lame_init_infile(&gf);
+ 
+   /* Now that all the options are set, lame needs to analyze them and
+    * set some more options
+    */
+   lame_init_params(&gf);
+   lame_print_config(&gf);   /* print usefull information about options being used */
+ 
+ 
+ 
+ 
+ #ifdef HAVEGTK
+   if (gf.gtkflag) gtk_init (&argc, &argv);
+   if (gf.gtkflag) gtkcontrol(&gf);
+   else
+ #endif
+     {
+ 
+       /* encode until we hit eof */
+       do {
+ 	/* read in 'iread' samples */
+ 	iread=lame_readframe(&gf,Buffer);
+ 
+ 
+ 	/* encode */
+ 	imp3=lame_encode_buffer(&gf,Buffer[0],Buffer[1],iread,
+               mp3buffer,(int)sizeof(mp3buffer)); 
+ 
+ 	/* was our output buffer big enough? */
+ 	if (imp3==-1) {
+ 	  fprintf(stderr,"mp3 buffer is not big enough... \n");
+ 	  exit(1);
+ 	}
+ 
+ 	if (fwrite(mp3buffer,1,imp3,outf) != imp3) {
+ 	  fprintf(stderr,"Error writing mp3 output");
+ 	  exit(1);
+ 	}
+       } while (iread);
+     }
+ 
+   imp3=lame_encode_finish(&gf,mp3buffer,(int)sizeof(mp3buffer));   /* may return one more mp3 frame */
+   fwrite(mp3buffer,1,imp3,outf);
+   fclose(outf);
+   lame_close_infile(&gf);            /* close the input file */
+   lame_mp3_tags(&gf);                /* add id3 or VBR tags to mp3 file */
+   return 0;
+ }
+ 
+ 
+ 
diff -r -c -N encoder/makefile.unix lame3.70/makefile.unix
*** encoder/makefile.unix	Wed Jan 22 02:43:23 1997
--- lame3.70/makefile.unix	Wed Dec 31 17:00:00 1969
***************
*** 1,77 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: makefile.unix,v 1.1 1996/02/14 05:28:25 rowlands Exp $
- ##
- ## Makefile for encoder for vanilla UNIX platform using standard make.
- ##
- ## $Log: makefile.unix,v $
- ## Revision 1.1  1996/02/14 05:28:25  rowlands
- ## Initial revision
- ##
- ############################################################################
- 
- # MODE= -O -DUNIX
- MODE= -g -DUNIX
- #MODE= -DMSC60 -AH -Zi -Gt
- OBJ_SUFFIX=.o
- EXE_SUFFIX=
- 
- PROGRAM	= encode$(EXE_SUFFIX)
- 
- all: $(PROGRAM)
- 
- $(PROGRAM) : \
- 	common.c common.h encode.c encoder.h formatBitstream.c \
- 	formatBitstream.h huffman.c huffman.h ieeefloat.c ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.c l3bitstream.h l3psy.c l3psy.h \
- 	l3side.h loop-pvt.h loop.c loop.h mdct.c mdct.h musicin.c \
- 	portableio.c portableio.h psy.c reservoir.c reservoir.h subs.c tonal.c
- 
- HEDS =  \
- 	common.h encoder.h formatBitstream.h huffman.h ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.h l3psy.h l3side.h loop-pvt.h loop.h \
- 	mdct.h portableio.h reservoir.h
- 
- OBJS = \
- 	common$(OBJ_SUFFIX) \
- 	encode$(OBJ_SUFFIX) \
- 	formatBitstream$(OBJ_SUFFIX) \
- 	huffman$(OBJ_SUFFIX) \
- 	ieeefloat$(OBJ_SUFFIX) \
- 	l3bitstream$(OBJ_SUFFIX) \
- 	l3psy$(OBJ_SUFFIX) \
- 	loop$(OBJ_SUFFIX) \
- 	mdct$(OBJ_SUFFIX) \
- 	musicin$(OBJ_SUFFIX) \
- 	portableio$(OBJ_SUFFIX) \
- 	psy$(OBJ_SUFFIX) \
- 	reservoir$(OBJ_SUFFIX) \
- 	subs$(OBJ_SUFFIX) \
- 	tonal$(OBJ_SUFFIX)
- 
- LFLAG = 
- 
- CC    = gcc
- LN    = gcc
- LNEXTRA=-lm
- #CC    = cl
- #LN    = cl
- 
- .c$(OBJ_SUFFIX): $(HEDS)
- 	$(CC) -c $(MODE) $*.c
- 
- all: $(PROGRAM)
- 
- default: all
- 
- 
- $(PROGRAM) : $(OBJS) $(HEDS)
- 	$(LN) -o $(PROGRAM) $(MODE) $(LFLAG) $(OBJS) $(LNEXTRA)
- 
- clean:
- 	rm -f $(OBJS)
- 
- veryclean:
- 	rm -f $(PROGRAM) $(OBJS)
--- 0 ----
diff -r -c -N encoder/mdct.c lame3.70/mdct.c
*** encoder/mdct.c	Wed Jan 22 02:43:17 1997
--- lame3.70/mdct.c	Wed Dec 31 17:00:00 1969
***************
*** 1,212 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: mdct.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: mdct.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #include "common.h"
- #include "l3side.h"
- #include "mdct.h"
- 
- double ca[8], cs[8];
- 
- /*
-   This is table B.9: coefficients for aliasing reduction
- */
- static double c[8] = { -0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142, -0.0037 };
- 
- void mdct_sub( L3SBS (*sb_sample), double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr )
- {
-     gr_info *cod_info;
-     double mdct_in[36];
-     int ch,gr,band,k,j;
-     double bu,bd;
-     static int init = 0;
-     int	block_type;
-     double (*mdct_enc)[2][32][18] = (double (*)[2][32][18]) mdct_freq;
-     
-     if ( init == 0 )
-     {
- 	/* prepare the aliasing reduction butterflies */
- 	for ( k = 0; k < 8; k++ )
- 	{
- 	    double sq;
- 	    sq = sqrt( 1.0 + c[k] * c[k] );
- 	    ca[k] = c[k] / sq;
- 	    cs[k] = 1.0 / sq;
- 	}
- 	init++;
-     }
-     
-     for ( gr = 0; gr < mode_gr; gr++ )
- 	for ( ch = 0; ch < stereo; ch++ )
- 	{
- 	    cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]) ;
- 	    block_type = cod_info->block_type;
- 	    
- 	    /*
- 	      Compensate for inversion in the analysis filter
- 	    */
- 	    for ( band = 0; band < 32; band++ )
- 		for ( k = 0; k < 18; k++ )
- 		    if ( (band & 1) && (k & 1) )
- 			(*sb_sample)[ch][gr+1][k][band] *= -1.0;
- 	    
- 	    /*
- 	      Perform imdct of 18 previous subband samples
- 	      + 18 current subband samples
- 	    */
- 	    for ( band = 0; band < 32; band++ )
- 	    {
- 		for ( k = 0; k < 18; k++ )
- 		{
- 		    mdct_in[k]    = (*sb_sample)[ch][ gr ][k][band];
- 		    mdct_in[k+18] = (*sb_sample)[ch][gr+1][k][band];
- 		}
- 		if ( cod_info->mixed_block_flag && (band < 2) )
- 		    block_type = 0;
- 		
- 		mdct( mdct_in, &mdct_enc[gr][ch][band][0], block_type );
- 	    }
- 	    
- 	    /*
- 	      Perform aliasing reduction butterfly
- 	      on long blocks
- 	    */
- 	    if ( block_type != 2 )
- 		for ( band = 0; band < 31; band++ )
- 		    for ( k = 0; k < 8; k++ )
- 		    {
- 			bu = mdct_enc[gr][ch][band][17-k] * cs[k] + mdct_enc[gr][ch][band+1][k] * ca[k];
- 			bd = mdct_enc[gr][ch][band+1][k] * cs[k] - mdct_enc[gr][ch][band][17-k] * ca[k];
- 			mdct_enc[gr][ch][band][17-k] = bu;
- 			mdct_enc[gr][ch][band+1][k]  = bd;
- 		    }
- 	    
- 	}
-     
-     /*
-       Save latest granule's subband samples to be used in
-       the next mdct call
-     */
-     for ( ch = 0; ch < stereo; ch++ )
- 	for ( j = 0; j < 18; j++ )
- 	    for ( band = 0; band < 32; band++ )
- 		(*sb_sample)[ch][0][j][band] = (*sb_sample)[ch][mode_gr][j][band];
- }
- 
- void mdct( double *in, double *out, int block_type )
- {
- /*-------------------------------------------------------------------*/
- /*                                                                   */
- /*   Function: Calculation of the MDCT                               */
- /*   In the case of long blocks ( block_type 0,1,3 ) there are       */
- /*   36 coefficents in the time domain and 18 in the frequency       */
- /*   domain.                                                         */
- /*   In the case of short blocks (block_type 2 ) there are 3         */
- /*   transformations with short length. This leads to 12 coefficents */
- /*   in the time and 6 in the frequency domain. In this case the     */
- /*   results are stored side by side in the vector out[].            */
- /*                                                                   */
- /*   New layer3                                                      */
- /*                                                                   */
- /*-------------------------------------------------------------------*/
- 
-   int l,k,i,m,N;
-   double sum;
-   static double win[4][36];
-   static int init = 0;
-   static double cos_s[6][12], cos_l[18][36];
- 
- 
-   if ( init == 0 )
-   {
-     /* type 0 */
-     for ( i = 0; i < 36; i++ )
-       win[0][i] = sin( PI/36 * (i + 0.5) );
-     /* type 1*/
-     for ( i = 0; i < 18; i++ ) 
-       win[1][i] = sin( PI/36 * (i + 0.5) );
-     for ( i = 18; i < 24; i++ )
-       win[1][i] = 1.0;
-     for ( i = 24; i < 30; i++ )
-       win[1][i] = sin( PI/12 * ( i + 0.5 - 18) );
-     for ( i = 30; i < 36; i++ )
-       win[1][i] = 0.0;
-     /* type 3*/
-     for ( i = 0; i < 6; i++ )
-       win[3][i] = 0.0;
-     for ( i = 6; i < 12; i++ ) 
-       win[3][i] = sin( PI/12 * (i + 0.5 - 6) );
-     for ( i = 12; i < 18; i++ )
-       win[3][i] = 1.0;
-     for ( i = 18; i < 36; i++ )
-       win[3][i] = sin( PI/36 * (i + 0.5) );
-     /* type 2*/
-     for ( i = 0; i < 12; i++ )
-     win[2][i] = sin( PI/12 * (i + 0.5) );
-     for ( i = 12; i < 36; i++ )
-       win[2][i] = 0.0;
- 
-     N = 12;
-     for ( m = 0; m < N / 2; m++ )
-       for ( k = 0; k < N; k++ )
-         cos_s[m][k] = cos( (PI /(2 * N)) * (2 * k + 1 + N / 2) *
-                      (2 * m + 1) ) / (N / 4);
- 
-     N = 36;
-     for ( m = 0; m < N / 2; m++ )
-       for ( k = 0; k < N; k++ )
-         cos_l[m][k] = cos( (PI / (2 * N)) * (2 * k + 1 + N / 2) *
-                      (2 * m + 1) ) / (N / 4);
- 
-     init++;
-   }
- 
-   if ( block_type == 2 )
-   {
-     N = 12;
-     for ( l = 0; l < 3; l++ )
-     {
-       for ( m = 0; m < N / 2; m++ )
-       {
-         for ( sum = 0.0, k = 0; k < N; k++ )
-           sum += win[block_type][k] * in[k + 6 * l + 6] * cos_s[m][k];
-         out[ 3 * m + l] = sum;
-       }
-     }
-   }
-   else
-   {
-     N = 36;
-     for ( m = 0; m < N / 2; m++ )
-     {
-       for ( sum = 0.0, k = 0; k < N; k++ )
-         sum += win[block_type][k] * in[k] * cos_l[m][k];
-       out[m] = sum;
-     }
-   }
- }
- 
- void
- delay( double (*xr)[2][576], int stereo )
- {
-     static double xr_buff[2][576];
-     double xr_buff2[2][576];
-     unsigned int i,j;
-     
-     for (i=0;i<stereo;i++)
-     {
- 	for (j=0;j<576;j++) xr_buff2[i][j] = xr_buff[i][j];
- 	for (j=0;j<576;j++) xr_buff[i][j]  = xr[1][i][j];
- 	for (j=0;j<576;j++) xr[1][i][j]    = xr[0][i][j];
- 	for (j=0;j<576;j++) xr[0][i][j]    = xr_buff2[i][j];
-     }
- }
--- 0 ----
diff -r -c -N encoder/mdct.h lame3.70/mdct.h
*** encoder/mdct.h	Wed Jan 22 02:43:17 1997
--- lame3.70/mdct.h	Wed Dec 31 17:00:00 1969
***************
*** 1,25 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: mdct.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: mdct.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef MDCT_DOT_H
- #define MDCT_DOT_H
- void mdct(double *in, double *out, int block_type);
- void inv_mdct(double *in, double *out, int block_type);
- 
- typedef double D32_18[SBLIMIT][18];
- typedef double L3SBS[2][3][18][SBLIMIT]; /* [gr][ch] */
- 
- void mdct_sub(L3SBS (*sb_sample), double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr );
- void mdct_sub_dec(double (*mdct_freq)[2][576], double inv_mdct_dec[3][2][18][32], int stereo, III_side_info_t *l3_side);
- void delay(double (*xr)[2][576], int stereo);
- #endif
--- 0 ----
diff -r -c -N encoder/mlame lame3.70/mlame
*** encoder/mlame	Wed Dec 31 17:00:00 1969
--- lame3.70/mlame	Sun Jan 30 22:49:48 2000
***************
*** 0 ****
--- 1,81 ----
+ #!/bin/bash 
+ #!/usr/local/bin/bash
+ ############################################################################
+ #   
+ #  Run the LAME encoder on multiple files, with option to delete .wav files
+ #  after encoding.  "mlame -h" will give instructions.
+ #
+ #  Robert Hegemann <Robert.Hegemann@gmx.de>
+ #
+ ############################################################################
+ 
+ mp3coder="lame"
+ options="-h -d -m j -b 128"
+ rmsrc=false
+ 
+ helptext="\
+ \nThis script runs the LAME mp3 encoder on multiple files: \n\n\
+ $0 [options] <file 1> ... <file n>\n\
+ \n\
+   options:\n\
+     -h                  this help text\n\
+     -r                  remove files after encoding\n\
+     -o \"<lame options>\" overrides script default options \"${options}\"\n\
+ \n\
+   example:\n\
+     $0 -r -o \"-v -V 0 -b 112\" a*.wav z*.aif\n\
+     \n\
+ "
+ 
+ #   process command-line options
+ #   this could be extended to fake the 
+ #   commandline interface of the mp3encoder
+ 
+ while getopts ":o:r" optn; do
+     case $optn in
+     o ) options=$OPTARG # replace default options
+         ;; 
+     r ) rmsrc=true
+         ;;
+     \? ) printf "$helptext"
+         exit 1  
+         ;;
+     esac
+ done
+ shift $(($OPTIND - 1))
+ 
+ #   process input-files
+ 
+ for filename in "$@"; do
+     case $filename in
+     *[*?]*  )   # means shell couldnt extend *.wav, etc.
+         echo "warning: no $filename file(s) found"
+         ;;
+     *[.][wW][aA][vV]  )
+         name=${filename%[.][wW][aA][vV]}
+         if $mp3coder $options "$filename" "${name}.mp3" 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f "$filename"
+             fi
+         fi
+         ;;
+     *[.][aA][iI][fF]  )
+         name=${filename%[.][aA][iI][fF]}
+         if $mp3coder $options "$filename" "${name}.mp3" 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f "$filename"
+             fi
+         fi
+         ;;
+     *   )
+         if $mp3coder $options "$filename" "${filename}.mp3" 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f "$filename"
+             fi
+         fi
+         ;;
+     esac
+ done
diff -r -c -N encoder/mp3rtp.c lame3.70/mp3rtp.c
*** encoder/mp3rtp.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mp3rtp.c	Thu Mar 16 12:05:26 2000
***************
*** 0 ****
--- 1,171 ----
+ #include <stdlib.h>
+ #include <string.h>
+ #include <time.h>
+ #include <unistd.h>
+ #include "lame.h"
+ #include "rtp.h"
+ 
+ 
+ /*
+ 
+ encode (via LAME) to mp3 with RTP streaming of the output.
+ 
+ Author:  Felix von Leitner <leitner@vim.org>
+ 
+ mp3rtp  ip:port:ttl  [lame encoding options]  infile outfile
+ 
+ example:
+ 
+ arecord -b 16 -s 22050 -w | ./mp3rtp 224.17.23.42:5004:2 -b 56 - /dev/null
+ 
+ 
+ 
+ */
+ 
+ 
+ struct rtpheader RTPheader;
+ struct sockaddr_in rtpsi;
+ int rtpsocket;
+ 
+ void rtp_output(char *mp3buffer,int mp3size)
+ {
+   sendrtp(rtpsocket,&rtpsi,&RTPheader,mp3buffer,mp3size);
+   RTPheader.timestamp+=5;
+   RTPheader.b.sequence++;
+ }
+ 
+ void rtp_usage(void) {
+     fprintf(stderr,"usage: mp3rtp ip:port:ttl  [encoder options] <infile> <outfile>\n");
+     exit(1);
+ }
+ 
+ 
+ 
+ char mp3buffer[LAME_MAXMP3BUFFER];
+ 
+ 
+ /************************************************************************
+ *
+ * main
+ *
+ * PURPOSE:  MPEG-1,2 Layer III encoder with GPSYCHO 
+ * psychoacoustic model.
+ *
+ ************************************************************************/
+ 
+ 
+ int main(int argc, char **argv)
+ {
+ 
+   int i,port,ttl;
+   char *tmp,*Arg;
+   lame_global_flags gf;
+   int iread,imp3;
+   FILE *outf;
+   short int Buffer[2][1152];
+ 
+   if(argc<=2) {
+     rtp_usage();
+     exit(1);
+   }
+ 
+   /* process args */
+   Arg = argv[1];
+   tmp=strchr(Arg,':');
+ 
+   if (!tmp) {
+     rtp_usage();
+     exit(1);
+   }
+   *tmp++=0;
+   port=atoi(tmp);
+   if (port<=0) {
+     rtp_usage();
+     exit(1);
+   }
+   tmp=strchr(tmp,':');
+   if (!tmp) {
+     rtp_usage();
+     exit(1);
+   }
+   *tmp++=0;
+   ttl=atoi(tmp);
+   if (tmp<=0) {
+     rtp_usage();
+     exit(1);
+   }
+   rtpsocket=makesocket(Arg,port,ttl,&rtpsi);
+   srand(getpid() ^ time(0));
+   initrtp(&RTPheader);
+ 
+ 
+   /* initialize encoder */
+   lame_init(&gf);
+ 
+   /* Remove the argumets that are rtp related, and then 
+    * parse the command line arguments, setting various flags in the
+    * struct pointed to by 'gf'.  If you want to parse your own arguments,
+    * or call libmp3lame from a program which uses a GUI to set arguments,
+    * skip this call and set the values of interest in the gf struct.  
+    * (see lame.h for documentation about these parameters)
+    */
+   for (i=1; i<argc-1; i++)  /* remove first argument, it was for rtp */
+     argv[i]=argv[i+1];
+   lame_parse_args(&gf,argc-1, argv); 
+ 
+   /* open the output file.  Filename parsed into gf.inPath */
+   if (!strcmp(gf.outPath, "-")) {
+ #ifdef __EMX__
+     _fsetmode(stdout,"b");
+ #elif (defined  __BORLANDC__)
+     setmode(_fileno(stdout), O_BINARY);
+ #elif (defined  __CYGWIN__)
+     setmode(fileno(stdout), _O_BINARY);
+ #elif (defined _WIN32)
+     _setmode(_fileno(stdout), _O_BINARY);
+ #endif
+     outf = stdout;
+   } else {
+     if ((outf = fopen(gf.outPath, "wb")) == NULL) {
+       fprintf(stderr,"Could not create \"%s\".\n", gf.outPath);
+       exit(1);
+     }
+   }
+ 
+ 
+   /* open the wav/aiff/raw pcm or mp3 input file.  This call will
+    * open the file with name gf.inFile, try to parse the headers and
+    * set gf.samplerate, gf.num_channels, gf.num_samples.
+    * if you want to do your own file input, skip this call and set
+    * these values yourself.  
+    */
+   lame_init_infile(&gf);
+ 
+ 
+   /* Now that all the options are set, lame needs to analyze them and
+    * set some more options 
+    */
+   lame_init_params(&gf);
+   lame_print_config(&gf);   /* print usefull information about options being used */
+ 
+   /* encode until we hit eof */
+   do {
+     /* read in 'iread' samples */
+     iread=lame_readframe(&gf,Buffer);
+     /* encode the frame */
+     imp3=lame_encode_buffer(&gf,Buffer[0],Buffer[1],iread,
+ 			    mp3buffer,sizeof(mp3buffer));
+     fwrite(mp3buffer,1,imp3,outf);       /* write the MP3 output to file  */
+     rtp_output(mp3buffer,imp3);          /* write MP3 output to RTP port */    
+   } while (iread);
+   
+ 
+   imp3=lame_encode_finish(&gf,mp3buffer,sizeof(mp3buffer));   /* may return one or more mp3 frame */
+   fwrite(mp3buffer,1,imp3,outf);  
+   rtp_output(mp3buffer,imp3);
+   fclose(outf);
+   lame_close_infile(&gf);             /* close the sound input file */
+   lame_mp3_tags(&gf);                /* add id3 or VBR tags to mp3 file */
+   return 0;
+ }
+ 
diff -r -c -N encoder/mp3x.c lame3.70/mp3x.c
*** encoder/mp3x.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mp3x.c	Thu Mar 16 12:05:26 2000
***************
*** 0 ****
--- 1,39 ----
+ #include "lame.h"
+ 
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * main
+ *
+ * PURPOSE:  MPEG-1,2 Layer III encoder with GPSYCHO 
+ * psychoacoustic model.
+ *
+ ************************************************************************/
+ int main(int argc, char **argv)
+ {
+   char mp3buffer[LAME_MAXMP3BUFFER];
+   lame_global_flags gf;  
+ 
+   lame_init(&gf);
+   if(argc==1)  lame_usage(&gf,argv[0]);  /* no command-line args  */
+ 
+   lame_parse_args(&gf,argc, argv); 
+   gf.gtkflag=1;
+   lame_init_infile(&gf);
+   lame_init_params(&gf);
+   lame_print_config(&gf);
+ 
+ 
+   gtk_init (&argc, &argv);
+   gtkcontrol(&gf);
+ 
+   lame_encode_finish(&gf,mp3buffer,sizeof(mp3buffer));
+   lame_close_infile(&gf);
+   return 0;
+ }
+ 
diff -r -c -N encoder/mpglib/.cvsignore lame3.70/mpglib/.cvsignore
*** encoder/mpglib/.cvsignore	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/.cvsignore	Tue Nov 30 12:30:46 1999
***************
*** 0 ****
--- 1,9 ----
+ *.d
+ Debug
+ DebugGTK
+ Release
+ ReleaseGTK
+ *.ncb
+ *.plg
+ *.opt
+ *.dll
diff -r -c -N encoder/mpglib/CVS/Entries lame3.70/mpglib/CVS/Entries
*** encoder/mpglib/CVS/Entries	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/CVS/Entries	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,16 ----
+ /.cvsignore/1.1/Tue Nov 30 19:30:46 1999//Tlame3_70
+ /Makefile/1.1.1.1/Wed Nov 24 08:44:31 1999//Tlame3_70
+ /README/1.1.1.1/Wed Nov 24 08:44:33 1999//Tlame3_70
+ /TODO/1.1.1.1/Wed Nov 24 08:44:33 1999//Tlame3_70
+ /common.c/1.4/Thu Mar 23 22:12:26 2000//Tlame3_70
+ /dct64_i386.c/1.2/Mon Mar  6 19:53:03 2000//Tlame3_70
+ /decode_i386.c/1.2/Mon Mar  6 19:53:03 2000//Tlame3_70
+ /huffman.h/1.1.1.1/Wed Nov 24 08:44:45 1999//Tlame3_70
+ /interface.c/1.2/Mon Mar  6 19:53:03 2000//Tlame3_70
+ /layer3.c/1.13/Thu Apr  6 18:50:53 2000//Tlame3_70
+ /main.c/1.13/Fri Mar 17 00:05:38 2000//Tlame3_70
+ /mpg123.h/1.3/Sat Feb 19 13:33:12 2000//Tlame3_70
+ /mpglib.dsp/1.6/Fri Mar 17 00:05:38 2000//Tlame3_70
+ /mpglib.h/1.2/Wed Jan  5 17:40:35 2000//Tlame3_70
+ /tabinit.c/1.2/Mon Mar  6 19:53:03 2000//Tlame3_70
+ D
diff -r -c -N encoder/mpglib/CVS/Repository lame3.70/mpglib/CVS/Repository
*** encoder/mpglib/CVS/Repository	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/CVS/Repository	Thu Apr  6 12:50:37 2000
***************
*** 0 ****
--- 1 ----
+ lame/mpglib
diff -r -c -N encoder/mpglib/CVS/Root lame3.70/mpglib/CVS/Root
*** encoder/mpglib/CVS/Root	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/CVS/Root	Thu Apr  6 12:50:37 2000
***************
*** 0 ****
--- 1 ----
+ markt@cvs.lame.sourceforge.net:/cvsroot/lame
diff -r -c -N encoder/mpglib/CVS/Tag lame3.70/mpglib/CVS/Tag
*** encoder/mpglib/CVS/Tag	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/CVS/Tag	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1 ----
+ Tlame3_70
diff -r -c -N encoder/mpglib/Makefile lame3.70/mpglib/Makefile
*** encoder/mpglib/Makefile	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/Makefile	Wed Nov 24 01:44:31 1999
***************
*** 0 ****
--- 1,22 ----
+ 
+ CC=gcc
+ CFLAGS=-Wall -g
+ 
+ all: mpglib
+ 
+ 
+ *.o: mpg123.h mpglib.h
+ 
+ mpglib: common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	$(CC) -o mpglib common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o main.o -lm
+ 
+ lib:    common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	ar -svru libmpg123.a main.o common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o 
+ 
+ 
+ clean:
+ 	rm *.o mpglib
+ 
+ 
diff -r -c -N encoder/mpglib/README lame3.70/mpglib/README
*** encoder/mpglib/README	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/README	Wed Nov 24 01:44:33 1999
***************
*** 0 ****
--- 1,33 ----
+ MP3 library
+ -----------
+ Version 0.2
+ 
+ This decoder is a 'light' version (thrown out all unnecessay parts)
+ from the mpg123 package. I made this for a company.
+ 
+ Currently only Layer3 is enabled to save some space. Layer1,2 isn't
+ tested at all. The interface will not change significantly. 
+ A backport to the mpg123 package is planed.
+ 
+ comiled and tested only on Solaris 2.6
+ main.c contains a simple demo application for library.
+ 
+ COPYING: you may use this source under GPL terms!
+ 
+ PLEASE NOTE: This software may contain patented alogrithm (at least
+   patented in some countries). It may be not allowed to sell/use products
+   based on this source code in these countries. Check this out first!
+ 
+ COPYRIGHT of MP3 music:
+   Please note, that the duplicating of copyrighted music without explicit
+   permission violates the rights of the owner.
+ 
+ SENDING PATCHES:
+   Maybe I change the copyright policy (ie some kind of more free BSD licencse).
+   Please consider this when sending patches/changes.
+ 
+ FEEDBACK:
+   I'm interessted to here from you, when you use this package as part
+   of another project.
+ 
+ 
diff -r -c -N encoder/mpglib/TODO lame3.70/mpglib/TODO
*** encoder/mpglib/TODO	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/TODO	Wed Nov 24 01:44:33 1999
***************
*** 0 ****
--- 1,2 ----
+ 
+ apply 'VBR' bug 
diff -r -c -N encoder/mpglib/common.c lame3.70/mpglib/common.c
*** encoder/mpglib/common.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/common.c	Thu Mar 23 15:12:26 2000
***************
*** 0 ****
--- 1,265 ----
+ #ifdef HAVEMPGLIB
+ #include <ctype.h>
+ #include <stdlib.h>
+ #include <signal.h>
+ 
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <fcntl.h>
+ 
+ #include "mpg123.h"
+ 
+ struct parameter param = { 1 , 1 , 0 , 0 };
+ 
+ int tabsel_123[2][3][16] = {
+    { {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,},
+      {0,32,48,56, 64, 80, 96,112,128,160,192,224,256,320,384,},
+      {0,32,40,48, 56, 64, 80, 96,112,128,160,192,224,256,320,} },
+ 
+    { {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,} }
+ };
+ 
+ long freqs[9] = { 44100, 48000, 32000,
+                   22050, 24000, 16000 ,
+                   11025 , 12000 , 8000 };
+ 
+ int bitindex;
+ unsigned char *wordpointer;
+ unsigned char *pcm_sample;
+ int pcm_point = 0;
+ 
+ 
+ #if 0
+ static void get_II_stuff(struct frame *fr)
+ {
+   static int translate[3][2][16] = 
+    { { { 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 } ,
+        { 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 } } ,
+      { { 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 } ,
+        { 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 } } ,
+      { { 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 } ,
+        { 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 } } };
+ 
+   int table,sblim;
+   static struct al_table *tables[5] = 
+        { alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
+   static int sblims[5] = { 27 , 30 , 8, 12 , 30 };
+ 
+   if(fr->lsf)
+     table = 4;
+   else
+     table = translate[fr->sampling_frequency][2-fr->stereo][fr->bitrate_index];
+   sblim = sblims[table];
+ 
+   fr->alloc = tables[table];
+   fr->II_sblimit = sblim;
+ }
+ #endif
+ 
+ #define HDRCMPMASK 0xfffffd00
+ 
+ #if 0
+ int head_check(unsigned long head)
+ {
+     if( (head & 0xffe00000) != 0xffe00000)
+ 	return FALSE;
+     if(!((head>>17)&3))
+ 	return FALSE;
+     if( ((head>>12)&0xf) == 0xf)
+ 	return FALSE;
+     if( ((head>>10)&0x3) == 0x3 )
+ 	return FALSE;
+     return TRUE;
+ }
+ #endif
+ 
+ /*
+  * the code a header and write the information
+  * into the frame structure
+  */
+ int decode_header(struct frame *fr,unsigned long newhead)
+ {
+ 
+ 
+     if( newhead & (1<<20) ) {
+       fr->lsf = (newhead & (1<<19)) ? 0x0 : 0x1;
+       fr->mpeg25 = 0;
+     }
+     else {
+       fr->lsf = 1;
+       fr->mpeg25 = 1;
+     }
+ 
+     
+     fr->lay = 4-((newhead>>17)&3);
+     if( ((newhead>>10)&0x3) == 0x3) {
+       fprintf(stderr,"Stream error\n");
+       exit(1);
+     }
+     if(fr->mpeg25) {
+       fr->sampling_frequency = 6 + ((newhead>>10)&0x3);
+     }
+     else
+       fr->sampling_frequency = ((newhead>>10)&0x3) + (fr->lsf*3);
+     fr->error_protection = ((newhead>>16)&0x1)^0x1;
+ 
+     if(fr->mpeg25) /* allow Bitrate change for 2.5 ... */
+       fr->bitrate_index = ((newhead>>12)&0xf);
+ 
+     fr->bitrate_index = ((newhead>>12)&0xf);
+     fr->padding   = ((newhead>>9)&0x1);
+     fr->extension = ((newhead>>8)&0x1);
+     fr->mode      = ((newhead>>6)&0x3);
+     fr->mode_ext  = ((newhead>>4)&0x3);
+     fr->copyright = ((newhead>>3)&0x1);
+     fr->original  = ((newhead>>2)&0x1);
+     fr->emphasis  = newhead & 0x3;
+ 
+     fr->stereo    = (fr->mode == MPG_MD_MONO) ? 1 : 2;
+ 
+     if(!fr->bitrate_index)
+     {
+       fprintf(stderr,"Free format not supported.\n");
+       return (0);
+     }
+ 
+     switch(fr->lay)
+     {
+       case 1:
+ #if 0
+ 		fr->do_layer = do_layer1;
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ? 
+                          (fr->mode_ext<<2)+4 : 32;
+         fr->framesize  = (long) tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize  = ((fr->framesize+fr->padding)<<2)-4;
+ #else
+         fprintf(stderr,"layer=1 Not supported!\n");
+ #endif
+         break;
+       case 2:
+ #if 0
+ 		fr->do_layer = do_layer2;
+         get_II_stuff(fr);
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ?
+                          (fr->mode_ext<<2)+4 : fr->II_sblimit;
+         fr->framesize = (long) tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize += fr->padding - 4;
+ #else
+         fprintf(stderr,"layer=2 Not supported!\n");
+ #endif
+         break;
+       case 3:
+ #if 0
+         fr->do_layer = do_layer3;
+         if(fr->lsf)
+           ssize = (fr->stereo == 1) ? 9 : 17;
+         else
+           ssize = (fr->stereo == 1) ? 17 : 32;
+ #endif
+ 
+ #if 0
+         if(fr->error_protection)
+           ssize += 2;
+ #endif
+           fr->framesize  = (long) tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000;
+           fr->framesize /= freqs[fr->sampling_frequency]<<(fr->lsf);
+           fr->framesize = fr->framesize + fr->padding - 4;
+         break; 
+       default:
+         fprintf(stderr,"Sorry, unknown layer type.\n"); 
+         return (0);
+     }
+ 
+     /*    print_header(fr); */
+ 
+     return 1;
+ }
+ 
+ 
+ #if 1
+ void print_header(struct frame *fr)
+ {
+ 	static char *modes[4] = { "Stereo", "Joint-Stereo", "Dual-Channel", "Single-Channel" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+ 
+ 	fprintf(stderr,"MPEG %s, Layer: %s, Freq: %ld, mode: %s, modext: %d, BPF : %d\n", 
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],freqs[fr->sampling_frequency],
+ 		modes[fr->mode],fr->mode_ext,fr->framesize+4);
+ 	fprintf(stderr,"Channels: %d, copyright: %s, original: %s, CRC: %s, emphasis: %d.\n",
+ 		fr->stereo,fr->copyright?"Yes":"No",
+ 		fr->original?"Yes":"No",fr->error_protection?"Yes":"No",
+ 		fr->emphasis);
+ 	fprintf(stderr,"Bitrate: %d Kbits/s, Extension value: %d\n",
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],fr->extension);
+ }
+ 
+ void print_header_compact(struct frame *fr)
+ {
+ 	static char *modes[4] = { "stereo", "joint-stereo", "dual-channel", "mono" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+  
+ 	fprintf(stderr,"MPEG %s layer %s, %d kbit/s, %ld Hz %s\n",
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],
+ 		freqs[fr->sampling_frequency], modes[fr->mode]);
+ }
+ 
+ #endif
+ 
+ unsigned int getbits(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   if(!number_of_bits)
+     return 0;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;
+     rval |= wordpointer[1];
+     rval <<= 8;
+     rval |= wordpointer[2];
+     rval <<= bitindex;
+     rval &= 0xffffff;
+ 
+     bitindex += number_of_bits;
+ 
+     rval >>= (24-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ unsigned int getbits_fast(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;	
+     rval |= wordpointer[1];
+     rval <<= bitindex;
+     rval &= 0xffff;
+     bitindex += number_of_bits;
+ 
+     rval >>= (16-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/dct64_i386.c lame3.70/mpglib/dct64_i386.c
*** encoder/mpglib/dct64_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/dct64_i386.c	Mon Mar  6 12:53:03 2000
***************
*** 0 ****
--- 1,317 ----
+ #ifdef HAVEMPGLIB
+ /*
+  * Discrete Cosine Tansform (DCT) for subband synthesis
+  * optimized for machines with no auto-increment. 
+  * The performance is highly compiler dependend. Maybe
+  * the dct64.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include "mpg123.h"
+ 
+ static void dct64_1(real *out0,real *out1,real *b1,real *b2,real *samples)
+ {
+ 
+  {
+   register real *costab = pnts[0];
+ 
+   b1[0x00] = samples[0x00] + samples[0x1F];
+   b1[0x1F] = (samples[0x00] - samples[0x1F]) * costab[0x0];
+ 
+   b1[0x01] = samples[0x01] + samples[0x1E];
+   b1[0x1E] = (samples[0x01] - samples[0x1E]) * costab[0x1];
+ 
+   b1[0x02] = samples[0x02] + samples[0x1D];
+   b1[0x1D] = (samples[0x02] - samples[0x1D]) * costab[0x2];
+ 
+   b1[0x03] = samples[0x03] + samples[0x1C];
+   b1[0x1C] = (samples[0x03] - samples[0x1C]) * costab[0x3];
+ 
+   b1[0x04] = samples[0x04] + samples[0x1B];
+   b1[0x1B] = (samples[0x04] - samples[0x1B]) * costab[0x4];
+ 
+   b1[0x05] = samples[0x05] + samples[0x1A];
+   b1[0x1A] = (samples[0x05] - samples[0x1A]) * costab[0x5];
+ 
+   b1[0x06] = samples[0x06] + samples[0x19];
+   b1[0x19] = (samples[0x06] - samples[0x19]) * costab[0x6];
+ 
+   b1[0x07] = samples[0x07] + samples[0x18];
+   b1[0x18] = (samples[0x07] - samples[0x18]) * costab[0x7];
+ 
+   b1[0x08] = samples[0x08] + samples[0x17];
+   b1[0x17] = (samples[0x08] - samples[0x17]) * costab[0x8];
+ 
+   b1[0x09] = samples[0x09] + samples[0x16];
+   b1[0x16] = (samples[0x09] - samples[0x16]) * costab[0x9];
+ 
+   b1[0x0A] = samples[0x0A] + samples[0x15];
+   b1[0x15] = (samples[0x0A] - samples[0x15]) * costab[0xA];
+ 
+   b1[0x0B] = samples[0x0B] + samples[0x14];
+   b1[0x14] = (samples[0x0B] - samples[0x14]) * costab[0xB];
+ 
+   b1[0x0C] = samples[0x0C] + samples[0x13];
+   b1[0x13] = (samples[0x0C] - samples[0x13]) * costab[0xC];
+ 
+   b1[0x0D] = samples[0x0D] + samples[0x12];
+   b1[0x12] = (samples[0x0D] - samples[0x12]) * costab[0xD];
+ 
+   b1[0x0E] = samples[0x0E] + samples[0x11];
+   b1[0x11] = (samples[0x0E] - samples[0x11]) * costab[0xE];
+ 
+   b1[0x0F] = samples[0x0F] + samples[0x10];
+   b1[0x10] = (samples[0x0F] - samples[0x10]) * costab[0xF];
+  }
+ 
+ 
+  {
+   register real *costab = pnts[1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x0F]; 
+   b2[0x0F] = (b1[0x00] - b1[0x0F]) * costab[0];
+   b2[0x01] = b1[0x01] + b1[0x0E]; 
+   b2[0x0E] = (b1[0x01] - b1[0x0E]) * costab[1];
+   b2[0x02] = b1[0x02] + b1[0x0D]; 
+   b2[0x0D] = (b1[0x02] - b1[0x0D]) * costab[2];
+   b2[0x03] = b1[0x03] + b1[0x0C]; 
+   b2[0x0C] = (b1[0x03] - b1[0x0C]) * costab[3];
+   b2[0x04] = b1[0x04] + b1[0x0B]; 
+   b2[0x0B] = (b1[0x04] - b1[0x0B]) * costab[4];
+   b2[0x05] = b1[0x05] + b1[0x0A]; 
+   b2[0x0A] = (b1[0x05] - b1[0x0A]) * costab[5];
+   b2[0x06] = b1[0x06] + b1[0x09]; 
+   b2[0x09] = (b1[0x06] - b1[0x09]) * costab[6];
+   b2[0x07] = b1[0x07] + b1[0x08]; 
+   b2[0x08] = (b1[0x07] - b1[0x08]) * costab[7];
+ 
+   b2[0x10] = b1[0x10] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x10]) * costab[0];
+   b2[0x11] = b1[0x11] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x11]) * costab[1];
+   b2[0x12] = b1[0x12] + b1[0x1D];
+   b2[0x1D] = (b1[0x1D] - b1[0x12]) * costab[2];
+   b2[0x13] = b1[0x13] + b1[0x1C];
+   b2[0x1C] = (b1[0x1C] - b1[0x13]) * costab[3];
+   b2[0x14] = b1[0x14] + b1[0x1B];
+   b2[0x1B] = (b1[0x1B] - b1[0x14]) * costab[4];
+   b2[0x15] = b1[0x15] + b1[0x1A];
+   b2[0x1A] = (b1[0x1A] - b1[0x15]) * costab[5];
+   b2[0x16] = b1[0x16] + b1[0x19];
+   b2[0x19] = (b1[0x19] - b1[0x16]) * costab[6];
+   b2[0x17] = b1[0x17] + b1[0x18];
+   b2[0x18] = (b1[0x18] - b1[0x17]) * costab[7];
+  }
+ 
+  {
+   register real *costab = pnts[2];
+ 
+   b1[0x00] = b2[0x00] + b2[0x07];
+   b1[0x07] = (b2[0x00] - b2[0x07]) * costab[0];
+   b1[0x01] = b2[0x01] + b2[0x06];
+   b1[0x06] = (b2[0x01] - b2[0x06]) * costab[1];
+   b1[0x02] = b2[0x02] + b2[0x05];
+   b1[0x05] = (b2[0x02] - b2[0x05]) * costab[2];
+   b1[0x03] = b2[0x03] + b2[0x04];
+   b1[0x04] = (b2[0x03] - b2[0x04]) * costab[3];
+ 
+   b1[0x08] = b2[0x08] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x08]) * costab[0];
+   b1[0x09] = b2[0x09] + b2[0x0E];
+   b1[0x0E] = (b2[0x0E] - b2[0x09]) * costab[1];
+   b1[0x0A] = b2[0x0A] + b2[0x0D];
+   b1[0x0D] = (b2[0x0D] - b2[0x0A]) * costab[2];
+   b1[0x0B] = b2[0x0B] + b2[0x0C];
+   b1[0x0C] = (b2[0x0C] - b2[0x0B]) * costab[3];
+ 
+   b1[0x10] = b2[0x10] + b2[0x17];
+   b1[0x17] = (b2[0x10] - b2[0x17]) * costab[0];
+   b1[0x11] = b2[0x11] + b2[0x16];
+   b1[0x16] = (b2[0x11] - b2[0x16]) * costab[1];
+   b1[0x12] = b2[0x12] + b2[0x15];
+   b1[0x15] = (b2[0x12] - b2[0x15]) * costab[2];
+   b1[0x13] = b2[0x13] + b2[0x14];
+   b1[0x14] = (b2[0x13] - b2[0x14]) * costab[3];
+ 
+   b1[0x18] = b2[0x18] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x18]) * costab[0];
+   b1[0x19] = b2[0x19] + b2[0x1E];
+   b1[0x1E] = (b2[0x1E] - b2[0x19]) * costab[1];
+   b1[0x1A] = b2[0x1A] + b2[0x1D];
+   b1[0x1D] = (b2[0x1D] - b2[0x1A]) * costab[2];
+   b1[0x1B] = b2[0x1B] + b2[0x1C];
+   b1[0x1C] = (b2[0x1C] - b2[0x1B]) * costab[3];
+  }
+ 
+  {
+   register real const cos0 = pnts[3][0];
+   register real const cos1 = pnts[3][1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x03];
+   b2[0x03] = (b1[0x00] - b1[0x03]) * cos0;
+   b2[0x01] = b1[0x01] + b1[0x02];
+   b2[0x02] = (b1[0x01] - b1[0x02]) * cos1;
+ 
+   b2[0x04] = b1[0x04] + b1[0x07];
+   b2[0x07] = (b1[0x07] - b1[0x04]) * cos0;
+   b2[0x05] = b1[0x05] + b1[0x06];
+   b2[0x06] = (b1[0x06] - b1[0x05]) * cos1;
+ 
+   b2[0x08] = b1[0x08] + b1[0x0B];
+   b2[0x0B] = (b1[0x08] - b1[0x0B]) * cos0;
+   b2[0x09] = b1[0x09] + b1[0x0A];
+   b2[0x0A] = (b1[0x09] - b1[0x0A]) * cos1;
+   
+   b2[0x0C] = b1[0x0C] + b1[0x0F];
+   b2[0x0F] = (b1[0x0F] - b1[0x0C]) * cos0;
+   b2[0x0D] = b1[0x0D] + b1[0x0E];
+   b2[0x0E] = (b1[0x0E] - b1[0x0D]) * cos1;
+ 
+   b2[0x10] = b1[0x10] + b1[0x13];
+   b2[0x13] = (b1[0x10] - b1[0x13]) * cos0;
+   b2[0x11] = b1[0x11] + b1[0x12];
+   b2[0x12] = (b1[0x11] - b1[0x12]) * cos1;
+ 
+   b2[0x14] = b1[0x14] + b1[0x17];
+   b2[0x17] = (b1[0x17] - b1[0x14]) * cos0;
+   b2[0x15] = b1[0x15] + b1[0x16];
+   b2[0x16] = (b1[0x16] - b1[0x15]) * cos1;
+ 
+   b2[0x18] = b1[0x18] + b1[0x1B];
+   b2[0x1B] = (b1[0x18] - b1[0x1B]) * cos0;
+   b2[0x19] = b1[0x19] + b1[0x1A];
+   b2[0x1A] = (b1[0x19] - b1[0x1A]) * cos1;
+ 
+   b2[0x1C] = b1[0x1C] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x1C]) * cos0;
+   b2[0x1D] = b1[0x1D] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x1D]) * cos1;
+  }
+ 
+  {
+   register real const cos0 = pnts[4][0];
+ 
+   b1[0x00] = b2[0x00] + b2[0x01];
+   b1[0x01] = (b2[0x00] - b2[0x01]) * cos0;
+   b1[0x02] = b2[0x02] + b2[0x03];
+   b1[0x03] = (b2[0x03] - b2[0x02]) * cos0;
+   b1[0x02] += b1[0x03];
+ 
+   b1[0x04] = b2[0x04] + b2[0x05];
+   b1[0x05] = (b2[0x04] - b2[0x05]) * cos0;
+   b1[0x06] = b2[0x06] + b2[0x07];
+   b1[0x07] = (b2[0x07] - b2[0x06]) * cos0;
+   b1[0x06] += b1[0x07];
+   b1[0x04] += b1[0x06];
+   b1[0x06] += b1[0x05];
+   b1[0x05] += b1[0x07];
+ 
+   b1[0x08] = b2[0x08] + b2[0x09];
+   b1[0x09] = (b2[0x08] - b2[0x09]) * cos0;
+   b1[0x0A] = b2[0x0A] + b2[0x0B];
+   b1[0x0B] = (b2[0x0B] - b2[0x0A]) * cos0;
+   b1[0x0A] += b1[0x0B];
+ 
+   b1[0x0C] = b2[0x0C] + b2[0x0D];
+   b1[0x0D] = (b2[0x0C] - b2[0x0D]) * cos0;
+   b1[0x0E] = b2[0x0E] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x0E]) * cos0;
+   b1[0x0E] += b1[0x0F];
+   b1[0x0C] += b1[0x0E];
+   b1[0x0E] += b1[0x0D];
+   b1[0x0D] += b1[0x0F];
+ 
+   b1[0x10] = b2[0x10] + b2[0x11];
+   b1[0x11] = (b2[0x10] - b2[0x11]) * cos0;
+   b1[0x12] = b2[0x12] + b2[0x13];
+   b1[0x13] = (b2[0x13] - b2[0x12]) * cos0;
+   b1[0x12] += b1[0x13];
+ 
+   b1[0x14] = b2[0x14] + b2[0x15];
+   b1[0x15] = (b2[0x14] - b2[0x15]) * cos0;
+   b1[0x16] = b2[0x16] + b2[0x17];
+   b1[0x17] = (b2[0x17] - b2[0x16]) * cos0;
+   b1[0x16] += b1[0x17];
+   b1[0x14] += b1[0x16];
+   b1[0x16] += b1[0x15];
+   b1[0x15] += b1[0x17];
+ 
+   b1[0x18] = b2[0x18] + b2[0x19];
+   b1[0x19] = (b2[0x18] - b2[0x19]) * cos0;
+   b1[0x1A] = b2[0x1A] + b2[0x1B];
+   b1[0x1B] = (b2[0x1B] - b2[0x1A]) * cos0;
+   b1[0x1A] += b1[0x1B];
+ 
+   b1[0x1C] = b2[0x1C] + b2[0x1D];
+   b1[0x1D] = (b2[0x1C] - b2[0x1D]) * cos0;
+   b1[0x1E] = b2[0x1E] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x1E]) * cos0;
+   b1[0x1E] += b1[0x1F];
+   b1[0x1C] += b1[0x1E];
+   b1[0x1E] += b1[0x1D];
+   b1[0x1D] += b1[0x1F];
+  }
+ 
+  out0[0x10*16] = b1[0x00];
+  out0[0x10*12] = b1[0x04];
+  out0[0x10* 8] = b1[0x02];
+  out0[0x10* 4] = b1[0x06];
+  out0[0x10* 0] = b1[0x01];
+  out1[0x10* 0] = b1[0x01];
+  out1[0x10* 4] = b1[0x05];
+  out1[0x10* 8] = b1[0x03];
+  out1[0x10*12] = b1[0x07];
+ 
+  b1[0x08] += b1[0x0C];
+  out0[0x10*14] = b1[0x08];
+  b1[0x0C] += b1[0x0a];
+  out0[0x10*10] = b1[0x0C];
+  b1[0x0A] += b1[0x0E];
+  out0[0x10* 6] = b1[0x0A];
+  b1[0x0E] += b1[0x09];
+  out0[0x10* 2] = b1[0x0E];
+  b1[0x09] += b1[0x0D];
+  out1[0x10* 2] = b1[0x09];
+  b1[0x0D] += b1[0x0B];
+  out1[0x10* 6] = b1[0x0D];
+  b1[0x0B] += b1[0x0F];
+  out1[0x10*10] = b1[0x0B];
+  out1[0x10*14] = b1[0x0F];
+ 
+  b1[0x18] += b1[0x1C];
+  out0[0x10*15] = b1[0x10] + b1[0x18];
+  out0[0x10*13] = b1[0x18] + b1[0x14];
+  b1[0x1C] += b1[0x1a];
+  out0[0x10*11] = b1[0x14] + b1[0x1C];
+  out0[0x10* 9] = b1[0x1C] + b1[0x12];
+  b1[0x1A] += b1[0x1E];
+  out0[0x10* 7] = b1[0x12] + b1[0x1A];
+  out0[0x10* 5] = b1[0x1A] + b1[0x16];
+  b1[0x1E] += b1[0x19];
+  out0[0x10* 3] = b1[0x16] + b1[0x1E];
+  out0[0x10* 1] = b1[0x1E] + b1[0x11];
+  b1[0x19] += b1[0x1D];
+  out1[0x10* 1] = b1[0x11] + b1[0x19];
+  out1[0x10* 3] = b1[0x19] + b1[0x15];
+  b1[0x1D] += b1[0x1B];
+  out1[0x10* 5] = b1[0x15] + b1[0x1D];
+  out1[0x10* 7] = b1[0x1D] + b1[0x13];
+  b1[0x1B] += b1[0x1F];
+  out1[0x10* 9] = b1[0x13] + b1[0x1B];
+  out1[0x10*11] = b1[0x1B] + b1[0x17];
+  out1[0x10*13] = b1[0x17] + b1[0x1F];
+  out1[0x10*15] = b1[0x1F];
+ }
+ 
+ /*
+  * the call via dct64 is a trick to force GCC to use
+  * (new) registers for the b1,b2 pointer to the bufs[xx] field
+  */
+ void dct64(real *a,real *b,real *c)
+ {
+   real bufs[0x40];
+   dct64_1(a,b,bufs,bufs+0x20,c);
+ }
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/decode_i386.c lame3.70/mpglib/decode_i386.c
*** encoder/mpglib/decode_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/decode_i386.c	Mon Mar  6 12:53:03 2000
***************
*** 0 ****
--- 1,156 ----
+ #ifdef HAVEMPGLIB
+ /* 
+  * Mpeg Layer-1,2,3 audio decoder 
+  * ------------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+  * See also 'README'
+  *
+  * slighlty optimized for machines without autoincrement/decrement.
+  * The performance is highly compiler dependend. Maybe
+  * the decode.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include <stdlib.h>
+ #include <math.h>
+ #include <string.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ extern struct mpstr *gmp;
+ 
+  /* old WRITE_SAMPLE */
+ #define WRITE_SAMPLE(samples,sum,clip) \
+   if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+   else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+   else { *(samples) = sum; }
+ 
+ int synth_1to1_mono(real *bandPtr,unsigned char *samples,int *pnt)
+ {
+   short samples_tmp[64];
+   short *tmp1 = samples_tmp;
+   int i,ret;
+   int pnt1 = 0;
+ 
+   ret = synth_1to1(bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+   samples += *pnt;
+ 
+   for(i=0;i<32;i++) {
+     *( (short *) samples) = *tmp1;
+     samples += 2;
+     tmp1 += 2;
+   }
+   *pnt += 64;
+ 
+   return ret;
+ }
+ 
+ 
+ int synth_1to1(real *bandPtr,int channel,unsigned char *out,int *pnt)
+ {
+   static const int step = 2;
+   int bo;
+   short *samples = (short *) (out + *pnt);
+ 
+   real *b0,(*buf)[0x110];
+   int clip = 0; 
+   int bo1;
+ 
+   bo = gmp->synth_bo;
+ 
+   if(!channel) {
+     bo--;
+     bo &= 0xf;
+     buf = gmp->synth_buffs[0];
+   }
+   else {
+     samples++;
+     buf = gmp->synth_buffs[1];
+   }
+ 
+   if(bo & 0x1) {
+     b0 = buf[0];
+     bo1 = bo;
+     dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+   }
+   else {
+     b0 = buf[1];
+     bo1 = bo+1;
+     dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+   }
+ 
+   gmp->synth_bo = bo;
+   
+   {
+     register int j;
+     real *window = decwin + 16 - bo1;
+ 
+     for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum -= window[0x1] * b0[0x1];
+       sum += window[0x2] * b0[0x2];
+       sum -= window[0x3] * b0[0x3];
+       sum += window[0x4] * b0[0x4];
+       sum -= window[0x5] * b0[0x5];
+       sum += window[0x6] * b0[0x6];
+       sum -= window[0x7] * b0[0x7];
+       sum += window[0x8] * b0[0x8];
+       sum -= window[0x9] * b0[0x9];
+       sum += window[0xA] * b0[0xA];
+       sum -= window[0xB] * b0[0xB];
+       sum += window[0xC] * b0[0xC];
+       sum -= window[0xD] * b0[0xD];
+       sum += window[0xE] * b0[0xE];
+       sum -= window[0xF] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+ 
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum += window[0x2] * b0[0x2];
+       sum += window[0x4] * b0[0x4];
+       sum += window[0x6] * b0[0x6];
+       sum += window[0x8] * b0[0x8];
+       sum += window[0xA] * b0[0xA];
+       sum += window[0xC] * b0[0xC];
+       sum += window[0xE] * b0[0xE];
+       WRITE_SAMPLE(samples,sum,clip);
+       b0-=0x10,window-=0x20,samples+=step;
+     }
+     window += bo1<<1;
+ 
+     for (j=15;j;j--,b0-=0x10,window-=0x20,samples+=step)
+     {
+       real sum;
+       sum = -window[-0x1] * b0[0x0];
+       sum -= window[-0x2] * b0[0x1];
+       sum -= window[-0x3] * b0[0x2];
+       sum -= window[-0x4] * b0[0x3];
+       sum -= window[-0x5] * b0[0x4];
+       sum -= window[-0x6] * b0[0x5];
+       sum -= window[-0x7] * b0[0x6];
+       sum -= window[-0x8] * b0[0x7];
+       sum -= window[-0x9] * b0[0x8];
+       sum -= window[-0xA] * b0[0x9];
+       sum -= window[-0xB] * b0[0xA];
+       sum -= window[-0xC] * b0[0xB];
+       sum -= window[-0xD] * b0[0xC];
+       sum -= window[-0xE] * b0[0xD];
+       sum -= window[-0xF] * b0[0xE];
+       sum -= window[-0x0] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+   }
+   *pnt += 128;
+ 
+   return clip;
+ }
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/huffman.h lame3.70/mpglib/huffman.h
*** encoder/mpglib/huffman.h	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/huffman.h	Wed Nov 24 01:44:45 1999
***************
*** 0 ****
--- 1,332 ----
+ /*
+  * huffman tables ... recalcualted to work with my optimzed
+  * decoder scheme (MH)
+  * 
+  * probably we could save a few bytes of memory, because the 
+  * smaller tables are often the part of a bigger table
+  */
+ 
+ struct newhuff 
+ {
+   unsigned int linbits;
+   short *table;
+ };
+ 
+ static short tab0[] = 
+ { 
+    0
+ };
+ 
+ static short tab1[] =
+ {
+   -5,  -3,  -1,  17,   1,  16,   0
+ };
+ 
+ static short tab2[] =
+ {
+  -15, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  17,  -1,   1,
+   16,   0
+ };
+ 
+ static short tab3[] =
+ {
+  -13, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  16,  17,  -1,
+    1,   0
+ };
+ 
+ static short tab5[] =
+ {
+  -29, -25, -23, -15,  -7,  -5,  -3,  -1,  51,  35,  50,  49,  -3,  -1,  19,
+    3,  -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab6[] =
+ {
+  -25, -19, -13,  -9,  -5,  -3,  -1,  51,   3,  35,  -1,  50,  48,  -1,  19,
+   49,  -3,  -1,  34,   2,  18,  -3,  -1,  33,  32,   1,  -1,  17,  -1,  16,
+    0
+ };
+ 
+ static short tab7[] =
+ {
+  -69, -65, -57, -39, -29, -17, -11,  -7,  -3,  -1,  85,  69,  -1,  84,  83,
+   -1,  53,  68,  -3,  -1,  37,  82,  21,  -5,  -1,  81,  -1,   5,  52,  -1,
+   80,  -1,  67,  51,  -5,  -3,  -1,  36,  66,  20,  -1,  65,  64, -11,  -7,
+   -3,  -1,   4,  35,  -1,  50,   3,  -1,  19,  49,  -3,  -1,  48,  34,  18,
+   -5,  -1,  33,  -1,   2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab8[] =
+ {
+  -65, -63, -59, -45, -31, -19, -13,  -7,  -5,  -3,  -1,  85,  84,  69,  83,
+   -3,  -1,  53,  68,  37,  -3,  -1,  82,   5,  21,  -5,  -1,  81,  -1,  52,
+   67,  -3,  -1,  80,  51,  36,  -5,  -3,  -1,  66,  20,  65,  -3,  -1,   4,
+   64,  -1,  35,  50,  -9,  -7,  -3,  -1,  19,  49,  -1,   3,  48,  34,  -1,
+    2,  32,  -1,  18,  33,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab9[] =
+ {
+  -63, -53, -41, -29, -19, -11,  -5,  -3,  -1,  85,  69,  53,  -1,  83,  -1,
+   84,   5,  -3,  -1,  68,  37,  -1,  82,  21,  -3,  -1,  81,  52,  -1,  67,
+   -1,  80,   4,  -7,  -3,  -1,  36,  66,  -1,  51,  64,  -1,  20,  65,  -5,
+   -3,  -1,  35,  50,  19,  -1,  49,  -1,   3,  48,  -5,  -3,  -1,  34,   2,
+   18,  -1,  33,  32,  -3,  -1,  17,   1,  -1,  16,   0
+ };
+ 
+ static short tab10[] =
+ {
+ -125,-121,-111, -83, -55, -35, -21, -13,  -7,  -3,  -1, 119, 103,  -1, 118,
+   87,  -3,  -1, 117, 102,  71,  -3,  -1, 116,  86,  -1, 101,  55,  -9,  -3,
+   -1, 115,  70,  -3,  -1,  85,  84,  99,  -1,  39, 114, -11,  -5,  -3,  -1,
+  100,   7, 112,  -1,  98,  -1,  69,  53,  -5,  -1,   6,  -1,  83,  68,  23,
+  -17,  -5,  -1, 113,  -1,  54,  38,  -5,  -3,  -1,  37,  82,  21,  -1,  81,
+   -1,  52,  67,  -3,  -1,  22,  97,  -1,  96,  -1,   5,  80, -19, -11,  -7,
+   -3,  -1,  36,  66,  -1,  51,   4,  -1,  20,  65,  -3,  -1,  64,  35,  -1,
+   50,   3,  -3,  -1,  19,  49,  -1,  48,  34,  -7,  -3,  -1,  18,  33,  -1,
+    2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab11[] =
+ {
+ -121,-113, -89, -59, -43, -27, -17,  -7,  -3,  -1, 119, 103,  -1, 118, 117,
+   -3,  -1, 102,  71,  -1, 116,  -1,  87,  85,  -5,  -3,  -1,  86, 101,  55,
+   -1, 115,  70,  -9,  -7,  -3,  -1,  69,  84,  -1,  53,  83,  39,  -1, 114,
+   -1, 100,   7,  -5,  -1, 113,  -1,  23, 112,  -3,  -1,  54,  99,  -1,  96,
+   -1,  68,  37, -13,  -7,  -5,  -3,  -1,  82,   5,  21,  98,  -3,  -1,  38,
+    6,  22,  -5,  -1,  97,  -1,  81,  52,  -5,  -1,  80,  -1,  67,  51,  -1,
+   36,  66, -15, -11,  -7,  -3,  -1,  20,  65,  -1,   4,  64,  -1,  35,  50,
+   -1,  19,  49,  -5,  -3,  -1,   3,  48,  34,  33,  -5,  -1,  18,  -1,   2,
+   32,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab12[] =
+ {
+ -115, -99, -73, -45, -27, -17,  -9,  -5,  -3,  -1, 119, 103, 118,  -1,  87,
+  117,  -3,  -1, 102,  71,  -1, 116, 101,  -3,  -1,  86,  55,  -3,  -1, 115,
+   85,  39,  -7,  -3,  -1, 114,  70,  -1, 100,  23,  -5,  -1, 113,  -1,   7,
+  112,  -1,  54,  99, -13,  -9,  -3,  -1,  69,  84,  -1,  68,  -1,   6,   5,
+   -1,  38,  98,  -5,  -1,  97,  -1,  22,  96,  -3,  -1,  53,  83,  -1,  37,
+   82, -17,  -7,  -3,  -1,  21,  81,  -1,  52,  67,  -5,  -3,  -1,  80,   4,
+   36,  -1,  66,  20,  -3,  -1,  51,  65,  -1,  35,  50, -11,  -7,  -5,  -3,
+   -1,  64,   3,  48,  19,  -1,  49,  34,  -1,  18,  33,  -7,  -5,  -3,  -1,
+    2,  32,   0,  17,  -1,   1,  16
+ };
+ 
+ static short tab13[] =
+ {
+ -509,-503,-475,-405,-333,-265,-205,-153,-115, -83, -53, -35, -21, -13,  -9,
+   -7,  -5,  -3,  -1, 254, 252, 253, 237, 255,  -1, 239, 223,  -3,  -1, 238,
+  207,  -1, 222, 191,  -9,  -3,  -1, 251, 206,  -1, 220,  -1, 175, 233,  -1,
+  236, 221,  -9,  -5,  -3,  -1, 250, 205, 190,  -1, 235, 159,  -3,  -1, 249,
+  234,  -1, 189, 219, -17,  -9,  -3,  -1, 143, 248,  -1, 204,  -1, 174, 158,
+   -5,  -1, 142,  -1, 127, 126, 247,  -5,  -1, 218,  -1, 173, 188,  -3,  -1,
+  203, 246, 111, -15,  -7,  -3,  -1, 232,  95,  -1, 157, 217,  -3,  -1, 245,
+  231,  -1, 172, 187,  -9,  -3,  -1,  79, 244,  -3,  -1, 202, 230, 243,  -1,
+   63,  -1, 141, 216, -21,  -9,  -3,  -1,  47, 242,  -3,  -1, 110, 156,  15,
+   -5,  -3,  -1, 201,  94, 171,  -3,  -1, 125, 215,  78, -11,  -5,  -3,  -1,
+  200, 214,  62,  -1, 185,  -1, 155, 170,  -1,  31, 241, -23, -13,  -5,  -1,
+  240,  -1, 186, 229,  -3,  -1, 228, 140,  -1, 109, 227,  -5,  -1, 226,  -1,
+   46,  14,  -1,  30, 225, -15,  -7,  -3,  -1, 224,  93,  -1, 213, 124,  -3,
+   -1, 199,  77,  -1, 139, 184,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -1,
+  198,  61, -37, -21,  -9,  -5,  -3,  -1, 211, 123,  45,  -1, 210,  29,  -5,
+   -1, 183,  -1,  92, 197,  -3,  -1, 153, 122, 195,  -7,  -5,  -3,  -1, 167,
+  151,  75, 209,  -3,  -1,  13, 208,  -1, 138, 168, -11,  -7,  -3,  -1,  76,
+  196,  -1, 107, 182,  -1,  60,  44,  -3,  -1, 194,  91,  -3,  -1, 181, 137,
+   28, -43, -23, -11,  -5,  -1, 193,  -1, 152,  12,  -1, 192,  -1, 180, 106,
+   -5,  -3,  -1, 166, 121,  59,  -1, 179,  -1, 136,  90, -11,  -5,  -1,  43,
+   -1, 165, 105,  -1, 164,  -1, 120, 135,  -5,  -1, 148,  -1, 119, 118, 178,
+  -11,  -3,  -1,  27, 177,  -3,  -1,  11, 176,  -1, 150,  74,  -7,  -3,  -1,
+   58, 163,  -1,  89, 149,  -1,  42, 162, -47, -23,  -9,  -3,  -1,  26, 161,
+   -3,  -1,  10, 104, 160,  -5,  -3,  -1, 134,  73, 147,  -3,  -1,  57,  88,
+   -1, 133, 103,  -9,  -3,  -1,  41, 146,  -3,  -1,  87, 117,  56,  -5,  -1,
+  131,  -1, 102,  71,  -3,  -1, 116,  86,  -1, 101, 115, -11,  -3,  -1,  25,
+  145,  -3,  -1,   9, 144,  -1,  72, 132,  -7,  -5,  -1, 114,  -1,  70, 100,
+   40,  -1, 130,  24, -41, -27, -11,  -5,  -3,  -1,  55,  39,  23,  -1, 113,
+   -1,  85,   7,  -7,  -3,  -1, 112,  54,  -1,  99,  69,  -3,  -1,  84,  38,
+   -1,  98,  53,  -5,  -1, 129,  -1,   8, 128,  -3,  -1,  22,  97,  -1,   6,
+   96, -13,  -9,  -5,  -3,  -1,  83,  68,  37,  -1,  82,   5,  -1,  21,  81,
+   -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20, -19, -11,
+   -5,  -1,  65,  -1,   4,  64,  -3,  -1,  35,  50,  19,  -3,  -1,  49,   3,
+   -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab15[] =
+ {
+ -495,-445,-355,-263,-183,-115, -77, -43, -27, -13,  -7,  -3,  -1, 255, 239,
+   -1, 254, 223,  -1, 238,  -1, 253, 207,  -7,  -3,  -1, 252, 222,  -1, 237,
+  191,  -1, 251,  -1, 206, 236,  -7,  -3,  -1, 221, 175,  -1, 250, 190,  -3,
+   -1, 235, 205,  -1, 220, 159, -15,  -7,  -3,  -1, 249, 234,  -1, 189, 219,
+   -3,  -1, 143, 248,  -1, 204, 158,  -7,  -3,  -1, 233, 127,  -1, 247, 173,
+   -3,  -1, 218, 188,  -1, 111,  -1, 174,  15, -19, -11,  -3,  -1, 203, 246,
+   -3,  -1, 142, 232,  -1,  95, 157,  -3,  -1, 245, 126,  -1, 231, 172,  -9,
+   -3,  -1, 202, 187,  -3,  -1, 217, 141,  79,  -3,  -1, 244,  63,  -1, 243,
+  216, -33, -17,  -9,  -3,  -1, 230,  47,  -1, 242,  -1, 110, 240,  -3,  -1,
+   31, 241,  -1, 156, 201,  -7,  -3,  -1,  94, 171,  -1, 186, 229,  -3,  -1,
+  125, 215,  -1,  78, 228, -15,  -7,  -3,  -1, 140, 200,  -1,  62, 109,  -3,
+   -1, 214, 227,  -1, 155, 185,  -7,  -3,  -1,  46, 170,  -1, 226,  30,  -5,
+   -1, 225,  -1,  14, 224,  -1,  93, 213, -45, -25, -13,  -7,  -3,  -1, 124,
+  199,  -1,  77, 139,  -1, 212,  -1, 184, 154,  -7,  -3,  -1, 169, 108,  -1,
+  198,  61,  -1, 211, 210,  -9,  -5,  -3,  -1,  45,  13,  29,  -1, 123, 183,
+   -5,  -1, 209,  -1,  92, 208,  -1, 197, 138, -17,  -7,  -3,  -1, 168,  76,
+   -1, 196, 107,  -5,  -1, 182,  -1, 153,  12,  -1,  60, 195,  -9,  -3,  -1,
+  122, 167,  -1, 166,  -1, 192,  11,  -1, 194,  -1,  44,  91, -55, -29, -15,
+   -7,  -3,  -1, 181,  28,  -1, 137, 152,  -3,  -1, 193,  75,  -1, 180, 106,
+   -5,  -3,  -1,  59, 121, 179,  -3,  -1, 151, 136,  -1,  43,  90, -11,  -5,
+   -1, 178,  -1, 165,  27,  -1, 177,  -1, 176, 105,  -7,  -3,  -1, 150,  74,
+   -1, 164, 120,  -3,  -1, 135,  58, 163, -17,  -7,  -3,  -1,  89, 149,  -1,
+   42, 162,  -3,  -1,  26, 161,  -3,  -1,  10, 160, 104,  -7,  -3,  -1, 134,
+   73,  -1, 148,  57,  -5,  -1, 147,  -1, 119,   9,  -1,  88, 133, -53, -29,
+  -13,  -7,  -3,  -1,  41, 103,  -1, 118, 146,  -1, 145,  -1,  25, 144,  -7,
+   -3,  -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  71,  -7,
+   -3,  -1,  40, 130,  -1,  24, 129,  -7,  -3,  -1, 116,   8,  -1, 128,  86,
+   -3,  -1, 101,  55,  -1, 115,  70, -17,  -7,  -3,  -1,  39, 114,  -1, 100,
+   23,  -3,  -1,  85, 113,  -3,  -1,   7, 112,  54,  -7,  -3,  -1,  99,  69,
+   -1,  84,  38,  -3,  -1,  98,  22,  -3,  -1,   6,  96,  53, -33, -19,  -9,
+   -5,  -1,  97,  -1,  83,  68,  -1,  37,  82,  -3,  -1,  21,  81,  -3,  -1,
+    5,  80,  52,  -7,  -3,  -1,  67,  36,  -1,  66,  51,  -1,  65,  -1,  20,
+    4,  -9,  -3,  -1,  35,  50,  -3,  -1,  64,   3,  19,  -3,  -1,  49,  48,
+   34,  -9,  -7,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -3,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab16[] =
+ {
+ -509,-503,-461,-323,-103, -37, -27, -15,  -7,  -3,  -1, 239, 254,  -1, 223,
+  253,  -3,  -1, 207, 252,  -1, 191, 251,  -5,  -1, 175,  -1, 250, 159,  -3,
+   -1, 249, 248, 143,  -7,  -3,  -1, 127, 247,  -1, 111, 246, 255,  -9,  -5,
+   -3,  -1,  95, 245,  79,  -1, 244, 243, -53,  -1, 240,  -1,  63, -29, -19,
+  -13,  -7,  -5,  -1, 206,  -1, 236, 221, 222,  -1, 233,  -1, 234, 217,  -1,
+  238,  -1, 237, 235,  -3,  -1, 190, 205,  -3,  -1, 220, 219, 174, -11,  -5,
+   -1, 204,  -1, 173, 218,  -3,  -1, 126, 172, 202,  -5,  -3,  -1, 201, 125,
+   94, 189, 242, -93,  -5,  -3,  -1,  47,  15,  31,  -1, 241, -49, -25, -13,
+   -5,  -1, 158,  -1, 188, 203,  -3,  -1, 142, 232,  -1, 157, 231,  -7,  -3,
+   -1, 187, 141,  -1, 216, 110,  -1, 230, 156, -13,  -7,  -3,  -1, 171, 186,
+   -1, 229, 215,  -1,  78,  -1, 228, 140,  -3,  -1, 200,  62,  -1, 109,  -1,
+  214, 155, -19, -11,  -5,  -3,  -1, 185, 170, 225,  -1, 212,  -1, 184, 169,
+   -5,  -1, 123,  -1, 183, 208, 227,  -7,  -3,  -1,  14, 224,  -1,  93, 213,
+   -3,  -1, 124, 199,  -1,  77, 139, -75, -45, -27, -13,  -7,  -3,  -1, 154,
+  108,  -1, 198,  61,  -3,  -1,  92, 197,  13,  -7,  -3,  -1, 138, 168,  -1,
+  153,  76,  -3,  -1, 182, 122,  60, -11,  -5,  -3,  -1,  91, 137,  28,  -1,
+  192,  -1, 152, 121,  -1, 226,  -1,  46,  30, -15,  -7,  -3,  -1, 211,  45,
+   -1, 210, 209,  -5,  -1,  59,  -1, 151, 136,  29,  -7,  -3,  -1, 196, 107,
+   -1, 195, 167,  -1,  44,  -1, 194, 181, -23, -13,  -7,  -3,  -1, 193,  12,
+   -1,  75, 180,  -3,  -1, 106, 166, 179,  -5,  -3,  -1,  90, 165,  43,  -1,
+  178,  27, -13,  -5,  -1, 177,  -1,  11, 176,  -3,  -1, 105, 150,  -1,  74,
+  164,  -5,  -3,  -1, 120, 135, 163,  -3,  -1,  58,  89,  42, -97, -57, -33,
+  -19, -11,  -5,  -3,  -1, 149, 104, 161,  -3,  -1, 134, 119, 148,  -5,  -3,
+   -1,  73,  87, 103, 162,  -5,  -1,  26,  -1,  10, 160,  -3,  -1,  57, 147,
+   -1,  88, 133,  -9,  -3,  -1,  41, 146,  -3,  -1, 118,   9,  25,  -5,  -1,
+  145,  -1, 144,  72,  -3,  -1, 132, 117,  -1,  56, 131, -21, -11,  -5,  -3,
+   -1, 102,  40, 130,  -3,  -1,  71, 116,  24,  -3,  -1, 129, 128,  -3,  -1,
+    8,  86,  55,  -9,  -5,  -1, 115,  -1, 101,  70,  -1,  39, 114,  -5,  -3,
+   -1, 100,  85,   7,  23, -23, -13,  -5,  -1, 113,  -1, 112,  54,  -3,  -1,
+   99,  69,  -1,  84,  38,  -3,  -1,  98,  22,  -1,  97,  -1,   6,  96,  -9,
+   -5,  -1,  83,  -1,  53,  68,  -1,  37,  82,  -1,  81,  -1,  21,   5, -33,
+  -23, -13,  -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20,
+   -5,  -1,  65,  -1,   4,  64,  -1,  35,  50,  -3,  -1,  19,  49,  -3,  -1,
+    3,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab24[] =
+ {
+ -451,-117, -43, -25, -15,  -7,  -3,  -1, 239, 254,  -1, 223, 253,  -3,  -1,
+  207, 252,  -1, 191, 251,  -5,  -1, 250,  -1, 175, 159,  -1, 249, 248,  -9,
+   -5,  -3,  -1, 143, 127, 247,  -1, 111, 246,  -3,  -1,  95, 245,  -1,  79,
+  244, -71,  -7,  -3,  -1,  63, 243,  -1,  47, 242,  -5,  -1, 241,  -1,  31,
+  240, -25,  -9,  -1,  15,  -3,  -1, 238, 222,  -1, 237, 206,  -7,  -3,  -1,
+  236, 221,  -1, 190, 235,  -3,  -1, 205, 220,  -1, 174, 234, -15,  -7,  -3,
+   -1, 189, 219,  -1, 204, 158,  -3,  -1, 233, 173,  -1, 218, 188,  -7,  -3,
+   -1, 203, 142,  -1, 232, 157,  -3,  -1, 217, 126,  -1, 231, 172, 255,-235,
+ -143, -77, -45, -25, -15,  -7,  -3,  -1, 202, 187,  -1, 141, 216,  -5,  -3,
+   -1,  14, 224,  13, 230,  -5,  -3,  -1, 110, 156, 201,  -1,  94, 186,  -9,
+   -5,  -1, 229,  -1, 171, 125,  -1, 215, 228,  -3,  -1, 140, 200,  -3,  -1,
+   78,  46,  62, -15,  -7,  -3,  -1, 109, 214,  -1, 227, 155,  -3,  -1, 185,
+  170,  -1, 226,  30,  -7,  -3,  -1, 225,  93,  -1, 213, 124,  -3,  -1, 199,
+   77,  -1, 139, 184, -31, -15,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -3,
+   -1, 198,  61,  -1, 211,  45,  -7,  -3,  -1, 210,  29,  -1, 123, 183,  -3,
+   -1, 209,  92,  -1, 197, 138, -17,  -7,  -3,  -1, 168, 153,  -1,  76, 196,
+   -3,  -1, 107, 182,  -3,  -1, 208,  12,  60,  -7,  -3,  -1, 195, 122,  -1,
+  167,  44,  -3,  -1, 194,  91,  -1, 181,  28, -57, -35, -19,  -7,  -3,  -1,
+  137, 152,  -1, 193,  75,  -5,  -3,  -1, 192,  11,  59,  -3,  -1, 176,  10,
+   26,  -5,  -1, 180,  -1, 106, 166,  -3,  -1, 121, 151,  -3,  -1, 160,   9,
+  144,  -9,  -3,  -1, 179, 136,  -3,  -1,  43,  90, 178,  -7,  -3,  -1, 165,
+   27,  -1, 177, 105,  -1, 150, 164, -17,  -9,  -5,  -3,  -1,  74, 120, 135,
+   -1,  58, 163,  -3,  -1,  89, 149,  -1,  42, 162,  -7,  -3,  -1, 161, 104,
+   -1, 134, 119,  -3,  -1,  73, 148,  -1,  57, 147, -63, -31, -15,  -7,  -3,
+   -1,  88, 133,  -1,  41, 103,  -3,  -1, 118, 146,  -1,  25, 145,  -7,  -3,
+   -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  40, -17,  -7,
+   -3,  -1, 130,  24,  -1,  71, 116,  -5,  -1, 129,  -1,   8, 128,  -1,  86,
+  101,  -7,  -5,  -1,  23,  -1,   7, 112, 115,  -3,  -1,  55,  39, 114, -15,
+   -7,  -3,  -1,  70, 100,  -1,  85, 113,  -3,  -1,  54,  99,  -1,  69,  84,
+   -7,  -3,  -1,  38,  98,  -1,  22,  97,  -5,  -3,  -1,   6,  96,  53,  -1,
+   83,  68, -51, -37, -23, -15,  -9,  -3,  -1,  37,  82,  -1,  21,  -1,   5,
+   80,  -1,  81,  -1,  52,  67,  -3,  -1,  36,  66,  -1,  51,  20,  -9,  -5,
+   -1,  65,  -1,   4,  64,  -1,  35,  50,  -1,  19,  49,  -7,  -5,  -3,  -1,
+    3,  48,  34,  18,  -1,  33,  -1,   2,  32,  -3,  -1,  17,   1,  -1,  16,
+    0
+ };
+ 
+ static short tab_c0[] =
+ {
+  -29, -21, -13,  -7,  -3,  -1,  11,  15,  -1,  13,  14,  -3,  -1,   7,   5,
+    9,  -3,  -1,   6,   3,  -1,  10,  12,  -3,  -1,   2,   1,  -1,   4,   8,
+    0
+ };
+ 
+ static short tab_c1[] =
+ {
+  -15,  -7,  -3,  -1,  15,  14,  -1,  13,  12,  -3,  -1,  11,  10,  -1,   9,
+    8,  -7,  -3,  -1,   7,   6,  -1,   5,   4,  -3,  -1,   3,   2,  -1,   1,
+    0
+ };
+ 
+ 
+ 
+ static struct newhuff ht[] = 
+ {
+  { /* 0 */ 0 , tab0  } ,
+  { /* 2 */ 0 , tab1  } ,
+  { /* 3 */ 0 , tab2  } ,
+  { /* 3 */ 0 , tab3  } ,
+  { /* 0 */ 0 , tab0  } ,
+  { /* 4 */ 0 , tab5  } ,
+  { /* 4 */ 0 , tab6  } ,
+  { /* 6 */ 0 , tab7  } ,
+  { /* 6 */ 0 , tab8  } ,
+  { /* 6 */ 0 , tab9  } ,
+  { /* 8 */ 0 , tab10 } ,
+  { /* 8 */ 0 , tab11 } ,
+  { /* 8 */ 0 , tab12 } ,
+  { /* 16 */ 0 , tab13 } ,
+  { /* 0  */ 0 , tab0  } ,
+  { /* 16 */ 0 , tab15 } ,
+ 
+  { /* 16 */ 1 , tab16 } ,
+  { /* 16 */ 2 , tab16 } ,
+  { /* 16 */ 3 , tab16 } ,
+  { /* 16 */ 4 , tab16 } ,
+  { /* 16 */ 6 , tab16 } ,
+  { /* 16 */ 8 , tab16 } ,
+  { /* 16 */ 10, tab16 } ,
+  { /* 16 */ 13, tab16 } ,
+  { /* 16 */ 4 , tab24 } ,
+  { /* 16 */ 5 , tab24 } ,
+  { /* 16 */ 6 , tab24 } ,
+  { /* 16 */ 7 , tab24 } ,
+  { /* 16 */ 8 , tab24 } ,
+  { /* 16 */ 9 , tab24 } ,
+  { /* 16 */ 11, tab24 } ,
+  { /* 16 */ 13, tab24 }
+ };
+ 
+ static struct newhuff htc[] = 
+ {
+  { /* 1 , 1 , */ 0 , tab_c0 } ,
+  { /* 1 , 1 , */ 0 , tab_c1 }
+ };
+ 
+ 
diff -r -c -N encoder/mpglib/interface.c lame3.70/mpglib/interface.c
*** encoder/mpglib/interface.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/interface.c	Mon Mar  6 12:53:03 2000
***************
*** 0 ****
--- 1,220 ----
+ #ifdef HAVEMPGLIB
+ #include <stdlib.h>
+ #include <stdio.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ 
+ /* Global mp .. it's a hack */
+ struct mpstr *gmp;
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp) 
+ {
+ 	memset(mp,0,sizeof(struct mpstr));
+ 
+ 	mp->framesize = 0;
+ 	mp->fsizeold = -1;
+ 	mp->bsize = 0;
+ 	mp->head = mp->tail = NULL;
+ 	mp->fr.single = -1;
+ 	mp->bsnum = 0;
+ 	mp->synth_bo = 1;
+ 
+ 	make_decode_tables(32767);
+ 	init_layer3(SBLIMIT);
+ 
+ 	return !0;
+ }
+ 
+ void ExitMP3(struct mpstr *mp)
+ {
+ 	struct buf *b,*bn;
+ 	
+ 	b = mp->tail;
+ 	while(b) {
+ 		free(b->pnt);
+ 		bn = b->next;
+ 		free(b);
+ 		b = bn;
+ 	}
+ }
+ 
+ static struct buf *addbuf(struct mpstr *mp,char *buf,int size)
+ {
+ 	struct buf *nbuf;
+ 
+ 	nbuf = (struct buf*) malloc( sizeof(struct buf) );
+ 	if(!nbuf) {
+ 		fprintf(stderr,"Out of memory!\n");
+ 		return NULL;
+ 	}
+ 	nbuf->pnt = (unsigned char*) malloc(size);
+ 	if(!nbuf->pnt) {
+ 		free(nbuf);
+ 		return NULL;
+ 	}
+ 	nbuf->size = size;
+ 	memcpy(nbuf->pnt,buf,size);
+ 	nbuf->next = NULL;
+ 	nbuf->prev = mp->head;
+ 	nbuf->pos = 0;
+ 
+ 	if(!mp->tail) {
+ 		mp->tail = nbuf;
+ 	}
+ 	else {
+ 	  mp->head->next = nbuf;
+ 	}
+ 
+ 	mp->head = nbuf;
+ 	mp->bsize += size;
+ 
+ 	return nbuf;
+ }
+ 
+ static void remove_buf(struct mpstr *mp)
+ {
+   struct buf *buf = mp->tail;
+   
+   mp->tail = buf->next;
+   if(mp->tail)
+     mp->tail->prev = NULL;
+   else {
+     mp->tail = mp->head = NULL;
+   }
+   
+   free(buf->pnt);
+   free(buf);
+ 
+ }
+ 
+ static int read_buf_byte(struct mpstr *mp)
+ {
+ 	unsigned int b;
+ 
+ 	int pos;
+ 
+ 	pos = mp->tail->pos;
+ 	while(pos >= mp->tail->size) {
+ 		remove_buf(mp);
+ 		pos = mp->tail->pos;
+ 		if(!mp->tail) {
+ 			fprintf(stderr,"Fatal error!\n");
+ 			exit(1);
+ 		}
+ 	}
+ 
+ 	b = mp->tail->pnt[pos];
+ 	mp->bsize--;
+ 	mp->tail->pos++;
+ 	
+ 
+ 	return b;
+ }
+ 
+ static void read_head(struct mpstr *mp)
+ {
+ 	unsigned long head;
+ 
+ 	head = read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 
+ 	mp->header = head;
+ }
+ 
+ int decodeMP3(struct mpstr *mp,char *in,int isize,char *out,
+ 		int osize,int *done)
+ {
+ 	int len;
+ 
+ 	gmp = mp;
+ 
+ 	if(osize < 4608) {
+ 		fprintf(stderr,"To less out space\n");
+ 		return MP3_ERR;
+ 	}
+ 
+ 	if(in) {
+ 		if(addbuf(mp,in,isize) == NULL) {
+ 			return MP3_ERR;
+ 		}
+ 	}
+ 
+ 
+ 	/* First decode header */
+ 	if(mp->framesize == 0) {
+ 		if(mp->bsize < 4) {
+ 			return MP3_NEED_MORE;
+ 		}
+ 		read_head(mp);
+ 		decode_header(&mp->fr,mp->header);
+ 		mp->framesize = mp->fr.framesize;
+ 	}
+ 
+ 	/*	  printf(" fr.framesize = %i \n",mp->fr.framesize);
+ 		  printf(" bsize        = %i \n",mp->bsize);
+ 	*/
+ 
+ 	if(mp->fr.framesize > mp->bsize) {
+ 	  return MP3_NEED_MORE;
+ 	}
+ 	wordpointer = mp->bsspace[mp->bsnum] + 512;
+ 	mp->bsnum = (mp->bsnum + 1) & 0x1;
+ 	bitindex = 0;
+ 
+ 	len = 0;
+ 	while(len < mp->framesize) {
+ 		int nlen;
+ 		int blen = mp->tail->size - mp->tail->pos;
+ 		if( (mp->framesize - len) <= blen) {
+                   nlen = mp->framesize-len;
+ 		}
+ 		else {
+                   nlen = blen;
+                 }
+ 		memcpy(wordpointer+len,mp->tail->pnt+mp->tail->pos,nlen);
+                 len += nlen;
+                 mp->tail->pos += nlen;
+ 		mp->bsize -= nlen;
+                 if(mp->tail->pos == mp->tail->size) {
+                    remove_buf(mp);
+                 }
+ 	}
+ 
+ 	*done = 0;
+ 	if(mp->fr.error_protection)
+            getbits(16);
+ 	do_layer3(&mp->fr,(unsigned char *) out,done);
+ 
+ 	mp->fsizeold = mp->framesize;
+ 	mp->framesize = 0;
+ 	return MP3_OK;
+ }
+ 
+ int set_pointer(long backstep)
+ {
+   unsigned char *bsbufold;
+   if(gmp->fsizeold < 0 && backstep > 0) {
+     fprintf(stderr,"Can't step back %ld!\n",backstep);
+     return MP3_ERR; 
+   }
+   bsbufold = gmp->bsspace[gmp->bsnum] + 512;
+   wordpointer -= backstep;
+   if (backstep)
+     memcpy(wordpointer,bsbufold+gmp->fsizeold-backstep,backstep);
+   bitindex = 0;
+   return MP3_OK;
+ }
+ 
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/layer3.c lame3.70/mpglib/layer3.c
*** encoder/mpglib/layer3.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/layer3.c	Thu Apr  6 12:50:53 2000
***************
*** 0 ****
--- 1,1738 ----
+ #ifdef HAVEMPGLIB
+ /* 
+  * Mpeg Layer-3 audio decoder 
+  * --------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp.
+  * All rights reserved. See also 'README'
+  */ 
+ 
+ #include <stdlib.h>
+ #include "mpg123.h"
+ #include "mpglib.h"
+ #include "huffman.h"
+ #ifdef HAVEGTK
+ #include "../gtkanal.h"
+ #endif
+ 
+ extern struct mpstr *gmp;
+ 
+ #define MPEG1
+ 
+ 
+ static real ispow[8207];
+ static real aa_ca[8],aa_cs[8];
+ static real COS1[12][6];
+ static real win[4][36];
+ static real win1[4][36];
+ static real gainpow2[256+118+4];
+ static real COS9[9];
+ static real COS6_1,COS6_2;
+ static real tfcos36[9];
+ static real tfcos12[3];
+ 
+ struct bandInfoStruct {
+   short longIdx[23];
+   short longDiff[22];
+   short shortIdx[14];
+   short shortDiff[13];
+ };
+ 
+ int longLimit[9][23];
+ int shortLimit[9][14];
+ 
+ struct bandInfoStruct bandInfo[9] = { 
+ 
+ /* MPEG 1.0 */
+  { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
+    {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
+    {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
+    {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
+    {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
+    {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
+    {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
+    {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,
+ 
+ /* MPEG 2.0 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
+    {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
+    {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,
+                                              /* docs: 332. mpg123: 330 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,332,394,464,540,576},
+    {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
+    {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,
+ 
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,
+ /* MPEG 2.5 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
+    {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
+    {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
+    {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
+ };
+ 
+ static int mapbuf0[9][152];
+ static int mapbuf1[9][156];
+ static int mapbuf2[9][44];
+ static int *map[9][3];
+ static int *mapend[9][3];
+ 
+ static unsigned int n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
+ static unsigned int i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */
+ 
+ static real tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
+ static real pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
+ 
+ static unsigned int get1bit(void)
+ {
+   unsigned char rval;
+   rval = *wordpointer << bitindex;
+ 
+   bitindex++;
+   wordpointer += (bitindex>>3);
+   bitindex &= 7;
+ 
+   return rval>>7;
+ }
+ 
+ 
+ 
+ 
+ /* 
+  * init tables for layer-3 
+  */
+ void init_layer3(int down_sample_sblimit)
+ {
+   int i,j,k,l;
+ 
+   for(i=-256;i<118+4;i++)
+     gainpow2[i+256] = pow((double)2.0,-0.25 * (double) (i+210) );
+ 
+   for(i=0;i<8207;i++)
+     ispow[i] = pow((double)i,(double)4.0/3.0);
+ 
+   for (i=0;i<8;i++)
+   {
+     static double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};
+     double sq=sqrt(1.0+Ci[i]*Ci[i]);
+     aa_cs[i] = 1.0/sq;
+     aa_ca[i] = Ci[i]/sq;
+   }
+ 
+   for(i=0;i<18;i++)
+   {
+     win[0][i]    = win[1][i]    = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+0) +1) ) / cos ( M_PI * (double) (2*(i+0) +19) / 72.0 );
+     win[0][i+18] = win[3][i+18] = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+18)+1) ) / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+   }
+   for(i=0;i<6;i++)
+   {
+     win[1][i+18] = 0.5 / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+     win[3][i+12] = 0.5 / cos ( M_PI * (double) (2*(i+12)+19) / 72.0 );
+     win[1][i+24] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+13) ) / cos ( M_PI * (double) (2*(i+24)+19) / 72.0 );
+     win[1][i+30] = win[3][i] = 0.0;
+     win[3][i+6 ] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) )  / cos ( M_PI * (double) (2*(i+6 )+19) / 72.0 );
+   }
+ 
+   for(i=0;i<9;i++)
+     COS9[i] = cos( M_PI / 18.0 * (double) i);
+ 
+   for(i=0;i<9;i++)
+     tfcos36[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 36.0 );
+   for(i=0;i<3;i++)
+     tfcos12[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 12.0 );
+ 
+   COS6_1 = cos( M_PI / 6.0 * (double) 1);
+   COS6_2 = cos( M_PI / 6.0 * (double) 2);
+ 
+   for(i=0;i<12;i++)
+   {
+     win[2][i]  = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) ) / cos ( M_PI * (double) (2*i+7) / 24.0 );
+     for(j=0;j<6;j++)
+       COS1[i][j] = cos( M_PI / 24.0 * (double) ((2*i+7)*(2*j+1)) );
+   }
+ 
+   for(j=0;j<4;j++) {
+     static int len[4] = { 36,36,12,36 };
+     for(i=0;i<len[j];i+=2)
+       win1[j][i] = + win[j][i];
+     for(i=1;i<len[j];i+=2)
+       win1[j][i] = - win[j][i];
+   }
+ 
+   for(i=0;i<16;i++)
+   {
+     double t = tan( (double) i * M_PI / 12.0 );
+     tan1_1[i] = t / (1.0+t);
+     tan2_1[i] = 1.0 / (1.0 + t);
+     tan1_2[i] = M_SQRT2 * t / (1.0+t);
+     tan2_2[i] = M_SQRT2 / (1.0 + t);
+ 
+     for(j=0;j<2;j++) {
+       double base = pow(2.0,-0.25*(j+1.0));
+       double p1=1.0,p2=1.0;
+       if(i > 0) {
+         if( i & 1 )
+           p1 = pow(base,(i+1.0)*0.5);
+         else
+           p2 = pow(base,i*0.5);
+       }
+       pow1_1[j][i] = p1;
+       pow2_1[j][i] = p2;
+       pow1_2[j][i] = M_SQRT2 * p1;
+       pow2_2[j][i] = M_SQRT2 * p2;
+     }
+   }
+ 
+   for(j=0;j<9;j++)
+   {
+    struct bandInfoStruct *bi = &bandInfo[j];
+    int *mp;
+    int cb,lwin;
+    short *bdf;
+ 
+    mp = map[j][0] = mapbuf0[j];
+    bdf = bi->longDiff;
+    for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
+      *mp++ = (*bdf) >> 1;
+      *mp++ = i;
+      *mp++ = 3;
+      *mp++ = cb;
+    }
+    bdf = bi->shortDiff+3;
+    for(cb=3;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][0] = mp;
+ 
+    mp = map[j][1] = mapbuf1[j];
+    bdf = bi->shortDiff+0;
+    for(i=0,cb=0;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][1] = mp;
+ 
+    mp = map[j][2] = mapbuf2[j];
+    bdf = bi->longDiff;
+    for(cb = 0; cb < 22 ; cb++) {
+      *mp++ = (*bdf++) >> 1;
+      *mp++ = cb;
+    }
+    mapend[j][2] = mp;
+ 
+   }
+ 
+   for(j=0;j<9;j++) {
+     for(i=0;i<23;i++) {
+       longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
+       if(longLimit[j][i] > (down_sample_sblimit) )
+         longLimit[j][i] = down_sample_sblimit;
+     }
+     for(i=0;i<14;i++) {
+       shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
+       if(shortLimit[j][i] > (down_sample_sblimit) )
+         shortLimit[j][i] = down_sample_sblimit;
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<6;j++) {
+       for(k=0;k<6;k++) {
+         int n = k + j * 6 + i * 36;
+         i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<4;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 16;
+         i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<3;j++) {
+       int n = j + i * 3;
+       i_slen2[n+244] = i|(j<<3) | (5<<12);
+       n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         for(l=0;l<4;l++) {
+           int n = l + k * 4 + j * 16 + i * 80;
+           n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
+         }
+       }
+     }
+   }
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 20;
+         n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
+       }
+     }
+   }
+ }
+ 
+ /*
+  * read additional side information
+  */
+ #ifdef MPEG1 
+ static void III_get_side_info_1(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch, gr;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(9);
+    if (stereo == 1)
+      si->private_bits = getbits_fast(5);
+    else 
+      si->private_bits = getbits_fast(3);
+ 
+    for (ch=0; ch<stereo; ch++) {
+        si->ch[ch].gr[0].scfsi = -1;
+        si->ch[ch].gr[1].scfsi = getbits_fast(4);
+    }
+ 
+    for (gr=0; gr<2; gr++) 
+    {
+      for (ch=0; ch<stereo; ch++) 
+      {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+           fprintf(stderr,"big_values too large!\n");
+           gr_info->big_values = 288;
+        }
+        {
+ 	 unsigned int qss = getbits_fast(8);
+ 	 gr_info->pow2gain = gainpow2+256 - qss + powdiff;
+ #ifdef HAVEGTK
+ 	 if (gtkflag) {
+ 	   pinfo->qss[gr][ch]=qss;
+ 	   pinfo->big_values[gr][ch]=gr_info->big_values;
+ 	 }
+ #endif
+        }
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits_fast(4);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+ 
+ 
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+ 	   unsigned int sbg = (getbits_fast(3)<<3);
+            gr_info->full_gain[i] = gr_info->pow2gain + sbg;
+ #ifdef HAVEGTK
+ 	   if (gtkflag)
+ 	     pinfo->sub_gain[gr][ch][i]=sbg/8;
+ #endif
+ 	 }
+ 
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+          gr_info->region1start = 36>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->preflag = get1bit();
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        if (gtkflag)
+ 	 pinfo->scalefac_scale[gr][ch]=gr_info->scalefac_scale;
+ #endif
+      }
+    }
+ }
+ #endif
+ 
+ /*
+  * Side Info for MPEG 2.0 / LSF
+  */
+ static void III_get_side_info_2(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(8);
+    if (stereo == 1)
+      si->private_bits = get1bit();
+    else 
+      si->private_bits = getbits_fast(2);
+ 
+    for (ch=0; ch<stereo; ch++) 
+    {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[0]);
+        unsigned int qss;
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+          fprintf(stderr,"big_values too large!\n");
+          gr_info->big_values = 288;
+        }
+        qss=getbits_fast(8);
+        gr_info->pow2gain = gainpow2+256 - qss + powdiff;
+ #ifdef HAVEGTK
+        if (gtkflag) {
+ 	   pinfo->qss[0][ch]=qss;
+ 	   pinfo->big_values[0][ch]=gr_info->big_values;
+        }
+ #endif
+ 
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits(9);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+ 	   unsigned int sbg = (getbits_fast(3)<<3);
+            gr_info->full_gain[i] = gr_info->pow2gain + sbg;
+ #ifdef HAVEGTK
+ 	   if (gtkflag)
+ 	     pinfo->sub_gain[0][ch][i]=sbg/8;
+ #endif
+ 	 }
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+ /* check this again! */
+          if(gr_info->block_type == 2)
+            gr_info->region1start = 36>>1;
+          else if(sfreq == 8)
+ /* check this for 2.5 and sfreq=8 */
+            gr_info->region1start = 108>>1;
+          else
+            gr_info->region1start = 54>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        if (gtkflag)
+ 	 pinfo->scalefac_scale[0][ch]=gr_info->scalefac_scale;
+ #endif
+    }
+ }
+ 
+ /*
+  * read scalefactors
+  */
+ #ifdef MPEG1
+ static int III_get_scale_factors_1(int *scf,struct gr_info_s *gr_info)
+ {
+    static unsigned char slen[2][16] = {
+      {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
+      {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
+    };
+    int numbits;
+    int num0 = slen[0][gr_info->scalefac_compress];
+    int num1 = slen[1][gr_info->scalefac_compress];
+ 
+     if (gr_info->block_type == 2) 
+     {
+       int i=18;
+       numbits = (num0 + num1) * 18;
+ 
+       if (gr_info->mixed_block_flag) {
+          for (i=8;i;i--)
+            *scf++ = getbits_fast(num0);
+          i = 9;
+          numbits -= num0; /* num0 * 17 + num1 * 18 */
+       }
+ 
+       for (;i;i--)
+         *scf++ = getbits_fast(num0);
+       for (i = 18; i; i--)
+         *scf++ = getbits_fast(num1);
+       *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
+     }
+     else 
+     {
+       int i;
+       int scfsi = gr_info->scfsi;
+ 
+       if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
+          for(i=11;i;i--)
+            *scf++ = getbits_fast(num0);
+          for(i=10;i;i--)
+            *scf++ = getbits_fast(num1);
+          numbits = (num0 + num1) * 10 + num0;
+       }
+       else {
+         numbits = 0;
+         if(!(scfsi & 0x8)) {
+           for (i=6;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 6;
+         }
+         else {
+           scf += 6;
+         }
+ 
+         if(!(scfsi & 0x4)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 5;
+         }
+         else {
+           scf += 5;
+         }
+ 
+         if(!(scfsi & 0x2)) {
+           for(i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           scf += 5;
+         }
+ 
+         if(!(scfsi & 0x1)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           scf += 5;
+         }
+       }
+ 
+       *scf++ = 0;  /* no l[21] in original sources */
+     }
+     return numbits;
+ }
+ #endif
+ 
+ static int III_get_scale_factors_2(int *scf,struct gr_info_s *gr_info,int i_stereo)
+ {
+   unsigned char *pnt;
+   int i,j;
+   unsigned int slen;
+   int n = 0;
+   int numbits = 0;
+ 
+   static unsigned char stab[3][6][4] = {
+    { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
+      { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
+    { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
+      {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
+    { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
+      { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } }; 
+ 
+   if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
+     slen = i_slen2[gr_info->scalefac_compress>>1];
+   else
+     slen = n_slen2[gr_info->scalefac_compress];
+ 
+   gr_info->preflag = (slen>>15) & 0x1;
+ 
+   n = 0;  
+   if( gr_info->block_type == 2 ) {
+     n++;
+     if(gr_info->mixed_block_flag)
+       n++;
+   }
+ 
+   pnt = stab[n][(slen>>12)&0x7];
+ 
+   for(i=0;i<4;i++) {
+     int num = slen & 0x7;
+     slen >>= 3;
+     if(num) {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = getbits_fast(num);
+       numbits += pnt[i] * num;
+     }
+     else {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = 0;
+     }
+   }
+   
+   n = (n << 1) + 1;
+   for(i=0;i<n;i++)
+     *scf++ = 0;
+ 
+   return numbits;
+ }
+ 
+ static int pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
+ static int pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+ 
+ /*
+  * don't forget to apply the same changes to III_dequantize_sample_ms() !!! 
+  */
+ static int III_dequantize_sample(real xr[SBLIMIT][SSLIMIT],int *scf,
+    struct gr_info_s *gr_info,int sfreq,int part2bits)
+ {
+   int shift = 1 + gr_info->scalefac_scale;
+   real *xrpnt = (real *) xr;
+   int l[3],l3;
+   int part2remain = gr_info->part2_3_length - part2bits;
+   int *me;
+ 
+   {
+     int bv       = gr_info->big_values;
+     int region1  = gr_info->region1start;
+     int region2  = gr_info->region2start;
+ 
+     l3 = ((576>>1)-bv)>>1;   
+ /*
+  * we may lose the 'odd' bit here !! 
+  * check this later again 
+  */
+     if(bv <= region1) {
+       l[0] = bv; l[1] = 0; l[2] = 0;
+     }
+     else {
+       l[0] = region1;
+       if(bv <= region2) {
+         l[1] = bv - l[0];  l[2] = 0;
+       }
+       else {
+         l[1] = region2 - l[0]; l[2] = bv - region2;
+       }
+     }
+   }
+  
+   if(gr_info->block_type == 2) {
+     /*
+      * decoding with short or mixed mode BandIndex table 
+      */
+     int i,max[4];
+     int step=0,lwin=0,cb=0;
+     register real v = 0.0;
+     register int *m,mc;
+ 
+     if(gr_info->mixed_block_flag) {
+       max[3] = -1;
+       max[0] = max[1] = max[2] = 2;
+       m = map[sfreq][0];
+       me = mapend[sfreq][0];
+     }
+     else {
+       max[0] = max[1] = max[2] = max[3] = -1;
+       /* max[3] not really needed in this case */
+       m = map[sfreq][1];
+       me = mapend[sfreq][1];
+     }
+ 
+     mc = 0;
+     for(i=0;i<2;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+       for(;lp;lp--,mc--) {
+         register int x,y;
+         if( (!mc) ) {
+           mc = *m++;
+           xrpnt = ((real *) xr) + (*m++);
+           lwin = *m++;
+           cb = *m++;
+           if(lwin == 3) {
+             v = gr_info->pow2gain[(*scf++) << shift];
+             step = 1;
+           }
+           else {
+             v = gr_info->full_gain[lwin][(*scf++) << shift];
+             step = 3;
+           }
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if(x == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+         }
+         else if(x) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+         if(y == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+         }
+         else if(y) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             xrpnt = ((real *) xr) + (*m++);
+             lwin = *m++;
+             cb = *m++;
+             if(lwin == 3) {
+               v = gr_info->pow2gain[(*scf++) << shift];
+               step = 1;
+             }
+             else {
+               v = gr_info->full_gain[lwin][(*scf++) << shift];
+               step = 3;
+             }
+           }
+           mc--;
+         }
+         if( (a & (0x8>>i)) ) {
+           max[lwin] = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit()) 
+             *xrpnt = -v;
+           else
+             *xrpnt = v;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+  
+     while( m < me ) {
+       if(!mc) {
+         mc = *m++;
+         xrpnt = ((real *) xr) + *m++;
+         if( (*m++) == 3)
+           step = 1;
+         else
+           step = 3;
+         m++; /* cb */
+       }
+       mc--;
+       *xrpnt = 0.0;
+       xrpnt += step;
+       *xrpnt = 0.0;
+       xrpnt += step;
+ /* we could add a little opt. here:
+  * if we finished a band for window 3 or a long band
+  * further bands could copied in a simple loop without a
+  * special 'map' decoding
+  */
+     }
+ 
+     gr_info->maxband[0] = max[0]+1;
+     gr_info->maxband[1] = max[1]+1;
+     gr_info->maxband[2] = max[2]+1;
+     gr_info->maxbandl = max[3]+1;
+ 
+     {
+       int rmax = max[0] > max[1] ? max[0] : max[1];
+       rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+       gr_info->maxb = rmax ? shortLimit[sfreq][rmax] : longLimit[sfreq][max[3]+1];
+     }
+ 
+   }
+   else {
+ 	/*
+      * decoding with 'long' BandIndex table (block_type != 2)
+      */
+     int *pretab = gr_info->preflag ? pretab1 : pretab2;
+     int i,max = -1;
+     int cb = 0;
+     register int *m = map[sfreq][2];
+     register real v = 0.0;
+     register int mc = 0;
+ #if 0
+     me = mapend[sfreq][2];
+ #endif
+ 
+ 	/*
+      * long hash table values
+      */
+     for(i=0;i<3;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+ 
+       for(;lp;lp--,mc--) {
+         int x,y;
+ 
+         if(!mc) {
+           mc = *m++;
+           v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           cb = *m++;
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if (x == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+         }
+         else if(x) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+ 
+         if (y == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+         }
+         else if(y) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/*
+      * short (count1table) values
+      */
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             cb = *m++;
+             v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           }
+           mc--;
+         }
+         if ( (a & (0x8>>i)) ) {
+           max = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit())
+             *xrpnt++ = -v;
+           else
+             *xrpnt++ = v;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/* 
+      * zero part
+      */
+     for(i=(&xr[SBLIMIT][0]-xrpnt)>>1;i;i--) {
+       *xrpnt++ = 0.0;
+       *xrpnt++ = 0.0;
+     }
+ 
+     gr_info->maxbandl = max+1;
+     gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+   }
+ 
+   while( part2remain > 16 ) {
+     getbits(16); /* Dismiss stuffing Bits */
+     part2remain -= 16;
+   }
+   if(part2remain > 0)
+     getbits(part2remain);
+   else if(part2remain < 0) {
+     fprintf(stderr,"mpg123: Can't rewind stream by %d bits!\n",-part2remain);
+     return 1; /* -> error */
+   }
+   return 0;
+ }
+ 
+ 
+ /* 
+  * III_stereo: calculate real channel values for Joint-I-Stereo-mode
+  */
+ static void III_i_stereo(real xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
+    struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
+ {
+       real (*xr)[SBLIMIT*SSLIMIT] = (real (*)[SBLIMIT*SSLIMIT] ) xr_buf;
+       struct bandInfoStruct *bi = &bandInfo[sfreq];
+       real *tab1,*tab2;
+ 
+       if(lsf) {
+         int p = gr_info->scalefac_compress & 0x1;
+ 	    if(ms_stereo) {
+           tab1 = pow1_2[p]; tab2 = pow2_2[p];
+         }
+         else {
+           tab1 = pow1_1[p]; tab2 = pow2_1[p];
+         }
+       }
+       else {
+         if(ms_stereo) {
+           tab1 = tan1_2; tab2 = tan2_2;
+         }
+         else {
+           tab1 = tan1_1; tab2 = tan2_1;
+         }
+       }
+ 
+       if (gr_info->block_type == 2)
+       {
+          int lwin,do_l = 0;
+          if( gr_info->mixed_block_flag )
+            do_l = 1;
+ 
+          for (lwin=0;lwin<3;lwin++) /* process each window */
+          {
+              /* get first band with zero values */
+            int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
+            if(sfb > 3)
+              do_l = 0;
+ 
+            for(;sfb<12;sfb++)
+            {
+              is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */ 
+              if(is_p != 7) {
+                real t1,t2;
+                sb = bi->shortDiff[sfb];
+                idx = bi->shortIdx[sfb] + lwin;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for (; sb > 0; sb--,idx+=3)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+            }
+ 
+ #if 1
+ /* in the original: copy 10 to 11 , here: copy 11 to 12 
+ maybe still wrong??? (copy 12 to 13?) */
+            is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[12];
+            idx = bi->shortIdx[12] + lwin;
+ #else
+            is_p = scalefac[10*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[11];
+            idx = bi->shortIdx[11] + lwin;
+ #endif
+            if(is_p != 7)
+            {
+              real t1,t2;
+              t1 = tab1[is_p]; t2 = tab2[is_p];
+              for ( ; sb > 0; sb--,idx+=3 )
+              {  
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+              }
+            }
+          } /* end for(lwin; .. ; . ) */
+ 
+          if (do_l)
+          {
+ /* also check l-part, if ALL bands in the three windows are 'empty'
+  * and mode = mixed_mode 
+  */
+            int sfb = gr_info->maxbandl;
+            int idx = bi->longIdx[sfb];
+ 
+            for ( ; sfb<8; sfb++ )
+            {
+              int sb = bi->longDiff[sfb];
+              int is_p = scalefac[sfb]; /* scale: 0-15 */
+              if(is_p != 7) {
+                real t1,t2;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for ( ; sb > 0; sb--,idx++)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+              else 
+                idx += sb;
+            }
+          }     
+       } 
+       else /* ((gr_info->block_type != 2)) */
+       {
+         int sfb = gr_info->maxbandl;
+         int is_p,idx = bi->longIdx[sfb];
+         for ( ; sfb<21; sfb++)
+         {
+           int sb = bi->longDiff[sfb];
+           is_p = scalefac[sfb]; /* scale: 0-15 */
+           if(is_p != 7) {
+             real t1,t2;
+             t1 = tab1[is_p]; t2 = tab2[is_p];
+             for ( ; sb > 0; sb--,idx++)
+             {
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+             }
+           }
+           else
+             idx += sb;
+         }
+ 
+         is_p = scalefac[20]; /* copy l-band 20 to l-band 21 */
+         if(is_p != 7)
+         {
+           int sb;
+           real t1 = tab1[is_p],t2 = tab2[is_p]; 
+ 
+           for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
+           {
+             real v = xr[0][idx];
+             xr[0][idx] = v * t1;
+             xr[1][idx] = v * t2;
+           }
+         }
+       } /* ... */
+ }
+ 
+ static void III_antialias(real xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info)
+ {
+    int sblim;
+ 
+    if(gr_info->block_type == 2)
+    {
+       if(!gr_info->mixed_block_flag) 
+         return;
+       sblim = 1; 
+    }
+    else {
+      sblim = gr_info->maxb-1;
+    }
+ 
+    /* 31 alias-reduction operations between each pair of sub-bands */
+    /* with 8 butterflies between each pair                         */
+ 
+    {
+      int sb;
+      real *xr1=(real *) xr[1];
+ 
+      for(sb=sblim;sb;sb--,xr1+=10)
+      {
+        int ss;
+        real *cs=aa_cs,*ca=aa_ca;
+        real *xr2 = xr1;
+ 
+        for(ss=7;ss>=0;ss--)
+        {       /* upper and lower butterfly inputs */
+          register real bu = *--xr2,bd = *xr1;
+          *xr2   = (bu * (*cs)   ) - (bd * (*ca)   );
+          *xr1++ = (bd * (*cs++) ) + (bu * (*ca++) );
+        }
+      }
+   }
+ }
+ 
+ /*
+  DCT insipired by Jeff Tsay's DCT from the maplay package
+  this is an optimized version with manual unroll.
+ 
+  References:
+  [1] S. Winograd: "On Computing the Discrete Fourier Transform",
+      Mathematics of Computation, Volume 32, Number 141, January 1978,
+      Pages 175-199
+ */
+ 
+ static void dct36(real *inbuf,real *o1,real *o2,real *wintab,real *tsbuf)
+ {
+   {
+     register real *in = inbuf;
+ 
+     in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
+     in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
+     in[11]+=in[10]; in[10]+=in[9];  in[9] +=in[8];
+     in[8] +=in[7];  in[7] +=in[6];  in[6] +=in[5];
+     in[5] +=in[4];  in[4] +=in[3];  in[3] +=in[2];
+     in[2] +=in[1];  in[1] +=in[0];
+ 
+     in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
+     in[9] +=in[7];  in[7] +=in[5];  in[5] +=in[3];  in[3] +=in[1];
+ 
+ 
+   {
+ 
+ #define MACRO0(v) { \
+     real tmp; \
+     out2[9+(v)] = (tmp = sum0 + sum1) * w[27+(v)]; \
+     out2[8-(v)] = tmp * w[26-(v)];  } \
+     sum0 -= sum1; \
+     ts[SBLIMIT*(8-(v))] = out1[8-(v)] + sum0 * w[8-(v)]; \
+     ts[SBLIMIT*(9+(v))] = out1[9+(v)] + sum0 * w[9+(v)]; 
+ #define MACRO1(v) { \
+ 	real sum0,sum1; \
+     sum0 = tmp1a + tmp2a; \
+ 	sum1 = (tmp1b + tmp2b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ #define MACRO2(v) { \
+     real sum0,sum1; \
+     sum0 = tmp2a - tmp1a; \
+     sum1 = (tmp2b - tmp1b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ 
+     register const real *c = COS9;
+     register real *out2 = o2;
+ 	register real *w = wintab;
+ 	register real *out1 = o1;
+ 	register real *ts = tsbuf;
+ 
+     real ta33,ta66,tb33,tb66;
+ 
+     ta33 = in[2*3+0] * c[3];
+     ta66 = in[2*6+0] * c[6];
+     tb33 = in[2*3+1] * c[3];
+     tb66 = in[2*6+1] * c[6];
+ 
+     { 
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[1] + ta33 + in[2*5+0] * c[5] + in[2*7+0] * c[7];
+       tmp1b =             in[2*1+1] * c[1] + tb33 + in[2*5+1] * c[5] + in[2*7+1] * c[7];
+       tmp2a = in[2*0+0] + in[2*2+0] * c[2] + in[2*4+0] * c[4] + ta66 + in[2*8+0] * c[8];
+       tmp2b = in[2*0+1] + in[2*2+1] * c[2] + in[2*4+1] * c[4] + tb66 + in[2*8+1] * c[8];
+ 
+       MACRO1(0);
+       MACRO2(8);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a = ( in[2*1+0] - in[2*5+0] - in[2*7+0] ) * c[3];
+       tmp1b = ( in[2*1+1] - in[2*5+1] - in[2*7+1] ) * c[3];
+       tmp2a = ( in[2*2+0] - in[2*4+0] - in[2*8+0] ) * c[6] - in[2*6+0] + in[2*0+0];
+       tmp2b = ( in[2*2+1] - in[2*4+1] - in[2*8+1] ) * c[6] - in[2*6+1] + in[2*0+1];
+ 
+       MACRO1(1);
+       MACRO2(7);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[5] - ta33 - in[2*5+0] * c[7] + in[2*7+0] * c[1];
+       tmp1b =             in[2*1+1] * c[5] - tb33 - in[2*5+1] * c[7] + in[2*7+1] * c[1];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[8] - in[2*4+0] * c[2] + ta66 + in[2*8+0] * c[4];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[8] - in[2*4+1] * c[2] + tb66 + in[2*8+1] * c[4];
+ 
+       MACRO1(2);
+       MACRO2(6);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[7] - ta33 + in[2*5+0] * c[1] - in[2*7+0] * c[5];
+       tmp1b =             in[2*1+1] * c[7] - tb33 + in[2*5+1] * c[1] - in[2*7+1] * c[5];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[4] + in[2*4+0] * c[8] + ta66 - in[2*8+0] * c[2];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[4] + in[2*4+1] * c[8] + tb66 - in[2*8+1] * c[2];
+ 
+       MACRO1(3);
+       MACRO2(5);
+     }
+ 
+ 	{
+ 		real sum0,sum1;
+     	sum0 =  in[2*0+0] - in[2*2+0] + in[2*4+0] - in[2*6+0] + in[2*8+0];
+     	sum1 = (in[2*0+1] - in[2*2+1] + in[2*4+1] - in[2*6+1] + in[2*8+1] ) * tfcos36[4];
+ 		MACRO0(4);
+ 	}
+   }
+ 
+   }
+ }
+ 
+ /*
+  * new DCT12
+  */
+ static void dct12(real *in,real *rawout1,real *rawout2,register real *wi,register real *ts)
+ {
+ #define DCT12_PART1 \
+              in5 = in[5*3];  \
+      in5 += (in4 = in[4*3]); \
+      in4 += (in3 = in[3*3]); \
+      in3 += (in2 = in[2*3]); \
+      in2 += (in1 = in[1*3]); \
+      in1 += (in0 = in[0*3]); \
+                              \
+      in5 += in3; in3 += in1; \
+                              \
+      in2 *= COS6_1; \
+      in3 *= COS6_1; \
+ 
+ #define DCT12_PART2 \
+      in0 += in4 * COS6_2; \
+                           \
+      in4 = in0 + in2;     \
+      in0 -= in2;          \
+                           \
+      in1 += in5 * COS6_2; \
+                           \
+      in5 = (in1 + in3) * tfcos12[0]; \
+      in1 = (in1 - in3) * tfcos12[2]; \
+                          \
+      in3 = in4 + in5;    \
+      in4 -= in5;         \
+                          \
+      in2 = in0 + in1;    \
+      in0 -= in1;
+ 
+ 
+    {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out1 = rawout1;
+      ts[SBLIMIT*0] = out1[0]; ts[SBLIMIT*1] = out1[1]; ts[SBLIMIT*2] = out1[2];
+      ts[SBLIMIT*3] = out1[3]; ts[SBLIMIT*4] = out1[4]; ts[SBLIMIT*5] = out1[5];
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        ts[(17-1)*SBLIMIT] = out1[17-1] + tmp0 * wi[11-1];
+        ts[(12+1)*SBLIMIT] = out1[12+1] + tmp0 * wi[6+1];
+        ts[(6 +1)*SBLIMIT] = out1[6 +1] + tmp1 * wi[1];
+        ts[(11-1)*SBLIMIT] = out1[11-1] + tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      ts[(17-0)*SBLIMIT] = out1[17-0] + in2 * wi[11-0];
+      ts[(12+0)*SBLIMIT] = out1[12+0] + in2 * wi[6+0];
+      ts[(12+2)*SBLIMIT] = out1[12+2] + in3 * wi[6+2];
+      ts[(17-2)*SBLIMIT] = out1[17-2] + in3 * wi[11-2];
+ 
+      ts[(6+0)*SBLIMIT]  = out1[6+0] + in0 * wi[0];
+      ts[(11-0)*SBLIMIT] = out1[11-0] + in0 * wi[5-0];
+      ts[(6+2)*SBLIMIT]  = out1[6+2] + in4 * wi[2];
+      ts[(11-2)*SBLIMIT] = out1[11-2] + in4 * wi[5-2];
+   }
+ 
+   in++;
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[5-1] = tmp0 * wi[11-1];
+        out2[0+1] = tmp0 * wi[6+1];
+        ts[(12+1)*SBLIMIT] += tmp1 * wi[1];
+        ts[(17-1)*SBLIMIT] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[5-0] = in2 * wi[11-0];
+      out2[0+0] = in2 * wi[6+0];
+      out2[0+2] = in3 * wi[6+2];
+      out2[5-2] = in3 * wi[11-2];
+ 
+      ts[(12+0)*SBLIMIT] += in0 * wi[0];
+      ts[(17-0)*SBLIMIT] += in0 * wi[5-0];
+      ts[(12+2)*SBLIMIT] += in4 * wi[2];
+      ts[(17-2)*SBLIMIT] += in4 * wi[5-2];
+   }
+ 
+   in++; 
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+      out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
+ 
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[11-1] = tmp0 * wi[11-1];
+        out2[6 +1] = tmp0 * wi[6+1];
+        out2[0+1] += tmp1 * wi[1];
+        out2[5-1] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[11-0] = in2 * wi[11-0];
+      out2[6 +0] = in2 * wi[6+0];
+      out2[6 +2] = in3 * wi[6+2];
+      out2[11-2] = in3 * wi[11-2];
+ 
+      out2[0+0] += in0 * wi[0];
+      out2[5-0] += in0 * wi[5-0];
+      out2[0+2] += in4 * wi[2];
+      out2[5-2] += in4 * wi[5-2];
+   }
+ }
+ 
+ /*
+  * III_hybrid
+  */
+ static void III_hybrid(real fsIn[SBLIMIT][SSLIMIT],real tsOut[SSLIMIT][SBLIMIT],
+    int ch,struct gr_info_s *gr_info)
+ {
+    real *tspnt = (real *) tsOut;
+    real (*block)[2][SBLIMIT*SSLIMIT] = gmp->hybrid_block;
+    int *blc = gmp->hybrid_blc;
+    real *rawout1,*rawout2;
+    int bt;
+    int sb = 0;
+ 
+    {
+      int b = blc[ch];
+      rawout1=block[b][ch];
+      b=-b+1;
+      rawout2=block[b][ch];
+      blc[ch] = b;
+    }
+ 
+   
+    if(gr_info->mixed_block_flag) {
+      sb = 2;
+      dct36(fsIn[0],rawout1,rawout2,win[0],tspnt);
+      dct36(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+      rawout1 += 36; rawout2 += 36; tspnt += 2;
+    }
+  
+    bt = gr_info->block_type;
+    if(bt == 2) {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct12(fsIn[sb],rawout1,rawout2,win[2],tspnt);
+        dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
+      }
+    }
+    else {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct36(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+        dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+      }
+    }
+ 
+    for(;sb<SBLIMIT;sb++,tspnt++) {
+      int i;
+      for(i=0;i<SSLIMIT;i++) {
+        tspnt[i*SBLIMIT] = *rawout1++;
+        *rawout2++ = 0.0;
+      }
+    }
+ }
+ 
+ /*
+  * main layer3 handler
+  */
+ int do_layer3(struct frame *fr,unsigned char *pcm_sample,int *pcm_point)
+ {
+   int gr, ch, ss,clip=0;
+   int scalefacs[2][39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
+   struct III_sideinfo sideinfo;
+   int stereo = fr->stereo;
+   int single = fr->single;
+   int ms_stereo,i_stereo;
+   int sfreq = fr->sampling_frequency;
+   int stereo1,granules;
+ 
+ 
+ 
+   if(stereo == 1) { /* stream is mono */
+     stereo1 = 1;
+     single = 0;
+   }
+   else if(single >= 0) /* stream is stereo, but force to mono */
+     stereo1 = 1;
+   else
+     stereo1 = 2;
+ 
+   if(fr->mode == MPG_MD_JOINT_STEREO) {
+     ms_stereo = fr->mode_ext & 0x2;
+     i_stereo  = fr->mode_ext & 0x1;
+   }
+   else
+     ms_stereo = i_stereo = 0;
+ 
+ 
+   if(fr->lsf) {
+     granules = 1;
+     III_get_side_info_2(&sideinfo,stereo,ms_stereo,sfreq,single);
+   }
+   else {
+     granules = 2;
+ #ifdef MPEG1
+     III_get_side_info_1(&sideinfo,stereo,ms_stereo,sfreq,single);
+ #else
+     fprintf(stderr,"Not supported\n");
+ #endif
+   }
+ 
+   if(set_pointer(sideinfo.main_data_begin) == MP3_ERR)
+     return 0; 
+ 
+ 
+   for (gr=0;gr<granules;gr++) 
+   {
+     static real hybridIn[2][SBLIMIT][SSLIMIT];
+     static real hybridOut[2][SSLIMIT][SBLIMIT];
+ 
+     {
+       struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
+       long part2bits;
+       if(fr->lsf)
+         part2bits = III_get_scale_factors_2(scalefacs[0],gr_info,0);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs[0],gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+ #ifdef HAVEGTK
+       if (gtkflag) {
+ 	int i;
+ 	for (i=0; i<39; i++) 
+ 	  pinfo->sfb_s[gr][0][i]=scalefacs[0][i];
+       }
+ #endif
+       if(III_dequantize_sample(hybridIn[0], scalefacs[0],gr_info,sfreq,part2bits))
+         return clip;
+     }
+     if(stereo == 2) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[1].gr[gr]);
+       long part2bits;
+       if(fr->lsf) 
+         part2bits = III_get_scale_factors_2(scalefacs[1],gr_info,i_stereo);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs[1],gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+ #ifdef HAVEGTK
+       if (gtkflag) {
+ 	int i;
+ 	for (i=0; i<39; i++) 
+ 	  pinfo->sfb_s[gr][1][i]=scalefacs[1][i];
+       }
+ #endif
+ 
+       if(III_dequantize_sample(hybridIn[1],scalefacs[1],gr_info,sfreq,part2bits))
+           return clip;
+ 
+       if(ms_stereo) {
+         int i;
+         for(i=0;i<SBLIMIT*SSLIMIT;i++) {
+           real tmp0,tmp1;
+           tmp0 = ((real *) hybridIn[0])[i];
+           tmp1 = ((real *) hybridIn[1])[i];
+           ((real *) hybridIn[1])[i] = tmp0 - tmp1;  
+           ((real *) hybridIn[0])[i] = tmp0 + tmp1;
+         }
+       }
+ 
+       if(i_stereo)
+         III_i_stereo(hybridIn,scalefacs[1],gr_info,sfreq,ms_stereo,fr->lsf);
+ 
+       if(ms_stereo || i_stereo || (single == 3) ) {
+         if(gr_info->maxb > sideinfo.ch[0].gr[gr].maxb) 
+           sideinfo.ch[0].gr[gr].maxb = gr_info->maxb;
+         else
+           gr_info->maxb = sideinfo.ch[0].gr[gr].maxb;
+       }
+ 
+       switch(single) {
+         case 3:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++,in0++)
+               *in0 = (*in0 + *in1++); /* *0.5 done by pow-scale */ 
+           }
+           break;
+         case 1:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++)
+               *in0++ = *in1++;
+           }
+           break;
+       }
+     }
+ 
+ #ifdef HAVEGTK
+     if (gtkflag) {
+     extern int tabsel_123[2][3][16];
+     extern int pretab[21];
+     int i,j,sb;
+     float ifqstep;
+ 
+     for (ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       ifqstep = ( pinfo->scalefac_scale[gr][ch] == 0 ) ? .5 : 1.0;
+       if (2==gr_info->block_type) {
+ 	for (i=0; i<3; i++) {
+ 	  for (sb=0; sb<12; sb++) {
+ 	    j = 3*sb+i;
+ 	    /*
+            is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; 
+ 	    */
+ 	    /* scalefac was copied into pinfo->sfb_s[] above */
+ 	    pinfo->sfb_s[gr][ch][j] = -ifqstep*pinfo->sfb_s[gr][ch][j-gr_info->mixed_block_flag];
+ 	    pinfo->sfb_s[gr][ch][j] -= 2*(pinfo->sub_gain[gr][ch][i]);
+ 	  }
+ 	  pinfo->sfb_s[gr][ch][3*sb+i] = - 2*(pinfo->sub_gain[gr][ch][i]);
+ 	}
+       }else{
+ 	for (sb=0; sb<21; sb++) {
+ 	  /* scalefac was copied into pinfo->sfb[] above */
+ 	  pinfo->sfb[gr][ch][sb] = pinfo->sfb_s[gr][ch][sb];
+ 	  if (gr_info->preflag) pinfo->sfb[gr][ch][sb] += pretab[sb];
+ 	  pinfo->sfb[gr][ch][sb] *= -ifqstep;
+ 	}
+       }
+     }
+ 
+ 
+     
+     pinfo->bitrate = 
+       tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index];
+     pinfo->sampfreq = freqs[sfreq];
+     pinfo->emph = fr->emphasis;
+     pinfo->crc = fr->error_protection;
+     pinfo->padding = fr->padding;
+     pinfo->stereo = fr->stereo;
+     pinfo->js =   (fr->mode == MPG_MD_JOINT_STEREO);
+     pinfo->ms_stereo = ms_stereo;
+     pinfo->i_stereo = i_stereo;
+     pinfo->maindata = sideinfo.main_data_begin;
+ 
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       pinfo->mixed[gr][ch] = gr_info->mixed_block_flag;
+       pinfo->mpg123blocktype[gr][ch]=gr_info->block_type;
+       pinfo->mainbits[gr][ch] = gr_info->part2_3_length;
+       if (gr==1) pinfo->scfsi[ch] = gr_info->scfsi;
+     }
+     for(ch=0;ch<stereo1;ch++) { 
+       int j=0;
+       for (sb=0;sb<SBLIMIT;sb++)
+ 	for(ss=0;ss<SSLIMIT;ss++,j++) 
+ 	  pinfo->mpg123xr[gr][ch][j]=hybridIn[ch][sb][ss];
+     }
+   }
+ 
+ #endif
+ 
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       III_antialias(hybridIn[ch],gr_info);
+       III_hybrid(hybridIn[ch], hybridOut[ch], ch,gr_info);
+     }
+ 
+     for(ss=0;ss<SSLIMIT;ss++) {
+       if(single >= 0) {
+         clip += synth_1to1_mono(hybridOut[0][ss],pcm_sample,pcm_point);
+       }
+       else {
+         int p1 = *pcm_point;
+         clip += synth_1to1(hybridOut[0][ss],0,pcm_sample,&p1);
+         clip += synth_1to1(hybridOut[1][ss],1,pcm_sample,pcm_point);
+       }
+     }
+   }
+   
+   return clip;
+ }
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/mpglib/main.c lame3.70/mpglib/main.c
*** encoder/mpglib/main.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/main.c	Thu Mar 16 17:05:38 2000
***************
*** 0 ****
--- 1,203 ----
+ #ifdef HAVEMPGLIB
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ #ifdef OS_AMIGAOS
+ #include "/lame.h"
+ #include "/util.h"
+ #include "/VbrTag.h"
+ #else
+ #include "../lame.h"
+ #include "../util.h"
+ #include "../VbrTag.h"
+ #endif /* OS_AMIGAOS */
+ 
+ #include <stdlib.h>
+ 
+ static char buf[16384];
+ #define FSIZE 8192  
+ static char out[FSIZE];
+ struct mpstr mp;
+ 
+ 
+ int is_syncword(char *header)
+ {
+ 
+ /*
+ unsigned int s0,s1;
+ s0 = (unsigned char) header[0];
+ s1 = (unsigned char) header[1] ;
+ printf(" syncword:  %2X   %2X   \n ",s0, s1);
+ */
+ 
+ /*
+ printf(" integer  %i \n",(int) ( header[0] == (char) 0xFF));
+ printf(" integer  %i \n",(int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ */
+ 
+ return 
+ ((int) ( header[0] == (char) 0xFF)) &&
+ ((int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ 
+ 
+ }
+ 
+ 
+ int lame_decode_initfile(FILE *fd, int *stereo, int *samp, int *bitrate, 
+ unsigned long *num_samples)
+ {
+   extern int tabsel_123[2][3][16];
+   VBRTAGDATA pTagData;
+   int ret,size,framesize;
+   unsigned long num_frames=0;
+   size_t len;
+   int xing_header;
+ 
+ 
+   InitMP3(&mp);
+   memset(buf, 0, sizeof(buf));
+   
+   /* skip RIFF type proprietary headers  */
+   /* look for sync word  FFF */
+   while (!is_syncword(buf)) {
+     buf[0]=buf[1]; 
+     if (fread(&buf[1],1,1,fd) == 0) return -1;  /* failed */
+   }
+   /*  ret = decodeMP3(&mp,buf,2,out,FSIZE,&size); */
+ 
+   /* read the header */
+   len = fread(&buf[2],1,46,fd);
+   if (len ==0 ) return -1;
+   len +=2;
+ 
+   /* check for Xing header */
+   xing_header = GetVbrTag(&pTagData,(unsigned char*)buf);
+   if (xing_header) {
+     num_frames=pTagData.frames;
+   }
+ 
+   size=0;
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+   if (size>0 && !xing_header) {
+     fprintf(stderr,"Opps: first frame of mpglib output will be lost \n");
+   }
+ 
+   *stereo = mp.fr.stereo;
+   *samp = freqs[mp.fr.sampling_frequency];
+   *bitrate = tabsel_123[mp.fr.lsf][mp.fr.lay-1][mp.fr.bitrate_index];
+   framesize = (mp.fr.lsf == 0) ? 1152 : 576;
+   *num_samples=MAX_U_32_NUM;
+   if (xing_header && num_frames) {
+     *num_samples=framesize * num_frames;
+   }
+ 
+   /*
+   printf("ret = %i NEED_MORE=%i \n",ret,MP3_NEED_MORE);
+   printf("stereo = %i \n",mp.fr.stereo);
+   printf("samp = %i  \n",(int)freqs[mp.fr.sampling_frequency]);
+   printf("framesize = %i  \n",framesize);
+   printf("num frames = %i  \n",(int)num_frames);
+   printf("num samp = %i  \n",(int)*num_samples);
+   */
+   return 0;
+ }
+ 
+ 
+ int lame_decode_init(void)
+ {
+   InitMP3(&mp);
+   memset(buf, 0, sizeof(buf));
+   return 0;
+ }
+ 
+ 
+ /*
+ For lame_decode_fromfile:  return code
+   -1     error
+    0     ok, but need more data before outputing any samples
+    n     number of samples output.  either 576 or 1152 depending on MP3 file.
+ */
+ int lame_decode_fromfile(FILE *fd, short pcm_l[], short pcm_r[])
+ {
+   int size,stereo;
+   int outsize=0,j,i,ret;
+   size_t len;
+ 
+   size=0;
+   len = fread(buf,1,64,fd);
+   if (len ==0 ) return 0;
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+ 
+   /* read more until we get a valid output frame */
+   while((ret == MP3_NEED_MORE) || !size) {
+     len = fread(buf,1,100,fd);
+     if (len ==0 ) return -1;
+     ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+     /* if (ret ==MP3_ERR) return -1;  lets ignore errors and keep reading... */
+     /*
+     printf("ret = %i size= %i  %i   %i  %i \n",ret,size,
+ 	   MP3_NEED_MORE,MP3_ERR,MP3_OK); 
+     */
+   }
+ 
+   stereo=mp.fr.stereo;
+ 
+   if (ret == MP3_OK) 
+   {
+     /*    write(1,out,size); */
+     outsize = size/(2*(stereo));
+     if ((outsize!=576) && (outsize!=1152)) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  Cant handle this... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	if (j==0) pcm_l[i] = ((short *) out)[mp.fr.stereo*i+j];
+ 	else pcm_r[i] = ((short *) out)[mp.fr.stereo*i+j];
+ 
+   }
+   if (ret==MP3_ERR) return -1;
+   else return outsize;
+ }
+ 
+ 
+ 
+ 
+ /*
+ For lame_decode:  return code
+   -1     error
+    0     ok, but need more data before outputing any samples
+    n     number of samples output.  either 576 or 1152 depending on MP3 file.
+ */
+ int lame_decode(char *buf,int len,short pcm_l[],short pcm_r[])
+ {
+   int size;
+   int outsize=0,j,i,ret;
+ 
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+   if (ret==MP3_OK) {
+     /*    printf("mpg123 output one frame out=%i \n",size/4);  */
+     outsize = size/(2*mp.fr.stereo);
+     if (outsize > 1152) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  shouldn't happen... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<mp.fr.stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	if (j==0) pcm_l[i] = ((short *) out)[mp.fr.stereo*i+j];
+ 	else pcm_r[i] = ((short *) out)[mp.fr.stereo*i+j];
+ 
+   }
+   /*
+   printf("ok, more, err:  %i %i %i  \n",MP3_OK, MP3_NEED_MORE, MP3_ERR);
+   printf("ret = %i out=%i \n",ret,outsize);
+   */
+   if (ret==MP3_ERR) return -1;
+   else return outsize;
+ }
+ 
+ #endif /* HAVEMPGLIB */
+ 
diff -r -c -N encoder/mpglib/mpg123.h lame3.70/mpglib/mpg123.h
*** encoder/mpglib/mpg123.h	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/mpg123.h	Sat Feb 19 06:33:12 2000
***************
*** 0 ****
--- 1,174 ----
+ #include        <stdio.h>
+ #include        <string.h>
+ #include        <signal.h>
+ 
+ 
+ #include        <math.h>
+ 
+ #ifndef M_PI
+ #define M_PI       3.14159265358979323846
+ #endif
+ #ifndef M_SQRT2
+ #define M_SQRT2    1.41421356237309504880
+ #endif
+ 
+ #ifdef _MSC_VER
+ #pragma warning( disable : 4244 )
+ #pragma warning( disable : 4305 )
+ # define REAL_IS_FLOAT
+ # define NEW_DCT9
+ 
+ # define random rand
+ # define srandom srand
+ 
+ #endif
+ 
+ #ifdef REAL_IS_FLOAT
+ #  define real float
+ #elif defined(REAL_IS_LONG_DOUBLE)
+ #  define real long double
+ #else
+ #  define real double
+ #endif
+ 
+ /* AUDIOBUFSIZE = n*64 with n=1,2,3 ...  */
+ #define		AUDIOBUFSIZE		16384
+ 
+ #define         FALSE                   0
+ #define         TRUE                    1
+ 
+ #define         SBLIMIT                 32
+ #define         SSLIMIT                 18
+ 
+ #define         MPG_MD_STEREO           0
+ #define         MPG_MD_JOINT_STEREO     1
+ #define         MPG_MD_DUAL_CHANNEL     2
+ #define         MPG_MD_MONO             3
+ 
+ #define MAXFRAMESIZE 1792
+ 
+ 
+ /* Pre Shift fo 16 to 8 bit converter table */
+ #define AUSHIFT (3)
+ 
+ struct frame {
+     int stereo;
+     int jsbound;
+     int single;
+     int lsf;
+     int mpeg25;
+     int header_change;
+     int lay;
+     int error_protection;
+     int bitrate_index;
+     int sampling_frequency;
+     int padding;
+     int extension;
+     int mode;
+     int mode_ext;
+     int copyright;
+     int original;
+     int emphasis;
+     int framesize; /* computed framesize */
+ };
+ 
+ struct parameter {
+ 	int quiet;	/* shut up! */
+ 	int tryresync;  /* resync stream after error */
+ 	int verbose;    /* verbose level */
+ 	int checkrange;
+ };
+ 
+ /* extern unsigned int   get1bit(void); */
+ extern unsigned int   getbits(int);
+ extern unsigned int   getbits_fast(int);
+ extern int set_pointer(long);
+ 
+ extern unsigned char *wordpointer;
+ extern int bitindex;
+ 
+ extern void make_decode_tables(long scaleval);
+ extern int do_layer3(struct frame *fr,unsigned char *,int *);
+ extern int decode_header(struct frame *fr,unsigned long newhead);
+ 
+ 
+ 
+ struct gr_info_s {
+       int scfsi;
+       unsigned part2_3_length;
+       unsigned big_values;
+       unsigned scalefac_compress;
+       unsigned block_type;
+       unsigned mixed_block_flag;
+       unsigned table_select[3];
+       unsigned subblock_gain[3];
+       unsigned maxband[3];
+       unsigned maxbandl;
+       unsigned maxb;
+       unsigned region1start;
+       unsigned region2start;
+       unsigned preflag;
+       unsigned scalefac_scale;
+       unsigned count1table_select;
+       real *full_gain[3];
+       real *pow2gain;
+ };
+ 
+ struct III_sideinfo
+ {
+   unsigned main_data_begin;
+   unsigned private_bits;
+   struct {
+     struct gr_info_s gr[2];
+   } ch[2];
+ };
+ 
+ extern int synth_1to1 (real *,int,unsigned char *,int *);
+ extern int synth_1to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_1to1_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_2to1 (real *,int,unsigned char *,int *);
+ extern int synth_2to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_2to1_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_4to1 (real *,int,unsigned char *,int *);
+ extern int synth_4to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_4to1_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_ntom (real *,int,unsigned char *,int *);
+ extern int synth_ntom_8bit (real *,int,unsigned char *,int *);
+ extern int synth_ntom_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern void rewindNbits(int bits);
+ extern int  hsstell(void);
+ extern int get_songlen(struct frame *fr,int no);
+ 
+ extern void init_layer3(int);
+ extern void init_layer2(void);
+ extern void make_decode_tables(long scale);
+ extern void make_conv16to8_table(int);
+ extern void dct64(real *,real *,real *);
+ 
+ extern void synth_ntom_set_step(long,long);
+ 
+ extern unsigned char *conv16to8;
+ extern long freqs[9];
+ extern real muls[27][64];
+ extern real decwin[512+32];
+ extern real *pnts[5];
+ 
+ extern struct parameter param;
+ 
+ 
diff -r -c -N encoder/mpglib/mpglib.dsp lame3.70/mpglib/mpglib.dsp
*** encoder/mpglib/mpglib.dsp	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/mpglib.dsp	Thu Mar 16 17:05:38 2000
***************
*** 0 ****
--- 1,164 ----
+ # Microsoft Developer Studio Project File - Name="mpglib" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Static Library" 0x0104
+ 
+ CFG=mpglib - Win32 Debug GTK
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak" CFG="mpglib - Win32 Debug GTK"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "mpglib - Win32 Release" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Debug" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Debug GTK" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Release GTK" (based on "Win32 (x86) Static Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ 
+ !IF  "$(CFG)" == "mpglib - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS"  /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Ox /Ot /Og /Oy /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "HAVEMPGLIB" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Debug GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "mpglib__"
+ # PROP BASE Intermediate_Dir "mpglib__"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "DebugGTK"
+ # PROP Intermediate_Dir "DebugGTK"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Z7 /Od /I "../WinGTK/glib-1.2" /I "../WinGTK/gtk-plus" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "HAVEGTK" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Release GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "mpglib_0"
+ # PROP BASE Intermediate_Dir "mpglib_0"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "ReleaseGTK"
+ # PROP Intermediate_Dir "ReleaseGTK"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "../WinGTK/glib-1.2" /I "../WinGTK/gtk-plus" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "HAVEGTK" /D "HAVEMPGLIB" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "mpglib - Win32 Release"
+ # Name "mpglib - Win32 Debug"
+ # Name "mpglib - Win32 Debug GTK"
+ # Name "mpglib - Win32 Release GTK"
+ # Begin Source File
+ 
+ SOURCE=.\common.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\dct64_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\decode_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\interface.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\layer3.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\main.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpg123.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpglib.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tabinit.c
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/mpglib/mpglib.h lame3.70/mpglib/mpglib.h
*** encoder/mpglib/mpglib.h	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/mpglib.h	Wed Jan  5 10:40:35 2000
***************
*** 0 ****
--- 1,49 ----
+ 
+ struct buf {
+         unsigned char *pnt;
+ 	long size;
+ 	long pos;
+         struct buf *next;
+         struct buf *prev;
+ };
+ 
+ struct framebuf {
+ 	struct buf *buf;
+ 	long pos;
+ 	struct frame *next;
+ 	struct frame *prev;
+ };
+ 
+ struct mpstr {
+ 	struct buf *head,*tail;
+ 	int bsize;
+ 	int framesize;
+         int fsizeold;
+ 	struct frame fr;
+         unsigned char bsspace[2][MAXFRAMESIZE+512]; /* MAXFRAMESIZE */
+ 	real hybrid_block[2][2][SBLIMIT*SSLIMIT];
+ 	int hybrid_blc[2];
+ 	unsigned long header;
+ 	int bsnum;
+ 	real synth_buffs[2][2][0x110];
+         int  synth_bo;
+ 	
+ };
+ 
+ 
+ #if ( defined(_MSC_VER) || defined(__BORLANDC__) )
+ 	typedef int BOOL; /* windef.h contains the same definition */
+ #else
+ 	#define BOOL int
+ #endif
+ 
+ #define MP3_ERR -1
+ #define MP3_OK  0
+ #define MP3_NEED_MORE 1
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp);
+ int decodeMP3(struct mpstr *mp,char *inmemory,int inmemsize,
+      char *outmemory,int outmemsize,int *done);
+ void ExitMP3(struct mpstr *mp);
+ 
diff -r -c -N encoder/mpglib/tabinit.c lame3.70/mpglib/tabinit.c
*** encoder/mpglib/tabinit.c	Wed Dec 31 17:00:00 1969
--- lame3.70/mpglib/tabinit.c	Mon Mar  6 12:53:03 2000
***************
*** 0 ****
--- 1,82 ----
+ #ifdef HAVEMPGLIB
+ #include <stdlib.h>
+ 
+ #include "mpg123.h"
+ 
+ real decwin[512+32];
+ static real cos64[16],cos32[8],cos16[4],cos8[2],cos4[1];
+ real *pnts[] = { cos64,cos32,cos16,cos8,cos4 };
+ 
+ #if 0
+ static unsigned char *conv16to8_buf = NULL;
+ unsigned char *conv16to8;
+ #endif
+ 
+ static long intwinbase[] = {
+      0,    -1,    -1,    -1,    -1,    -1,    -1,    -2,    -2,    -2,
+     -2,    -3,    -3,    -4,    -4,    -5,    -5,    -6,    -7,    -7,
+     -8,    -9,   -10,   -11,   -13,   -14,   -16,   -17,   -19,   -21,
+    -24,   -26,   -29,   -31,   -35,   -38,   -41,   -45,   -49,   -53,
+    -58,   -63,   -68,   -73,   -79,   -85,   -91,   -97,  -104,  -111,
+   -117,  -125,  -132,  -139,  -147,  -154,  -161,  -169,  -176,  -183,
+   -190,  -196,  -202,  -208,  -213,  -218,  -222,  -225,  -227,  -228,
+   -228,  -227,  -224,  -221,  -215,  -208,  -200,  -189,  -177,  -163,
+   -146,  -127,  -106,   -83,   -57,   -29,     2,    36,    72,   111,
+    153,   197,   244,   294,   347,   401,   459,   519,   581,   645,
+    711,   779,   848,   919,   991,  1064,  1137,  1210,  1283,  1356,
+   1428,  1498,  1567,  1634,  1698,  1759,  1817,  1870,  1919,  1962,
+   2001,  2032,  2057,  2075,  2085,  2087,  2080,  2063,  2037,  2000,
+   1952,  1893,  1822,  1739,  1644,  1535,  1414,  1280,  1131,   970,
+    794,   605,   402,   185,   -45,  -288,  -545,  -814, -1095, -1388,
+  -1692, -2006, -2330, -2663, -3004, -3351, -3705, -4063, -4425, -4788,
+  -5153, -5517, -5879, -6237, -6589, -6935, -7271, -7597, -7910, -8209,
+  -8491, -8755, -8998, -9219, -9416, -9585, -9727, -9838, -9916, -9959,
+  -9966, -9935, -9863, -9750, -9592, -9389, -9139, -8840, -8492, -8092,
+  -7640, -7134, -6574, -5959, -5288, -4561, -3776, -2935, -2037, -1082,
+    -70,   998,  2122,  3300,  4533,  5818,  7154,  8540,  9975, 11455,
+  12980, 14548, 16155, 17799, 19478, 21189, 22929, 24694, 26482, 28289,
+  30112, 31947, 33791, 35640, 37489, 39336, 41176, 43006, 44821, 46617,
+  48390, 50137, 51853, 53534, 55178, 56778, 58333, 59838, 61289, 62684,
+  64019, 65290, 66494, 67629, 68692, 69679, 70590, 71420, 72169, 72835,
+  73415, 73908, 74313, 74630, 74856, 74992, 75038 };
+ 
+ void make_decode_tables(long scaleval)
+ {
+   int i,j,k,kr,divv;
+   real *table,*costab;
+ 
+   
+   for(i=0;i<5;i++)
+   {
+     kr=0x10>>i; divv=0x40>>i;
+     costab = pnts[i];
+     for(k=0;k<kr;k++)
+       costab[k] = 1.0 / (2.0 * cos(M_PI * ((double) k * 2.0 + 1.0) / (double) divv));
+   }
+ 
+   table = decwin;
+   scaleval = -scaleval;
+   for(i=0,j=0;i<256;i++,j++,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ 
+   for( /* i=256 */ ;i<512;i++,j--,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ }
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/musicin.c lame3.70/musicin.c
*** encoder/musicin.c	Wed Jan 22 02:43:17 1997
--- lame3.70/musicin.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1151 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: musicin.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: musicin.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
-  *          Davis Pan                                                 *
-  * 3/06/91  Douglas Wong,       rename: setup.h to endef.h            *
-  *                              removed extraneous variables          *
-  * 3/21/91  J.Georges Fritsch   introduction of the bit-stream        *
-  *                              package. This package allows you      *
-  *                              to generate the bit-stream in a       *
-  *                              binary or ascii format                *
-  * 3/31/91  Bill Aspromonte     replaced the read of the SB matrix    *
-  *                              by an "code generated" one            *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Incorporated Jean-Georges Fritsch's   *
-  *                              "bitstream.c" package.                *
-  *                              Modified to strictly adhere to        *
-  *                              encoded bitstream specs, including    *
-  *                              "Berlin changes".                     *
-  *                              Modified user interface dialog & code *
-  *                              to accept any input & output          *
-  *                              filenames desired.  Also added        *
-  *                              de-emphasis prompt and final bail-out *
-  *                              opportunity before encoding.          *
-  *                              Added AIFF PCM sound file reading     *
-  *                              capability.                           *
-  *                              Modified PCM sound file handling to   *
-  *                              process all incoming samples and fill *
-  *                              out last encoded frame with zeros     *
-  *                              (silence) if needed.                  *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 27jun91  dpwe (Aware Inc)    Used new frame_params struct.         *
-  *                              Clear all automatic arrays.           *
-  *                              Changed some variable names,          *
-  *                              simplified some code.                 *
-  *                              Track number of bits actually sent.   *
-  *                              Fixed padding slot, stereo bitrate    *
-  *                              Added joint-stereo : scales L+R.      *
-  * 6/12/91  Earle Jennings      added fix for MS_DOS in obtain_param  *
-  * 6/13/91  Earle Jennings      added stack length adjustment before  *
-  *                              main for MS_DOS                       *
-  * 7/10/91  Earle Jennings      conversion of all float to FLOAT      *
-  *                              port to MsDos from MacIntosh completed*
-  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
-  * 8/22/91  Jens Spille         new obtain_parameters()               *
-  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
-  *          Don H. Lee,                                               *
-  *          Peter W. Farrett                                          *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  *                              newly introduced functions are        *
-  *                              I_CRC_calc, II_CRC_calc and encode_CRC*
-  *                              Additions and revisions are marked    *
-  *                              with "dhl" for clarity                *
-  *11/11/91 Katherine Wang       Documentation of code.                *
-  *                                (variables in documentation are     *
-  *                                surround by the # symbol, and an '*'*
-  *                                denotes layer I or II versions)     *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 2/25/92  Masahiro Iwadare    made code cleaner and more consistent *
-  * 8/07/92  Mike Coleman        make exit() codes return error status *
-  *                              made slight changes for portability   *
-  *19 aug 92 Soren H. Nielsen    Changed MS-DOS file name extensions.  *
-  * 8/25/92  Shaun Astarabadi    Replaced rint() function with explicit*
-  *                              rounding for portability with MSDOS.  *
-  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() calls.     *
-  *10/19/92  Masahiro Iwadare    added info->mode and info->mode_ext   *
-  *                              updates for AIFF format files         *
-  * 3/10/93  Kevin Peterson      In parse_args, only set non default   *
-  *                              bit rate if specified in arg list.    *
-  *                              Use return value from aiff_read_hdrs  *
-  *                              to fseek to start of sound data       *
-  * 7/26/93  Davis Pan           fixed bug in printing info->mode_ext  *
-  *                              value for joint stereo condition      *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  * 11/7/95 Soeren H. Nielsen    LSF added. Bug fix in MSDOS ext.      *
-  * 8/02/95 mc@fivebats.com      Changed default bitrate selection so  *
-  *                              it works with the new LSF stuff       *
-  *10/01/95 mc@fivebats.com      Added layer3                          *
-  **********************************************************************/
- 
- #ifdef MS_DOS
- #include <dos.h>
- #endif
- #include <stdlib.h>
- #include "common.h"
- #include "encoder.h"
- #include "l3psy.h"
- #include "mdct.h"
- #include "loop.h"
- #include "l3bitstream.h"
- #include <assert.h>
- 
- /* Global variable definitions for "musicin.c" */
- 
- FILE               *musicin;
- Bit_stream_struc   bs;
- char               *programName;
- 
- /* Implementations */
- 
- /************************************************************************
- *
- * obtain_parameters
- *
- * PURPOSE:  Prompts for and reads user input for encoding parameters
- *
- * SEMANTICS:  The parameters read are:
- * - input and output filenames
- * - sampling frequency (if AIFF file, will read from the AIFF file header)
- * - layer number
- * - mode (stereo, joint stereo, dual channel or mono)
- * - psychoacoustic model (I or II)
- * - total bitrate, irrespective of the mode
- * - de-emphasis, error protection, copyright and original or copy flags
- *
- ************************************************************************/
- 
- void
- obtain_parameters(fr_ps,psy,num_samples,original_file_name,encoded_file_name)
- frame_params    *fr_ps;
- int             *psy;
- unsigned long   *num_samples;
- char            original_file_name[MAX_NAME_SIZE];
- char            encoded_file_name[MAX_NAME_SIZE];
- {
-     int j;
-     long int freq;
-     int model, brt;
-     char t[50];
-     IFF_AIFF pcm_aiff_data;
-     layer *info = fr_ps->header;
-     long soundPosition;
- #ifdef  MS_DOS
-     char temp_str[MAX_NAME_SIZE];
- #endif 
- 
-     do  {
-        printf("Enter PCM input file name <required>: ");
-        gets(original_file_name);
-        if (original_file_name[0] == NULL_CHAR)
-        printf("PCM input file name is required.\n");
-     } while (original_file_name[0] == NULL_CHAR);
-     printf(">>> PCM input file name is: %s\n", original_file_name);
-  
-     if ((musicin = fopen(original_file_name, "rb")) == NULL) {
-        printf("Could not find \"%s\".\n", original_file_name);
-        exit(1);
-     }
- 
- #ifdef  MS_DOS
-     /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
-     new_ext(original_file_name, DFLT_EXT, temp_str);
-     printf("Enter MPEG encoded output file name <%s>: ",
-            temp_str);
- #else
-     printf("Enter MPEG encoded output file name <%s%s>: ",
-            original_file_name, DFLT_EXT);
- #endif
-  
-     gets(encoded_file_name);
-     
-     if (encoded_file_name[0] == NULL_CHAR) {
- #ifdef  MS_DOS
-   strcpy(encoded_file_name, temp_str);
- #else
-         strcat(strcpy(encoded_file_name, original_file_name), DFLT_EXT);
- #endif
-     }
-         
- 
-     printf(">>> MPEG encoded output file name is: %s\n", encoded_file_name);
-  
-     open_bit_stream_w(&bs, encoded_file_name, BUFFER_SIZE);
-  
-     if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
- 
-        printf(">>> Using Audio IFF sound file headers\n");
- 
-        aiff_check(original_file_name, &pcm_aiff_data, &info->version);
- 
-        if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
-           printf("Could not seek to PCM sound data in \"%s\".\n",
-                  original_file_name);
-           exit(1);
-        }
- 
-        info->sampling_frequency =
-       SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
-        printf(">>> %f Hz sampling frequency selected\n",
-               pcm_aiff_data.sampleRate);
- 
-        /* Determine number of samples in sound file */
- #ifndef MS_DOS
-        *num_samples = pcm_aiff_data.numChannels *
-                       pcm_aiff_data.numSampleFrames;
- #else
-        *num_samples = (long)(pcm_aiff_data.numChannels) *
-                       (long)(pcm_aiff_data.numSampleFrames);
- #endif
- 
-     }
-     else {    /* Not using Audio IFF sound file headers. */
- 
-        printf("What is the sampling frequency? <44100>[Hz]: ");
-        gets(t);
-        freq = atol(t);
-        switch (freq) {
-           case 48000 : info->sampling_frequency = 1;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 44100 : info->sampling_frequency = 0;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 32000 : info->sampling_frequency = 2;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 24000 : info->sampling_frequency = 1;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 22050 : info->sampling_frequency = 0;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 16000 : info->sampling_frequency = 2;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           default:    info->sampling_frequency = 0;
-               printf(">>> Default 44.1 kHz samp freq selected\n");
-        }
-        printf(">>> Encoding algorithm is %s\n", version_names[info->version]);
-        if (fseek(musicin, 0, SEEK_SET) != 0) {
-           printf("Could not seek to PCM sound data in \"%s\".\n",
-                   original_file_name);
-           exit(1);
-        }
-  
-        /* Declare sound file to have "infinite" number of samples. */
-        *num_samples = MAX_U_32_NUM;
- 
-     }
- 
-     printf("Which layer do you want to use?\n");
-     printf("Available: Layer (1), Layer (<2>), Layer (3): ");
-     gets(t);
-     switch(*t){
-        case '1': info->lay = 1; printf(">>> Using Layer %s\n",t); break;
-        case '2': info->lay = 2; printf(">>> Using Layer %s\n",t); break;
-      case '3': info->lay = 3; printf(">>> Using Layer %s\n",t); break;
-        default:  info->lay = 2; printf(">>> Using default Layer 2\n"); break;
-     }
- 
-     printf("Which mode do you want?\n");
-     printf("Available: (<s>)tereo, (j)oint stereo, ");
-     printf("(d)ual channel, s(i)ngle Channel: ");
-     gets(t);
-     switch(*t){
-        case 's':
-        case 'S':
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'j':
-        case 'J':
-           info->mode = MPG_MD_JOINT_STEREO;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'd':
-        case 'D':
-           info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'i':
-        case 'I':
-           info->mode = MPG_MD_MONO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        default:
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using default stereo mode\n");
-           break;
-     }
- 
-     printf("Which psychoacoustic model do you want to use? <1>: ");
-     gets(t);
-     model = atoi(t);
-     if (model > 2 || model < 1) {
-        printf(">>> Default model 1 selected\n");
-        *psy = 1;
-     }
-     else {
-        *psy = model;
-        printf(">>> Using psychoacoustic model %d\n", model);
-     }
-     
-     /* set default bitrate to highest allowed, which is index 14 */
-   brt = bitrate[info->version][info->lay-1][14];
-     printf( "What is the total bitrate? <%u>[kbps]: ", brt );
-     gets( t );
-     brt = atoi( t );
-     if ( brt == 0 )
-       j = 15;
-     else
-       j = 0;
-     while ( j < 15 )
-     {
-     if ( bitrate[info->version][info->lay-1][j] == brt )
-           break;
-     j++;
-     }
-     if ( j == 15 )
-     {
-     brt = bitrate[info->version][info->lay-1][14];
-         printf( ">>> Using default %u kbps\n", brt );
-         info->bitrate_index = 14;
-     }
-     else
-     {
-        info->bitrate_index = j;
-        printf( ">>> Bitrate = %d kbps\n", bitrate[info->version][info->lay-1][j] );
-     }
-  
-     printf("What type of de-emphasis should the decoder use?\n");
-     printf("Available: (<n>)one, (5)0/15 microseconds, (c)citt j.17: ");
-     gets(t);
-     if (*t != 'n' && *t != '5' && *t != 'c') {
-        printf(">>> Using default no de-emphasis\n");
-        info->emphasis = 0;
-     }
-     else {
-        if (*t == 'n')      info->emphasis = 0;
-        else if (*t == '5') info->emphasis = 1;
-        else if (*t == 'c') info->emphasis = 3;
-        printf(">>> Using de-emphasis %s\n",t);
-     }
-  
- /*  Start 2. Part changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want to set the private bit? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->extension = 1;
-     else                        info->extension = 0;
-     if(info->extension) printf(">>> Private bit set\n");
-     else                printf(">>> Private bit not set\n");
-  
- /*  End changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want error protection? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->error_protection = TRUE;
-     else                        info->error_protection = FALSE;
-     if(info->error_protection) printf(">>> Error protection used\n");
-     else printf(">>> Error protection not used\n");
-  
-     printf("Is the material copyrighted? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->copyright = 1;
-     else                        info->copyright = 0;
-     if(info->copyright) printf(">>> Copyrighted material\n");
-     else                printf(">>> Material not copyrighted\n");
-  
-     printf("Is this the original? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->original = 1;
-     else                        info->original = 0;
-     if(info->original) printf(">>> Original material\n");
-     else               printf(">>> Material not original\n");
-  
-     printf("Do you wish to exit (last chance before encoding)? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') exit(0);
- }
- 
- /************************************************************************
- *
- * parse_args
- *
- * PURPOSE:  Sets encoding parameters to the specifications of the
- * command line.  Default settings are used for parameters
- * not specified in the command line.
- *
- * SEMANTICS:  The command line is parsed according to the following
- * syntax:
- *
- * -l  is followed by the layer number
- * -m  is followed by the mode
- * -p  is followed by the psychoacoustic model number
- * -s  is followed by the sampling rate
- * -b  is followed by the total bitrate, irrespective of the mode
- * -d  is followed by the emphasis flag
- * -c  is followed by the copyright/no_copyright flag
- * -o  is followed by the original/not_original flag
- * -e  is followed by the error_protection on/off flag
- *
- * If the input file is in AIFF format, the sampling frequency is read
- * from the AIFF header.
- *
- * The input and output filenames are read into #inpath# and #outpath#.
- *
- ************************************************************************/
-  
- void
- parse_args(argc, argv, fr_ps, psy, num_samples, inPath, outPath)
- int     argc;
- char    **argv;
- frame_params  *fr_ps;
- int     *psy;
- unsigned long *num_samples;
- char    inPath[MAX_NAME_SIZE];
- char    outPath[MAX_NAME_SIZE];
- {
-    FLOAT srate;
-    int   brate;
-    layer *info = fr_ps->header;
-    int   err = 0, i = 0;
-    IFF_AIFF pcm_aiff_data;
-    long samplerate;
-    long soundPosition;
-  
-    /* preset defaults */
-    inPath[0] = '\0';   outPath[0] = '\0';
-    info->lay = DFLT_LAY;
-    switch(DFLT_MOD) {
-       case 's': info->mode = MPG_MD_STEREO; info->mode_ext = 0; break;
-       case 'd': info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; break;
-       case 'j': info->mode = MPG_MD_JOINT_STEREO; break;
-       case 'm': info->mode = MPG_MD_MONO; info->mode_ext = 0; break;
-       default:
-          fprintf(stderr, "%s: Bad mode dflt %c\n", programName, DFLT_MOD);
-          abort();
-    }
-    *psy = DFLT_PSY;
-    if((info->sampling_frequency = SmpFrqIndex((long)(1000*DFLT_SFQ), &info->version)) < 0) {
-       fprintf(stderr, "%s: bad sfrq default %.2f\n", programName, DFLT_SFQ);
-       abort();
-    }
-   info->bitrate_index = 14;
-   brate = 0;
-    switch(DFLT_EMP) {
-       case 'n': info->emphasis = 0; break;
-       case '5': info->emphasis = 1; break;
-       case 'c': info->emphasis = 3; break;
-       default: 
-          fprintf(stderr, "%s: Bad emph dflt %c\n", programName, DFLT_EMP);
-          abort();
-    }
-    info->copyright = 0; info->original = 0; info->error_protection = FALSE;
-  
-    /* process args */
-    while(++i<argc && err == 0) {
-       char c, *token, *arg, *nextArg;
-       int  argUsed;
-  
-       token = argv[i];
-       if(*token++ == '-') {
-          if(i+1 < argc) nextArg = argv[i+1];
-          else           nextArg = "";
-          argUsed = 0;
-          while( (c = *token++) ) {
-             if(*token /* NumericQ(token) */) arg = token;
-             else                             arg = nextArg;
-             switch(c) {
-                case 'l':        info->lay = atoi(arg); argUsed = 1;
-                   if(info->lay<1 || info->lay>3) {
-                      fprintf(stderr,"%s: -l layer must be 1, 2, or 3, not %s\n",
-                           programName, arg);
-                      err = 1;
-                   }
-                   break;
-                case 'm':        argUsed = 1;
-                   if (*arg == 's')
-                     { info->mode = MPG_MD_STEREO; info->mode_ext = 0; }
-                   else if (*arg == 'd')
-                     { info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; }
-                   else if (*arg == 'j')
-                     { info->mode = MPG_MD_JOINT_STEREO; }
-                   else if (*arg == 'm')
-                     { info->mode = MPG_MD_MONO; info->mode_ext = 0; }
-                   else {
-                     fprintf(stderr,"%s: -m mode must be s/d/j/m not %s\n",
-                             programName, arg);
-                     err = 1;
-                   }
-                   break;
-                case 'p':        *psy = atoi(arg); argUsed = 1;
-                   if(*psy<1 || *psy>2) {
-                      fprintf(stderr,"%s: -p model must be 1 or 2, not %s\n",
-                              programName, arg);
-                      err = 1;
-                   }
-                   break;
- 
-                case 's':
-                   argUsed = 1;
-                   srate = atof( arg );
-                   /* samplerate = rint( 1000.0 * srate ); $A  */
-                   samplerate = (long) (( 1000.0 * srate ) + 0.5);
-                   if( (info->sampling_frequency =
-           SmpFrqIndex((long) samplerate, &info->version)) < 0 )
-                       err = 1;
-                   break;
-                   
-                case 'b':        
-         argUsed = 1;
-       brate = atoi(arg); 
-       break;
-                case 'd':        argUsed = 1;
-                   if (*arg == 'n')                    info->emphasis = 0;
-                   else if (*arg == '5')               info->emphasis = 1;
-                   else if (*arg == 'c')               info->emphasis = 3;
-                   else {
-                      fprintf(stderr,"%s: -d emp must be n/5/c not %s\n",
-                              programName, arg);
-                      err = 1;
-                   }
-                   break;
-                 case 'c':       info->copyright = 1; break;
-                 case 'o':       info->original  = 1; break;
-                 case 'e':       info->error_protection = TRUE; break;
-                 default:        fprintf(stderr,"%s: unrec option %c\n",
-                                         programName, c);
-                                 err = 1; break;
-             }
-             if(argUsed) {
-                if(arg == token)    token = "";   /* no more from token */
-                else                ++i;          /* skip arg we used */
-                arg = ""; argUsed = 0;
-             }
-          }
-       }
-       else {
-          if(inPath[0] == '\0')       strcpy(inPath, argv[i]);
-          else if(outPath[0] == '\0') strcpy(outPath, argv[i]);
-          else {
-             fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
-             err = 1;
-          }
-       }
-    }
- 
-    if(err || inPath[0] == '\0') usage();  /* never returns */
-  
-    if(outPath[0] == '\0') {
- #ifdef MS_DOS
-       /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
-       new_ext(inPath, DFLT_EXT, outPath);
- #else
-       strcpy(outPath, inPath);
-       strcat(outPath, DFLT_EXT);
- #endif
-    }
- 
-    if ((musicin = fopen(inPath, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", inPath);
-       exit(1);
-    }
-  
-    open_bit_stream_w(&bs, outPath, BUFFER_SIZE);
- 
-    if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
- 
-       printf(">>> Using Audio IFF sound file headers\n");
- 
-       aiff_check(inPath, &pcm_aiff_data, &info->version);
- 
-       if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
-          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
-          exit(1);
-       }
- 
-       info->sampling_frequency = SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
-       printf(">>> %f Hz sampling frequency selected\n",
-              pcm_aiff_data.sampleRate);
- 
-       /* Determine number of samples in sound file */
- #ifndef MS_DOS
-       *num_samples = pcm_aiff_data.numChannels *
-                      pcm_aiff_data.numSampleFrames;
- #else
-       *num_samples = (long)(pcm_aiff_data.numChannels) *
-                      (long)(pcm_aiff_data.numSampleFrames);
- #endif
-       if ( pcm_aiff_data.numChannels == 1 ) {
-         info->mode = MPG_MD_MONO;
-         info->mode_ext = 0;
-       }
-    }
-    else {    /* Not using Audio IFF sound file headers. */
- 
-       if (fseek(musicin, 0, SEEK_SET) != 0) {
-          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
-          exit(1);
-       }
-  
-       /* Declare sound file to have "infinite" number of samples. */
-       *num_samples = MAX_U_32_NUM;
- 
-    }
-    if ( brate == 0 )
-     brate = bitrate[info->version][info->lay-1][14];
-    if( (info->bitrate_index = BitrateIndex(info->lay, brate, info->version)) < 0) err=1;
-    if(err || inPath[0] == '\0') usage();  /* never returns */
- 
- }
- 
- /************************************************************************
- *
- * print_config
- *
- * PURPOSE:  Prints the encoding parameters used
- *
- ************************************************************************/
-  
- void print_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
- {
-  layer *info = fr_ps->header;
-  
-    printf("Encoding configuration:\n");
-    printf("Algorithm=%s\n", version_names[info->version]);
-    if(info->mode != MPG_MD_JOINT_STEREO)
-       printf("Layer=%s   mode=%s   extn=%d   psy model=%d\n",
-              layer_names[info->lay-1], mode_names[info->mode],
-              info->mode_ext, *psy);
-    else printf("Layer=%s   mode=%s   extn=data dependant   psy model=%d\n",
-                layer_names[info->lay-1], mode_names[info->mode], *psy);
-    printf("samp frq=%.1f kHz   total bitrate=%d kbps\n",
-           s_freq[info->version][info->sampling_frequency],
-           bitrate[info->version][info->lay-1][info->bitrate_index]);
-    printf("de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",
-           info->emphasis, info->copyright, info->original,
-           ((info->error_protection) ? "on" : "off"));
-    printf("input file: '%s'   output file: '%s'\n", inPath, outPath);
- }
- 
- 
- 
- 
-  
- /************************************************************************
- *
- * main
- *
- * PURPOSE:  MPEG I Encoder supporting layers 1 and 2, and 3, with
- * psychoacoustic models 1 (MUSICAM) and 2 (AT&T)
- *
- * SEMANTICS:  One overlapping frame of audio of up to 2 channels are
- * processed at a time in the following order:
- * (associated routines are in parentheses)
- *
- * 1.  Filter sliding window of data to get 32 subband
- * samples per channel.
- * (window_subband,filter_subband)
- *
- * 2.  If joint stereo mode, combine left and right channels
- * for subbands above #jsbound#.
- * (*_combine_LR)
- *
- * 3.  Calculate scalefactors for the frame, and if layer 2,
- * also calculate scalefactor select information.
- * (*_scale_factor_calc)
- *
- * 4.  Calculate psychoacoustic masking levels using selected
- * psychoacoustic model.
- * (*_Psycho_One, psycho_anal)
- *
- * 5.  Perform iterative bit allocation for subbands with low
- * mask_to_noise ratios using masking levels from step 4.
- * (*_main_bit_allocation)
- *
- * 6.  If error protection flag is active, add redundancy for
- * error protection.
- * (*_CRC_calc)
- *
- * 7.  Pack bit allocation, scalefactors, and scalefactor select
- * information (layer 2) onto bitstream.
- * (*_encode_bit_alloc,*_encode_scale,II_transmission_pattern)
- *
- * 8.  Quantize subbands and pack them into bitstream
- * (*_subband_quantization, *_sample_encoding)
- *
- ************************************************************************/
- 
- int frameNum=0;
- 
- void main(argc, argv)
- int     argc;
- char    **argv;
- {
-     typedef double SBS[2][3][SCALE_BLOCK][SBLIMIT];
-     SBS  FAR        *sb_sample;
-     L3SBS  FAR        *l3_sb_sample;
-     typedef double JSBS[3][SCALE_BLOCK][SBLIMIT];
-     JSBS FAR        *j_sample;
-     typedef double IN[2][HAN_SIZE];
-     IN   FAR        *win_que;
-     typedef unsigned int SUB[2][3][SCALE_BLOCK][SBLIMIT];
-     SUB  FAR        *subband;
-     
-     frame_params fr_ps;
-     layer info;
-     char original_file_name[MAX_NAME_SIZE];
-     char encoded_file_name[MAX_NAME_SIZE];
-     short FAR **win_buf;
-     static short FAR buffer[2][1152];
-     static unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
-     static unsigned int scalar[2][3][SBLIMIT], j_scale[3][SBLIMIT];
-     static double FAR ltmin[2][SBLIMIT], lgmin[2][SBLIMIT], max_sc[2][SBLIMIT];
-     FLOAT snr32[32];
-     short sam[2][1344]; /* was [1056]; */
-     int whole_SpF, extra_slot = 0;
-     double avg_slots_per_frame, frac_SpF, slot_lag;
-     int model, stereo, error_protection;
-     static unsigned int crc;
-     int i, j, k, adb;
-     unsigned long bitsPerSlot, samplesPerFrame;
-     unsigned long frameBits, sentBits = 0;
-     unsigned long num_samples;
-     
- #ifdef  MACINTOSH
-     argc = ccommand( &argv );
- #endif
-     
- 
-     /* Most large variables are declared dynamically to ensure
-        compatibility with smaller machines */
-     
-     sb_sample = (SBS FAR *) mem_alloc(sizeof(SBS), "sb_sample");
-     l3_sb_sample = (L3SBS FAR *) mem_alloc(sizeof(SBS), "l3_sb_sample");
-     j_sample = (JSBS FAR *) mem_alloc(sizeof(JSBS), "j_sample");
-     win_que = (IN FAR *) mem_alloc(sizeof(IN), "Win_que");
-     subband = (SUB FAR *) mem_alloc(sizeof(SUB),"subband");
-     win_buf = (short FAR **) mem_alloc(sizeof(short *)*2, "win_buf");
-  
-     /* clear buffers */
-     memset((char *) buffer, 0, sizeof(buffer));
-     memset((char *) bit_alloc, 0, sizeof(bit_alloc));
-     memset((char *) scalar, 0, sizeof(scalar));
-     memset((char *) j_scale, 0, sizeof(j_scale));
-     memset((char *) scfsi, 0, sizeof(scfsi));
-     memset((char *) ltmin, 0, sizeof(ltmin));
-     memset((char *) lgmin, 0, sizeof(lgmin));
-     memset((char *) max_sc, 0, sizeof(max_sc));
-     memset((char *) snr32, 0, sizeof(snr32));
-     memset((char *) sam, 0, sizeof(sam));
-  
-     fr_ps.header = &info;
-     fr_ps.tab_num = -1;             /* no table loaded */
-     fr_ps.alloc = NULL;
-     info.version = MPEG_AUDIO_ID;   /* Default: MPEG-1 */
- 
-     programName = argv[0];
-     if(argc==1)     /* no command-line args */
-        obtain_parameters(&fr_ps, &model, &num_samples,
-                          original_file_name, encoded_file_name);
-     else
- 	parse_args(argc, argv, &fr_ps, &model, &num_samples,
- 		   original_file_name, encoded_file_name);
-     print_config(&fr_ps, &model,
-                  original_file_name, encoded_file_name);
-     
-     hdr_to_frps(&fr_ps);
-     stereo = fr_ps.stereo;
-     error_protection = info.error_protection;
-     
-     if (info.lay == 1)
-     { bitsPerSlot = 32; samplesPerFrame = 384;  }
-     else 
- 	if ( info.lay == 2 )
- 	{ bitsPerSlot = 8;  samplesPerFrame = 1152; }
- 	else	
- 	{  /* layer 3 */
- 	    bitsPerSlot = 8;
- 	    samplesPerFrame = info.version == 1 ? 1152 : 576;
- 	    
- 	    /* Apologize for missing features */
- 	    if ( info.mode == MPG_MD_JOINT_STEREO )
- 	    {
- 		fprintf( stderr, "Sorry, joint stereo not yet available for layer3\n" );
- 		exit( 1 );
- 	    }
- #if 0
- 	    if ( info.version != MPEG_AUDIO_ID )
- 	    {
- 		fprintf( stderr, "Sorry, MPEG2-LSF not yet available for layer3\n" );
- 		exit( 1 );
- 	    }
- #endif
- 	    if ( model != 2 )
- 	    {
- 		fprintf( stderr, "Sorry, psycho model 1 not available for layer3\n" );
- 		exit( 1 );
- 	    }
- 	}
-     /* Figure average number of 'slots' per frame. */
-     /* Bitrate means TOTAL for both channels, not per side. */
-     avg_slots_per_frame = ((double)samplesPerFrame /
-                            s_freq[info.version][info.sampling_frequency]) *
- 			   ((double)bitrate[info.version][info.lay-1][info.bitrate_index] /
- 			    (double)bitsPerSlot);
-     whole_SpF = (int) avg_slots_per_frame;
-     printf("slots/frame = %d\n",whole_SpF);
-     frac_SpF  = avg_slots_per_frame - (double)whole_SpF;
-     slot_lag  = -frac_SpF;
-     printf("frac SpF=%.3f, tot bitrate=%d kbps, s freq=%.1f kHz\n",
-            frac_SpF, bitrate[info.version][info.lay-1][info.bitrate_index],
-            s_freq[info.version][info.sampling_frequency]);
-     
-     if (frac_SpF != 0)
- 	printf("Fractional number of slots, padding required\n");
-     else info.padding = 0;
-     
-     while ( get_audio(musicin, buffer, num_samples, stereo, &info) > 0 )
-     {
- 	fprintf(stderr, "{%4lu}", frameNum++); fflush(stderr);
- 	win_buf[0] = &buffer[0][0];
- 	win_buf[1] = &buffer[1][0];
- 	if (frac_SpF != 0) {
- 	    if (slot_lag > (frac_SpF-1.0) ) {
- 		slot_lag -= frac_SpF;
- 		extra_slot = 0;
- 		info.padding = 0;
- 		/*  printf("No padding for this frame\n"); */
- 	    }
- 	    else {
- 		extra_slot = 1;
- 		info.padding = 1;
- 		slot_lag += (1-frac_SpF);
- 		/*  printf("Padding for this frame\n");    */
- 	    }
- 	}
- 	adb = (whole_SpF+extra_slot) * bitsPerSlot;
- 	
- 	switch (info.lay)
- 	{
- 	    
- /***************************** Layer I **********************************/
- 	    
-           case 1 :
- 	    for (j=0;j<SCALE_BLOCK;j++)
- 		for (k=0;k<stereo;k++) {
- 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
- 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][0][j][0]);
- 		}
- 	    
- 	    I_scale_factor_calc(*sb_sample, scalar, stereo);
- 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
-                 I_combine_LR(*sb_sample, *j_sample);
-                 I_scale_factor_calc(j_sample, &j_scale, 1);
- 	    }
- 	    
- 	    put_scale(scalar, &fr_ps, max_sc);
- 	    
- 	    if (model == 1) I_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
- 	    else {
-                 for (k=0;k<stereo;k++) {
- 		    psycho_anal(&buffer[k][0],&sam[k][0], k, info.lay, snr32,
- 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
- 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
-                 }
- 	    }
- 	    
- 	    I_main_bit_allocation(ltmin, bit_alloc, &adb, &fr_ps);
- 	    
- 	    if (error_protection) I_CRC_calc(&fr_ps, bit_alloc, &crc);
- 	    
- 	    encode_info(&fr_ps, &bs);
- 	    
- 	    if (error_protection) encode_CRC(crc, &bs);
- 	    
- 	    I_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
- 	    I_encode_scale(scalar, bit_alloc, &fr_ps, &bs);
- 	    I_subband_quantization(scalar, *sb_sample, j_scale, *j_sample,
- 				   bit_alloc, *subband, &fr_ps);
- 	    I_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
- 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
- 	    break;
- 	    
- /***************************** Layer 2 **********************************/
- 	    
-           case 2 :
- 	    for (i=0;i<3;i++) for (j=0;j<SCALE_BLOCK;j++)
-                 for (k=0;k<stereo;k++) {
- 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
- 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][i][j][0]);
-                 }
- 	    
- 	    II_scale_factor_calc(*sb_sample, scalar, stereo, fr_ps.sblimit);
- 	    pick_scale(scalar, &fr_ps, max_sc);
- 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
- 		II_combine_LR(*sb_sample, *j_sample, fr_ps.sblimit);
- 		II_scale_factor_calc(j_sample, &j_scale, 1, fr_ps.sblimit);
- 	    }       /* this way we calculate more mono than we need */
- 	    /* but it is cheap */
- 	    
- 	    if (model == 1) II_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
- 	    else {
- 		for (k=0;k<stereo;k++) {
- 		    psycho_anal(&buffer[k][0],&sam[k][0], k, 
- 				info.lay, snr32,
- 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
- 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
- 		}
- 	    }
- 	    
- 	    II_transmission_pattern(scalar, scfsi, &fr_ps);
- 	    II_main_bit_allocation(ltmin, scfsi, bit_alloc, &adb, &fr_ps);
- 	    
- 	    if (error_protection)
- 		II_CRC_calc(&fr_ps, bit_alloc, scfsi, &crc);
- 	    
- 	    encode_info(&fr_ps, &bs);
- 	    
- 	    if (error_protection) encode_CRC(crc, &bs);
- 	    
- 	    II_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
- 	    II_encode_scale(bit_alloc, scfsi, scalar, &fr_ps, &bs);
- 	    II_subband_quantization(scalar, *sb_sample, j_scale,
- 				    *j_sample, bit_alloc, *subband, &fr_ps);
- 	    II_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
- 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
- 	    break;
- 	    
- /***************************** Layer 3 **********************************/
- 
- 	  case 3:
- 	  {
- 	      /*
- 		large "auto" vars are static due to the Macintosh linker
- 	      */ 
- 	      static double xr[2][2][576];
- 	      static double xr_dec[2][2][576];
- 	      static double pe[2][2];
- 	      static int l3_enc[2][2][576];
- 	      static III_psy_ratio ratio;
- 	      static III_side_info_t l3_side;
- 	      static III_scalefac_t  scalefac;
- 	      int gr, mode_gr, ch;
- 	      int mean_bits, sideinfo_len;
- 	      
- 	      int bitsPerFrame = 8 * whole_SpF + (info.padding * 8);
- 	      mode_gr = (info.version == 1) ? 2 : 1;
- 
- 	      /*
- 		determine the mean bitrate for main data
- 	      */
- 	      sideinfo_len = 32;
- 	      if ( info.version == 1 )
- 	      {   /* MPEG 1 */
- 		  if ( stereo == 1 )
- 		      sideinfo_len += 136;
- 		  else
- 		      sideinfo_len += 256;
- 	      }
- 	      else
- 	      {   /* MPEG 2 */
- 		  if ( stereo == 1 )
- 		      sideinfo_len += 72;
- 		  else
- 		      sideinfo_len += 136;
- 	      }
- 	      if ( info.error_protection )
- 		  sideinfo_len += 16;
- 	      mean_bits = (bitsPerFrame - sideinfo_len) / mode_gr;
- 
- 	      /*
- 		psychoacoustic model
- 	      */
- 	      for ( gr = 0; gr < mode_gr; gr++ )
- 		  for ( ch = 0; ch < stereo; ch++ )
- 		  {
- 		      L3psycho_anal( &buffer[ch][gr*576], &sam[ch][0], ch, info.lay,
- 				     snr32, s_freq[info.version][info.sampling_frequency] * 1000.0,
- 				     &ratio.l[gr][ch][0], &ratio.s[gr][ch][0],
- 				     &pe[gr][ch], &l3_side.gr[gr].ch[ch].tt );
- 		  }
- 
- 	      /*
- 		polyphase filtering
- 	      */
- 	      for( gr = 0; gr < mode_gr; gr++ )
- 		  for ( ch = 0; ch < stereo; ch++ )
- 		      for ( j = 0; j < 18; j++ )
- 		      {
- 			  window_subband( &win_buf[ch], &(*win_que)[ch][0], ch );
- 			  filter_subband( &(*win_que)[ch][0],  &(*l3_sb_sample)[ch][gr+1][j][0] );
- 		      }
- 
- 	      /*
- 		apply mdct to the polyphase outputs
- 	      */
- 	      mdct_sub( l3_sb_sample, xr, stereo, &l3_side, mode_gr );
- #if 0
- 	      delay( xr, stereo );
- #endif
- 	      /*
- 		bit and noise allocation
- 	      */
- 	      iteration_loop( pe, xr, &ratio, &l3_side, l3_enc, mean_bits,
- 			      stereo, xr_dec, &scalefac, &fr_ps, 0, bitsPerFrame );
- 
- 	      /*
- 		write the frame to the bitstream
- 	      */
- 	      III_format_bitstream( bitsPerFrame, &fr_ps, l3_enc, &l3_side, &scalefac, &bs,
- 				    xr, NULL, 0 );
- 	  }
- 	    break;  /* end of layer 3 */
- 	    
- 
- 	} /* end switch  */
- 	
- 	frameBits = sstell( &bs ) - sentBits;
- 	if ( frameBits % bitsPerSlot )   /* a program failure */
- 	    fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
- 		     frameBits, frameBits/bitsPerSlot,
- 		     frameBits%bitsPerSlot );
- 	sentBits += frameBits;
- 
-     }    
- 
-     if ( info.lay == 3 )
- 	III_FlushBitstream();
- 
-     close_bit_stream_w( &bs );
- 
-     printf("Avg slots/frame = %.3f; b/smp = %.2f; br = %.3f kbps\n",
-            (FLOAT) sentBits / (frameNum * bitsPerSlot),
-            (FLOAT) sentBits / (frameNum * samplesPerFrame),
-            (FLOAT) sentBits / (frameNum * samplesPerFrame) *
-            s_freq[info.version][info.sampling_frequency]);
- 
-     if (fclose(musicin) != 0){
- 	printf("Could not close \"%s\".\n", original_file_name);
- 	exit(2);
-     }
- 
- #ifdef  MACINTOSH
-     set_mac_file_attr( encoded_file_name, VOL_REF_NUM, CREATOR_ENCODE,
- 		       FILETYPE_ENCODE );
- #endif
- 
-     printf("Encoding of \"%s\" with psychoacoustic model %d is finished\n",
-            original_file_name, model);
-     printf("The MPEG encoded output file name is \"%s\"\n",
- 	   encoded_file_name);
-     exit(0);
- }
-  
- /************************************************************************
- *
- * usage
- *
- * PURPOSE:  Writes command line syntax to the file specified by #stderr#
- *
- ************************************************************************/
- 
- void usage()  /* print syntax & exit */
- {
-     fprintf(stderr,
-     "usage: %s                         queries for all arguments, or\n",
-             programName);
-     fprintf(stderr,
-     "       %s [-l lay][-m mode][-p psy][-s sfrq][-b br][-d emp]\n",
-             programName);
-     fprintf(stderr,
-     "          [-c][-o][-e] inputPCM [outBS]\n");
-     fprintf(stderr,"where\n");
-     fprintf(stderr," -l lay   use layer <lay> coding   (dflt %4u)\n",DFLT_LAY);
-     fprintf(stderr," -m mode  channel mode : s/d/j/m   (dflt %4c)\n",DFLT_MOD);
-     fprintf(stderr," -p psy   psychoacoustic model 1/2 (dflt %4u)\n",DFLT_PSY);
-     fprintf(stderr," -s sfrq  input smpl rate in kHz   (dflt %4.1f)\n",DFLT_SFQ);
-     fprintf(stderr," -b br    total bitrate in kbps    (dflt highest)\n");
-     fprintf(stderr," -d emp   de-emphasis n/5/c        (dflt %4c)\n",DFLT_EMP);
-     fprintf(stderr," -c       mark as copyright\n");
-     fprintf(stderr," -o       mark as original\n");
-     fprintf(stderr," -e       add error protection\n");
-     fprintf(stderr," inputPCM input PCM sound file (standard or AIFF)\n");
-     fprintf(stderr," outBS    output bit stream of encoded audio (dflt inName+%s)\n",
-             DFLT_EXT);
-     exit(1);
- }
- 
- /************************************************************************
- *
- * aiff_check
- *
- * PURPOSE:  Checks AIFF header information to make sure it is valid.
- *           Exits if not.
- *
- ************************************************************************/
- 
- void aiff_check( char *file_name, IFF_AIFF *pcm_aiff_data, int *version)
- {
-     if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
-        printf("Sound data is not PCM in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if(SmpFrqIndex((long)pcm_aiff_data->sampleRate, version) < 0) {
-        printf("in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
-         printf("Sound data is not %d bits in \"%s\".\n",
-                sizeof(short) * BITS_IN_A_BYTE, file_name);
-         exit(1);
-     }
- 
-     if (pcm_aiff_data->numChannels != MONO &&
-         pcm_aiff_data->numChannels != STEREO) {
-        printf("Sound data is not mono or stereo in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->blkAlgn.blockSize != 0) {
-        printf("Block size is not %d bytes in \"%s\".\n", 0, file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->blkAlgn.offset != 0) {
-        printf("Block offset is not %d bytes in \"%s\".\n", 0, file_name);
-        exit(1);
-     }
- }
--- 0 ----
diff -r -c -N encoder/newmdct.c lame3.70/newmdct.c
*** encoder/newmdct.c	Wed Dec 31 17:00:00 1969
--- lame3.70/newmdct.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,631 ----
+ /*
+  *	MP3 window subband -> subband filtering -> mdct routine
+  *
+  *	Copyright (c) 1999 Takehiro TOMINAGA
+  *
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ /*
+  *         Special Thanks to Patrick De Smet for your advices.
+  */
+ 
+ 
+ #include "util.h"
+ #include "l3side.h"
+ #include "newmdct.h"
+ 
+ #define SCALE 32768
+ 
+ static FLOAT8 enwindow[] = 
+ {
+   3.5780907e-02,1.7876148e-02,3.134727e-03,2.457142e-03,
+     9.71317e-04,  2.18868e-04, 1.01566e-04,  1.3828e-05,
+ 
+   3.5758972e-02, 3.401756e-03,  9.83715e-04,   9.9182e-05,
+       -4.77e-07,  1.03951e-04,  9.53674e-04, 2.841473e-03,
+      1.2398e-05,  1.91212e-04, 2.283096e-03,1.6994476e-02,
+   1.8756866e-02, 2.630711e-03,  2.47478e-04,   1.4782e-05,
+ 
+   3.5694122e-02, 3.643036e-03,  9.91821e-04,   9.6321e-05,
+       -4.77e-07,  1.05858e-04,  9.30786e-04, 2.521515e-03,
+      1.1444e-05,  1.65462e-04, 2.110004e-03,1.6112804e-02,
+   1.9634247e-02, 2.803326e-03,  2.77042e-04,   1.6689e-05,
+ 
+   3.5586357e-02, 3.858566e-03,  9.95159e-04,   9.3460e-05,
+       -4.77e-07,  1.07288e-04,  9.02653e-04, 2.174854e-03,
+      1.0014e-05,  1.40190e-04, 1.937389e-03,1.5233517e-02,
+   2.0506859e-02, 2.974033e-03,  3.07560e-04,   1.8120e-05,
+ 
+   3.5435200e-02, 4.049301e-03,  9.94205e-04,   9.0599e-05,
+       -4.77e-07,  1.08242e-04,  8.68797e-04, 1.800537e-03,
+       9.060e-06,  1.16348e-04, 1.766682e-03,1.4358521e-02,
+   2.1372318e-02,  3.14188e-03,  3.39031e-04,   1.9550e-05,
+ 
+   3.5242081e-02, 4.215240e-03,  9.89437e-04,   8.7261e-05,
+       -4.77e-07,  1.08719e-04,  8.29220e-04, 1.399517e-03,
+       8.106e-06,   9.3937e-05, 1.597881e-03,1.3489246e-02,
+   2.2228718e-02, 3.306866e-03,  3.71456e-04,   2.1458e-05,
+ 
+   3.5007000e-02, 4.357815e-03,  9.80854e-04,   8.3923e-05,
+       -4.77e-07,  1.08719e-04,   7.8392e-04,  9.71317e-04,
+       7.629e-06,   7.2956e-05, 1.432419e-03,1.2627602e-02,
+   2.3074150e-02, 3.467083e-03,  4.04358e-04,   2.3365e-05,
+ 
+   3.4730434e-02, 4.477024e-03,  9.68933e-04,   8.0585e-05,
+       -9.54e-07,  1.08242e-04,  7.31945e-04,  5.15938e-04,
+       6.676e-06,   5.2929e-05, 1.269817e-03,1.1775017e-02,
+   2.3907185e-02, 3.622532e-03,  4.38213e-04,   2.5272e-05,
+ 
+   3.4412861e-02, 4.573822e-03,  9.54151e-04,   7.6771e-05,
+       -9.54e-07,  1.06812e-04,  6.74248e-04,   3.3379e-05,
+       6.199e-06,   3.4332e-05, 1.111031e-03,1.0933399e-02,
+   2.4725437e-02, 3.771782e-03,  4.72546e-04,   2.7657e-05,
+ 
+   3.4055710e-02, 4.649162e-03,  9.35555e-04,   7.3433e-05,
+       -9.54e-07,  1.05381e-04,  6.10352e-04, -4.75883e-04,
+       5.245e-06,   1.7166e-05,  9.56535e-04,1.0103703e-02,
+   2.5527000e-02, 3.914356e-03,  5.07355e-04,   3.0041e-05,
+ 
+   3.3659935e-02, 4.703045e-03,  9.15051e-04,   7.0095e-05,
+       -9.54e-07,  1.02520e-04,  5.39303e-04,-1.011848e-03,
+       4.768e-06,     9.54e-07,  8.06808e-04, 9.287834e-03,
+   2.6310921e-02, 4.048824e-03,  5.42164e-04,   3.2425e-05,
+ 
+   3.3225536e-02, 4.737377e-03,  8.91685e-04,   6.6280e-05,
+      -1.431e-06,   9.9182e-05,  4.62532e-04,-1.573563e-03,
+       4.292e-06,  -1.3828e-05,  6.61850e-04, 8.487225e-03,
+   2.7073860e-02, 4.174709e-03,  5.76973e-04,   3.4809e-05,
+ 
+   3.2754898e-02, 4.752159e-03,  8.66413e-04,   6.2943e-05,
+      -1.431e-06,   9.5367e-05,  3.78609e-04,-2.161503e-03,
+       3.815e-06,   -2.718e-05,  5.22137e-04, 7.703304e-03,
+   2.7815342e-02, 4.290581e-03,  6.11782e-04,   3.7670e-05,
+ 
+   3.2248020e-02, 4.748821e-03,  8.38757e-04,   5.9605e-05,
+      -1.907e-06,   9.0122e-05,  2.88486e-04,-2.774239e-03,
+       3.338e-06,  -3.9577e-05,  3.88145e-04, 6.937027e-03,
+   2.8532982e-02, 4.395962e-03,  6.46591e-04,   4.0531e-05,
+ 
+   3.1706810e-02, 4.728317e-03,  8.09669e-04,    5.579e-05,
+      -1.907e-06,   8.4400e-05,  1.91689e-04,-3.411293e-03,
+       3.338e-06,  -5.0545e-05,  2.59876e-04, 6.189346e-03,
+   2.9224873e-02, 4.489899e-03,  6.80923e-04,   4.3392e-05,
+ 
+   3.1132698e-02, 4.691124e-03,  7.79152e-04,   5.2929e-05,
+      -2.384e-06,   7.7724e-05,   8.8215e-05,-4.072189e-03,
+       2.861e-06,  -6.0558e-05,  1.37329e-04, 5.462170e-03,
+   2.9890060e-02, 4.570484e-03,  7.14302e-04,   4.6253e-05,
+ 
+   3.0526638e-02, 4.638195e-03,  7.47204e-04,   4.9591e-05,
+    4.756451e-03,   2.1458e-05,  -6.9618e-05,    2.384e-06
+ };
+ 
+ static FLOAT8 sb_sample[2][2][18][SBLIMIT];
+ static FLOAT8 mm[16][SBLIMIT - 1];
+ 
+ #define NS 12
+ #define NL 36
+ 
+ static const int all[] = {0,2,3,5,6,8,9,11,12,14,15,17};
+ static FLOAT8 ca[8], cs[8];
+ static FLOAT8 cos_s[NS / 2][NS / 2];
+ static FLOAT8 cos_l[(NL / 2) * 12 + (NL / 6) * 4 + (NL / 18) * 2];
+ static FLOAT8 win[4][36];
+ 
+ #define work (&win[2][4])
+ 
+ /************************************************************************
+ *
+ * window_subband()
+ *
+ * PURPOSE:  Overlapping window on PCM samples
+ *
+ * SEMANTICS:
+ * 32 16-bit pcm samples are scaled to fractional 2's complement and
+ * concatenated to the end of the window buffer #x#. The updated window
+ * buffer #x# is then windowed by the analysis window #c# to produce the
+ * windowed sample #z#
+ *
+ ************************************************************************/
+ 
+ static void window_subband(short *xk, FLOAT8 d[SBLIMIT], FLOAT8 *in)
+ {
+     int i;
+     FLOAT8 s, t, *wp;
+     wp = enwindow;
+     {
+ 	t  =  xk[255];
+ 	t += (xk[223] - xk[287]) * *wp++;
+ 	t += (xk[191] + xk[319]) * *wp++;
+ 	t += (xk[159] - xk[351]) * *wp++;
+ 	t += (xk[127] + xk[383]) * *wp++;
+ 	t += (xk[ 95] - xk[415]) * *wp++;
+ 	t += (xk[ 63] + xk[447]) * *wp++;
+ 	t += (xk[ 31] - xk[479]) * *wp++;
+ 	in[15] = t;
+     }
+ 
+     for (i = 14; i >= 0; --i) {
+ 	short *x1 = &xk[i];
+ 	short *x2 = &xk[-i];
+ 	FLOAT8 w;
+ 
+ 	s = x2[270]; t = x1[240];
+ 	w = *wp++; s += x2[334] * w; t += x1[176] * w;
+ 	w = *wp++; s += x2[398] * w; t += x1[112] * w;
+ 	w = *wp++; s += x2[462] * w; t += x1[ 48] * w;
+ 	w = *wp++; s += x2[ 14] * w; t += x1[496] * w;
+ 	w = *wp++; s += x2[ 78] * w; t += x1[432] * w;
+ 	w = *wp++; s += x2[142] * w; t += x1[368] * w;
+ 	w = *wp++; s += x2[206] * w; t += x1[304] * w;
+ 
+ 	w = *wp++; s += x1[ 16] * w; t -= x2[494] * w;
+ 	w = *wp++; s += x1[ 80] * w; t -= x2[430] * w;
+ 	w = *wp++; s += x1[144] * w; t -= x2[366] * w;
+ 	w = *wp++; s += x1[208] * w; t -= x2[302] * w;
+ 	w = *wp++; s -= x1[272] * w; t += x2[238] * w;
+ 	w = *wp++; s -= x1[336] * w; t += x2[174] * w;
+ 	w = *wp++; s -= x1[400] * w; t += x2[110] * w;
+ 	w = *wp++; s -= x1[464] * w; t += x2[ 46] * w;
+ 
+ 	in[30 - i] = s;
+ 	in[i] = t;
+     }
+ 
+     {
+ 	s  = xk[239];
+ 	s += xk[175] * *wp++;
+ 	s += xk[111] * *wp++;
+ 	s += xk[ 47] * *wp++;
+ 	s -= xk[303] * *wp++;
+ 	s -= xk[367] * *wp++;
+ 	s -= xk[431] * *wp++;
+ 	s -= xk[495] * *wp++;
+ 	/* in[-1] = s;  */
+     }
+ 
+     in++;
+     wp = &mm[0][0];
+     for (i = 15; i >= 0; --i) {
+ 	int j;
+ 	FLOAT8 s0 = s; /* mm[i][0] is always 1 */
+ 	FLOAT8 s1 = t * *wp++;
+ 	for (j = 14; j >= 0; j--) {
+ 	    s0 += *wp++ * *in++;
+ 	    s1 += *wp++ * *in++;
+ 	}
+ 	in -= 30;
+ 	d[i     ] = s0 + s1;
+ 	d[31 - i] = s0 - s1;
+     }
+ }
+ 
+ 
+ /*-------------------------------------------------------------------*/
+ /*                                                                   */
+ /*   Function: Calculation of the MDCT                               */
+ /*   In the case of long blocks (type 0,1,3) there are               */
+ /*   36 coefficents in the time domain and 18 in the frequency       */
+ /*   domain.                                                         */
+ /*   In the case of short blocks (type 2) there are 3                */
+ /*   transformations with short length. This leads to 12 coefficents */
+ /*   in the time and 6 in the frequency domain. In this case the     */
+ /*   results are stored side by side in the vector out[].            */
+ /*                                                                   */
+ /*   New layer3                                                      */
+ /*                                                                   */
+ /*-------------------------------------------------------------------*/
+ 
+ static void mdct_short(FLOAT8 *out, FLOAT8 *in)
+ {
+     int m;
+     for (m = NS / 2 - 1; m >= 0; --m) {
+ 	int l;
+ 	FLOAT8 a0, a1, a2, a3, a4, a5;
+ 	a0 = cos_s[m][0];
+ 	a1 = cos_s[m][1];
+ 	a2 = cos_s[m][2];
+ 	a3 = cos_s[m][3];
+ 	a4 = cos_s[m][4];
+ 	a5 = cos_s[m][5];
+ 	for (l = 2; l >= 0; l--) {
+ 	    out[3 * m + l] =
+ 		a0 * in[6 * l    ] +
+ 		a1 * in[6 * l + 1] +
+ 		a2 * in[6 * l + 2] +
+ 		a3 * in[6 * l + 3] +
+ 		a4 * in[6 * l + 4] +
+ 		a5 * in[6 * l + 5];
+ 	}
+     }
+ }
+ 
+ static void mdct_long(FLOAT8 *out, FLOAT8 *in)
+ {
+     FLOAT8 s0, s1, s2, s3, s4, s5;
+     int j = sizeof(all) / sizeof(int) - 1;
+     FLOAT8 *cos_l0 = cos_l;
+     do {
+ 	out[all[j]] =
+ 	    in[ 0] * cos_l0[ 0] +
+ 	    in[ 1] * cos_l0[ 1] +
+ 	    in[ 2] * cos_l0[ 2] +
+ 	    in[ 3] * cos_l0[ 3] +
+ 	    in[ 4] * cos_l0[ 4] +
+ 	    in[ 5] * cos_l0[ 5] +
+ 	    in[ 6] * cos_l0[ 6] +
+ 	    in[ 7] * cos_l0[ 7] +
+ 	    in[ 8] * cos_l0[ 8] +
+ 	    in[ 9] * cos_l0[ 9] +
+ 	    in[10] * cos_l0[10] +
+ 	    in[11] * cos_l0[11] +
+ 	    in[12] * cos_l0[12] +
+ 	    in[13] * cos_l0[13] +
+ 	    in[14] * cos_l0[14] +
+ 	    in[15] * cos_l0[15] +
+ 	    in[16] * cos_l0[16] +
+ 	    in[17] * cos_l0[17];
+ 	cos_l0 += 18;
+     } while (--j >= 0);
+ 
+     s0 = in[0] + in[ 5] + in[15];
+     s1 = in[1] + in[ 4] + in[16];
+     s2 = in[2] + in[ 3] + in[17];
+     s3 = in[6] - in[ 9] + in[14];
+     s4 = in[7] - in[10] + in[13];
+     s5 = in[8] - in[11] + in[12];
+ 
+     /* 16 */
+     out[16] =
+ 	s0 * cos_l0[0] + s1 * cos_l0[1] + s2 * cos_l0[2] +
+ 	s3 * cos_l0[3] + s4 * cos_l0[4] + s5 * cos_l0[5];
+     cos_l0 += 6;
+ 
+     /* 10 */
+     out[10] =
+ 	s0 * cos_l0[0] + s1 * cos_l0[1] + s2 * cos_l0[2] +
+ 	s3 * cos_l0[3] + s4 * cos_l0[4] + s5 * cos_l0[5];
+     cos_l0 += 6;
+ 
+     /* 7 */
+     out[7] =
+ 	s0 * cos_l0[0] + s1 * cos_l0[1] + s2 * cos_l0[2] +
+ 	s3 * cos_l0[3] + s4 * cos_l0[4] + s5 * cos_l0[5];
+     cos_l0 += 6;
+ 
+     /* 1 */
+     out[1] =
+ 	s0 * cos_l0[0] + s1 * cos_l0[1] + s2 * cos_l0[2] +
+ 	s3 * cos_l0[3] + s4 * cos_l0[4] + s5 * cos_l0[5];
+     cos_l0 += 6;
+ 
+     s0 = s0 - s1 + s5;
+     s2 = s2 - s3 - s4;
+     /* 13 */
+     out[13] = s0 * cos_l0[0] + s2 * cos_l0[1];
+ 
+     /* 4 */
+     out[4] = s0 * cos_l0[2] + s2 * cos_l0[3];
+ }
+ 
+ 
+ void mdct_sub48(lame_global_flags *gfp,
+     short *w0, short *w1,
+     FLOAT8 mdct_freq[2][2][576],
+     III_side_info_t *l3_side)
+ {
+     int gr, k, ch;
+     short *wk;
+     static int init = 0;
+ 
+     if ( init == 0 ) {
+         void mdct_init48(void);
+ 	mdct_init48();
+ 	init++;
+     }
+ 
+     wk = w0;
+     /* thinking cache performance, ch->gr loop is better than gr->ch loop */
+     for (ch = 0; ch < gfp->stereo; ch++) {
+ 	for (gr = 0; gr < gfp->mode_gr; gr++) {
+ 	    int	band;
+ 	    FLOAT8 *mdct_enc = mdct_freq[gr][ch];
+ 	    gr_info *gi = &(l3_side->gr[gr].ch[ch].tt);
+ 	    FLOAT8 *samp = sb_sample[ch][1 - gr][0];
+ 
+ 	    for (k = 0; k < 18 / 2; k++) {
+ 		window_subband(wk, samp, work);
+ 		window_subband(wk + 32, samp + 32, work);
+ 		/*
+ 		 * Compensate for inversion in the analysis filter
+ 		 */
+ 		for (band = 1; band < 32; band += 2)
+ 		    samp[band + 32] *= -1.0;
+ 		samp += 64;
+ 		wk += 64;
+ 	    }
+ 
+ 
+ 	    /* apply filters on the polyphase filterbank outputs */
+ 	    /* bands <= gfp->highpass_band will be zeroed out below */
+ 	    /* bands >= gfp->lowpass_band  will be zeroed out below */
+ 	    if (gfp->filter_type==0) {
+ 	      FLOAT8 amp,freq;
+ 	      for (band=gfp->highpass_band+1;  band < gfp->lowpass_band ; band++) { 
+ 		freq = band/31.0;
+ 		if (gfp->lowpass1 < freq && freq < gfp->lowpass2) {
+ 		  amp = cos((PI/2)*(gfp->lowpass1-freq)/(gfp->lowpass2-gfp->lowpass1));
+ 		  for (k=0; k<18; k++) 
+ 		    sb_sample[ch][1-gr][k][band]*=amp;
+ 		}
+ 		if (gfp->highpass1 < freq && freq < gfp->highpass2) {
+ 		  amp = cos((PI/2)*(gfp->highpass2-freq)/(gfp->highpass2-gfp->highpass1));
+ 		  for (k=0; k<18; k++) 
+ 		    sb_sample[ch][1-gr][k][band]*=amp;
+ 		}
+ 	      }
+ 	    }
+ 	    
+ 
+ 
+ 	    /*
+ 	     * Perform imdct of 18 previous subband samples
+ 	     * + 18 current subband samples
+ 	     */
+ 	    for (band = 0; band < 32; band++, mdct_enc += 18) 
+               {
+ 		int type = gi->block_type;
+ #ifdef ALLOW_MIXED
+ 		if (gi->mixed_block_flag && band < 2)
+ 		    type = 0;
+ #endif
+ 		if (band >= gfp->lowpass_band || band <= gfp->highpass_band) {
+ 		    memset((char *)mdct_enc,0,18*sizeof(FLOAT8));
+ 		}else {
+ 		  if (type == SHORT_TYPE) {
+ 		    for (k = 2; k >= 0; --k) {
+ 		      FLOAT8 w1 = win[SHORT_TYPE][k];
+ 		      work[k] =
+ 			sb_sample[ch][gr][k+6][band] * w1 -
+ 			sb_sample[ch][gr][11-k][band];
+ 		      work[k+3] =
+ 			sb_sample[ch][gr][k+12][band] +
+ 			sb_sample[ch][gr][17-k][band] * w1;
+ 		      
+ 		      work[k+6] =
+ 			sb_sample[ch][gr][k+12][band] * w1 -
+ 			sb_sample[ch][gr][17-k][band];
+ 		      work[k+9] =
+ 			sb_sample[ch][1-gr][k][band] +
+ 			sb_sample[ch][1-gr][5-k][band] * w1;
+ 		      
+ 		      work[k+12] =
+ 			sb_sample[ch][1-gr][k][band] * w1 -
+ 			sb_sample[ch][1-gr][5-k][band];
+ 		      work[k+15] =
+ 			sb_sample[ch][1-gr][k+6][band] +
+ 			sb_sample[ch][1-gr][11-k][band] * w1;
+ 		    }
+ 		    mdct_short(mdct_enc, work);
+ 		  } else {
+ 		    for (k = 8; k >= 0; --k) {
+ 		      work[k] =
+ 			win[type][k  ] * sb_sample[ch][gr][k   ][band]
+ 			- win[type][k+9] * sb_sample[ch][gr][17-k][band];
+ 		      
+ 		      work[9+k] =
+ 			win[type][k+18] * sb_sample[ch][1-gr][k   ][band]
+ 			+ win[type][k+27] * sb_sample[ch][1-gr][17-k][band];
+ 		    }
+ 		    mdct_long(mdct_enc, work);
+ 		  }
+ 		}
+ 		
+ 		
+ 		/*
+ 		  Perform aliasing reduction butterfly
+ 		*/
+ 		if (type != SHORT_TYPE) {
+ 		  if (band == 0)
+ 		    continue;
+ 		  for (k = 7; k >= 0; --k) {
+ 		    FLOAT8 bu,bd;
+ 		    bu = mdct_enc[k] * ca[k] + mdct_enc[-1-k] * cs[k];
+ 		    bd = mdct_enc[k] * cs[k] - mdct_enc[-1-k] * ca[k];
+ 		    
+ 		    mdct_enc[-1-k] = bu;
+ 		    mdct_enc[k]    = bd;
+ 		  }
+ 		}
+ 	      }
+ 	}
+ 	wk = w1;
+ 	if (gfp->mode_gr == 1) {
+ 	    memcpy(sb_sample[ch][0], sb_sample[ch][1], 576 * sizeof(FLOAT8));
+ 	}
+     }
+ }
+ 
+ 
+ 
+ void mdct_init48(void)
+ {
+     int i, k, m;
+     FLOAT8 sq;
+     FLOAT8 max;
+ 
+     /* prepare the aliasing reduction butterflies */
+     for (k = 0; k < 8; k++) {
+ 	/*
+ 	  This is table B.9: coefficients for aliasing reduction
+ 	  */
+ 	static const FLOAT8 c[8] = {
+ 	    -0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142, -0.0037
+ 	};
+ 	sq = 1.0 + c[k] * c[k];
+ 	sq = sqrt(sq);
+ 	ca[k] = c[k] / sq;
+ 	cs[k] = 1.0 / sq;
+     }
+ 
+     /* type 0*/
+     for (i = 0; i < 36; i++)
+ 	win[0][i] = sin(PI/36 * (i + 0.5));
+     /* type 1*/
+     for (i = 0; i < 18; i++) 
+ 	win[1][i] = win[0][i];
+     for (; i < 24; i++)
+ 	win[1][i] = 1.0;
+     for (; i < 30; i++)
+ 	win[1][i] = cos(PI/12 * (i + 0.5));
+     for (; i < 36; i++)
+ 	win[1][i] = 0.0;
+     /* type 3*/
+     for (i = 0; i < 36; i++)
+ 	win[3][i] = win[1][35 - i];
+ 
+     sq = 4.0 / NL;
+     {
+ 	FLOAT8 *cos_l0 = cos_l;
+ 	static const int d3[] = {1,7,10,16};
+ 	static const int d9[] = {4,13};
+ 
+ 	int j = sizeof(all) / sizeof(int) - 1;
+ 	do {
+ 	    m = all[j];
+ 	    for (k = 0; k < NL / 4; k++) {
+ 		*cos_l0++ = sq *
+ 		    cos((PI / (4 * NL)) * (2 * m + 1) * (4 * k + 2 + NL));
+ 	    }
+ 	    for (k = 0; k < NL / 4; k++) {
+ 		*cos_l0++ = sq *
+ 		    cos((PI / (4 * NL)) * (2 * m + 1) * (4 * k + 2 + NL * 3));
+ 	    }
+ 	} while (--j >= 0);
+ 
+ 	j = sizeof(d3) / sizeof(int) - 1;
+ 	do {
+ 	    m = d3[j];
+ 	    for (k = 0; k < 3; k++) {
+ 		*cos_l0++ = sq *
+ 		    cos((PI / (4 * NL)) * (2 * m + 1) * (4 * k + 2 + NL));
+ 	    }
+ 	    for (k = 6; k < 9; k++) {
+ 		*cos_l0++ = sq *
+ 		    cos((PI / (4 * NL)) * (2 * m + 1) * (4 * k + 2 + NL));
+ 	    }
+ 	} while (--j >= 0);
+ 
+ 	j = sizeof(d9) / sizeof(int) - 1;
+ 	do {
+ 	    m = d9[j];
+ 	    *cos_l0++ = sq *
+ 		cos((PI / (4 * NL)) * (2 * m + 1) * (2 + NL));
+ 	    *cos_l0++ = sq *
+ 		cos((PI / (4 * NL)) * (2 * m + 1) * (4 * 2 + 2 + NL));
+ 	} while (--j >= 0);
+     }
+ 
+     max = enwindow[256 - 8];
+     {
+ 	FLOAT8 *wp = enwindow;
+ 	FLOAT8 *wr = enwindow;
+ 	FLOAT8 mmax[32 - 1];
+ 
+ 	{
+ 	    FLOAT8 w = *wp++;
+ 	    mmax[15] = w / max;
+ 
+ 	    for (k = 0; k < 7; k++) {
+ 		*wr++ = *wp++ / w;
+ 	    }
+ 	}
+ 
+ 	for (i = 14; i >= 0; --i) {
+ 	    FLOAT8 w = *wp++;
+ 	    mmax[i] = mmax[30 - i] = w / max;
+ 
+ 	    for (k = 0; k < 15; k++) {
+ 		*wr++ = *wp++ / w;
+ 	    }
+ 	}
+ 
+ 	{
+ 	    wp++;
+ 	    for (k = 0; k < 7; k++) {
+ 		*wr++ = *wp++ / max;
+ 	    }
+ 	}
+ 
+ 	wp = &mm[0][0];
+ 	for (i = 15; i >= 0; --i) {
+ 	    for (k = 1; k < 32; k++) {
+ 		*wp++ = cos((2 * i + 1) * k * PI/64) * mmax[k - 1];
+ 	    }
+ 	}
+     }
+ 
+     /* swap window data*/
+     for (k = 0; k < 4; k++) {
+ 	FLOAT8 a;
+ 
+ 	a = win[0][17-k];
+ 	win[0][17-k] = win[0][9+k];
+ 	win[0][9+k] = a;
+ 
+ 	a = win[0][35-k];
+ 	win[0][35-k] = win[0][27+k];
+ 	win[0][27+k] = a;
+ 
+ 	a = win[1][17-k];
+ 	win[1][17-k] = win[1][9+k];
+ 	win[1][9+k] = a;
+ 
+ 	a = win[1][35-k];
+ 	win[1][35-k] = win[1][27+k];
+ 	win[1][27+k] = a;
+ 
+ 	a = win[3][17-k];
+ 	win[3][17-k] = win[3][9+k];
+ 	win[3][9+k] = a;
+ 
+ 	a = win[3][35-k];
+ 	win[3][35-k] = win[3][27+k];
+ 	win[3][27+k] = a;
+     }
+ 
+     for (i = 0; i < 36; i++) {
+ 	win[0][i] *= max / SCALE;
+ 	win[1][i] *= max / SCALE;
+ 	win[3][i] *= max / SCALE;
+     }
+ 
+     /* type 2(short)*/
+     sq = 4.0 / NS;
+     for (i = 0; i < NS / 4; i++) {
+ 	FLOAT8 w2 = cos(PI/12 * (i + 0.5)) * max / SCALE * sq;
+ 	win[SHORT_TYPE][i] = tan(PI/12 * (i + 0.5));
+ 
+ 	for (m = 0; m < NS / 2; m++) {
+ 	    cos_s[m][i] = w2 *
+ 		cos((PI / (4 * NS)) * (2 * m + 1) * (4 * i + 2 + NS));
+ 	    cos_s[m][i + NS / 4] = w2 *
+ 		cos((PI / (4 * NS)) * (2 * m + 1) * (4 * i + 2 + NS * 3));
+ 	}
+     }
+ }
diff -r -c -N encoder/newmdct.h lame3.70/newmdct.h
*** encoder/newmdct.h	Wed Dec 31 17:00:00 1969
--- lame3.70/newmdct.h	Tue Mar 21 16:02:17 2000
***************
*** 0 ****
--- 1,6 ----
+ #ifndef MDCT_DOT_H
+ #define MDCT_DOT_H
+ void mdct_sub48(lame_global_flags *gfp,short *w0, short *w1,
+ 	      FLOAT8 mdct_freq[2][2][576],
+ 	      III_side_info_t *l3_side);
+ #endif
diff -r -c -N encoder/parse.c lame3.70/parse.c
*** encoder/parse.c	Wed Dec 31 17:00:00 1969
--- lame3.70/parse.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,724 ----
+ #ifdef LAMEPARSE
+ 
+ #include "util.h"
+ #include "id3tag.h"
+ #include "get_audio.h"
+ #include "brhist.h"
+ #include "version.h"
+ 
+ 
+ 
+ #define         MAX_NAME_SIZE           300
+   char    inPath[MAX_NAME_SIZE];
+   char    outPath[MAX_NAME_SIZE];
+ 
+ 
+ /************************************************************************
+ *
+ * usage
+ *
+ * PURPOSE:  Writes command line syntax to the file specified by #stderr#
+ *
+ ************************************************************************/
+ 
+ void lame_usage(lame_global_flags *gfp,char *name)  /* print syntax & exit */
+ {
+   lame_print_version(stderr);
+   fprintf(stderr,"\n");
+   fprintf(stderr,"USAGE   :  %s [options] <infile> [outfile]\n",name);
+   fprintf(stderr,"\n<infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"Try \"%s --help\" for more information\n",name);
+   exit(1);
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * usage
+ *
+ * PURPOSE:  Writes command line syntax to the file specified by #stdout#
+ *
+ ************************************************************************/
+ 
+ void lame_help(lame_global_flags *gfp,char *name)  /* print syntax & exit */
+ {
+   lame_print_version(stdout);
+   fprintf(stdout,"\n");
+   fprintf(stdout,"USAGE   :  %s [options] <infile> [outfile]\n",name);
+   fprintf(stdout,"\n<infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"OPTIONS :\n");
+   fprintf(stdout,"  Input options:\n");
+   fprintf(stdout,"    -r              input is raw pcm\n");
+   fprintf(stdout,"    -x              force byte-swapping of input\n");
+   fprintf(stdout,"    -s sfreq        sampling frequency of input file(kHz) - default 44.1kHz\n");
+   fprintf(stdout,"    --mp3input      input file is a MP3 file\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  Filter options:\n");
+   fprintf(stdout,"    -k              keep ALL frequencies (disables all filters)\n");
+   fprintf(stdout,"  --lowpass freq         frequency(kHz), lowpass filter cutoff above freq\n");
+   fprintf(stdout,"  --lowpass-width freq   frequency(kHz) - default 15%% of lowpass freq\n");
+   fprintf(stdout,"  --highpass freq        frequency(kHz), highpass filter cutoff below freq\n");
+   fprintf(stdout,"  --highpass-width freq  frequency(kHz) - default 15%% of highpass freq\n");
+   fprintf(stdout,"  --resample sfreq  sampling frequency of output file(kHz)- default=input sfreq\n");
+   fprintf(stdout,"  --cwlimit freq    compute tonality up to freq (in kHz) default 8.8717\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  Operational options:\n");
+   fprintf(stdout,"    -m mode         (s)tereo, (j)oint, (f)orce or (m)ono  (default j)\n");
+   fprintf(stdout,"                    force = force ms_stereo on all frames. Faster\n");
+   fprintf(stdout,"    -a              downmix from stereo to mono file for mono encoding\n");
+   fprintf(stdout,"    -d              allow channels to have different blocktypes\n");
+   fprintf(stdout,"    -S              don't print progress report, VBR histograms\n");
+   fprintf(stdout,"    --athonly       only use the ATH for masking\n");
+   fprintf(stdout,"    --noath         disable the ATH for masking\n");
+   fprintf(stdout,"    --noshort       do not use short blocks\n");
+   fprintf(stdout,"    --voice         experimental voice mode\n");
+   fprintf(stdout,"    --preset type   type must be phone, voice, fm, tape, hifi, cd or studio\n");
+   fprintf(stdout,"                    help gives some more infos on these\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  CBR (constant bitrate, the default) options:\n");
+   fprintf(stdout,"    -h              higher quality, but a little slower.  Recommended.\n");
+   fprintf(stdout,"    -f              fast mode (very low quality)\n");
+   fprintf(stdout,"    -b bitrate      set the bitrate, default 128kbps\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  VBR options:\n");
+   fprintf(stdout,"    -v              use variable bitrate (VBR)\n");
+   fprintf(stdout,"    -V n            quality setting for VBR.  default n=%i\n",gfp->VBR_q);
+   fprintf(stdout,"                    0=high quality,bigger files. 9=smaller files\n");
+   fprintf(stdout,"    -b bitrate      specify minimum allowed bitrate, default 32kbs\n");
+   fprintf(stdout,"    -B bitrate      specify maximum allowed bitrate, default 256kbs\n");
+   fprintf(stdout,"    -t              disable Xing VBR informational tag\n");
+   fprintf(stdout,"    --nohist        disable VBR histogram display\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  MP3 header/stream options:\n");
+   fprintf(stdout,"    -e emp          de-emphasis n/5/c  (obsolete)\n");
+   fprintf(stdout,"    -c              mark as copyright\n");
+   fprintf(stdout,"    -o              mark as non-original\n");
+   fprintf(stdout,"    -p              error protection.  adds 16bit checksum to every frame\n");
+   fprintf(stdout,"                    (the checksum is computed correctly)\n");
+   fprintf(stdout,"    --nores         disable the bit reservoir\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  Specifying any of the following options will add an ID3 tag:\n");
+   fprintf(stdout,"     --tt \"title\"     title of song (max 30 chars)\n");
+   fprintf(stdout,"     --ta \"artist\"    artist who did the song (max 30 chars)\n");
+   fprintf(stdout,"     --tl \"album\"     album where it came from (max 30 chars)\n");
+   fprintf(stdout,"     --ty \"year\"      year in which the song/album was made (max 4 chars)\n");
+   fprintf(stdout,"     --tc \"comment\"   additional info (max 30 chars)\n");
+   fprintf(stdout,"                      (or max 28 chars if using the \"track\" option)\n");
+   fprintf(stdout,"     --tn \"track\"     track number of the song on the CD (1 to 99)\n");
+   fprintf(stdout,"                      (using this option will add an ID3v1.1 tag)\n");
+   fprintf(stdout,"     --tg \"genre\"     genre of song (name or number)\n");
+   fprintf(stdout,"\n");
+ #ifdef HAVEGTK
+   fprintf(stdout,"    -g              run graphical analysis on <infile>\n");
+ #endif
+   display_bitrates(stdout);
+   exit(0);
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * usage
+ *
+ * PURPOSE:  Writes presetting info to #stdout#
+ *
+ ************************************************************************/
+ 
+ void lame_presets_info(lame_global_flags *gfp,char *name)  /* print syntax & exit */
+ {
+   lame_print_version(stdout);
+   fprintf(stdout,"\n");
+   fprintf(stdout,"Presets are some shortcuts for common settings.\n");
+   fprintf(stdout,"They can be combined with -v if you want VBR MP3s.\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset phone    =>  --resample      16\n");
+   fprintf(stdout,"                        --highpass       0.260\n");
+   fprintf(stdout,"                        --highpasswidth  0.040\n");
+   fprintf(stdout,"                        --lowpass        3.700\n");
+   fprintf(stdout,"                        --lowpasswidth   0.300\n");
+   fprintf(stdout,"                        --noshort\n");
+   fprintf(stdout,"                        -m   m\n");
+   fprintf(stdout,"                        -b  16\n");
+   fprintf(stdout,"                  plus  -b   8  \\\n");
+   fprintf(stdout,"                        -B  56   > in combination with -v\n");
+   fprintf(stdout,"                        -V   5  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset voice:   =>  --resample      24\n");
+   fprintf(stdout,"                        --highpass       0.100\n");
+   fprintf(stdout,"                        --highpasswidth  0.020\n");
+   fprintf(stdout,"                        --lowpass       11\n");
+   fprintf(stdout,"                        --lowpasswidth   2\n");
+   fprintf(stdout,"                        --noshort\n");
+   fprintf(stdout,"                        -m   m\n");
+   fprintf(stdout,"                        -b  32\n");
+   fprintf(stdout,"                  plus  -b   8  \\\n");
+   fprintf(stdout,"                        -B  96   > in combination with -v\n");
+   fprintf(stdout,"                        -V   4  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset fm:      =>  --resample      32\n");
+   fprintf(stdout,"                        --highpass       0.030\n");
+   fprintf(stdout,"                        --highpasswidth  0\n");
+   fprintf(stdout,"                        --lowpass       11.4\n");
+   fprintf(stdout,"                        --lowpasswidth   0\n");
+   fprintf(stdout,"                        -m   j\n");
+   fprintf(stdout,"                        -b  96\n");
+   fprintf(stdout,"                  plus  -b  32  \\\n");
+   fprintf(stdout,"                        -B 192   > in combination with -v\n");
+   fprintf(stdout,"                        -V   4  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset tape:    =>  --lowpass       17\n");
+   fprintf(stdout,"                        --lowpasswidth   2\n");
+   fprintf(stdout,"                        --highpass       0.015\n");
+   fprintf(stdout,"                        --highpasswidth  0.015\n");
+   fprintf(stdout,"                        -m   j\n");
+   fprintf(stdout,"                        -b 128\n");
+   fprintf(stdout,"                  plus  -b  32  \\\n");
+   fprintf(stdout,"                        -B 192   > in combination with -v\n");
+   fprintf(stdout,"                        -V   4  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset hifi:    =>  --lowpass       20\n");
+   fprintf(stdout,"                        --lowpasswidth   3\n");
+   fprintf(stdout,"                        --highpass       0.015\n");
+   fprintf(stdout,"                        --highpasswidth  0.015\n");
+   fprintf(stdout,"                        -h\n");
+   fprintf(stdout,"                        -m   j\n");
+   fprintf(stdout,"                        -b 160\n");
+   fprintf(stdout,"                  plus  -b  32  \\\n");
+   fprintf(stdout,"                        -B 224   > in combination with -v\n");
+   fprintf(stdout,"                        -V   3  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset cd:      =>  -k\n");
+   fprintf(stdout,"                        -h\n");
+   fprintf(stdout,"                        -m   s\n");
+   fprintf(stdout,"                        -b 192\n");
+   fprintf(stdout,"                  plus  -b  80  \\\n");
+   fprintf(stdout,"                        -B 256   > in combination with -v\n");
+   fprintf(stdout,"                        -V   2  /\n");
+   fprintf(stdout,"\n");
+   fprintf(stdout,"  --preset studio:  =>  -k\n");
+   fprintf(stdout,"                        -h\n");
+   fprintf(stdout,"                        -m   s\n");
+   fprintf(stdout,"                        -b 256\n");
+   fprintf(stdout,"                  plus  -b 112  \\\n");
+   fprintf(stdout,"                        -B 320   > in combination with -v\n");
+   fprintf(stdout,"                        -V   0  /\n");
+   fprintf(stdout,"\n");
+ 
+   exit(0);
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * parse_args
+ *
+ * PURPOSE:  Sets encoding parameters to the specifications of the
+ * command line.  Default settings are used for parameters
+ * not specified in the command line.
+ *
+ * If the input file is in WAVE or AIFF format, the sampling frequency is read
+ * from the AIFF header.
+ *
+ * The input and output filenames are read into #inpath# and #outpath#.
+ *
+ ************************************************************************/
+ void lame_parse_args(lame_global_flags *gfp,int argc, char **argv)
+ {
+   FLOAT srate;
+   int   err = 0, i = 0;
+   int autoconvert=0;
+   int user_quality=0;
+ 
+   char *programName = argv[0]; 
+   int track = 0;
+ 
+   inPath[0] = '\0';   
+   outPath[0] = '\0';
+   gfp->inPath=inPath;
+   gfp->outPath=outPath;
+ 
+   id3_inittag(&id3tag);
+   id3tag.used = 0;
+ 
+   /* process args */
+   while(++i<argc && err == 0) {
+     char c, *token, *arg, *nextArg;
+     int  argUsed;
+     
+     token = argv[i];
+     if(*token++ == '-') {
+       if(i+1 < argc) nextArg = argv[i+1];
+       else           nextArg = "";
+       argUsed = 0;
+       if (! *token) {
+ 	/* The user wants to use stdin and/or stdout. */
+ 	if(inPath[0] == '\0')       strncpy(inPath, argv[i],MAX_NAME_SIZE);
+ 	else if(outPath[0] == '\0') strncpy(outPath, argv[i],MAX_NAME_SIZE);
+       } 
+       if (*token == '-') {
+ 	/* GNU style */
+ 	token++;
+ 
+ 	if (strcmp(token, "resample")==0) {
+ 	  argUsed=1;
+ 	  srate = atof( nextArg );
+ 	  /* samplerate = rint( 1000.0 * srate ); $A  */
+ 	  gfp->out_samplerate =  (( 1000.0 * srate ) + 0.5);
+ 	  if (srate  < 1) {
+ 	    fprintf(stderr,"Must specify a samplerate with --resample\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "mp3input")==0) {
+ 	  gfp->input_format=sf_mp3;
+ 	}
+ 	else if (strcmp(token, "voice")==0) {
+ 	  gfp->lowpassfreq=12000;
+ 	  gfp->VBR_max_bitrate_kbps=160;
+ 	  gfp->no_short_blocks=1;
+ 	}
+ 	else if (strcmp(token, "noshort")==0) {
+ 	  gfp->no_short_blocks=1;
+ 	}
+ 	else if (strcmp(token, "noath")==0) {
+ 	  gfp->noATH=1;
+ 	}
+ 	else if (strcmp(token, "nores")==0) {
+ 	  gfp->disable_reservoir=1;
+ 	  gfp->padding=0;
+ 	}
+ 	else if (strcmp(token, "athonly")==0) {
+ 	  gfp->ATHonly=1;
+ 	}
+ 	else if (strcmp(token, "nohist")==0) {
+ #ifdef BRHIST
+ 	  disp_brhist = 0;
+ #endif
+ 	}
+ 	/* options for ID3 tag */
+  	else if (strcmp(token, "tt")==0) {
+  		id3tag.used=1;      argUsed = 1;
+   		strncpy(id3tag.title, nextArg, 30);
+  		}
+  	else if (strcmp(token, "ta")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.artist, nextArg, 30);
+  		}
+  	else if (strcmp(token, "tl")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.album, nextArg, 30);
+  		}
+  	else if (strcmp(token, "ty")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.year, nextArg, 4);
+  		}
+  	else if (strcmp(token, "tc")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.comment, nextArg, 30);
+  		}
+  	else if (strcmp(token, "tn")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		track = atoi(nextArg);
+   		if (track < 1) { track = 1; }
+   		if (track > 99) { track = 99; }
+   		id3tag.track = track;
+  		}
+  	else if (strcmp(token, "tg")==0) {
+ 		argUsed = strtol (nextArg, &token, 10);
+ 		if (nextArg==token) {
+ 		  /* Genere was given as a string, so it's number*/
+ 		  for (argUsed=0; argUsed<=genre_last; argUsed++) {
+ 		    if (!strcmp (genre_list[argUsed], nextArg)) { break; }
+ 		  }
+  		}
+ 		if (argUsed>genre_last) { 
+ 		  argUsed=255; 
+ 		  fprintf(stderr,"Unknown genre: %s.  Specifiy genre number \n", nextArg);
+ 		}
+ 	        argUsed &= 255; c=(char)(argUsed);
+ 
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.genre, &c, 1);
+ 	       }
+ 	else if (strcmp(token, "lowpass")==0) {
+ 	  argUsed=1;
+ 	  gfp->lowpassfreq =  (( 1000.0 * atof( nextArg ) ) + 0.5);
+ 	  if (gfp->lowpassfreq  < 1) {
+ 	    fprintf(stderr,"Must specify lowpass with --lowpass freq, freq >= 0.001 kHz\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "lowpass-width")==0) {
+ 	  argUsed=1;
+ 	  gfp->lowpasswidth =  (( 1000.0 * atof( nextArg ) ) + 0.5);
+ 	  if (gfp->lowpasswidth  < 0) {
+ 	    fprintf(stderr,"Must specify lowpass width with --lowpass-width freq, freq >= 0 kHz\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "highpass")==0) {
+ 	  argUsed=1;
+ 	  gfp->highpassfreq =  (( 1000.0 * atof( nextArg ) ) + 0.5);
+ 	  if (gfp->highpassfreq  < 1) {
+ 	    fprintf(stderr,"Must specify highpass with --highpass freq, freq >= 0.001 kHz\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "highpass-width")==0) {
+ 	  argUsed=1;
+ 	  gfp->highpasswidth =  (( 1000.0 * atof( nextArg ) ) + 0.5);
+ 	  if (gfp->highpasswidth  < 0) {
+ 	    fprintf(stderr,"Must specify highpass width with --highpass-width freq, freq >= 0 kHz\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "cwlimit")==0) {
+ 	  argUsed=1;
+ 	  gfp->cwlimit =  atof( nextArg );
+ 	  if (gfp->cwlimit <= 0 ) {
+ 	    fprintf(stderr,"Must specify cwlimit in kHz\n");
+ 	    exit(1);
+ 	  }
+ 	} /* some more GNU-ish options could be added
+ 	   * version       => complete name, version and license info (normal exit)  
+ 	   * quiet/silent  => no messages on screen
+ 	   * brief         => few messages on screen (name, status report)
+ 	   * verbose       => all infos to screen (brhist, internal flags/filters)
+ 	   * o/output file => specifies output filename
+ 	   * O             => stdout
+ 	   * i/input file  => specifies input filename
+ 	   * I             => stdin
+ 	   */
+ 	else if (strcmp(token, "help") ==0
+ 	       ||strcmp(token, "usage")==0){
+ 	  lame_help(gfp,programName);  /* doesn't return */
+ 	}
+ 	else if (strcmp(token, "preset")==0) {
+ 	  argUsed=1;
+ 	  if (strcmp(nextArg,"phone")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 16; 
+ 	    gfp->highpassfreq=260;
+             gfp->highpasswidth=40; 
+ 	    gfp->lowpassfreq=3700;
+ 	    gfp->lowpasswidth=300;
+ 	    gfp->VBR_q=5;
+ 	    gfp->VBR_min_bitrate_kbps=8;
+ 	    gfp->VBR_max_bitrate_kbps=56;
+ 	    gfp->no_short_blocks=1;
+ 	    gfp->out_samplerate =  16000;
+ 	    gfp->mode = MPG_MD_MONO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->quality = 5;
+ 	  }
+ 	  else if (strcmp(nextArg,"voice")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 56; 
+ 	    gfp->highpassfreq=100;  
+ 	    gfp->highpasswidth=20;
+ 	    gfp->lowpasswidth=2000;
+ 	    gfp->lowpassfreq=11000;
+ 	    gfp->VBR_q=4;
+ 	    gfp->VBR_min_bitrate_kbps=8;
+ 	    gfp->VBR_max_bitrate_kbps=96;
+ 	    gfp->no_short_blocks=1;
+ 	    gfp->mode = MPG_MD_MONO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->out_samplerate =  24000; 
+ 	    gfp->quality = 5;
+ 	  }
+ 	  else if (strcmp(nextArg,"fm")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 96; 
+             gfp->highpassfreq=30;
+             gfp->highpasswidth=0;
+             gfp->lowpassfreq=15000;
+             gfp->lowpasswidth=0;
+ 	    gfp->VBR_q=4;
+ 	    gfp->VBR_min_bitrate_kbps=32;
+ 	    gfp->VBR_max_bitrate_kbps=192;
+ 	    gfp->mode = MPG_MD_JOINT_STEREO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    /*gfp->out_samplerate =  32000; */ /* determined automatically based on bitrate & sample freq. */
+ 	    gfp->quality = 5;
+ 	  }
+ 	  else if (strcmp(nextArg,"tape")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 128; 
+             gfp->highpassfreq=15;
+             gfp->highpasswidth=15;
+             gfp->lowpassfreq=17000;
+             gfp->lowpasswidth=2000;
+ 	    gfp->VBR_q=4;
+ 	    gfp->VBR_min_bitrate_kbps=32;
+ 	    gfp->VBR_max_bitrate_kbps=192;
+ 	    gfp->mode = MPG_MD_JOINT_STEREO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->quality = 5;
+ 	  }
+ 	  else if (strcmp(nextArg,"hifi")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 160;            
+ 	    gfp->highpassfreq=15;
+             gfp->highpasswidth=15;
+             gfp->lowpassfreq=20000;
+             gfp->lowpasswidth=3000;
+ 	    gfp->VBR_q=3;
+ 	    gfp->VBR_min_bitrate_kbps=32;
+ 	    gfp->VBR_max_bitrate_kbps=224;
+ 	    gfp->mode = MPG_MD_JOINT_STEREO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->quality = 2;
+ 	  }
+ 	  else if (strcmp(nextArg,"cd")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 192;  
+ 	    gfp->lowpassfreq=-1;
+             gfp->highpassfreq=-1;
+ 	    gfp->VBR_q=2;
+ 	    gfp->VBR_min_bitrate_kbps=80;
+ 	    gfp->VBR_max_bitrate_kbps=256;
+ 	    gfp->mode = MPG_MD_STEREO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->quality = 2;
+ 	  }
+ 	  else if (strcmp(nextArg,"studio")==0)
+ 	  { /* when making changes, please update help text too */
+ 	    gfp->brate = 256; 
+ 	    gfp->lowpassfreq=-1;
+             gfp->highpassfreq=-1;
+ 	    gfp->VBR_q=0;
+ 	    gfp->VBR_min_bitrate_kbps=112;
+ 	    gfp->VBR_max_bitrate_kbps=320;
+ 	    gfp->mode = MPG_MD_STEREO; 
+ 	    gfp->mode_fixed = 1; 
+ 	    gfp->quality = 2; /* should be 0, but does not work now */
+ 	  }
+ 	  else if (strcmp(nextArg,"help")==0)
+ 	  {
+ 	    lame_presets_info(gfp,programName);  /* doesn't return */
+ 	  }
+ 	  else
+ 	    {
+ 	      fprintf(stderr,"%s: --preset type, type must be phone, voice, fm, tape, hifi, cd or studio, not %s\n",
+ 		      programName, nextArg);
+ 	      exit(1);
+ 	    }
+ 	} /* --preset */
+ 	else
+ 	  {
+ 	    fprintf(stderr,"%s: unrec option --%s\n",
+ 		    programName, token);
+ 	  }
+ 	i += argUsed;
+ 	
+       } else  while( (c = *token++) ) {
+ 	if(*token ) arg = token;
+ 	else                             arg = nextArg;
+ 	switch(c) {
+ 	case 'm':        argUsed = 1;   gfp->mode_fixed = 1;
+ 	  if (*arg == 's')
+ 	    { gfp->mode = MPG_MD_STEREO; }
+ 	  else if (*arg == 'd')
+ 	    { gfp->mode = MPG_MD_DUAL_CHANNEL; }
+ 	  else if (*arg == 'j')
+ 	    { gfp->mode = MPG_MD_JOINT_STEREO; }
+ 	  else if (*arg == 'f')
+ 	    { gfp->mode = MPG_MD_JOINT_STEREO; gfp->force_ms=1; }
+ 	  else if (*arg == 'm')
+ 	    { gfp->mode = MPG_MD_MONO; }
+ 	  else {
+ 	    fprintf(stderr,"%s: -m mode must be s/d/j/f/m not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 	case 'V':        argUsed = 1;   gfp->VBR = 1;  
+ 	  gfp->VBR_q = atoi(arg);
+ 	  if (gfp->VBR_q <0) gfp->VBR_q=0;
+ 	  if (gfp->VBR_q >9) gfp->VBR_q=9;
+ 	  break;
+ 	case 'q':        argUsed = 1; 
+ 	  user_quality = atoi(arg);
+ 	  if (user_quality<0) user_quality=0;
+ 	  if (user_quality>9) user_quality=9;
+ 	  break;
+ 	case 's':
+ 	  argUsed = 1;
+ 	  srate = atof( arg );
+ 	  /* samplerate = rint( 1000.0 * srate ); $A  */
+ 	  gfp->in_samplerate =  (( 1000.0 * srate ) + 0.5);
+ 	  break;
+ 	case 'b':        
+ 	  argUsed = 1;
+ 	  gfp->brate = atoi(arg); 
+ 	  gfp->VBR_min_bitrate_kbps=gfp->brate;
+ 	  break;
+ 	case 'B':        
+ 	  argUsed = 1;
+ 	  gfp->VBR_max_bitrate_kbps=atoi(arg); 
+ 	  break;	
+ 	case 't':  /* dont write VBR tag */
+ 	  gfp->bWriteVbrTag=0;
+ 	  break;
+ 	case 'r':  /* force raw pcm input file */
+ #ifdef LIBSNDFILE
+ 	  fprintf(stderr,"WARNING: libsndfile may ignore -r and perform fseek's on the input.\n");
+ 	  fprintf(stderr,"Compile without libsndfile if this is a problem.\n");
+ #endif
+ 	  gfp->input_format=sf_raw;
+ 	  break;
+ 	case 'x':  /* force byte swapping */
+ 	  gfp->swapbytes=TRUE;
+ 	  break;
+ 	case 'p': /* (jo) error_protection: add crc16 information to stream */
+ 	  gfp->error_protection = 1; 
+ 	  break;
+ 	case 'a': /* autoconvert input file from stereo to mono - for mono mp3 encoding */
+ 	  autoconvert=1;
+ 	  gfp->mode=MPG_MD_MONO;
+ 	  gfp->mode_fixed=1;
+ 	  break;
+ 	case 'h': 
+ 	  gfp->quality = 2;
+ 	  break;
+ 	case 'k': 
+ 	  gfp->lowpassfreq=-1;
+ 	  gfp->highpassfreq=-1;
+ 	  break;
+ 	case 'd': 
+ 	  gfp->allow_diff_short = 1;
+ 	  break;
+ 	case 'v': 
+ 	  gfp->VBR = 1; 
+ 	  break;
+ 	case 'S': 
+ 	  gfp->silent = TRUE;
+ 	  break;
+ 	case 'X':        argUsed = 1;   gfp->experimentalX = 0;
+ 	  if (*arg == '0')
+ 	    { gfp->experimentalX=0; }
+ 	  else if (*arg == '1')
+ 	    { gfp->experimentalX=1; }
+ 	  else if (*arg == '2')
+ 	    { gfp->experimentalX=2; }
+ 	  else if (*arg == '3')
+ 	    { gfp->experimentalX=3; }
+ 	  else if (*arg == '4')
+ 	    { gfp->experimentalX=4; }
+ 	  else if (*arg == '5')
+ 	    { gfp->experimentalX=5; }
+ 	  else if (*arg == '6')
+ 	    { gfp->experimentalX=6; }
+ 	  else {
+ 	    fprintf(stderr,"%s: -X n must be 0-6, not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 
+ 
+ 	case 'Y': 
+ 	  gfp->experimentalY = TRUE;
+ 	  break;
+ 	case 'Z': 
+ 	  gfp->experimentalZ = TRUE;
+ 	  break;
+ 	case 'f': 
+ 	  gfp->quality= 9;
+ 	  break;
+ 	case 'g': /* turn on gtk analysis */
+ #ifdef HAVEGTK
+ 	  gfp->gtkflag = TRUE;
+ #else
+ 	    fprintf(stderr,"LAME not compiled with GTK support, -g not supported.\n",
+ 		    programName, arg);
+ #endif
+ 	  break;
+ 
+ 	case 'e':        argUsed = 1;
+ 	  if (*arg == 'n')                    gfp->emphasis = 0;
+ 	  else if (*arg == '5')               gfp->emphasis = 1;
+ 	  else if (*arg == 'c')               gfp->emphasis = 3;
+ 	  else {
+ 	    fprintf(stderr,"%s: -e emp must be n/5/c not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 	case 'c':   gfp->copyright = 1; break;
+ 	case 'o':   gfp->original  = 0; break;
+ 	
+ 	case '?':   lame_help(gfp,programName);  /* doesn't return */
+ 	default:    fprintf(stderr,"%s: unrec option %c\n",
+ 				programName, c);
+ 	err = 1; break;
+ 	}
+ 	if(argUsed) {
+ 	  if(arg == token)    token = "";   /* no more from token */
+ 	  else                ++i;          /* skip arg we used */
+ 	  arg = ""; argUsed = 0;
+ 	}
+       }
+     } else {
+       if(inPath[0] == '\0')       strncpy(inPath, argv[i], MAX_NAME_SIZE);
+       else if(outPath[0] == '\0') strncpy(outPath, argv[i], MAX_NAME_SIZE);
+       else {
+ 	fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
+ 	err = 1;
+       }
+     }
+   }  /* loop over args */
+ 
+ 
+ 
+   if(err || inPath[0] == '\0') lame_usage(gfp,programName);  /* never returns */
+   if (inPath[0]=='-') gfp->silent=1;  /* turn off status - it's broken for stdin */
+   if(outPath[0] == '\0') {
+     if (inPath[0]=='-') {
+       /* if input is stdin, default output is stdout */
+       strcpy(outPath,"-");
+     }else {
+       strncpy(outPath, inPath, MAX_NAME_SIZE - 4);
+       strncat(outPath, ".mp3", 4 );
+     }
+   }
+   /* some file options not allowed with stdout */
+   if (outPath[0]=='-') {
+     gfp->bWriteVbrTag=0; /* turn off VBR tag */
+     if (id3tag.used) {
+       id3tag.used=0;         /* turn of id3 tagging */
+       fprintf(stderr,"id3tag ignored: id3 tagging not supported for stdout.\n");
+     }
+   }
+ 
+ 
+   /* if user did not explicitly specify input is mp3, check file name */
+   if (gfp->input_format != sf_mp3)
+     if (!(strcmp((char *) &inPath[strlen(inPath)-4],".mp3")))
+       gfp->input_format = sf_mp3;
+ 
+ #if !(defined HAVEMPGLIB || defined AMIGA_MPEGA)
+   if (gfp->input_format == sf_mp3) {
+     fprintf(stderr,"Error: libmp3lame not compiled with mp3 *decoding* support \n");
+     exit(1);
+   }
+ #endif
+   /* default guess for number of channels */
+   if (autoconvert) gfp->num_channels=2; 
+   else if (gfp->mode == MPG_MD_MONO) gfp->num_channels=1;
+   else gfp->num_channels=2;
+ 
+   /* user specified a quality value.  override any defaults set above */
+   if (user_quality)   gfp->quality=user_quality;
+ 
+ }
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/portableio.c lame3.70/portableio.c
*** encoder/portableio.c	Wed Jan 22 02:43:12 1997
--- lame3.70/portableio.c	Wed Nov 24 01:43:35 1999
***************
*** 43,51 ****
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: portableio.c,v 2.6 1991/04/30 17:06:02 malcolm Exp $
   *
   * $Log: portableio.c,v $
   * Revision 2.6  91/04/30  17:06:02  malcolm
   */
  
--- 43,55 ----
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: portableio.c,v 1.1.1.1 1999/11/24 08:43:35 markt Exp $
   *
   * $Log: portableio.c,v $
+  * Revision 1.1.1.1  1999/11/24 08:43:35  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 2.6  91/04/30  17:06:02  malcolm
   */
  
***************
*** 59,66 ****
  
  
  int
! ReadByte(fp)
! FILE *fp;
  {
  	int	result;
  
--- 63,69 ----
  
  
  int
! ReadByte(FILE *fp)
  {
  	int	result;
  
***************
*** 72,79 ****
  
  
  int
! Read16BitsLowHigh(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 75,81 ----
  
  
  int
! Read16BitsLowHigh(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 90,97 ****
  
  
  int
! Read16BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 92,98 ----
  
  
  int
! Read16BitsHighLow(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 108,125 ****
  
  
  void
! Write8Bits(fp, i)
! FILE *fp;
! int i;
  {
  	putc(i&0xff,fp);
  }
  
  
  void
! Write16BitsLowHigh(fp, i)
! FILE *fp;
! int i;
  {
  	putc(i&0xff,fp);
  	putc((i>>8)&0xff,fp);
--- 109,122 ----
  
  
  void
! Write8Bits(FILE *fp, int i)
  {
  	putc(i&0xff,fp);
  }
  
  
  void
! Write16BitsLowHigh(FILE *fp, int i)
  {
  	putc(i&0xff,fp);
  	putc((i>>8)&0xff,fp);
***************
*** 127,135 ****
  
  
  void
! Write16BitsHighLow(fp, i)
! FILE *fp;
! int i;
  {
  	putc((i>>8)&0xff,fp);
  	putc(i&0xff,fp);
--- 124,130 ----
  
  
  void
! Write16BitsHighLow(FILE *fp, int i)
  {
  	putc((i>>8)&0xff,fp);
  	putc(i&0xff,fp);
***************
*** 137,144 ****
  
  
  int
! Read24BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, third;
  	int	result;
--- 132,138 ----
  
  
  int
! Read24BitsHighLow(FILE *fp)
  {
  	int	first, second, third;
  	int	result;
***************
*** 157,164 ****
  
  
  int
! Read32Bits(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 151,157 ----
  
  
  int
! Read32Bits(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 175,182 ****
  
  
  int
! Read32BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 168,174 ----
  
  
  int
! Read32BitsHighLow(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 193,201 ****
  
  
  void
! Write32Bits(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
--- 185,191 ----
  
  
  void
! Write32Bits(FILE *fp, int i)
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
***************
*** 203,211 ****
  
  
  void
! Write32BitsLowHigh(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
--- 193,199 ----
  
  
  void
! Write32BitsLowHigh(FILE *fp, int i)
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
***************
*** 213,243 ****
  
  
  void
! Write32BitsHighLow(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsHighLow(fp,(int)((i>>16)&0xffffL));
  	Write16BitsHighLow(fp,(int)(i&0xffffL));
  }
  
! void ReadBytes(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
! 	while (!feof(fp) & n-- > 0)
  		*p++ = getc(fp);
  }
  
! void ReadBytesSwapped(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & n-- > 0)
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
--- 201,223 ----
  
  
  void
! Write32BitsHighLow(FILE *fp, int i)
  {
  	Write16BitsHighLow(fp,(int)((i>>16)&0xffffL));
  	Write16BitsHighLow(fp,(int)(i&0xffffL));
  }
  
! void ReadBytes(FILE	*fp, char *p, int n)
  {
! 	while (!feof(fp) & (n-- > 0))
  		*p++ = getc(fp);
  }
  
! void ReadBytesSwapped(FILE *fp, char *p, int n)
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & (n-- > 0))
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
***************
*** 247,265 ****
  	}
  }
  
! void WriteBytes(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	while (n-- > 0)
  		putc(*p++, fp);
  }
  
! void WriteBytesSwapped(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	p += n-1;
  	while (n-- > 0)
--- 227,239 ----
  	}
  }
  
! void WriteBytes(FILE *fp, char *p, int n)
  {
  	while (n-- > 0)
  		putc(*p++, fp);
  }
  
! void WriteBytesSwapped(FILE *fp, char *p, int n)
  {
  	p += n-1;
  	while (n-- > 0)
***************
*** 267,274 ****
  }
  
  defdouble
! ReadIeeeFloatHighLow(fp)
! FILE *fp;
  {
  	char	bits[kFloatLength];
  
--- 241,247 ----
  }
  
  defdouble
! ReadIeeeFloatHighLow(FILE *fp)
  {
  	char	bits[kFloatLength];
  
***************
*** 277,284 ****
  }
  
  defdouble
! ReadIeeeFloatLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kFloatLength];
  
--- 250,256 ----
  }
  
  defdouble
! ReadIeeeFloatLowHigh(FILE *fp)
  {
  	char	bits[kFloatLength];
  
***************
*** 287,294 ****
  }
  
  defdouble
! ReadIeeeDoubleHighLow(fp)
! FILE *fp;
  {
  	char	bits[kDoubleLength];
  
--- 259,265 ----
  }
  
  defdouble
! ReadIeeeDoubleHighLow(FILE *fp)
  {
  	char	bits[kDoubleLength];
  
***************
*** 297,304 ****
  }
  
  defdouble
! ReadIeeeDoubleLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kDoubleLength];
  
--- 268,274 ----
  }
  
  defdouble
! ReadIeeeDoubleLowHigh(FILE *fp)
  {
  	char	bits[kDoubleLength];
  
***************
*** 307,314 ****
  }
  
  defdouble
! ReadIeeeExtendedHighLow(fp)
! FILE *fp;
  {
  	char	bits[kExtendedLength];
  
--- 277,283 ----
  }
  
  defdouble
! ReadIeeeExtendedHighLow(FILE *fp)
  {
  	char	bits[kExtendedLength];
  
***************
*** 317,324 ****
  }
  
  defdouble
! ReadIeeeExtendedLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kExtendedLength];
  
--- 286,292 ----
  }
  
  defdouble
! ReadIeeeExtendedLowHigh(FILE *fp)
  {
  	char	bits[kExtendedLength];
  
***************
*** 327,335 ****
  }
  
  void
! WriteIeeeFloatLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kFloatLength];
  
--- 295,301 ----
  }
  
  void
! WriteIeeeFloatLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kFloatLength];
  
***************
*** 338,346 ****
  }
  
  void
! WriteIeeeFloatHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kFloatLength];
  
--- 304,310 ----
  }
  
  void
! WriteIeeeFloatHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kFloatLength];
  
***************
*** 349,357 ****
  }
  
  void
! WriteIeeeDoubleLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kDoubleLength];
  
--- 313,319 ----
  }
  
  void
! WriteIeeeDoubleLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kDoubleLength];
  
***************
*** 360,368 ****
  }
  
  void
! WriteIeeeDoubleHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kDoubleLength];
  
--- 322,328 ----
  }
  
  void
! WriteIeeeDoubleHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kDoubleLength];
  
***************
*** 371,379 ****
  }
  
  void
! WriteIeeeExtendedLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kExtendedLength];
  
--- 331,337 ----
  }
  
  void
! WriteIeeeExtendedLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kExtendedLength];
  
***************
*** 383,391 ****
  
  
  void
! WriteIeeeExtendedHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kExtendedLength];
  
--- 341,347 ----
  
  
  void
! WriteIeeeExtendedHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kExtendedLength];
  
diff -r -c -N encoder/portableio.h lame3.70/portableio.h
*** encoder/portableio.h	Wed Jan 22 02:43:15 1997
--- lame3.70/portableio.h	Wed Nov 24 01:43:37 1999
***************
*** 46,54 ****
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: portableio.h,v 2.6 1991/04/30 17:06:02 malcolm Exp $
   *
   * $Log: portableio.h,v $
   * Revision 2.6  91/04/30  17:06:02  malcolm
   */
  
--- 46,58 ----
   * conversions, and accommodated conversions involving +/- infinity,
   * NaN's, and denormalized numbers.
   *
!  * $Id: portableio.h,v 1.1.1.1 1999/11/24 08:43:37 markt Exp $
   *
   * $Log: portableio.h,v $
+  * Revision 1.1.1.1  1999/11/24 08:43:37  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 2.6  91/04/30  17:06:02  malcolm
   */
  
diff -r -c -N encoder/psy.c lame3.70/psy.c
*** encoder/psy.c	Wed Jan 22 02:43:18 1997
--- lame3.70/psy.c	Wed Dec 31 17:00:00 1969
***************
*** 1,454 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: psy.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: psy.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
-  *                              replace of floats with FLOAT          *
-  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
-  * 7/24/92  M. Iwadare          HANN window coefficients modified.    *
-  * 7/27/92  Masahiro Iwadare    Bug fix, FFT modification for Layer 3 *
-  * 7/27/92  Masahiro Iwadare    Bug fix, "new", "old", and "oldest"   *
-  *                              updates                               *
-  * 8/07/92  Mike Coleman        Bug fix, read_absthr()                *
-  * 95/3/21  Jon Rowlands        Removed extra debug statements        *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- FILE		*fpo;	/* file pointer */
- void psycho_anal(buffer,savebuf,chn,lay,snr32,sfreq)
- short int *buffer;
- short int savebuf[1056];
- int   chn, lay;
- FLOAT snr32[32];
- double sfreq;        /* to match prototype : float args are always double */
- {
-  unsigned int   i, j, k;
-  FLOAT          r_prime, phi_prime;
-  FLOAT          freq_mult, bval_lo, minthres, sum_energy;
-  double         tb, temp1, temp2, temp3;
- 
- /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
- /* to be remembered for the unpredictability measure.  For "r" and        */
- /* "phi_sav", the first index from the left is the channel select and     */
- /* the second index is the "age" of the data.                             */
- 
-  static int     new = 0, old = 1, oldest = 0;
-  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
- 
- /* The following static variables are constants.                           */
- 
-  static double  nmt = 5.5;
- 
-  static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
-                                920, 1080, 1270,1480,1720,2000,2320, 2700,
-                               3150, 3700, 4400,5300,6400,7700,9500,12000,
-                              15500,25000,30000};
- 
-  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
-                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
- 
- /* The following pointer variables point to large areas of memory         */
- /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
- /* allocation is used in order to avoid stack frame or data area          */
- /* overflow errors that otherwise would have occurred at compile time     */
- /* on the Macintosh computer.                                             */
- 
-  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
-  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
-  FLOAT          *c, *fthr;
-  F32            *snrtmp;
- 
-  static int     *numlines;
-  static int     *partition;
-  static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
-  static double  *tmn;
-  static FCB     *s;
-  static FHBLK   *lthr;
-  static F2HBLK  *r, *phi_sav;
- 
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
- 
-  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
-  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
-  nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
-  cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
-  ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
-  bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
-  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
-  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
-  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
-  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
-  c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
-  fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
-  snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
- 
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
- 
-      numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
-      partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
-      fpo = fopen("out.dat", "wb");
- 	if(fpo==NULL) {
- 		puts("\t The attempt to open the output file failed.\n");
- 		exit(-1);}
-      cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
-      rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
-      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
-      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr");
-      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
-      s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
-      lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
-      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
-      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
- 
-      i = sfreq + 0.5;
-      switch(i){
-         case 32000: sfreq_idx = 0; break;
-         case 44100: sfreq_idx = 1; break;
-         case 48000: sfreq_idx = 2; break;
-         default:    printf("error, invalid sampling frequency: %d Hz\n",i);
-         exit(-1);
-      }
-      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
-      read_absthr(absthr, sfreq_idx);
-      if(lay==1){
-         flush = 384;
-         syncsize = 1024;
-         sync_flush = 576;
-      }
-      else {
-         flush = 384*3.0/2.0;
-         syncsize = 1056;
-         sync_flush = syncsize - flush;
-      }
- /* calculate HANN window coefficients */
- /*   for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0))); */
-      for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
- /* reset states used in unpredictability measure */
-      for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
-         lthr[0][i] = 60802371420160.0;
-         lthr[1][i] = 60802371420160.0;
-      }
- /*****************************************************************************
-  * Initialization: Compute the following constants for use later             *
-  *    partition[HBLKSIZE] = the partition number associated with each        *
-  *                          frequency line                                   *
-  *    cbval[CBANDS]       = the center (average) bark value of each          *
-  *                          partition                                        *
-  *    numlines[CBANDS]    = the number of frequency lines in each partition  *
-  *    tmn[CBANDS]         = tone masking noise                               *
-  *****************************************************************************/
- /* compute fft frequency multiplicand */
-      freq_mult = sfreq/BLKSIZE;
-  
- /* calculate fft frequency, then bval of each line (use fthr[] as tmp storage)*/
-      for(i=0;i<HBLKSIZE;i++){
-         temp1 = i*freq_mult;
-         j = 1;
-         while(temp1>crit_band[j])j++;
-         fthr[i]=j-1+(temp1-crit_band[j-1])/(crit_band[j]-crit_band[j-1]);
-      }
-      partition[0] = 0;
- /* temp2 is the counter of the number of frequency lines in each partition */
-      temp2 = 1;
-      cbval[0]=fthr[0];
-      bval_lo=fthr[0];
-      for(i=1;i<HBLKSIZE;i++){
-         if((fthr[i]-bval_lo)>0.33){
-            partition[i]=partition[i-1]+1;
-            cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-            cbval[partition[i]] = fthr[i];
-            bval_lo = fthr[i];
-            numlines[partition[i-1]] = temp2;
-            temp2 = 1;
-         }
-         else {
-            partition[i]=partition[i-1];
-            cbval[partition[i]] += fthr[i];
-            temp2++;
-         }
-      }
-      numlines[partition[i-1]] = temp2;
-      cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-  
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
-      for(j=0;j<CBANDS;j++){
-         for(i=0;i<CBANDS;i++){
-            temp1 = (cbval[i] - cbval[j])*1.05;
-            if(temp1>=0.5 && temp1<=2.5){
-               temp2 = temp1 - 0.5;
-               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
-            }
-            else temp2 = 0;
-            temp1 += 0.474;
-            temp3 = 15.811389+7.5*temp1-17.5*sqrt((double) (1.0+temp1*temp1));
-            if(temp3 <= -100) s[i][j] = 0;
-            else {
-               temp3 = (temp2 + temp3)*LN_TO_LOG10;
-               s[i][j] = exp(temp3);
-            }
-         }
-      }
- 
-   /* Calculate Tone Masking Noise values */
-      for(j=0;j<CBANDS;j++){
-         temp1 = 15.5 + cbval[j];
-         tmn[j] = (temp1>24.5) ? temp1 : 24.5;
-   /* Calculate normalization factors for the net spreading functions */
-         rnorm[j] = 0;
-         for(i=0;i<CBANDS;i++){
-            rnorm[j] += s[j][i];
-         }
-      }
-      init++;
-  }
-  
- /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
-      for(i=0; i<lay; i++){
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-         for(j=0; j<syncsize; j++){
-            if(j<(sync_flush))savebuf[j] = savebuf[j+flush];
-            else savebuf[j] = *buffer++;
-            if(j<BLKSIZE){
- /**window data with HANN window***********************************************/
-               wsamp_r[j] = window[j]*((FLOAT) savebuf[j]);
-               wsamp_i[j] = 0;
-            }
-         }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
- /*only update data "age" pointers after you are done with both channels      */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-          if(lay==2 || (lay==1 && chn==0) ){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- temp1=r[chn][new][j] * cos((double) phi[j]) - r_prime * cos((double) phi_prime);
- temp2=r[chn][new][j] * sin((double) phi[j]) - r_prime * sin((double) phi_prime);
-            temp3=r[chn][new][j] + fabs((double)r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- 
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- 
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
-            tb = -0.434294482*log((double) cb[j])-0.301029996;
- 	   cb[j]=tb;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- 
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
- /*temp1 is the preliminary threshold */
-            temp1=nb[partition[j]];
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- 
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            minthres = 60802371420160.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               if(minthres>fthr[j+k])minthres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(minthres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            minthres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               minthres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/minthres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
-   case 3:
-      printf("layer 3 is not currently supported\n");
-      break;
-   default:
-      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
-  }
- 
- /* These mem_free() calls must correspond with the mem_alloc() calls     */
- /* used at the beginning of this function to simulate "automatic"        */
- /* variables placed on the stack.                                        */
- 
-  mem_free((void **) &grouped_c);
-  mem_free((void **) &grouped_e);
-  mem_free((void **) &nb);
-  mem_free((void **) &cb);
-  mem_free((void **) &ecb);
-  mem_free((void **) &bc);
-  mem_free((void **) &wsamp_r);
-  mem_free((void **) &wsamp_i);
-  mem_free((void **) &phi);
-  mem_free((void **) &energy);
-  mem_free((void **) &c);
-  mem_free((void **) &fthr);
-  mem_free((void **) &snrtmp);
- }
- 
- /******************************************************************************
- routine to read in absthr table from a file.
- ******************************************************************************/
- 
- void read_absthr(absthr, table)
- FLOAT *absthr;
- int table;
- {
-  FILE *fp;
-  long j,index;
-  float a;
-  char t[80];
-  char ta[16];
- 
-  strcpy( ta, "absthr_0" );
-  
-  switch(table){
-     case 0 : ta[7] = '0';
-              break;
-     case 1 : ta[7] = '1';
-              break;
-     case 2 : ta[7] = '2';
-              break;
-     default : printf("absthr table: Not valid table number\n");
-  }
-  if(!(fp = OpenTableFile(ta) ) ){
-     printf("Please check %s table\n", ta);
-     exit(1);
-  }
-  fgets(t, 150, fp);
-  sscanf(t, "table %ld", &index);
-  if(index != table){
-     printf("error in absthr table %s",ta);
-     exit(1);
-  }
-  for(j=0; j<HBLKSIZE; j++){
-     fgets(t,80,fp);
-     sscanf(t,"%f", &a);
-     absthr[j] =  a;
-  }
-  fclose(fp);
- }
--- 0 ----
diff -r -c -N encoder/psymodel.c lame3.70/psymodel.c
*** encoder/psymodel.c	Wed Dec 31 17:00:00 1969
--- lame3.70/psymodel.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,1253 ----
+ /**********************************************************************
+  *   date   programmers         comment                               *
+  * 2/25/91  Davis Pan           start of version 1.0 records          *
+  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
+  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
+  *                              replace of floats with FLOAT          *
+  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
+  * 3/16/92  Masahiro Iwadare	Modification for Layer III            *
+  * 17/4/93  Masahiro Iwadare    Updated for IS Modification           *
+  **********************************************************************/
+ 
+ #include "util.h"
+ #include "encoder.h"
+ #include "psymodel.h"
+ #include "l3side.h"
+ #include <assert.h>
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #endif
+ #include "tables.h"
+ #include "fft.h"
+ 
+ #ifdef M_LN10
+ #define		LN_TO_LOG10		(M_LN10/10)
+ #else
+ #define         LN_TO_LOG10             0.2302585093
+ #endif
+ 
+ 
+ void L3para_read( FLOAT8 sfreq, int numlines[CBANDS],int numlines_s[CBANDS], int partition_l[HBLKSIZE],
+ 		  FLOAT8 minval[CBANDS], FLOAT8 qthr_l[CBANDS], 
+ 		  FLOAT8 s3_l[CBANDS + 1][CBANDS + 1],
+ 		  FLOAT8 s3_s[CBANDS + 1][CBANDS + 1],
+                   FLOAT8 qthr_s[CBANDS],
+ 		  FLOAT8 SNR_s[CBANDS],
+ 		  int bu_l[SBPSY_l], int bo_l[SBPSY_l],
+ 		  FLOAT8 w1_l[SBPSY_l], FLOAT8 w2_l[SBPSY_l],
+ 		  int bu_s[SBPSY_s], int bo_s[SBPSY_s],
+ 		  FLOAT8 w1_s[SBPSY_s], FLOAT8 w2_s[SBPSY_s] );
+ 									
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+  
+ 
+ void L3psycho_anal( lame_global_flags *gfp,
+                     short int *buffer[2],int gr_out , 
+                     FLOAT8 *ms_ratio,
+                     FLOAT8 *ms_ratio_next,
+ 		    FLOAT8 *ms_ener_ratio,
+ 		    III_psy_ratio masking_ratio[2][2],
+ 		    III_psy_ratio masking_MS_ratio[2][2],
+ 		    FLOAT8 percep_entropy[2],FLOAT8 percep_MS_entropy[2], 
+                     int blocktype_d[2])
+ {
+ 
+ /* to get a good cache performance, one has to think about
+  * the sequence, in which the variables are used
+  */
+   
+ /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
+ /* to be remembered for the unpredictability measure.  For "r" and        */
+ /* "phi_sav", the first index from the left is the channel select and     */
+ /* the second index is the "age" of the data.                             */
+   static FLOAT8	minval[CBANDS],qthr_l[CBANDS];
+   static FLOAT8	qthr_s[CBANDS];
+   static FLOAT8	nb_1[4][CBANDS], nb_2[4][CBANDS];
+   static FLOAT8 s3_s[CBANDS + 1][CBANDS + 1];
+   static FLOAT8 s3_l[CBANDS + 1][CBANDS + 1];
+ 
+   static III_psy_xmin thm[4];
+   static III_psy_xmin en[4];
+   
+   /* unpredictability calculation
+    */
+   static int cw_upper_index;
+   static int cw_lower_index;
+   static FLOAT ax_sav[4][2][HBLKSIZE];
+   static FLOAT bx_sav[4][2][HBLKSIZE];
+   static FLOAT rx_sav[4][2][HBLKSIZE];
+   static FLOAT cw[HBLKSIZE];
+ 
+   /* fft and energy calculation
+    */
+   FLOAT (*wsamp_l)[BLKSIZE];
+   FLOAT (*wsamp_s)[3][BLKSIZE_s];
+   FLOAT tot_ener[4];
+   static FLOAT wsamp_L[2][BLKSIZE];
+   static FLOAT energy[HBLKSIZE];
+   static FLOAT wsamp_S[2][3][BLKSIZE_s];
+   static FLOAT energy_s[3][HBLKSIZE_s];
+ 
+   /* convolution
+    */
+   static FLOAT8 eb[CBANDS];
+   static FLOAT8 cb[CBANDS];
+   static FLOAT8 thr[CBANDS];
+   
+   /* Scale Factor Bands
+    */
+   static FLOAT8	w1_l[SBPSY_l], w2_l[SBPSY_l];
+   static FLOAT8	w1_s[SBPSY_s], w2_s[SBPSY_s];
+   static FLOAT8 mld_l[SBPSY_l],mld_s[SBPSY_s];
+   static int	bu_l[SBPSY_l],bo_l[SBPSY_l] ;
+   static int	bu_s[SBPSY_s],bo_s[SBPSY_s] ;
+   static int	npart_l,npart_s;
+   static int	npart_l_orig,npart_s_orig;
+   
+   static int	s3ind[CBANDS][2];
+   static int	s3ind_s[CBANDS][2];
+ 
+   static int	numlines_s[CBANDS] ;
+   static int	numlines_l[CBANDS];
+   static int	partition_l[HBLKSIZE];
+   
+   /* frame analyzer 
+    */
+ #ifdef HAVEGTK
+   static FLOAT energy_save[4][HBLKSIZE];
+   static FLOAT8 pe_save[4];
+   static FLOAT8 ers_save[4];
+ #endif
+ 
+   /* ratios 
+    */
+   static FLOAT8 pe[4]={0,0,0,0};
+   static FLOAT8 ms_ratio_s_old=0,ms_ratio_l_old=0;
+   static FLOAT8 ms_ener_ratio_old=.25;
+   FLOAT8 ms_ratio_l=0,ms_ratio_s=0;
+ 
+   /* block type 
+    */
+   static int	blocktype_old[2];
+   int blocktype[2],uselongblock[2];
+   
+   /* usual variables like loop indices, etc..
+    */
+   int numchn, chn;
+   int   b, i, j, k;
+   int	sb,sblock;
+   FLOAT cwlimit;
+ 
+ 
+   /* initialization of static variables
+    */
+   if((gfp->frameNum==0) && (gr_out==0)){
+     FLOAT8	SNR_s[CBANDS];
+     
+     blocktype_old[0]=STOP_TYPE;
+     blocktype_old[1]=STOP_TYPE;
+     i = gfp->out_samplerate;
+     switch(i){
+     case 32000: break;
+     case 44100: break;
+     case 48000: break;
+     case 16000: break;
+     case 22050: break;
+     case 24000: break;
+     default:    fprintf(stderr,"error, invalid sampling frequency: %d Hz\n",i);
+       exit(-1);
+     }
+     
+     /* reset states used in unpredictability measure */
+     memset (rx_sav,0, sizeof(rx_sav));
+     memset (ax_sav,0, sizeof(ax_sav));
+     memset (bx_sav,0, sizeof(bx_sav));
+     memset (en,0, sizeof(en));
+     memset (thm,0, sizeof(thm));
+     
+ 
+     /*  gfp->cwlimit = sfreq*j/1024.0;  */
+     cw_lower_index=6;
+     if (gfp->cwlimit>0) 
+       cwlimit=gfp->cwlimit;
+     else
+       cwlimit=8.8717;
+     cw_upper_index = cwlimit*1000.0*1024.0/((FLOAT8) gfp->out_samplerate);
+     cw_upper_index=Min(HBLKSIZE-4,cw_upper_index);      /* j+3 < HBLKSIZE-1 */
+     cw_upper_index=Max(6,cw_upper_index);
+ 
+     for ( j = 0; j < HBLKSIZE; j++ )
+       cw[j] = 0.4;
+     
+     /* setup stereo demasking thresholds */
+     /* formula reverse enginerred from plot in paper */
+     for ( sb = 0; sb < SBPSY_s; sb++ ) {
+       FLOAT8 mld = 1.25*(1-cos(PI*sb/SBPSY_s))-2.5;
+       mld_s[sb] = pow(10.0,mld);
+     }
+     for ( sb = 0; sb < SBPSY_l; sb++ ) {
+       FLOAT8 mld = 1.25*(1-cos(PI*sb/SBPSY_l))-2.5;
+       mld_l[sb] = pow(10.0,mld);
+     }
+     
+     for (i=0;i<HBLKSIZE;i++) partition_l[i]=-1;
+ 
+     L3para_read( (FLOAT8) gfp->out_samplerate,numlines_l,numlines_s,partition_l,minval,qthr_l,s3_l,s3_s,
+ 		 qthr_s,SNR_s,
+ 		 bu_l,bo_l,w1_l,w2_l, bu_s,bo_s,w1_s,w2_s );
+     
+     
+     /* npart_l_orig   = number of partition bands before convolution */
+     /* npart_l  = number of partition bands after convolution */
+     npart_l_orig=0; npart_s_orig=0;
+     for (i=0;i<HBLKSIZE;i++) 
+       if (partition_l[i]>npart_l_orig) npart_l_orig=partition_l[i];
+     npart_l_orig++;
+ 
+     for (i=0;numlines_s[i]>=0;i++)
+       ;
+     npart_s_orig = i;
+     
+     npart_l=bo_l[SBPSY_l-1]+1;
+     npart_s=bo_s[SBPSY_s-1]+1;
+ 
+     /* MPEG2 tables are screwed up 
+      * the mapping from paritition bands to scalefactor bands will use
+      * more paritition bands than we have.  
+      * So we will not compute these fictitious partition bands by reducing
+      * npart_l below.  */
+     if (npart_l > npart_l_orig) {
+       npart_l=npart_l_orig;
+       bo_l[SBPSY_l-1]=npart_l-1;
+       w2_l[SBPSY_l-1]=1.0;
+     }
+     if (npart_s > npart_s_orig) {
+       npart_s=npart_s_orig;
+       bo_s[SBPSY_s-1]=npart_s-1;
+       w2_s[SBPSY_s-1]=1.0;
+     }
+     
+     
+     
+     for (i=0; i<npart_l; i++) {
+       for (j = 0; j < npart_l_orig; j++) {
+ 	if (s3_l[i][j] != 0.0)
+ 	  break;
+       }
+       s3ind[i][0] = j;
+       
+       for (j = npart_l_orig - 1; j > 0; j--) {
+ 	if (s3_l[i][j] != 0.0)
+ 	  break;
+       }
+       s3ind[i][1] = j;
+     }
+ 
+ 
+     for (i=0; i<npart_s; i++) {
+       for (j = 0; j < npart_s_orig; j++) {
+ 	if (s3_s[i][j] != 0.0)
+ 	  break;
+       }
+       s3ind_s[i][0] = j;
+       
+       for (j = npart_s_orig - 1; j > 0; j--) {
+ 	if (s3_s[i][j] != 0.0)
+ 	  break;
+       }
+       s3ind_s[i][1] = j;
+     }
+     
+     
+     /*  
+       #include "debugscalefac.c"
+     */
+     
+ 
+ #define AACS3
+ #define NEWS3XX
+ 
+ #ifdef AACS3
+     /* AAC values, results in more masking over MP3 values */
+ # define TMN 18
+ # define NMT 6
+ #else
+     /* MP3 values */
+ # define TMN 29
+ # define NMT 6
+ #endif
+ 
+ #define rpelev 2
+ #define rpelev2 16
+ 
+     /* compute norm_l, norm_s instead of relying on table data */
+     for ( b = 0;b < npart_l; b++ ) {
+       FLOAT8 norm=0;
+       for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ ) {
+ 	norm += s3_l[b][k];
+       }
+       for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ ) {
+ 	s3_l[b][k] *= exp(-LN_TO_LOG10 * NMT) / norm;
+       }
+       /*printf("%i  norm=%f  norm_l=%f \n",b,1/norm,norm_l[b]);*/
+     }
+ 
+     /* MPEG1 SNR_s data is given in db, convert to energy */
+     if (gfp->version == 1) {
+       for ( b = 0;b < npart_s; b++ ) {
+ 	SNR_s[b]=exp( (FLOAT8) SNR_s[b] * LN_TO_LOG10 );
+       }
+     }
+ 
+     for ( b = 0;b < npart_s; b++ ) {
+       FLOAT8 norm=0;
+       for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) {
+ 	norm += s3_s[b][k];
+       }
+       for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) {
+ 	s3_s[b][k] *= SNR_s[b] / norm;
+       }
+       /*printf("%i  norm=%f  norm_s=%f \n",b,1/norm,norm_l[b]);*/
+     }
+     
+     init_fft();
+   }
+   /************************* End of Initialization *****************************/
+   
+ 
+ 
+   
+   
+   numchn = gfp->stereo;
+   /* chn=2 and 3 = Mid and Side channels */
+   if (gfp->mode == MPG_MD_JOINT_STEREO) numchn=4;
+   for (chn=0; chn<numchn; chn++) {
+   
+     wsamp_s = wsamp_S+(chn & 1);
+     wsamp_l = wsamp_L+(chn & 1);
+ 
+ 
+     if (chn<2) {    
+       /**********************************************************************
+        *  compute FFTs
+        **********************************************************************/
+       fft_long ( *wsamp_l, chn, buffer);
+       fft_short( *wsamp_s, chn, buffer); 
+       
+       /* LR maskings  */
+       percep_entropy[chn] = pe[chn]; 
+       masking_ratio[gr_out][chn].thm = thm[chn];
+       masking_ratio[gr_out][chn].en = en[chn];
+     }else{
+       /* MS maskings  */
+       percep_MS_entropy[chn-2] = pe[chn]; 
+       masking_MS_ratio[gr_out][chn-2].en = en[chn];
+       masking_MS_ratio[gr_out][chn-2].thm = thm[chn];
+       
+       if (chn == 2)
+       {
+         for (j = BLKSIZE-1; j >=0 ; --j)
+         {
+           FLOAT l = wsamp_L[0][j];
+           FLOAT r = wsamp_L[1][j];
+           wsamp_L[0][j] = (l+r)*(FLOAT)(SQRT2*0.5);
+           wsamp_L[1][j] = (l-r)*(FLOAT)(SQRT2*0.5);
+         }
+         for (b = 2; b >= 0; --b)
+         {
+           for (j = BLKSIZE_s-1; j >= 0 ; --j)
+           {
+             FLOAT l = wsamp_S[0][b][j];
+             FLOAT r = wsamp_S[1][b][j];
+             wsamp_S[0][b][j] = (l+r)*(FLOAT)(SQRT2*0.5);
+             wsamp_S[1][b][j] = (l-r)*(FLOAT)(SQRT2*0.5);
+           }
+         }
+       }
+     }
+ 
+     /**********************************************************************
+      *  compute energies
+      **********************************************************************/
+     
+     
+     
+     energy[0]  = (*wsamp_l)[0];
+     energy[0] *= energy[0];
+     
+     tot_ener[chn] = energy[0]; /* sum total energy at nearly no extra cost */
+     
+     for (j=BLKSIZE/2-1; j >= 0; --j)
+     {
+       FLOAT re = (*wsamp_l)[BLKSIZE/2-j];
+       FLOAT im = (*wsamp_l)[BLKSIZE/2+j];
+       energy[BLKSIZE/2-j] = (re * re + im * im) * (FLOAT)0.5;
+       
+       tot_ener[chn] += energy[BLKSIZE/2-j];
+     }
+     for (b = 2; b >= 0; --b)
+     {
+       energy_s[b][0]  = (*wsamp_s)[b][0];
+       energy_s[b][0] *=  energy_s [b][0];
+       for (j=BLKSIZE_s/2-1; j >= 0; --j)
+       {
+         FLOAT re = (*wsamp_s)[b][BLKSIZE_s/2-j];
+         FLOAT im = (*wsamp_s)[b][BLKSIZE_s/2+j];
+         energy_s[b][BLKSIZE_s/2-j] = (re * re + im * im) * (FLOAT)0.5;
+       }
+     }
+ 
+ 
+ #ifdef HAVEGTK
+   if(gfp->gtkflag) {
+     for (j=0; j<HBLKSIZE ; j++) {
+       pinfo->energy[gr_out][chn][j]=energy_save[chn][j];
+       energy_save[chn][j]=energy[j];
+     }
+   }
+ #endif
+     
+     /**********************************************************************
+      *    compute unpredicatability of first six spectral lines            * 
+      **********************************************************************/
+     for ( j = 0; j < cw_lower_index; j++ )
+       {	 /* calculate unpredictability measure cw */
+ 	FLOAT an, a1, a2;
+ 	FLOAT bn, b1, b2;
+ 	FLOAT rn, r1, r2;
+ 	FLOAT numre, numim, den;
+ 
+ 	a2 = ax_sav[chn][1][j];
+ 	b2 = bx_sav[chn][1][j];
+ 	r2 = rx_sav[chn][1][j];
+ 	a1 = ax_sav[chn][1][j] = ax_sav[chn][0][j];
+ 	b1 = bx_sav[chn][1][j] = bx_sav[chn][0][j];
+ 	r1 = rx_sav[chn][1][j] = rx_sav[chn][0][j];
+ 	an = ax_sav[chn][0][j] = (*wsamp_l)[j];
+ 	bn = bx_sav[chn][0][j] = j==0 ? (*wsamp_l)[0] : (*wsamp_l)[BLKSIZE-j];  
+ 	rn = rx_sav[chn][0][j] = sqrt(energy[j]);
+ 
+ 	{ /* square (x1,y1) */
+ 	  if( r1 != 0 ) {
+ 	    numre = (a1*b1);
+ 	    numim = (a1*a1-b1*b1)*(FLOAT)0.5;
+ 	    den = r1*r1;
+ 	  } else {
+ 	    numre = 1;
+ 	    numim = 0;
+ 	    den = 1;
+ 	  }
+ 	}
+ 	
+ 	{ /* multiply by (x2,-y2) */
+ 	  if( r2 != 0 ) {
+ 	    FLOAT tmp2 = (numim+numre)*(a2+b2)*(FLOAT)0.5;
+ 	    FLOAT tmp1 = -a2*numre+tmp2;
+ 	    numre =       -b2*numim+tmp2;
+ 	    numim = tmp1;
+ 	    den *= r2;
+ 	  } else {
+ 	    /* do nothing */
+ 	  }
+ 	}
+ 	
+ 	{ /* r-prime factor */
+ 	  FLOAT tmp = (2*r1-r2)/den;
+ 	  numre *= tmp;
+ 	  numim *= tmp;
+ 	}
+ 	den=rn+fabs(2*r1-r2);
+ 	if( den != 0 ) {
+ 	  numre = (an+bn)*(FLOAT)0.5-numre;
+ 	  numim = (an-bn)*(FLOAT)0.5-numim;
+ 	  den = sqrt(numre*numre+numim*numim)/den;
+ 	}
+ 	cw[j] = den;
+       }
+ 
+ 
+ 
+     /**********************************************************************
+      *     compute unpredicatibility of next 200 spectral lines            *
+      **********************************************************************/ 
+     for ( j = cw_lower_index; j < cw_upper_index; j += 4 )
+       {/* calculate unpredictability measure cw */
+ 	FLOAT rn, r1, r2;
+ 	FLOAT numre, numim, den;
+ 	
+ 	k = (j+2) / 4; 
+ 	
+ 	{ /* square (x1,y1) */
+ 	  r1 = energy_s[0][k];
+ 	  if( r1 != 0 ) {
+ 	    FLOAT a1 = (*wsamp_s)[0][k]; 
+ 	    FLOAT b1 = (*wsamp_s)[0][BLKSIZE_s-k]; /* k is never 0 */
+ 	    numre = (a1*b1);
+ 	    numim = (a1*a1-b1*b1)*(FLOAT)0.5;
+ 	    den = r1;
+ 	    r1 = sqrt(r1);
+ 	  } else {
+ 	    numre = 1;
+ 	    numim = 0;
+ 	    den = 1;
+ 	  }
+ 	}
+ 	
+ 	
+ 	{ /* multiply by (x2,-y2) */
+ 	  r2 = energy_s[2][k];
+ 	  if( r2 != 0 ) {
+ 	    FLOAT a2 = (*wsamp_s)[2][k]; 
+ 	    FLOAT b2 = (*wsamp_s)[2][BLKSIZE_s-k];
+ 	    
+ 	    
+ 	    FLOAT tmp2 = (numim+numre)*(a2+b2)*(FLOAT)0.5;
+ 	    FLOAT tmp1 = -a2*numre+tmp2;
+ 	    numre =       -b2*numim+tmp2;
+ 	    numim = tmp1;
+ 	    
+ 	    r2 = sqrt(r2);
+ 	    den *= r2;
+ 	  } else {
+ 	    /* do nothing */
+ 	  }
+ 	}
+ 	
+ 	{ /* r-prime factor */
+ 	  FLOAT tmp = (2*r1-r2)/den;
+ 	  numre *= tmp;
+ 	  numim *= tmp;
+ 	}
+ 	
+ 	rn = sqrt(energy_s[1][k]);
+ 	den=rn+fabs(2*r1-r2);
+ 	if( den != 0 ) {
+ 	  FLOAT an = (*wsamp_s)[1][k]; 
+ 	  FLOAT bn = (*wsamp_s)[1][BLKSIZE_s-k];
+ 	  numre = (an+bn)*(FLOAT)0.5-numre;
+ 	  numim = (an-bn)*(FLOAT)0.5-numim;
+ 	  den = sqrt(numre*numre+numim*numim)/den;
+ 	}
+ 	
+ 	cw[j+1] = cw[j+2] = cw[j+3] = cw[j] = den;
+       }
+     
+ #if 0
+     for ( j = 14; j < HBLKSIZE-4; j += 4 )
+       {/* calculate energy from short ffts */
+ 	FLOAT8 tot,ave;
+ 	k = (j+2) / 4; 
+ 	for (tot=0, sblock=0; sblock < 3; sblock++)
+ 	  tot+=energy_s[sblock][k];
+ 	ave = energy[j+1]+ energy[j+2]+ energy[j+3]+ energy[j];
+ 	ave /= 4.;
+ 	/*
+ 	  printf("energy / tot %i %5.2f   %e  %e\n",j,ave/(tot*16./3.),
+ 	  ave,tot*16./3.);
+ 	*/
+ 	energy[j+1] = energy[j+2] = energy[j+3] =  energy[j]=tot;
+       }
+ #endif
+     
+     
+     
+     
+     
+     
+     
+     
+     /**********************************************************************
+      *    Calculate the energy and the unpredictability in the threshold   *
+      *    calculation partitions                                           *
+      **********************************************************************/
+ #if 0
+     for ( b = 0; b < CBANDS; b++ )
+       {
+ 	eb[b] = 0;
+ 	cb[b] = 0;
+       }
+     for ( j = 0; j < HBLKSIZE; j++ )
+       {
+ 	int tp = partition_l[j];
+ 	
+ 	if ( tp >= 0 )
+ 	  {
+ 	    eb[tp] += energy[j];
+ 	    cb[tp] += cw[j] * energy[j];
+ 	  }
+ 	assert(tp<npart_l_orig);
+       }
+ #else
+     b = 0;
+     for (j = 0; j < cw_upper_index;)
+       {
+ 	FLOAT8 ebb, cbb;
+ 	int i;
+ 
+ 	ebb = energy[j];
+ 	cbb = energy[j] * cw[j];
+ 	j++;
+ 
+ 	for (i = numlines_l[b] - 1; i > 0; i--)
+ 	  {
+ 	    ebb += energy[j];
+ 	    cbb += energy[j] * cw[j];
+ 	    j++;
+ 	  }
+ 	eb[b] = ebb;
+ 	cb[b] = cbb;
+ 	b++;
+       }
+ 
+     for (; b < npart_l_orig; b++ )
+       {
+ 	int i;
+ 	FLOAT8 ebb = energy[j++];
+ 
+ 	for (i = numlines_l[b] - 1; i > 0; i--)
+ 	  {
+ 	    ebb += energy[j++];
+ 	  }
+ 	eb[b] = ebb;
+ 	cb[b] = ebb * 0.4;
+       }
+ #endif
+ 
+     /**********************************************************************
+      *      convolve the partitioned energy and unpredictability           *
+      *      with the spreading function, s3_l[b][k]                        *
+      ******************************************************************** */
+     pe[chn] = 0;		/*  calculate percetual entropy */
+     for ( b = 0;b < npart_l; b++ )
+       {
+ 	FLOAT8 tbb,ecb,ctb;
+ 	FLOAT8 temp_1; /* BUG of IS */
+ 
+ 	ecb = 0;
+ 	ctb = 0;
+ 	for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ )
+ 	  {
+ 	    ecb += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
+ 	    ctb += s3_l[b][k] * cb[k];
+ 	  }
+ 
+ 	/* calculate the tonality of each threshold calculation partition */
+ 	/* calculate the SNR in each threshhold calculation partition */
+ 
+ 	tbb = ecb;
+ 	if (tbb != 0)
+ 	  {
+ 	    tbb = ctb / tbb;
+ 	    if (tbb <= 0.04875584301)
+ 	      {
+ 		tbb = exp(-LN_TO_LOG10 * (TMN - NMT));
+ 	      }
+ 	    else if (tbb > 0.4989003827)
+ 	      {
+ 		tbb = 1;
+ 	      }
+ 	    else
+ 	      {
+ 		tbb = log(tbb);
+ 		tbb = exp(((TMN - NMT)*(LN_TO_LOG10*0.299))
+ 			+ ((TMN - NMT)*(LN_TO_LOG10*0.43 ))*tbb);  /* conv1=-0.299, conv2=-0.43 */
+ 	      }
+ 	  }
+ 
+ 	tbb = Min(minval[b], tbb);
+ 	ecb *= tbb;
+ 
+ 	/* pre-echo control */
+ 	/* rpelev=2.0, rpelev2=16.0 */
+ 	temp_1 = Min(ecb, Min(rpelev*nb_1[chn][b],rpelev2*nb_2[chn][b]) );
+ 	thr[b] = Max( qthr_l[b], temp_1 ); 
+ 	nb_2[chn][b] = nb_1[chn][b];
+ 	nb_1[chn][b] = ecb;
+ 
+ 	/* note: all surges in PE are because of the above pre-echo formula
+ 	 * for temp_1.  it this is not used, PE is always around 600
+ 	 */
+ 
+ 	if (thr[b] < eb[b])
+ 	  {
+ 	    /* there's no non sound portition, because thr[b] is
+ 	     maximum of qthr_l and temp_1 */
+ 	    pe[chn] -= numlines_l[b] * log(thr[b] / eb[b]);
+ 	  }
+       }
+ 
+ 
+ #ifdef HAVEGTK
+     if (gfp->gtkflag) {
+       FLOAT mn,mx,ma=0,mb=0,mc=0;
+ 
+       for ( j = HBLKSIZE_s/2; j < HBLKSIZE_s; j ++)
+       {
+         ma += energy_s[0][j];
+         mb += energy_s[1][j];
+         mc += energy_s[2][j];
+       }
+       mn = Min(ma,mb);
+       mn = Min(mn,mc);
+       mx = Max(ma,mb);
+       mx = Max(mx,mc);
+ 
+       pinfo->ers[gr_out][chn]=ers_save[chn];
+       ers_save[chn]=mx/(1e-12+mn);
+       pinfo->pe[gr_out][chn]=pe_save[chn];
+       pe_save[chn]=pe[chn];
+     }
+ #endif
+     
+     /*************************************************************** 
+      * determine the block type (window type) based on L & R channels
+      * 
+      ***************************************************************/
+     if (chn<2) {
+       if (gfp->no_short_blocks){
+ 	uselongblock[chn]=1;
+       } else {
+ 	/* tuned for t1.wav.  doesnt effect most other samples */
+ 	if (pe[chn] > 3000) {
+ 	  uselongblock[chn]=0;
+ 	} else { 
+ 	  FLOAT mn,mx,ma=0,mb=0,mc=0;
+ 	
+ 	  for ( j = HBLKSIZE_s/2; j < HBLKSIZE_s; j ++)
+ 	  {
+ 	      ma += energy_s[0][j];
+ 	      mb += energy_s[1][j];
+ 	      mc += energy_s[2][j];
+ 	  }
+ 	  mn = Min(ma,mb);
+ 	  mn = Min(mn,mc);
+ 	  mx = Max(ma,mb);
+ 	  mx = Max(mx,mc);
+ 
+ 	  uselongblock[chn] = 1;
+ 	  
+ 	  if ( mx > 30*mn ) 
+ 	  {/* big surge of energy - always use short blocks */
+ 	    uselongblock[chn] = 0;
+ 	  } 
+ 	  else if ((mx > 10*mn) && (pe[chn] > 1000))
+ 	  {/* medium surge, medium pe - use short blocks */
+ 	    uselongblock[chn] = 0;
+ 	  }
+ 	} 
+       }
+     }
+ 
+ 
+ 
+     /*************************************************************** 
+      * compute masking thresholds for both short and long blocks
+      ***************************************************************/
+     /* longblock threshold calculation (part 2) */
+     for ( sb = 0; sb < SBPSY_l; sb++ )
+       {
+ 	FLOAT8 enn = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
+ 	FLOAT8 thmm = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
+ 	for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
+ 	  {
+ 	    enn  += eb[b];
+ 	    thmm += thr[b];
+ 	  }
+ 	en[chn].l[sb] = enn;
+ 	thm[chn].l[sb] = thmm;
+       }
+     
+     
+     /* threshold calculation for short blocks */
+     for ( sblock = 0; sblock < 3; sblock++ )
+       {
+ 	j = 0;
+ 	for ( b = 0; b < npart_s_orig; b++ )
+ 	  {
+ 	    int i;
+ 	    FLOAT ecb = energy_s[sblock][j++];
+ 	    for (i = numlines_s[b]; i > 0; i--)
+ 	      {
+ 		ecb += energy_s[sblock][j++];
+ 	      }
+ 	    eb[b] = ecb;
+ 	  }
+ 
+ 	for ( b = 0; b < npart_s; b++ )
+ 	  {
+ 	    FLOAT8 ecb = 0;
+ 	    for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ )
+ 	      {
+ 		ecb += s3_s[b][k] * eb[k];
+ 	      }
+ 	    thr[b] = Max (qthr_s[b], ecb);
+ 	  }
+ 
+ 	for ( sb = 0; sb < SBPSY_s; sb++ )
+ 	  {
+ 	    FLOAT8 enn  = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
+ 	    FLOAT8 thmm = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
+ 	    for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
+ 	      {
+ 		enn  += eb[b];
+ 		thmm += thr[b];
+ 	      }
+ 	    en[chn].s[sb][sblock] = enn;
+ 	    thm[chn].s[sb][sblock] = thmm;
+ 	  }
+       }
+   } /* end loop over chn */
+ 
+ 
+   /* compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper */
+   if ( numchn==4 /* mid/side and r/l */) {
+     FLOAT8 rside,rmid,mld;
+     int chmid=2,chside=3; 
+     
+     for ( sb = 0; sb < SBPSY_l; sb++ ) {
+       /* use this fix if L & R masking differs by 2db or less */
+       /* if db = 10*log10(x2/x1) < 2 */
+       /* if (x2 < 1.58*x1) { */
+       if (thm[0].l[sb] <= 1.58*thm[1].l[sb]
+ 	  && thm[1].l[sb] <= 1.58*thm[0].l[sb]) {
+ 
+ 	mld = mld_l[sb]*en[chside].l[sb];
+ 	rmid = Max(thm[chmid].l[sb], Min(thm[chside].l[sb],mld));
+ 
+ 	mld = mld_l[sb]*en[chmid].l[sb];
+ 	rside = Max(thm[chside].l[sb],Min(thm[chmid].l[sb],mld));
+ 
+ 	thm[chmid].l[sb]=rmid;
+ 	thm[chside].l[sb]=rside;
+       }
+     }
+     for ( sb = 0; sb < SBPSY_s; sb++ ) {
+       for ( sblock = 0; sblock < 3; sblock++ ) {
+ 	if (thm[0].s[sb][sblock] <= 1.58*thm[1].s[sb][sblock]
+ 	    && thm[1].s[sb][sblock] <= 1.58*thm[0].s[sb][sblock]) {
+ 
+ 	  mld = mld_s[sb]*en[chside].s[sb][sblock];
+ 	  rmid = Max(thm[chmid].s[sb][sblock],Min(thm[chside].s[sb][sblock],mld));
+ 
+ 	  mld = mld_s[sb]*en[chmid].s[sb][sblock];
+ 	  rside = Max(thm[chside].s[sb][sblock],Min(thm[chmid].s[sb][sblock],mld));
+ 
+ 	  thm[chmid].s[sb][sblock]=rmid;
+ 	  thm[chside].s[sb][sblock]=rside;
+ 	}
+       }
+     }
+   }
+ 
+ 
+   
+ 
+   
+   
+   if (gfp->mode == MPG_MD_JOINT_STEREO)  {
+     /* determin ms_ratio from masking thresholds*/
+     /* use ms_stereo (ms_ratio < .35) if average thresh. diff < 5 db */
+     FLOAT8 db,x1,x2,sidetot=0,tot=0;
+     for (sb= SBPSY_l/4 ; sb< SBPSY_l; sb ++ ) {
+       x1 = Min(thm[0].l[sb],thm[1].l[sb]);
+       x2 = Max(thm[0].l[sb],thm[1].l[sb]);
+       /* thresholds difference in db */
+       if (x2 >= 1000*x1)  db=3;
+       else db = log10(x2/x1);  
+       /*  printf("db = %f %e %e  \n",db,thm[0].l[sb],thm[1].l[sb]);*/
+       sidetot += db;
+       tot++;
+     }
+     ms_ratio_l= (sidetot/tot)*0.7; /* was .35*(sidetot/tot)/5.0*10 */
+     ms_ratio_l = Min(ms_ratio_l,0.5);
+     
+     sidetot=0; tot=0;
+     for ( sblock = 0; sblock < 3; sblock++ )
+       for ( sb = SBPSY_s/4; sb < SBPSY_s; sb++ ) {
+ 	x1 = Min(thm[0].s[sb][sblock],thm[1].s[sb][sblock]);
+ 	x2 = Max(thm[0].s[sb][sblock],thm[1].s[sb][sblock]);
+ 	/* thresholds difference in db */
+ 	if (x2 >= 1000*x1)  db=3;
+ 	else db = log10(x2/x1);  
+ 	sidetot += db;
+ 	tot++;
+       }
+     ms_ratio_s = (sidetot/tot)*0.7; /* was .35*(sidetot/tot)/5.0*10 */
+     ms_ratio_s = Min(ms_ratio_s,.5);
+   }
+ 
+   /*************************************************************** 
+    * determin final block type
+    ***************************************************************/
+ 
+   for (chn=0; chn<gfp->stereo; chn++) {
+     blocktype[chn] = NORM_TYPE;
+   }
+ 
+ 
+   if (gfp->stereo==2) {
+     if (!gfp->allow_diff_short || gfp->mode==MPG_MD_JOINT_STEREO) {
+       /* force both channels to use the same block type */
+       /* this is necessary if the frame is to be encoded in ms_stereo.  */
+       /* But even without ms_stereo, FhG  does this */
+       int bothlong= (uselongblock[0] && uselongblock[1]);
+       if (!bothlong) {
+ 	uselongblock[0]=0;
+ 	uselongblock[1]=0;
+       }
+     }
+   }
+ 
+   
+   
+   /* update the blocktype of the previous granule, since it depends on what
+    * happend in this granule */
+   for (chn=0; chn<gfp->stereo; chn++) {
+     if ( uselongblock[chn])
+       {				/* no attack : use long blocks */
+ 	switch( blocktype_old[chn] ) 
+ 	  {
+ 	  case NORM_TYPE:
+ 	  case STOP_TYPE:
+ 	    blocktype[chn] = NORM_TYPE;
+ 	    break;
+ 	  case SHORT_TYPE:
+ 	    blocktype[chn] = STOP_TYPE; 
+ 	    break;
+ 	  case START_TYPE:
+ 	    fprintf( stderr, "Error in block selecting\n" );
+ 	    abort();
+ 	    break; /* problem */
+ 	  }
+       } else   {
+ 	/* attack : use short blocks */
+ 	blocktype[chn] = SHORT_TYPE;
+ 	if ( blocktype_old[chn] == NORM_TYPE ) {
+ 	  blocktype_old[chn] = START_TYPE;
+ 	}
+ 	if ( blocktype_old[chn] == STOP_TYPE ) {
+ 	  blocktype_old[chn] = SHORT_TYPE ;
+ 	}
+       }
+     
+     blocktype_d[chn] = blocktype_old[chn];  /* value returned to calling program */
+     blocktype_old[chn] = blocktype[chn];    /* save for next call to l3psy_anal */
+   }
+   
+   if (blocktype_d[0]==2) 
+     *ms_ratio = ms_ratio_s_old;
+   else
+     *ms_ratio = ms_ratio_l_old;
+ 
+   ms_ratio_s_old = ms_ratio_s;
+   ms_ratio_l_old = ms_ratio_l;
+ 
+   /* we dont know the block type of this frame yet - assume long */
+   *ms_ratio_next = ms_ratio_l;
+ 
+ 
+ 
+   /*********************************************************************/
+   /* compute side_energy / (side+mid)_energy */
+   /* 0 = no energy in side channel */
+   /* .5 = half of total energy in side channel */
+   /*********************************************************************/
+   if (numchn==4)  {
+     FLOAT tmp = tot_ener[3]+tot_ener[2];
+     *ms_ener_ratio = ms_ener_ratio_old;
+     ms_ener_ratio_old=0;
+     if (tmp>0) ms_ener_ratio_old=tot_ener[3]/tmp;
+   } else
+     /* we didn't compute ms_ener_ratios */
+     *ms_ener_ratio = 0;
+  
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ void L3para_read(FLOAT8 sfreq, int *numlines_l,int *numlines_s, int *partition_l, FLOAT8 *minval,
+ FLOAT8 *qthr_l, FLOAT8 s3_l[64][64], FLOAT8 s3_s[CBANDS + 1][CBANDS + 1],
+ FLOAT8 *qthr_s, FLOAT8 *SNR, 
+ int *bu_l, int *bo_l, FLOAT8 *w1_l, FLOAT8 *w2_l, 
+ int *bu_s, int *bo_s, FLOAT8 *w1_s, FLOAT8 *w2_s)
+ {
+   FLOAT8 freq_tp;
+   FLOAT8 bval_l[CBANDS], bval_s[CBANDS];
+   int   cbmax=0, cbmax_tp;
+   FLOAT8 *p = psy_data;
+ 
+   int  sbmax ;
+   int  i,j,k,k2,loop, part_max ;
+   int freq_scale=1;
+ 
+ 
+   /* use MPEG1 tables.  The MPEG2 tables in tables.c appear to be 
+    * junk.  MPEG2 doc claims data for these tables is the same as the
+    * MPEG1 data for 2x sampling frequency */
+   /*  if (sfreq<32000) freq_scale=2; */
+   
+ 
+ 
+   /* Read long block data */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       cbmax_tp = (int) *p++;
+       cbmax_tp++;
+ 
+       if (sfreq == freq_tp/freq_scale )
+ 	{
+ 	  cbmax = cbmax_tp;
+ 	  for(i=0,k2=0;i<cbmax_tp;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      numlines_l[i] = (int) *p++;
+ 	      minval[i] = exp(-((*p++) - NMT) * LN_TO_LOG10);
+ 	      qthr_l[i] = *p++;
+ 	      /* norm_l[i] = *p++*/ p++;
+ 	      bval_l[i] = *p++;
+ 	      if (j!=i)
+ 		{
+ 		  fprintf(stderr,"1. please check \"psy_data\"");
+ 		  exit(-1);
+ 		}
+ 	      for(k=0;k<numlines_l[i];k++)
+ 		partition_l[k2++] = i ;
+ 	    }
+ 	}
+       else
+ 	p += cbmax_tp * 6;
+     }
+ 
+ #define NEWBARKXXX
+ #ifdef NEWBARK
+   /* compute bark values of each critical band */
+   j = 0;
+   for(i=0;i<cbmax;i++)
+     {
+       FLOAT8 ji, freq, bark;
+ 
+       ji = j + (numlines_l[i]-1)/2.0;
+       freq = sfreq*ji/1024000.0;
+       bark = 13*atan(.76*freq) + 3.5*atan(freq*freq/(7.5*7.5));
+ 
+       printf("%i %i bval_l table=%f  f=%f  formaula=%f \n",i,j,bval_l[i],freq,bark);
+       bval_l[i]=bark;
+       j += numlines_l[i];
+     }
+ #endif
+ 
+   /************************************************************************
+    * Now compute the spreading function, s[j][i], the value of the spread-*
+    * ing function, centered at band j, for band i, store for later use    *
+    ************************************************************************/
+   /* i.e.: sum over j to spread into signal barkval=i  
+      NOTE: i and j are used opposite as in the ISO docs */
+   part_max = cbmax ;
+   for(i=0;i<part_max;i++)
+     {
+       FLOAT8 tempx,x,tempy,temp;
+       for(j=0;j<part_max;j++)
+ 	{
+ 	  /*tempx = (bval_l[i] - bval_l[j])*1.05;*/
+ 	  if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
+ 	  else    tempx = (bval_l[i] - bval_l[j])*1.5;
+ 
+ #ifdef AACS3	
+           if (i>=j) tempx = (bval_l[i] - bval_l[j])*3.0;
+ 	  else    tempx = (bval_l[i] - bval_l[j])*1.5; 
+ #endif
+ 
+ 	  if(tempx>=0.5 && tempx<=2.5)
+ 	    {
+ 	      temp = tempx - 0.5;
+ 	      x = 8.0 * (temp*temp - 2.0 * temp);
+ 	    }
+ 	  else x = 0.0;
+ 	  tempx += 0.474;
+ 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
+ 
+ #ifdef NEWS3
+ 	  if (j>=i) tempy = (bval_l[j] - bval_l[i])*(-15);
+ 	  else    tempy = (bval_l[j] - bval_l[i])*25;
+ 	  x=0; 
+ #endif
+ 	  /*
+ 	  if ((i==part_max/2)  && (fabs(bval_l[j] - bval_l[i])) < 3) {
+ 	    printf("bark=%f   x+tempy = %f  \n",bval_l[j] - bval_l[i],x+tempy);
+ 	  }
+ 	  */
+ 
+ 	  if (tempy <= -60.0) s3_l[i][j] = 0.0;
+ 	  else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 ); 
+ 	}
+     }
+ 
+   /* Read short block data */
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       cbmax_tp = (int) *p++;
+       cbmax_tp++;
+ 
+       if (sfreq == freq_tp/freq_scale )
+ 	{
+ 	  cbmax = cbmax_tp;
+ 	  for(i=0,k2=0;i<cbmax_tp;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      numlines_s[i] = (int) *p++;
+ 	      qthr_s[i] = *p++;         
+ 	      /* norm_s[i] =*p++ */ p++;         
+ 	      SNR[i] = *p++;            
+ 	      bval_s[i] = *p++;
+ 	      if (j!=i)
+ 		{
+ 		  fprintf(stderr,"3. please check \"psy_data\"");
+ 		  exit(-1);
+ 		}
+ 	      numlines_s[i]--;
+ 	    }
+ 	  numlines_s[i] = -1;
+ 	}
+       else
+ 	p += cbmax_tp * 6;
+     }
+ 
+ 
+ #ifdef NEWBARK
+   /* compute bark values of each critical band */
+   j = 0;
+   for(i=0;i<cbmax;i++)
+     {
+       FLOAT8 ji, freq, bark;
+       ji = (j * 2 + numlines_s[i]) / 2.0;
+       freq = sfreq*ji/256000.0;
+       bark = 13*atan(.76*freq) + 3.5*atan(freq*freq/(7.5*7.5));
+       printf("%i %i bval_s = %f  %f  %f \n",i,j,bval_s[i],freq,bark);
+       bval_s[i]=bark;
+       j += numlines_s[i] + 1;
+     }
+ #endif
+ 
+ 
+ 
+   /************************************************************************
+    * Now compute the spreading function, s[j][i], the value of the spread-*
+    * ing function, centered at band j, for band i, store for later use    *
+    ************************************************************************/
+   part_max = cbmax ;
+   for(i=0;i<part_max;i++)
+     {
+       FLOAT8 tempx,x,tempy,temp;
+       for(j=0;j<part_max;j++)
+ 	{
+ 	  /* tempx = (bval_s[i] - bval_s[j])*1.05;*/
+ 	  if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
+ 	  else    tempx = (bval_s[i] - bval_s[j])*1.5;
+ #ifdef AACS3
+           if (i>=j) tempx = (bval_s[i] - bval_s[j])*3.0;
+ 	  else    tempx = (bval_s[i] - bval_s[j])*1.5; 
+ #endif
+ 	  if(tempx>=0.5 && tempx<=2.5)
+ 	    {
+ 	      temp = tempx - 0.5;
+ 	      x = 8.0 * (temp*temp - 2.0 * temp);
+ 	    }
+ 	  else x = 0.0;
+ 	  tempx += 0.474;
+ 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
+ #ifdef NEWS3
+ 	  if (j>=i) tempy = (bval_s[j] - bval_s[i])*(-15);
+ 	  else    tempy = (bval_s[j] - bval_s[i])*25;
+ 	  x=0; 
+ #endif
+ 	  if (tempy <= -60.0) s3_s[i][j] = 0.0;
+ 	  else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
+ 	}
+     }
+   /* Read long block data for converting threshold calculation 
+      partitions to scale factor bands */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       sbmax =  (int) *p++;
+       sbmax++;
+ 
+       if (sfreq == freq_tp/freq_scale)
+ 	{
+ 	  for(i=0;i<sbmax;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      p++;             
+ 	      bu_l[i] = (int) *p++;
+ 	      bo_l[i] = (int) *p++;
+ 	      w1_l[i] = (FLOAT8) *p++;
+ 	      w2_l[i] = (FLOAT8) *p++;
+ 	      if (j!=i)
+ 		{ fprintf(stderr,"30:please check \"psy_data\"\n");
+ 		exit(-1);
+ 		}
+ 
+ 	      if (i!=0)
+ 		if ( (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
+ 		  {
+ 		    fprintf(stderr,"31l: please check \"psy_data.\"\n");
+                   fprintf(stderr,"w1,w2: %f %f \n",w1_l[i],w2_l[i-1]);
+ 		    exit(-1);
+ 		  }
+ 	    }
+ 	}
+       else
+ 	p += sbmax * 6;
+     }
+ 
+   /* Read short block data for converting threshold calculation 
+      partitions to scale factor bands */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       sbmax = (int) *p++;
+       sbmax++;
+ 
+       if (sfreq == freq_tp/freq_scale)
+ 	{
+ 	  for(i=0;i<sbmax;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      p++;
+ 	      bu_s[i] = (int) *p++;
+ 	      bo_s[i] = (int) *p++;
+ 	      w1_s[i] = *p++;
+ 	      w2_s[i] = *p++;
+ 	      if (j!=i)
+ 		{ fprintf(stderr,"30:please check \"psy_data\"\n");
+ 		exit(-1);
+ 		}
+ 
+ 	      if (i!=0)
+ 		if ( (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
+ 		  { 
+                   fprintf(stderr,"31s: please check \"psy_data.\"\n");
+                   fprintf(stderr,"w1,w2: %f %f \n",w1_s[i],w2_s[i-1]);
+ 		  exit(-1);
+ 		  }
+ 	    }
+ 	}
+       else
+ 	p += sbmax * 6;
+     }
+ 
+ }
diff -r -c -N encoder/psymodel.h lame3.70/psymodel.h
*** encoder/psymodel.h	Wed Dec 31 17:00:00 1969
--- lame3.70/psymodel.h	Fri Mar 24 11:07:30 2000
***************
*** 0 ****
--- 1,15 ----
+ #ifndef L3PSY_DOT_H_
+ #define L3PSY_DOT_H_
+ 
+ /* l3psy.c */
+ #include "l3side.h"
+ void L3psycho_anal( lame_global_flags *gfp,
+                     short int *buffer[2], int gr , 
+ 		    FLOAT8 *ms_ratio, 
+ 		    FLOAT8 *ms_ratio_next, 
+ 		    FLOAT8 *ms_ener_ratio, 
+ 		    III_psy_ratio ratio[2][2],
+ 		    III_psy_ratio MS_ratio[2][2],
+ 		    FLOAT8 pe[2], FLOAT8 pe_MS[2], 
+                     int blocktype_d[2]); 
+ #endif
diff -r -c -N encoder/quantize-pvt.c lame3.70/quantize-pvt.c
*** encoder/quantize-pvt.c	Wed Dec 31 17:00:00 1969
--- lame3.70/quantize-pvt.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,1318 ----
+ #include <assert.h>
+ #include "util.h"
+ #include "tables.h"
+ #include "reservoir.h"
+ #include "quantize-pvt.h"
+ 
+ FLOAT masking_lower=1;
+ int convert_mdct, reduce_sidechannel;
+ /*
+ mt 5/99.  These global flags denote 4 possibilities:
+                                                                 mode    l3_xmin
+ 1   MDCT input L/R, quantize L/R,   psy-model thresholds: L/R   -m s     either
+ 2   MDCT input L/R, quantize M/S,   psy-model thresholds: L/R   -m j     orig
+ 3   MDCT input M/S, quantize M/S,   psy-model thresholds: M/S   -m f     either
+ 4   MDCT input L/R, quantize M/S,   psy-model thresholds: M/S   -m j -h  m/s
+ 
+ 1:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=0          
+ 2:  convert_mdct = 1, convert_psy=1,  reduce_sidechannel=1
+ 3:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=1   (this mode no longer used)
+ 4:  convert_mdct = 1, convert_psy=0,  reduce_sidechannel=1
+ 
+ if (convert_mdct), then iteration_loop will quantize M/S data from
+ the L/R input MDCT coefficients.
+ 
+ if (convert_psy), then calc_noise will compute the noise for the L/R
+ channels from M/S MDCT data and L/R psy-model threshold information.
+ Distortion in ether L or R channel will be marked as distortion in
+ both Mid and Side channels.  
+ NOTE: 3/00: this mode has been removed.  
+ 
+ if (reduce_sidechannel) then outer_loop will allocate less bits
+ to the side channel and more bits to the mid channel based on relative 
+ energies.
+ */
+ 
+ 
+ 
+ /*
+   The following table is used to implement the scalefactor
+   partitioning for MPEG2 as described in section
+   2.4.3.2 of the IS. The indexing corresponds to the
+   way the tables are presented in the IS:
+ 
+   [table_number][row_in_table][column of nr_of_sfb]
+ */
+ unsigned nr_of_sfb_block[6][3][4] =
+ {
+   {
+     {6, 5, 5, 5},
+     {9, 9, 9, 9},
+     {6, 9, 9, 9}
+   },
+   {
+     {6, 5, 7, 3},
+     {9, 9, 12, 6},
+     {6, 9, 12, 6}
+   },
+   {
+     {11, 10, 0, 0},
+     {18, 18, 0, 0},
+     {15,18,0,0}
+   },
+   {
+     {7, 7, 7, 0},
+     {12, 12, 12, 0},
+     {6, 15, 12, 0}
+   },
+   {
+     {6, 6, 6, 3},
+     {12, 9, 9, 6},
+     {6, 12, 9, 6}
+   },
+   {
+     {8, 8, 5, 0},
+     {15,12,9,0},
+     {6,18,9,0}
+   }
+ };
+ 
+ 
+ /* Table B.6: layer3 preemphasis */
+ int  pretab[21] =
+ {
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 1, 1, 2, 2, 3, 3, 3, 2
+ };
+ 
+ /*
+   Here are MPEG1 Table B.8 and MPEG2 Table B.1
+   -- Layer III scalefactor bands. 
+   Index into this using a method such as:
+     idx  = fr_ps->header->sampling_frequency
+            + (fr_ps->header->version * 3)
+ */
+ 
+ struct scalefac_struct sfBandIndex[6] =
+ {
+   { /* Table B.2.b: 22.05 kHz */
+     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+     {0,4,8,12,18,24,32,42,56,74,100,132,174,192}
+   },
+   { /* Table B.2.c: 24 kHz */                 /* docs: 332. mpg123: 330 */
+     {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278, 332, 394,464,540,576},
+     {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
+   },
+   { /* Table B.2.a: 16 kHz */
+     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+     {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
+   },
+   { /* Table B.8.b: 44.1 kHz */
+     {0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
+     {0,4,8,12,16,22,30,40,52,66,84,106,136,192}
+   },
+   { /* Table B.8.c: 48 kHz */
+     {0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
+     {0,4,8,12,16,22,28,38,50,64,80,100,126,192}
+   },
+   { /* Table B.8.a: 32 kHz */
+     {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
+     {0,4,8,12,16,22,30,42,58,78,104,138,180,192}
+   }
+ };
+ 
+ struct scalefac_struct scalefac_band;
+ 
+ 
+ FLOAT8 pow20[Q_MAX];
+ FLOAT8 ipow20[Q_MAX];
+ FLOAT8 pow43[PRECALC_SIZE];
+ static FLOAT8 adj43[PRECALC_SIZE];
+ static FLOAT8 adj43asm[PRECALC_SIZE];
+ static FLOAT8 ATH_l[SBPSY_l];
+ static FLOAT8 ATH_s[SBPSY_l];
+ 
+ FLOAT8 ATH_mdct_long[576];
+ FLOAT8 ATH_mdct_short[192];
+ 
+ 
+ /************************************************************************/
+ /*  initialization for iteration_loop */
+ /************************************************************************/
+ void
+ iteration_init( lame_global_flags *gfp,III_side_info_t *l3_side, int l3_enc[2][2][576])
+ {
+   gr_info *cod_info;
+   int ch, gr, i;
+ 
+   l3_side->resvDrain = 0;
+ 
+   if ( gfp->frameNum==0 ) {
+     for (i = 0; i < SBMAX_l + 1; i++) {
+       scalefac_band.l[i] =
+ 	sfBandIndex[gfp->samplerate_index + (gfp->version * 3)].l[i];
+     }
+     for (i = 0; i < SBMAX_s + 1; i++) {
+       scalefac_band.s[i] =
+ 	sfBandIndex[gfp->samplerate_index + (gfp->version * 3)].s[i];
+     }
+ 
+     l3_side->main_data_begin = 0;
+     compute_ath(gfp,ATH_l,ATH_s);
+ 
+     for(i=0;i<PRECALC_SIZE;i++)
+         pow43[i] = pow((FLOAT8)i, 4.0/3.0);
+ 
+     for (i = 0; i < PRECALC_SIZE-1; i++)
+ 	adj43[i] = (i + 1) - pow(0.5 * (pow43[i] + pow43[i + 1]), 0.75);
+     adj43[i] = 0.5;
+ 
+ 
+     adj43asm[0] = 0.0;
+     for (i = 1; i < PRECALC_SIZE; i++)
+       adj43asm[i] = i - 0.5 - pow(0.5 * (pow43[i - 1] + pow43[i]),0.75);
+ 
+     for (i = 0; i < Q_MAX; i++) {
+ 	ipow20[i] = pow(2.0, (double)(i - 210) * -0.1875);
+ 	pow20[i] = pow(2.0, (double)(i - 210) * 0.25);
+     }
+   }
+ 
+ 
+   convert_mdct=0;
+   reduce_sidechannel=0;
+   if (gfp->mode_ext==MPG_MD_MS_LR) {
+     convert_mdct = 1;
+     reduce_sidechannel=1;
+   }
+   
+   /* some intializations. */
+   for ( gr = 0; gr < gfp->mode_gr; gr++ ){
+     for ( ch = 0; ch < gfp->stereo; ch++ ){
+       cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
+ 
+       if (cod_info->block_type == SHORT_TYPE)
+         {
+ 	  cod_info->sfb_lmax = 0; /* No sb*/
+ 	  cod_info->sfb_smax = 0;
+         }
+       else
+ 	{
+ 	  /* MPEG 1 doesnt use last scalefactor band */
+ 	  cod_info->sfb_lmax = SBPSY_l;
+ 	  cod_info->sfb_smax = SBPSY_s;    /* No sb */
+ 	}
+ 
+     }
+   }
+ 
+ 
+   /* dont bother with scfsi. */
+   for ( ch = 0; ch < gfp->stereo; ch++ )
+     for ( i = 0; i < 4; i++ )
+       l3_side->scfsi[ch][i] = 0;
+ }
+ 
+ 
+ 
+ 
+ 
+ /* 
+ compute the ATH for each scalefactor band 
+ cd range:  0..96db
+ 
+ Input:  3.3kHz signal  32767 amplitude  (3.3kHz is where ATH is smallest = -5db)
+ longblocks:  sfb=12   en0/bw=-11db    max_en0 = 1.3db
+ shortblocks: sfb=5           -9db              0db
+ 
+ Input:  1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated)
+ longblocks:  amp=1      sfb=12   en0/bw=-103 db      max_en0 = -92db
+             amp=32767   sfb=12           -12 db                 -1.4db 
+ 
+ Input:  1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated)
+ shortblocks: amp=1      sfb=5   en0/bw= -99                    -86 
+             amp=32767   sfb=5           -9  db                  4db 
+ 
+ 
+ MAX energy of largest wave at 3.3kHz = 1db
+ AVE energy of largest wave at 3.3kHz = -11db
+ Let's take AVE:  -11db = maximum signal in sfb=12.  
+ Dynamic range of CD: 96db.  Therefor energy of smallest audible wave 
+ in sfb=12  = -11  - 96 = -107db = ATH at 3.3kHz.  
+ 
+ ATH formula for this wave: -5db.  To adjust to LAME scaling, we need
+ ATH = ATH_formula  - 103  (db)
+ ATH = ATH * 2.5e-10      (ener)
+ 
+ */
+ FLOAT8 ATHformula(lame_global_flags *gfp,FLOAT8 f)
+ {
+   FLOAT8 ath;
+   f  = Max(0.02, f);
+   /* from Painter & Spanias, 1997 */
+   /* minimum: (i=77) 3.3kHz = -5db */
+   ath=(3.640 * pow(f,-0.8)
+        -  6.500 * exp(-0.6*pow(f-3.3,2.0))
+        +  0.001 * pow(f,4.0));
+   /* convert to energy */
+   if (gfp->noATH)
+     ath -= 200; /* disables ATH */
+   else {
+     ath -= 114;    /* MDCT scaling.  From tests by macik and MUS420 code */
+     /* ath -= 109; */
+   }
+ #ifdef RH_QUALITY_CONTROL 
+   /* purpose of RH_QUALITY_CONTROL:
+    * at higher quality lower ATH masking abilities   => needs more bits
+    * at lower quality increase ATH masking abilities => needs less bits
+    * works together with adjusted masking lowering of GPSYCHO thresholds
+    * (Robert.Hegemann@gmx.de 2000-01-30)
+    */
+   ath -= (4-gfp->VBR_q)*4.0; 
+ #endif
+   ath = pow( 10.0, ath/10.0 );
+   return ath;
+ }
+  
+ 
+ void compute_ath(lame_global_flags *gfp,FLOAT8 ATH_l[SBPSY_l],FLOAT8 ATH_s[SBPSY_l])
+ {
+   int sfb,i,start,end;
+   FLOAT8 ATH_f;
+   FLOAT8 samp_freq = gfp->out_samplerate/1000.0;
+ #ifdef RH_ATH
+   /* going from average to peak level ATH masking
+    */
+   FLOAT8 adjust_mdct_scaling = 10.0; 
+ #endif
+   
+ 
+   /* last sfb is not used */
+   for ( sfb = 0; sfb < SBPSY_l; sfb++ ) {
+     start = scalefac_band.l[ sfb ];
+     end   = scalefac_band.l[ sfb+1 ];
+     ATH_l[sfb]=1e99;
+     for (i=start ; i < end; i++) {
+       ATH_f = ATHformula(gfp,samp_freq*i/(2*576)); /* freq in kHz */
+       ATH_l[sfb]=Min(ATH_l[sfb],ATH_f);
+ #ifdef RH_ATH
+       ATH_mdct_long[i] = ATH_f*adjust_mdct_scaling;
+ #endif
+     }
+     /*
+     printf("sfb=%i %f  ATH=%f %f  %f   \n",sfb,samp_freq*start/(2*576),
+ 10*log10(ATH_l[sfb]),
+ 10*log10( ATHformula(samp_freq*start/(2*576)))  ,
+ 10*log10(ATHformula(samp_freq*end/(2*576))));
+     */
+   }
+ 
+   for ( sfb = 0; sfb < SBPSY_s; sfb++ ){
+     start = scalefac_band.s[ sfb ];
+     end   = scalefac_band.s[ sfb+1 ];
+     ATH_s[sfb]=1e99;
+     for (i=start ; i < end; i++) {
+       ATH_f = ATHformula(gfp,samp_freq*i/(2*192));     /* freq in kHz */
+       ATH_s[sfb]=Min(ATH_s[sfb],ATH_f);
+ #ifdef RH_ATH
+       ATH_mdct_short[i] = ATH_f*adjust_mdct_scaling;
+ #endif
+     }
+   }
+ }
+ 
+ 
+ 
+ 
+ 
+ /* convert from L/R <-> Mid/Side */
+ void ms_convert(FLOAT8 xr[2][576],FLOAT8 xr_org[2][576])
+ {
+   int i;
+   for ( i = 0; i < 576; i++ ) {
+     FLOAT8 l = xr_org[0][i];
+     FLOAT8 r = xr_org[1][i];
+     xr[0][i] = (l+r)*(SQRT2*0.5);
+     xr[1][i] = (l-r)*(SQRT2*0.5);
+   }
+ }
+ 
+ 
+ 
+ /************************************************************************
+  * allocate bits among 2 channels based on PE
+  * mt 6/99
+  ************************************************************************/
+ void on_pe(lame_global_flags *gfp,FLOAT8 pe[2][2],III_side_info_t *l3_side,
+ int targ_bits[2],int mean_bits, int gr)
+ {
+   gr_info *cod_info;
+   int extra_bits,tbits,bits;
+   int add_bits[2]; 
+   int ch;
+ 
+   /* allocate targ_bits for granule */
+   ResvMaxBits( mean_bits, &tbits, &extra_bits, gr);
+     
+ 
+   for (ch=0 ; ch < gfp->stereo ; ch ++) {
+     /******************************************************************
+      * allocate bits for each channel 
+      ******************************************************************/
+     cod_info = &l3_side->gr[gr].ch[ch].tt;
+     
+     targ_bits[ch]=tbits/gfp->stereo;
+     
+     /* allocate extra bits from reservoir based on PE */
+     bits=0;
+     
+     /* extra bits based on PE > 700 */
+     add_bits[ch]=(pe[gr][ch]-750)/1.55;  /* 1.4; */
+     
+     /* short blocks need extra, no matter what the pe */
+     if (cod_info->block_type==SHORT_TYPE) 
+       if (add_bits[ch]<500) add_bits[ch]=500;
+     
+     if (add_bits[ch] < 0) add_bits[ch]=0;
+     bits += add_bits[ch];
+     
+     if (bits > extra_bits) add_bits[ch] = (extra_bits*add_bits[ch])/bits;
+     if ((targ_bits[ch]+add_bits[ch]) > 4095) 
+       add_bits[ch]=4095-targ_bits[ch];
+ 
+     targ_bits[ch] = targ_bits[ch] + add_bits[ch];
+     extra_bits -= add_bits[ch];
+   }
+ }
+ 
+ void reduce_side(int targ_bits[2],FLOAT8 ms_ener_ratio,int mean_bits)
+ {
+ int ch;
+ int numchn=2;
+     /*  ms_ener_ratio = 0:  allocate 66/33  mid/side  fac=.33  
+      *  ms_ener_ratio =.5:  allocate 50/50 mid/side   fac= 0 */
+     /* 75/25 split is fac=.5 */
+     /* float fac = .50*(.5-ms_ener_ratio[gr])/.5;*/
+     float fac = .33*(.5-ms_ener_ratio)/.5;
+     if (fac<0) fac=0;
+     
+     if (targ_bits[1] >= 125) {
+       /* dont reduce side channel below 125 bits */
+       if (targ_bits[1]-targ_bits[1]*fac > 125) {
+ 	targ_bits[0] += targ_bits[1]*fac;
+ 	targ_bits[1] -= targ_bits[1]*fac;
+       } else {
+ 	targ_bits[0] += targ_bits[1] - 125;
+ 	targ_bits[1] = 125;
+       }
+     }
+     
+     /* dont allow to many bits per channel */  
+     for (ch=0; ch<numchn; ch++) {
+       int max_bits = Min(4095,mean_bits/2 + 1200);
+       if (targ_bits[ch] > max_bits) {
+ 	targ_bits[ch] = max_bits;
+       }
+     }
+ 
+ }
+ 
+ /*************************************************************************** 
+  *         inner_loop                                                      * 
+  *************************************************************************** 
+  * The code selects the best global gain for a particular set of scalefacs */
+  
+ int
+ inner_loop( lame_global_flags *gfp,FLOAT8 xrpow[576],
+ 	    int l3_enc[576], int max_bits,
+ 	    gr_info *cod_info)
+ {
+     int bits;
+     assert( max_bits >= 0 );
+     cod_info->global_gain--;
+     do
+     {
+       cod_info->global_gain++;
+       bits = count_bits(gfp,l3_enc, xrpow, cod_info);
+     }
+     while ( bits > max_bits );
+     return bits;
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            scale_bitcount                                             */
+ /*************************************************************************/
+ 
+ /* Also calculates the number of bits necessary to code the scalefactors. */
+ 
+ int scale_bitcount( III_scalefac_t *scalefac, gr_info *cod_info)
+ {
+     int i, k, sfb, max_slen1 = 0, max_slen2 = 0, /*a, b, */ ep = 2;
+ 
+     static int slen1[16] = { 1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8,16,16 };
+     static int slen2[16] = { 1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8 };
+ 
+     static int slen1_tab[16] = {0,
+ 	18, 36, 54, 54, 36, 54, 72, 54, 72, 90, 72, 90,108,108,126
+     };
+     static int slen2_tab[16] = {0,
+ 	10, 20, 30, 33, 21, 31, 41, 32, 42, 52, 43, 53, 63, 64, 74
+     };
+     int *tab;
+ 
+ 
+     if ( cod_info->block_type == SHORT_TYPE )
+     {
+             tab = slen1_tab;
+             /* a = 18; b = 18;  */
+             for ( i = 0; i < 3; i++ )
+             {
+                 for ( sfb = 0; sfb < 6; sfb++ )
+                     if (scalefac->s[sfb][i] > max_slen1 )
+                         max_slen1 = scalefac->s[sfb][i];
+                 for (sfb = 6; sfb < SBPSY_s; sfb++ )
+                     if ( scalefac->s[sfb][i] > max_slen2 )
+                         max_slen2 = scalefac->s[sfb][i];
+             }
+     }
+     else
+     { /* block_type == 1,2,or 3 */
+         tab = slen2_tab;
+         /* a = 11; b = 10;   */
+         for ( sfb = 0; sfb < 11; sfb++ )
+             if ( scalefac->l[sfb] > max_slen1 )
+                 max_slen1 = scalefac->l[sfb];
+ 
+ 	if (!cod_info->preflag) {
+ 	    for ( sfb = 11; sfb < SBPSY_l; sfb++ )
+ 		if (scalefac->l[sfb] < pretab[sfb])
+ 		    break;
+ 
+ 	    if (sfb == SBPSY_l) {
+ 		cod_info->preflag = 1;
+ 		for ( sfb = 11; sfb < SBPSY_l; sfb++ )
+ 		    scalefac->l[sfb] -= pretab[sfb];
+ 	    }
+ 	}
+ 
+         for ( sfb = 11; sfb < SBPSY_l; sfb++ )
+             if ( scalefac->l[sfb] > max_slen2 )
+                 max_slen2 = scalefac->l[sfb];
+     }
+ 
+ 
+ 
+     /* from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99
+      * loop over *all* posible values of scalefac_compress to find the
+      * one which uses the smallest number of bits.  ISO would stop
+      * at first valid index */
+     cod_info->part2_length = LARGE_BITS;
+     for ( k = 0; k < 16; k++ )
+     {
+         if ( (max_slen1 < slen1[k]) && (max_slen2 < slen2[k]) &&
+              ((int)cod_info->part2_length > tab[k])) {
+ 	  cod_info->part2_length=tab[k];
+ 	  cod_info->scalefac_compress=k;
+ 	  ep=0;  /* we found a suitable scalefac_compress */
+ 	}
+     }
+     return ep;
+ }
+ 
+ 
+ 
+ /*
+   table of largest scalefactors (number of bits) for MPEG2
+ */
+ /*
+ static unsigned max_sfac_tab[6][4] =
+ {
+     {4, 4, 3, 3},
+     {4, 4, 3, 0},
+     {3, 2, 0, 0},
+     {4, 5, 5, 0},
+     {3, 3, 3, 0},
+     {2, 2, 0, 0}
+ };
+ */
+ /*
+   table of largest scalefactor values for MPEG2
+ */
+ static unsigned max_range_sfac_tab[6][4] =
+ {
+  { 15, 15, 7,  7},
+  { 15, 15, 7,  0},
+  { 7,  3,  0,  0},
+  { 15, 31, 31, 0},
+  { 7,  7,  7,  0},
+  { 3,  3,  0,  0}
+ };
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            scale_bitcount_lsf                                         */
+ /*************************************************************************/
+ 
+ /* Also counts the number of bits to encode the scalefacs but for MPEG 2 */ 
+ /* Lower sampling frequencies  (24, 22.05 and 16 kHz.)                   */
+  
+ /*  This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,     */
+ /* "Audio Decoding Layer III"                                            */
+ 
+ int scale_bitcount_lsf(III_scalefac_t *scalefac, gr_info *cod_info)
+ {
+     int table_number, row_in_table, partition, nr_sfb, window, over;
+     int i, sfb, max_sfac[ 4 ];
+     unsigned *partition_table;
+ 
+     /*
+       Set partition table. Note that should try to use table one,
+       but do not yet...
+     */
+     if ( cod_info->preflag )
+ 	table_number = 2;
+     else
+ 	table_number = 0;
+ 
+     for ( i = 0; i < 4; i++ )
+ 	max_sfac[i] = 0;
+ 
+     if ( cod_info->block_type == SHORT_TYPE )
+     {
+ 	    row_in_table = 1;
+ 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	    for ( sfb = 0, partition = 0; partition < 4; partition++ )
+ 	    {
+ 		nr_sfb = partition_table[ partition ] / 3;
+ 		for ( i = 0; i < nr_sfb; i++, sfb++ )
+ 		    for ( window = 0; window < 3; window++ )
+ 			if ( scalefac->s[sfb][window] > max_sfac[partition] )
+ 			    max_sfac[partition] = scalefac->s[sfb][window];
+ 	    }
+     }
+     else
+     {
+ 	row_in_table = 0;
+ 	partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	for ( sfb = 0, partition = 0; partition < 4; partition++ )
+ 	{
+ 	    nr_sfb = partition_table[ partition ];
+ 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
+ 		if ( scalefac->l[sfb] > max_sfac[partition] )
+ 		    max_sfac[partition] = scalefac->l[sfb];
+ 	}
+     }
+ 
+     for ( over = 0, partition = 0; partition < 4; partition++ )
+     {
+ 	if ( max_sfac[partition] > (int)max_range_sfac_tab[table_number][partition] )
+ 	    over++;
+     }
+     if ( !over )
+     {
+ 	/*
+ 	  Since no bands have been over-amplified, we can set scalefac_compress
+ 	  and slen[] for the formatter
+ 	*/
+ 	static int log2tab[] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 };
+ 
+ 	unsigned slen1, slen2, slen3, slen4;
+ 
+         cod_info->sfb_partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	for ( partition = 0; partition < 4; partition++ )
+ 	    cod_info->slen[partition] = log2tab[max_sfac[partition]];
+ 
+ 	/* set scalefac_compress */
+ 	slen1 = cod_info->slen[ 0 ];
+ 	slen2 = cod_info->slen[ 1 ];
+ 	slen3 = cod_info->slen[ 2 ];
+ 	slen4 = cod_info->slen[ 3 ];
+ 
+ 	switch ( table_number )
+ 	{
+ 	  case 0:
+ 	    cod_info->scalefac_compress = (((slen1 * 5) + slen2) << 4)
+ 		+ (slen3 << 2)
+ 		+ slen4;
+ 	    break;
+ 
+ 	  case 1:
+ 	    cod_info->scalefac_compress = 400
+ 		+ (((slen1 * 5) + slen2) << 2)
+ 		+ slen3;
+ 	    break;
+ 
+ 	  case 2:
+ 	    cod_info->scalefac_compress = 500 + (slen1 * 3) + slen2;
+ 	    break;
+ 
+ 	  default:
+ 	    fprintf( stderr, "intensity stereo not implemented yet\n" );
+ 	    exit( EXIT_FAILURE );
+ 	    break;
+ 	}
+     }
+ #ifdef DEBUG
+     if ( over ) 
+         printf( "---WARNING !! Amplification of some bands over limits\n" );
+ #endif
+     if (!over) {
+       assert( cod_info->sfb_partition_table );     
+       cod_info->part2_length=0;
+       for ( partition = 0; partition < 4; partition++ )
+ 	cod_info->part2_length += cod_info->slen[partition] * cod_info->sfb_partition_table[partition];
+     }
+     return over;
+ }
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            calc_xmin                                                  */
+ /*************************************************************************/
+ 
+ /*
+   Calculate the allowed distortion for each scalefactor band,
+   as determined by the psychoacoustic model.
+   xmin(sb) = ratio(sb) * en(sb) / bw(sb)
+ 
+   returns number of sfb's with energy > ATH
+ */
+ int calc_xmin( lame_global_flags *gfp,FLOAT8 xr[576], III_psy_ratio *ratio,
+ 	       gr_info *cod_info, III_psy_xmin *l3_xmin)
+ {
+     int start, end, bw,l, b, ath_over=0;
+ 	u_int	sfb;
+     FLOAT8 en0, xmin, ener;
+ 
+     if (gfp->ATHonly) {    
+       for ( sfb = cod_info->sfb_smax; sfb < SBPSY_s; sfb++ )
+ 	  for ( b = 0; b < 3; b++ )
+ 	      l3_xmin->s[sfb][b]=ATH_s[sfb];
+       for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+ 	  l3_xmin->l[sfb]=ATH_l[sfb];
+ 
+     }else{
+ 
+       for ( sfb = cod_info->sfb_smax; sfb < SBPSY_s; sfb++ ) {
+ 	start = scalefac_band.s[ sfb ];
+         end   = scalefac_band.s[ sfb + 1 ];
+ 	bw = end - start;
+         for ( b = 0; b < 3; b++ ) {
+ 	  for (en0 = 0.0, l = start; l < end; l++) {
+ 	    ener = xr[l * 3 + b];
+ 	    ener = ener * ener;
+ 	    en0 += ener;
+ 	  }
+ 	  en0 /= bw;
+ 
+ 	  xmin = ratio->en.s[sfb][b];
+ 	  if (xmin > 0.0)
+ 	    xmin = en0 * ratio->thm.s[sfb][b] * masking_lower / xmin;
+ 
+ #ifdef RH_ATH
+           /* do not mix up ATH masking with GPSYCHO thresholds
+ 	   */
+ 	  l3_xmin->s[sfb][b] = Max(1e-20, xmin);
+ #else
+ 	  l3_xmin->s[sfb][b] = Max(ATH_s[sfb], xmin);
+ #endif
+ 	  if (en0 > ATH_s[sfb]) ath_over++;
+ 	}
+       }
+ 
+       for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ ){
+ 	start = scalefac_band.l[ sfb ];
+ 	end   = scalefac_band.l[ sfb+1 ];
+ 	bw = end - start;
+ 
+         for (en0 = 0.0, l = start; l < end; l++ ) {
+ 	  ener = xr[l] * xr[l];
+ 	  en0 += ener;
+ 	}
+ 	en0 /= bw;
+ 
+ 	xmin = ratio->en.l[sfb];
+ 	if (xmin > 0.0)
+ 	  xmin = en0 * ratio->thm.l[sfb] * masking_lower / xmin;
+ 
+ 
+ #ifdef RH_ATH
+         /* do not mix up ATH masking with GPSYCHO thresholds
+ 	 */
+ 	l3_xmin->l[sfb]=Max(1e-20, xmin);
+ #else
+ 	l3_xmin->l[sfb]=Max(ATH_l[sfb], xmin);
+ #endif
+ 	if (en0 > ATH_l[sfb]) ath_over++;
+       }
+     }
+     return ath_over;
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            loop_break                                                 */
+ /*************************************************************************/
+ 
+ /*  Function: Returns zero if there is a scalefac which has not been
+     amplified. Otherwise it returns one. 
+ */
+ 
+ int loop_break( III_scalefac_t *scalefac, gr_info *cod_info)
+ {
+     int i;
+ 	u_int sfb;
+ 
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+         if ( scalefac->l[sfb] == 0 )
+ 	    return 0;
+ 
+     for ( sfb = cod_info->sfb_smax; sfb < SBPSY_s; sfb++ )
+       for ( i = 0; i < 3; i++ ) 
+             if ( scalefac->s[sfb][i] == 0 )
+ 		return 0;
+ 
+     return 1;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /*
+  ----------------------------------------------------------------------
+   if someone wants to try to find a faster step search function,
+   here is some code which gives a lower bound for the step size:
+   
+   for (max_xrspow = 0, i = 0; i < 576; ++i)
+   {
+     max_xrspow = Max(max_xrspow, xrspow[i]);
+   }
+   lowerbound = 210+log10(max_xrspow/IXMAX_VAL)/(0.1875*LOG2);
+  
+  
+                                                  Robert.Hegemann@gmx.de
+  ----------------------------------------------------------------------
+ */
+ 
+ 
+ typedef enum {
+     BINSEARCH_NONE,
+     BINSEARCH_UP, 
+     BINSEARCH_DOWN
+ } binsearchDirection_t;
+ 
+ /*-------------------------------------------------------------------------*/
+ int 
+ bin_search_StepSize2 (lame_global_flags *gfp,int desired_rate, int start, int *ix, 
+                       FLOAT8 xrspow[576], gr_info *cod_info)
+ /*-------------------------------------------------------------------------*/
+ {
+     static int CurrentStep = 4;
+     int nBits;
+     int flag_GoneOver = 0;
+     int StepSize = start;
+     binsearchDirection_t Direction = BINSEARCH_NONE;
+ 
+     do
+     {
+ 	cod_info->global_gain = StepSize;
+ 	nBits = count_bits(gfp,ix, xrspow, cod_info);  
+ 
+ 	if (CurrentStep == 1 )
+         {
+ 	    break; /* nothing to adjust anymore */
+ 	}
+ 	if (flag_GoneOver)
+ 	{
+ 	    CurrentStep /= 2;
+ 	}
+ 	if (nBits > desired_rate)  /* increase Quantize_StepSize */
+ 	{
+ 	    if (Direction == BINSEARCH_DOWN && !flag_GoneOver)
+ 	    {
+ 		flag_GoneOver = 1;
+ 		CurrentStep /= 2; /* late adjust */
+ 	    }
+ 	    Direction = BINSEARCH_UP;
+ 	    StepSize += CurrentStep;
+ 	    if (StepSize > 255) break;
+ 	}
+ 	else if (nBits < desired_rate)
+ 	{
+ 	    if (Direction == BINSEARCH_UP && !flag_GoneOver)
+ 	    {
+ 		flag_GoneOver = 1;
+ 		CurrentStep /= 2; /* late adjust */
+ 	    }
+ 	    Direction = BINSEARCH_DOWN;
+ 	    StepSize -= CurrentStep;
+ 	    if (StepSize < 0) break;
+ 	}
+ 	else break; /* nBits == desired_rate;; most unlikely to happen.*/
+     } while (1); /* For-ever, break is adjusted. */
+ 
+     CurrentStep = abs(start - StepSize);
+     
+     if (CurrentStep >= 4) {
+ 	CurrentStep = 4;
+     } else {
+ 	CurrentStep = 2;
+     }
+ 
+     return nBits;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ #if (defined(__GNUC__) && defined(__i386__))
+ #define USE_GNUC_ASM
+ #endif
+ #ifdef _MSC_VER
+ #define USE_MSC_ASM
+ #endif
+ 
+ 
+ 
+ /*********************************************************************
+  * XRPOW_FTOI is a macro to convert floats to ints.  
+  * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]
+  *                                         ROUNDFAC= -0.0946
+  *
+  * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]   
+  *                                   ROUNDFAC=0.4054
+  *********************************************************************/
+ #ifdef USE_GNUC_ASM
+ #  define QUANTFAC(rx)  adj43asm[rx]
+ #  define ROUNDFAC -0.0946
+ #  define XRPOW_FTOI(src, dest) \
+      asm ("fistpl %0 " : "=m"(dest) : "t"(src) : "st")
+ #elif defined (USE_MSC_ASM)
+ #  define QUANTFAC(rx)  adj43asm[rx]
+ #  define ROUNDFAC -0.0946
+ #  define XRPOW_FTOI(src, dest) do { \
+      FLOAT8 src_ = (src); \
+      int dest_; \
+      { \
+        __asm fld src_ \
+        __asm fistp dest_ \
+      } \
+      (dest) = dest_; \
+    } while (0)
+ #else
+ #  define QUANTFAC(rx)  adj43[rx]
+ #  define ROUNDFAC 0.4054
+ #  define XRPOW_FTOI(src,dest) ((dest) = (int)(src))
+ #endif
+ 
+ #ifdef USE_MSC_ASM
+ /* define F8type and F8size according to type of FLOAT8 */
+ # if defined FLOAT8_is_double
+ #  define F8type qword
+ #  define F8size 8
+ # elif defined FLOAT8_is_float
+ #  define F8type dword
+ #  define F8size 4
+ # else
+ /* only float and double supported */
+ #  error invalid FLOAT8 type for USE_MSC_ASM
+ # endif
+ #endif
+ 
+ #ifdef USE_GNUC_ASM
+ /* define F8type and F8size according to type of FLOAT8 */
+ # if defined FLOAT8_is_double
+ #  define F8type "l"
+ #  define F8size "8"
+ # elif defined FLOAT8_is_float
+ #  define F8type "s"
+ #  define F8size "4"
+ # else
+ /* only float and double supported */
+ #  error invalid FLOAT8 type for USE_GNUC_ASM
+ # endif
+ #endif
+ 
+ /*********************************************************************
+  * nonlinear quantization of xr 
+  * More accurate formula than the ISO formula.  Takes into account
+  * the fact that we are quantizing xr -> ix, but we want ix^4/3 to be 
+  * as close as possible to x^4/3.  (taking the nearest int would mean
+  * ix is as close as possible to xr, which is different.)
+  * From Segher Boessenkool <segher@eastsite.nl>  11/1999
+  * ASM optimization from 
+  *    Mathew Hendry <scampi@dial.pipex.com> 11/1999
+  *    Acy Stapp <AStapp@austin.rr.com> 11/1999
+  *    Takehiro Tominaga <tominaga@isoternet.org> 11/1999
+  *********************************************************************/
+ 
+ void quantize_xrpow(FLOAT8 xr[576], int ix[576], gr_info *cod_info) {
+   /* quantize on xr^(3/4) instead of xr */
+   const FLOAT8 istep = IPOW20(cod_info->global_gain);
+ 
+ #if defined (USE_GNUC_ASM) 
+   {
+       int rx[4];
+       __asm__ __volatile__(
+         "\n\nloop1:\n\t"
+ 
+         "fld" F8type " 0*" F8size "(%1)\n\t"
+         "fld" F8type " 1*" F8size "(%1)\n\t"
+         "fld" F8type " 2*" F8size "(%1)\n\t"
+         "fld" F8type " 3*" F8size "(%1)\n\t"
+ 
+         "fxch %%st(3)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(2)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(1)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(3)\n\t"
+         "fmul %%st(4)\n\t"
+ 
+         "addl $4*" F8size ", %1\n\t"
+         "addl $16, %3\n\t"
+ 
+         "fxch %%st(2)\n\t"
+         "fistl %5\n\t"
+         "fxch %%st(1)\n\t"
+         "fistl 4+%5\n\t"
+         "fxch %%st(3)\n\t"
+         "fistl 8+%5\n\t"
+         "fxch %%st(2)\n\t"
+         "fistl 12+%5\n\t"
+ 
+         "dec %4\n\t"
+ 
+         "movl %5, %%eax\n\t"
+         "movl 4+%5, %%ebx\n\t"
+         "fxch %%st(1)\n\t"
+         "fadd" F8type " (%2,%%eax," F8size ")\n\t"
+         "fxch %%st(3)\n\t"
+         "fadd" F8type " (%2,%%ebx," F8size ")\n\t"
+ 
+         "movl 8+%5, %%eax\n\t"
+         "movl 12+%5, %%ebx\n\t"
+         "fxch %%st(2)\n\t"
+         "fadd" F8type " (%2,%%eax," F8size ")\n\t"
+         "fxch %%st(1)\n\t"
+         "fadd" F8type " (%2,%%ebx," F8size ")\n\t"
+ 
+         "fxch %%st(3)\n\t"
+         "fistpl -16(%3)\n\t"
+         "fxch %%st(1)\n\t"
+         "fistpl -12(%3)\n\t"
+         "fistpl -8(%3)\n\t"
+         "fistpl -4(%3)\n\t"
+ 
+         "jnz loop1\n\n"
+         : /* no outputs */
+         : "t" (istep), "r" (xr), "r" (adj43asm), "r" (ix), "r" (576 / 4), "m" (rx)
+         : "%eax", "%ebx", "memory", "cc"
+       );
+   }
+ #elif defined (USE_MSC_ASM)
+   {
+       /* asm from Acy Stapp <AStapp@austin.rr.com> */
+       int rx[4];
+       _asm {
+           fld F8type ptr [istep]
+           mov esi, dword ptr [xr]
+           lea edi, dword ptr [adj43asm]
+           mov edx, dword ptr [ix]
+           mov ecx, 576/4
+       } loop1: _asm {
+           fld F8type ptr [esi+(0*F8size)] // 0
+           fld F8type ptr [esi+(1*F8size)] // 1 0
+           fld F8type ptr [esi+(2*F8size)] // 2 1 0
+           fld F8type ptr [esi+(3*F8size)] // 3 2 1 0
+           fxch st(3)                  // 0 2 1 3
+           fmul st(0), st(4)
+           fxch st(2)                  // 1 2 0 3
+           fmul st(0), st(4)
+           fxch st(1)                  // 2 1 0 3
+           fmul st(0), st(4)
+           fxch st(3)                  // 3 1 0 2
+           fmul st(0), st(4)
+ 
+           add esi, 4*F8size
+           add edx, 16
+ 
+           fxch st(2)                  // 0 1 3 2
+           fist dword ptr [rx]
+           fxch st(1)                  // 1 0 3 2
+           fist dword ptr [rx+4]
+           fxch st(3)                  // 2 0 3 1
+           fist dword ptr [rx+8]
+           fxch st(2)                  // 3 0 2 1
+           fist dword ptr [rx+12]
+ 
+           dec ecx
+ 
+           mov eax, dword ptr [rx]
+           mov ebx, dword ptr [rx+4]
+           fxch st(1)                  // 0 3 2 1
+           fadd F8type ptr [edi+eax*F8size]
+           fxch st(3)                  // 1 3 2 0
+           fadd F8type ptr [edi+ebx*F8size]
+ 
+           mov eax, dword ptr [rx+8]
+           mov ebx, dword ptr [rx+12]
+           fxch st(2)                  // 2 3 1 0
+           fadd F8type ptr [edi+eax*F8size]
+           fxch st(1)                  // 3 2 1 0
+           fadd F8type ptr [edi+ebx*F8size]
+           fxch st(3)                  // 0 2 1 3
+           fistp dword ptr [edx-16]    // 2 1 3
+           fxch st(1)                  // 1 2 3
+           fistp dword ptr [edx-12]    // 2 3
+           fistp dword ptr [edx-8]     // 3
+           fistp dword ptr [edx-4]
+ 
+           jnz loop1
+ 
+           mov dword ptr [xr], esi
+           mov dword ptr [ix], edx
+           fstp st(0)
+       }
+   }
+ #else
+ #if 0
+   {   /* generic code if you write ASM for XRPOW_FTOI() */
+       FLOAT8 x;
+       int j, rx;
+       for (j = 576 / 4; j > 0; --j) {
+           x = *xr++ * istep;
+           XRPOW_FTOI(x, rx);
+           XRPOW_FTOI(x + QUANTFAC(rx), *ix++);
+ 
+           x = *xr++ * istep;
+           XRPOW_FTOI(x, rx);
+           XRPOW_FTOI(x + QUANTFAC(rx), *ix++);
+ 
+           x = *xr++ * istep;
+           XRPOW_FTOI(x, rx);
+           XRPOW_FTOI(x + QUANTFAC(rx), *ix++);
+ 
+           x = *xr++ * istep;
+           XRPOW_FTOI(x, rx);
+           XRPOW_FTOI(x + QUANTFAC(rx), *ix++);
+       }
+   }
+ #endif
+   {/* from Wilfried.Behne@t-online.de.  Reported to be 2x faster than 
+       the above code (when not using ASM) on PowerPC */
+      	int j;
+      	
+      	for ( j = 576/8; j > 0; --j)
+      	{
+ 			FLOAT8	x1, x2, x3, x4, x5, x6, x7, x8;
+ 			int		rx1, rx2, rx3, rx4, rx5, rx6, rx7, rx8;
+ 			x1 = *xr++ * istep;
+ 			x2 = *xr++ * istep;
+ 			XRPOW_FTOI(x1, rx1);
+ 			x3 = *xr++ * istep;
+ 			XRPOW_FTOI(x2, rx2);
+ 			x4 = *xr++ * istep;
+ 			XRPOW_FTOI(x3, rx3);
+ 			x5 = *xr++ * istep;
+ 			XRPOW_FTOI(x4, rx4);
+ 			x6 = *xr++ * istep;
+ 			XRPOW_FTOI(x5, rx5);
+ 			x7 = *xr++ * istep;
+ 			XRPOW_FTOI(x6, rx6);
+ 			x8 = *xr++ * istep;
+ 			XRPOW_FTOI(x7, rx7);
+ 			x1 += QUANTFAC(rx1);
+ 			XRPOW_FTOI(x8, rx8);
+ 			x2 += QUANTFAC(rx2);
+ 			XRPOW_FTOI(x1,*ix++);
+ 			x3 += QUANTFAC(rx3);
+ 			XRPOW_FTOI(x2,*ix++);
+ 			x4 += QUANTFAC(rx4);		
+ 			XRPOW_FTOI(x3,*ix++);
+ 			x5 += QUANTFAC(rx5);
+ 			XRPOW_FTOI(x4,*ix++);
+ 			x6 += QUANTFAC(rx6);
+ 			XRPOW_FTOI(x5,*ix++);
+ 			x7 += QUANTFAC(rx7);
+ 			XRPOW_FTOI(x6,*ix++);
+ 			x8 += QUANTFAC(rx8);		
+ 			XRPOW_FTOI(x7,*ix++);
+ 			XRPOW_FTOI(x8,*ix++);
+      	}
+ 	}
+ #endif
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ void quantize_xrpow_ISO( FLOAT8 xr[576], int ix[576], gr_info *cod_info )
+ {
+   /* quantize on xr^(3/4) instead of xr */
+   const FLOAT8 istep = IPOW20(cod_info->global_gain);
+   
+ #if defined(USE_GNUC_ASM)
+    {
+       __asm__ __volatile__ (
+         "\n\nloop0:\n\t"
+ 
+         "fld" F8type " 0*" F8size "(%3)\n\t"
+         "fld" F8type " 1*" F8size "(%3)\n\t"
+         "fld" F8type " 2*" F8size "(%3)\n\t"
+         "fld" F8type " 3*" F8size "(%3)\n\t"
+ 
+         "addl $4*" F8size ", %3\n\t"
+         "addl $16, %4\n\t"
+ 
+         "fxch %%st(3)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(2)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(1)\n\t"
+         "fmul %%st(4)\n\t"
+         "fxch %%st(3)\n\t"
+         "fmul %%st(4)\n\t"
+ 
+         "dec %0\n\t"
+ 
+         "fxch %%st(2)\n\t"
+         "fadd %%st(5)\n\t"
+         "fxch %%st(1)\n\t"
+         "fadd %%st(5)\n\t"
+         "fxch %%st(3)\n\t"
+         "fadd %%st(5)\n\t"
+         "fxch %%st(2)\n\t"
+         "fadd %%st(5)\n\t"
+ 
+         "fxch %%st(1)\n\t"
+         "fistpl -16(%4)\n\t"
+         "fxch %%st(2)\n\t"
+         "fistpl -12(%4)\n\t"
+         "fistpl -8(%4)\n\t"
+         "fistpl -4(%4)\n\t"
+ 
+         "jnz loop0\n\n"
+ 
+         : /* no outputs */
+         : "r" (576 / 4), "u" ((FLOAT8)(0.4054 - 0.5)), "t" (istep), "r" (xr), "r" (ix)
+         : "memory", "cc"
+       );
+   }
+ #elif defined(USE_MSC_ASM)
+   {
+       /* asm from Acy Stapp <AStapp@austin.rr.com> */
+       const FLOAT8 temp0 = 0.4054 - 0.5;
+       _asm {
+           mov ecx, 576/4;
+           fld F8type ptr [temp0];
+           fld F8type ptr [istep];
+           mov eax, dword ptr [xr];
+           mov edx, dword ptr [ix];
+       } loop0: _asm {
+           fld F8type ptr [eax+0*F8size]; // 0
+           fld F8type ptr [eax+1*F8size]; // 1 0
+           fld F8type ptr [eax+2*F8size]; // 2 1 0
+           fld F8type ptr [eax+3*F8size]; // 3 2 1 0
+ 
+           add eax, 4*F8size;
+           add edx, 16;
+ 
+           fxch st(3); // 0 2 1 3
+           fmul st(0), st(4);
+           fxch st(2); // 1 2 0 3
+           fmul st(0), st(4);
+           fxch st(1); // 2 1 0 3
+           fmul st(0), st(4);
+           fxch st(3); // 3 1 0 2
+           fmul st(0), st(4);
+ 
+           dec ecx;
+ 
+           fxch st(2); // 0 1 3 2
+           fadd st(0), st(5);
+           fxch st(1); // 1 0 3 2
+           fadd st(0), st(5);
+           fxch st(3); // 2 0 3 1
+           fadd st(0), st(5);
+           fxch st(2); // 3 0 2 1
+           fadd st(0), st(5);
+ 
+           fxch st(1); // 0 3 2 1 
+           fistp dword ptr [edx-16]; // 3 2 1
+           fxch st(2); // 1 2 3
+           fistp dword ptr [edx-12];
+           fistp dword ptr [edx-8];
+           fistp dword ptr [edx-4];
+ 
+           jnz loop0;
+ 
+           mov dword ptr [xr], eax;
+           mov dword ptr [ix], edx;
+           fstp st(0);
+           fstp st(0);
+       }
+   }
+ #else
+ #if 0
+    /* generic ASM */
+       register int j;
+       for (j=576/4;j>0;j--) {
+          XRPOW_FTOI(istep * (*xr++) + ROUNDFAC, *ix++);
+          XRPOW_FTOI(istep * (*xr++) + ROUNDFAC, *ix++);
+          XRPOW_FTOI(istep * (*xr++) + ROUNDFAC, *ix++);
+          XRPOW_FTOI(istep * (*xr++) + ROUNDFAC, *ix++);
+       }
+ #endif
+   {
+       register int j;
+       const FLOAT8 compareval0 = (1.0 - 0.4054)/istep;
+       /* depending on architecture, it may be worth calculating a few more compareval's.
+          eg.  compareval1 = (2.0 - 0.4054/istep); 
+               .. and then after the first compare do this ...
+               if compareval1>*xr then ix = 1;
+          On a pentium166, it's only worth doing the one compare (as done here), as the second
+          compare becomes more expensive than just calculating the value. Architectures with 
+          slow FP operations may want to add some more comparevals. try it and send your diffs 
+          statistically speaking
+          73% of all xr*istep values give ix=0
+          16% will give 1
+          4%  will give 2
+       */
+       for (j=576;j>0;j--) 
+         {
+           if (compareval0 > *xr) {
+             *(ix++) = 0;
+             xr++;
+           } else
+ 	    /*    *(ix++) = (int)( istep*(*(xr++))  + 0.4054); */
+             XRPOW_FTOI(  istep*(*(xr++))  + ROUNDFAC , *(ix++) );
+         }
+   }
+ #endif
+ }
diff -r -c -N encoder/quantize-pvt.h lame3.70/quantize-pvt.h
*** encoder/quantize-pvt.h	Wed Dec 31 17:00:00 1969
--- lame3.70/quantize-pvt.h	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,124 ----
+ #ifndef LOOP_PVT_H
+ #define LOOP_PVT_H
+ 
+ #define IXMAX_VAL 8206 /* ix always <= 8191+15.    see count_bits() */
+ #define PRECALC_SIZE (IXMAX_VAL+2)
+ 
+ extern FLOAT masking_lower;
+ extern int convert_mdct, convert_psy, reduce_sidechannel;
+ extern unsigned nr_of_sfb_block[6][3][4];
+ extern int pretab[21];
+ 
+ struct scalefac_struct
+ {
+    int l[1+SBMAX_l];
+    int s[1+SBMAX_s];
+ };
+ 
+ extern struct scalefac_struct scalefac_band;
+ extern struct scalefac_struct sfBandIndex[6];
+ 
+ extern FLOAT8 pow43[PRECALC_SIZE];
+ 
+ #define Q_MAX 256
+ 
+ extern FLOAT8 pow20[Q_MAX];
+ extern FLOAT8 ipow20[Q_MAX];
+ 
+ #ifdef RH_ATH
+ extern FLOAT8 ATH_mdct_long[576], ATH_mdct_short[192];
+ #endif
+ 
+ FLOAT8 ATHformula(lame_global_flags *gfp,FLOAT8 f);
+ void compute_ath(lame_global_flags *gfp,FLOAT8 ATH_l[SBPSY_l],FLOAT8 ATH_s[SBPSY_l]);
+ void ms_convert(FLOAT8 xr[2][576],FLOAT8 xr_org[2][576]);
+ void on_pe(lame_global_flags *gfp,FLOAT8 pe[2][2],III_side_info_t *l3_side,
+ int targ_bits[2],int mean_bits, int gr);
+ void reduce_side(int targ_bits[2],FLOAT8 ms_ener_ratio,int mean_bits);
+ 
+ 
+ void outer_loop( lame_global_flags *gfp,
+                 FLOAT8 xr[576],     /*vector of the magnitudees of the spectral values */
+                 int bits,
+ 		FLOAT8 noise[4],
+                 III_psy_xmin *l3_xmin, /* the allowed distortion of the scalefactor */
+                 int l3_enc[576],    /* vector of quantized values ix(0..575) */
+ 		 III_scalefac_t *scalefac, /* scalefactors */
+ 		 gr_info *,
+                 FLOAT8 xfsf[4][SBPSY_l],
+ 		int ch);
+ 
+ 
+ 
+ void iteration_init( lame_global_flags *gfp,III_side_info_t *l3_side, int l3_enc[2][2][576]);
+ 
+ int inner_loop( lame_global_flags *gfp,FLOAT8 xrpow[576],
+                 int l3_enc[576],
+                 int max_bits,
+                 gr_info *cod_info);
+ 
+ int calc_xmin( lame_global_flags *gfp,FLOAT8 xr[576],
+                III_psy_ratio *ratio,
+                gr_info *cod_info,
+                III_psy_xmin *l3_xmin);
+ 
+ 
+ int scale_bitcount( III_scalefac_t *scalefac, gr_info *cod_info);
+ int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info);
+ int calc_noise1( FLOAT8 xr[576],
+                  int ix[576],
+                  gr_info *cod_info,
+                  FLOAT8 xfsf[4][SBPSY_l], 
+ 		 FLOAT8 distort[4][SBPSY_l],
+                  III_psy_xmin *l3_xmin,
+ 		 III_scalefac_t *,
+                  FLOAT8 *noise, FLOAT8 *tot_noise, FLOAT8 *max_noise);
+ 
+ int loop_break( III_scalefac_t *scalefac, gr_info *cod_info);
+ 
+ void amp_scalefac_bands(FLOAT8 xrpow[576],
+ 			gr_info *cod_info,
+ 			III_scalefac_t *scalefac,
+ 			FLOAT8 distort[4][SBPSY_l]);
+ 
+ void quantize_xrpow( FLOAT8 xr[576],
+                int  ix[576],
+                gr_info *cod_info );
+ void quantize_xrpow_ISO( FLOAT8 xr[576],
+                int  ix[576],
+                gr_info *cod_info );
+ 
+ int
+ new_choose_table( int ix[576],
+ 		  unsigned int begin,
+ 		  unsigned int end, int * s );
+ 
+ int bin_search_StepSize2(lame_global_flags *gfp,int desired_rate, int start, int ix[576],
+                          FLOAT8 xrspow[576], gr_info * cod_info);
+ int count_bits(lame_global_flags *gfp,int  *ix, FLOAT8 xr[576], gr_info *cod_info);
+ 
+ 
+ int quant_compare(int type,
+ int best_over,FLOAT8 best_tot_noise,FLOAT8 best_over_noise,FLOAT8 best_max_over,
+ int over,FLOAT8 tot_noise, FLOAT8 over_noise,FLOAT8 max_noise);
+ 
+ int VBR_compare(
+ int best_over,FLOAT8 best_tot_noise,FLOAT8 best_over_noise,FLOAT8 best_max_over,
+ int over,FLOAT8 tot_noise, FLOAT8 over_noise,FLOAT8 max_noise);
+ 
+ void best_huffman_divide(int gr, int ch, gr_info *cod_info, int *ix);
+ 
+ void best_scalefac_store(lame_global_flags *gfp,int gr, int ch,
+ 			 int l3_enc[2][2][576],
+ 			 III_side_info_t *l3_side,
+ 			 III_scalefac_t scalefac[2][2]);
+ 
+ int init_outer_loop(
+     lame_global_flags *gfp,
+     FLOAT8 xr[576],        /*  could be L/R OR MID/SIDE */
+     gr_info *cod_info);
+ 
+ #define LARGE_BITS 100000
+ 
+ #endif
+ 
diff -r -c -N encoder/quantize.c lame3.70/quantize.c
*** encoder/quantize.c	Wed Dec 31 17:00:00 1969
--- lame3.70/quantize.c	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,1201 ----
+ #define MAXNOISEXX
+ /*
+  *	MP3 quantization
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ 
+ 
+ #include <assert.h>
+ #include "util.h"
+ #include "l3side.h"
+ #include "quantize.h"
+ #include "l3bitstream.h"
+ #include "reservoir.h"
+ #include "quantize-pvt.h"
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #endif
+ 
+ 
+ 
+ #ifdef HAVEGTK
+ 
+ /************************************************************************/
+ /*  updates plotting data                                               */
+ /************************************************************************/
+ void 
+ set_pinfo (
+     gr_info *cod_info,
+     III_psy_ratio *ratio, 
+     III_scalefac_t *scalefac,
+     FLOAT8 xr[576],        
+     FLOAT8 xfsf[4][SBPSY_l],
+     FLOAT8 noise[4],
+     int gr,
+     int ch
+ )
+ {
+   int sfb;
+   FLOAT ifqstep;
+   int i,l,start,end,bw;
+   FLOAT8 en0;
+   D192_3 *xr_s = (D192_3 *)xr;
+   ifqstep = ( cod_info->scalefac_scale == 0 ) ? .5 : 1.0;
+ 	  
+   if (cod_info->block_type == SHORT_TYPE) {
+     for ( i = 0; i < 3; i++ ) {
+       for ( sfb = 0; sfb < SBPSY_s; sfb++ )  {
+ 	start = scalefac_band.s[ sfb ];
+ 	end   = scalefac_band.s[ sfb + 1 ];
+ 	bw = end - start;
+ 	for ( en0 = 0.0, l = start; l < end; l++ ) 
+ 	  en0 += (*xr_s)[l][i] * (*xr_s)[l][i];
+ 	en0=Max(en0/bw,1e-20);
+ 		
+ 	/* conversion to FFT units */
+ 	en0 = ratio->en.s[sfb][i]/en0;
+ 	
+ 	pinfo->xfsf_s[gr][ch][3*sfb+i] =  xfsf[i+1][sfb]*en0;
+ 	pinfo->thr_s[gr][ch][3*sfb+i] = ratio->thm.s[sfb][i];
+ 	pinfo->en_s[gr][ch][3*sfb+i] = ratio->en.s[sfb][i]; 
+ 	
+ 	pinfo->LAMEsfb_s[gr][ch][3*sfb+i]=
+ 	  -2*cod_info->subblock_gain[i]-ifqstep*scalefac->s[sfb][i];
+       }
+     }
+   }else{
+     for ( sfb = 0; sfb < SBPSY_l; sfb++ )   {
+       start = scalefac_band.l[ sfb ];
+       end   = scalefac_band.l[ sfb+1 ];
+       bw = end - start;
+       for ( en0 = 0.0, l = start; l < end; l++ ) 
+ 	en0 += xr[l] * xr[l];
+       en0=Max(en0/bw,1e-20);
+       /*
+ 	printf("diff  = %f \n",10*log10(Max(ratio[gr][ch].en.l[sfb],1e-20))
+ 	-(10*log10(en0)+150));
+       */
+       
+       /* convert to FFT units */
+       en0 =   ratio->en.l[sfb]/en0;
+       
+       pinfo->xfsf[gr][ch][sfb] =  xfsf[0][sfb]*en0;
+       pinfo->thr[gr][ch][sfb] = ratio->thm.l[sfb];
+       pinfo->en[gr][ch][sfb] = ratio->en.l[sfb];
+       
+       pinfo->LAMEsfb[gr][ch][sfb]=-ifqstep*scalefac->l[sfb];
+       if (cod_info->preflag && sfb>=11) 
+ 	pinfo->LAMEsfb[gr][ch][sfb]-=ifqstep*pretab[sfb];
+     }
+   }
+   pinfo->LAMEqss[gr][ch] = cod_info->global_gain;
+   pinfo->LAMEmainbits[gr][ch] = cod_info->part2_3_length;
+ 
+   pinfo->over      [gr][ch] = noise[0];
+   pinfo->max_noise [gr][ch] = noise[1];
+   pinfo->over_noise[gr][ch] = noise[2];
+   pinfo->tot_noise [gr][ch] = noise[3];
+ }
+ 
+ #endif
+ 
+ 
+ 
+ /************************************************************************/
+ /*  iteration_loop()                                                    */
+ /************************************************************************/
+ void
+ iteration_loop( lame_global_flags *gfp,
+                 FLOAT8 pe[2][2], FLOAT8 ms_ener_ratio[2],
+ 		FLOAT8 xr[2][2][576], III_psy_ratio ratio[2][2],
+ 		III_side_info_t *l3_side, int l3_enc[2][2][576],
+ 		III_scalefac_t scalefac[2][2])
+ {
+   FLOAT8 xfsf[4][SBPSY_l];
+   FLOAT8 noise[4]; /* over,max_noise,over_noise,tot_noise; */
+   III_psy_xmin l3_xmin[2];
+   gr_info *cod_info;
+   int bitsPerFrame;
+   int mean_bits;
+   int ch, gr, i, bit_rate;
+ 
+ 
+   iteration_init(gfp,l3_side,l3_enc);
+   bit_rate = bitrate_table[gfp->version][gfp->bitrate_index];
+ 
+ 
+   getframebits(gfp,&bitsPerFrame, &mean_bits);
+   ResvFrameBegin(gfp, l3_side, mean_bits, bitsPerFrame );
+ 
+   /* quantize! */
+ 
+ 
+ 
+   for ( gr = 0; gr < gfp->mode_gr; gr++ ) {
+     int targ_bits[2];
+ 
+     if (convert_mdct) 
+       ms_convert(xr[gr], xr[gr]);
+     
+     on_pe(gfp,pe,l3_side,targ_bits,mean_bits, gr);
+ #ifdef RH_SIDE_CBR
+ #else
+     if (reduce_sidechannel) 
+       reduce_side(targ_bits,ms_ener_ratio[gr],mean_bits);
+ #endif      
+     
+     for (ch=0 ; ch < gfp->stereo ; ch ++) {
+       cod_info = &l3_side->gr[gr].ch[ch].tt;	
+       if (!init_outer_loop(gfp,xr[gr][ch], cod_info))
+         {
+           /* xr contains no energy 
+            * cod_info was set in init_outer_loop above
+ 	   */
+           memset(&scalefac[gr][ch],0,sizeof(III_scalefac_t));
+           memset(l3_enc[gr][ch],0,576*sizeof(int));
+ 	  noise[0]=noise[1]=noise[2]=noise[3]=0;
+         }
+       else
+ 	{
+           calc_xmin(gfp,xr[gr][ch], &ratio[gr][ch], cod_info, &l3_xmin[ch]);
+ 	  outer_loop( gfp,xr[gr][ch], targ_bits[ch], noise,
+ 		      &l3_xmin[ch], l3_enc[gr][ch], 
+ 		      &scalefac[gr][ch], cod_info, xfsf, ch);
+         }
+       best_scalefac_store(gfp,gr, ch, l3_enc, l3_side, scalefac);
+       if (gfp->use_best_huffman==1 && cod_info->block_type == NORM_TYPE) {
+ 	best_huffman_divide(gr, ch, cod_info, l3_enc[gr][ch]);
+       }
+ #ifdef HAVEGTK
+       if (gfp->gtkflag)
+ 	set_pinfo (cod_info, &ratio[gr][ch], &scalefac[gr][ch], xr[gr][ch], xfsf, noise, gr, ch);
+ #endif
+ 
+ /*#define NORES_TEST */
+ #ifndef NORES_TEST
+       ResvAdjust(gfp,cod_info, l3_side, mean_bits );
+ #endif
+       /* set the sign of l3_enc */
+       for ( i = 0; i < 576; i++) {
+ 	if (xr[gr][ch][i] < 0)
+ 	  l3_enc[gr][ch][i] *= -1;
+       }
+     }
+   } /* loop over gr */
+ 
+ #ifdef NORES_TEST
+   /* replace ResvAdjust above with this code if you do not want
+      the second granule to use bits saved by the first granule.
+      when combined with --nores, this is usefull for testing only */
+   for ( gr = 0; gr < gfp->mode_gr; gr++ ) {
+     for ( ch =  0; ch < gfp->stereo; ch++ ) {
+ 	cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 	ResvAdjust(gfp, cod_info, l3_side, mean_bits );
+     }
+   }
+ #endif
+ 
+ 
+ 
+   ResvFrameEnd(gfp,l3_side, mean_bits );
+ }
+ 
+ 
+ void 
+ set_masking_lower (int VBR_q,int nbits)
+ {
+ 	FLOAT masking_lower_db, adjust;
+ 	
+ 	/* quality setting */
+ 	/* Adjust allowed masking based on quality setting */
+ 	
+ #ifdef  RH_QUALITY_CONTROL	
+ 	/* - lower masking depending on Quality setting
+ 	 * - quality control together with adjusted ATH MDCT scaling
+ 	 *   on lower quality setting allocate more noise from
+ 	 *   ATH masking, and on higher quality setting allocate
+ 	 *   less noise from ATH masking.
+ 	 * - experiments show that going more than 2dB over GPSYCHO's
+ 	 *   limits ends up in very annoying artefacts
+ 	 */
+ 	static FLOAT dbQ[10]={-6.0,-4.5,-3.0,-1.5,0,0.3,0.6,1.0,1.5,2.0};
+ 	
+ 	assert( VBR_q <= 9 );
+ 	assert( VBR_q >= 0 );
+ 	
+ 	masking_lower_db = dbQ[VBR_q];	
+ 	adjust = 0;
+ #else
+ 	/* masking_lower varies from -8 to +10 db */
+ 	masking_lower_db = -6 + 2*VBR_q;
+ 	/* adjust by -6(min)..0(max) depending on bitrate */
+ 	adjust = (nbits-125)/(2500.0-125.0);
+ 	adjust = 4*(adjust-1);
+ #endif
+ 	masking_lower_db += adjust;
+ 	masking_lower = pow(10.0,masking_lower_db/10);
+ }
+ 
+ /************************************************************************
+  *
+  * VBR_iteration_loop()   
+  *
+  * tries to find out how many bits are needed for each granule and channel
+  * to get an acceptable quantization. An appropriate bitrate will then be
+  * choosed for quantization.  rh 8/99                                                
+  *
+  ************************************************************************/
+ void
+ VBR_iteration_loop (lame_global_flags *gfp,
+                 FLOAT8 pe[2][2], FLOAT8 ms_ener_ratio[2],
+                 FLOAT8 xr[2][2][576], III_psy_ratio ratio[2][2],
+                 III_side_info_t * l3_side, int l3_enc[2][2][576],
+                 III_scalefac_t scalefac[2][2])
+ {
+ #ifdef HAVEGTK
+   plotting_data bst_pinfo;
+ #endif
+   gr_info         bst_cod_info, clean_cod_info;
+   III_scalefac_t  bst_scalefac;
+   int             bst_l3_enc[576]; 
+   
+   III_psy_xmin l3_xmin;
+   gr_info  *cod_info = NULL;
+   int       save_bits[2][2];
+   FLOAT8    noise[4];      /* over,max_noise,over_noise,tot_noise; */
+   FLOAT8    targ_noise[4]; /* over,max_noise,over_noise,tot_noise; */
+   FLOAT8    xfsf[4][SBPSY_l];
+   int       this_bits, dbits;
+   int       used_bits=0;
+   int       min_bits,max_bits,min_mean_bits=0;
+   int       frameBits[15];
+   int       bitsPerFrame;
+   int       bits;
+   int       mean_bits;
+   int       i,ch, gr, analog_silence;
+   int	    reparted = 0;
+ 
+   iteration_init(gfp,l3_side,l3_enc);
+ 
+ #ifdef RH_QUALITY_CONTROL
+   /* with RH_QUALITY_CONTROL we have to set masking_lower only once */
+   set_masking_lower(gfp->VBR_q, 0 );
+ #endif      
+ 
+   /*******************************************************************
+    * how many bits are available for each bitrate?
+    *******************************************************************/
+   for( gfp->bitrate_index = 1;
+        gfp->bitrate_index <= gfp->VBR_max_bitrate;
+        gfp->bitrate_index++    ) {
+     getframebits (gfp,&bitsPerFrame, &mean_bits);
+     if (gfp->bitrate_index == gfp->VBR_min_bitrate) {
+       /* always use at least this many bits per granule per channel */
+       /* unless we detect analog silence, see below */
+       min_mean_bits=mean_bits/gfp->stereo;
+     }
+     frameBits[gfp->bitrate_index]=
+       ResvFrameBegin (gfp,l3_side, mean_bits, bitsPerFrame);
+   }
+ 
+   gfp->bitrate_index=gfp->VBR_max_bitrate;
+ 
+   
+   /*******************************************************************
+    * how many bits would we use of it?
+    *******************************************************************/
+   analog_silence=0;
+   for (gr = 0; gr < gfp->mode_gr; gr++) {
+     int num_chan=gfp->stereo;
+ #ifdef  RH_SIDE_VBR
+     /* my experiences are, that side channel reduction  
+      * does more harm than good when VBR encoding
+      * (Robert.Hegemann@gmx.de 2000-02-18)
+      */
+ #else
+     /* determine quality based on mid channel only */
+     if (reduce_sidechannel) num_chan=1;  
+ #endif
+ 
+     /* copy data to be quantized into xr */
+     if (convert_mdct)
+ 	ms_convert(xr[gr],xr[gr]);
+ 
+     for (ch = 0; ch < num_chan; ch++) { 
+       int real_bits;
+       
+       /******************************************************************
+        * find smallest number of bits for an allowable quantization
+        ******************************************************************/
+       cod_info = &l3_side->gr[gr].ch[ch].tt;
+       min_bits = Max(125,min_mean_bits);
+ 
+       if (!init_outer_loop(gfp,xr[gr][ch], cod_info))
+       {
+         /* xr contains no energy 
+          * cod_info was set in init_outer_loop above
+ 	 */
+         memset(&scalefac[gr][ch],0,sizeof(III_scalefac_t));
+         memset(l3_enc[gr][ch],0,576*sizeof(int));
+         save_bits[gr][ch] = 0;
+ #ifdef HAVEGTK
+ 	if (gfp->gtkflag)
+ 	  set_pinfo(cod_info, &ratio[gr][ch], &scalefac[gr][ch], xr[gr][ch], xfsf, noise, gr, ch);
+ #endif
+ 	analog_silence=1;
+ 	continue; /* with next channel */
+       }
+       
+       memcpy( &clean_cod_info, cod_info, sizeof(gr_info) );
+       
+ #ifdef RH_QUALITY_CONTROL
+       /*
+        * masking lower already set in the beginning
+        */
+ #else
+       /*
+        * has to be set before calculating l3_xmin
+        */
+       set_masking_lower( gfp->VBR_q,2500 );
+ #endif      
+       /* check for analolg silence */
+       /* if energy < ATH, set min_bits = 125 */
+       if (0==calc_xmin(gfp,xr[gr][ch], &ratio[gr][ch], cod_info, &l3_xmin)) {
+ 	  analog_silence=1;
+ 	  min_bits=125;
+       }
+ 
+       if (cod_info->block_type==SHORT_TYPE) {
+ 	  min_bits += Max(1100,pe[gr][ch]);
+ 	  min_bits=Min(min_bits,1800);
+       }
+ 
+       max_bits = 1200 + frameBits[gfp->VBR_max_bitrate]/(gfp->stereo*gfp->mode_gr);
+       max_bits=Min(max_bits,2500);
+       max_bits=Max(max_bits,min_bits);
+ 
+       dbits = (max_bits-min_bits)/4;
+       this_bits = (max_bits+min_bits)/2;
+       real_bits = max_bits+1;
+ 
+       /* bin search to within +/- 10 bits of optimal */
+       do {
+ 	  int better;
+ 	  assert(this_bits>=min_bits);
+ 	  assert(this_bits<=max_bits);
+ 
+ 	  if( this_bits >= real_bits ){
+ 	      /* 
+ 	       * we already found a quantization with fewer bits
+ 	       * so we can skip this try
+ 	       */
+ 	      this_bits -= dbits;
+ 	      dbits /= 2;
+ 	      continue; /* skips the rest of this do-while loop */
+ 	  }
+ 
+ 	  /* VBR will look for a quantization which has better values
+ 	   * then those specified below.*/
+ 	  targ_noise[0]=0;          /* over */
+ 	  targ_noise[1]=0;          /* max_noise */
+ 	  targ_noise[2]=0;          /* over_noise */
+ 	  targ_noise[3]=0;          /* tot_noise */
+ 	
+ 	  targ_noise[0]=Max(0,targ_noise[0]);
+ 	  targ_noise[2]=Max(0,targ_noise[2]);
+ 
+ 	  /*
+ 	   *  OK, start with a fresh setting
+ 	   *  - scalefac  will be set up by outer_loop
+ 	   *  - l3_enc    will be set up by outer_loop
+ 	   *  + cod_info  we will restore our initialized one, see below
+ 	   */
+ 	  memcpy( cod_info, &clean_cod_info, sizeof(gr_info) );
+ 
+ #ifdef RH_QUALITY_CONTROL
+           /*
+ 	   * there is no need for a recalculation of l3_xmin,
+ 	   * because masking_lower did not change within this do-while
+ 	   */
+ #else
+ 	  /* quality setting */
+ 	  set_masking_lower( gfp->VBR_q,this_bits );
+           /* 
+ 	   * compute max allowed distortion, masking lower has changed
+ 	   */
+           calc_xmin(gfp,xr[gr][ch], &ratio[gr][ch], cod_info, &l3_xmin);
+ #endif
+ 	  outer_loop( gfp,xr[gr][ch], this_bits, noise, 
+ 		      &l3_xmin, l3_enc[gr][ch],
+ 		      &scalefac[gr][ch], cod_info, xfsf,
+ 		      ch);
+ 
+ 	  /* is quantization as good as we are looking for ? */
+ 	  better=VBR_compare((int)targ_noise[0],targ_noise[3],targ_noise[2],
+ 			     targ_noise[1],(int)noise[0],noise[3],noise[2],
+ 			     noise[1]);
+ #ifdef HAVEGTK
+ 	  if (gfp->gtkflag)
+ 	    set_pinfo(cod_info, &ratio[gr][ch], &scalefac[gr][ch], xr[gr][ch], xfsf, noise, gr, ch);
+ #endif
+ 	  if (better) {
+ 	      /* 
+ 	       * we now know it can be done with "real_bits"
+ 	       * and maybe we can skip some iterations
+ 	       */
+ 	      real_bits = cod_info->part2_3_length;
+ 	      /*
+ 	       * save best quantization so far
+ 	       */
+               memcpy( &bst_scalefac, &scalefac[gr][ch], sizeof(III_scalefac_t)  );
+               memcpy(  bst_l3_enc,    l3_enc  [gr][ch], sizeof(int)*576         );
+               memcpy( &bst_cod_info,  cod_info,         sizeof(gr_info)         );
+ #ifdef HAVEGTK
+               if (gfp->gtkflag) 
+                 memcpy( &bst_pinfo, pinfo, sizeof(plotting_data) );
+ #endif
+ 	      /*
+ 	       * try with fewer bits
+ 	       */
+ 	      this_bits -= dbits;
+ 	  } else {
+ 	      /*
+ 	       * try with more bits
+ 	       */
+ 	      this_bits += dbits;
+ 	  }
+ 	  dbits /= 2;
+       } while (dbits>10) ;
+       
+       if (real_bits <= max_bits)
+       {
+         /* restore best quantization found */
+         memcpy(  cod_info,         &bst_cod_info, sizeof(gr_info)        );
+         memcpy( &scalefac[gr][ch], &bst_scalefac, sizeof(III_scalefac_t) );
+         memcpy(  l3_enc  [gr][ch],  bst_l3_enc,   sizeof(int)*576        );
+ #ifdef HAVEGTK
+         if (gfp->gtkflag) 
+           memcpy( pinfo, &bst_pinfo, sizeof(plotting_data) );
+ #endif
+       }
+       assert((int)cod_info->part2_3_length <= max_bits);
+       save_bits[gr][ch] = cod_info->part2_3_length;
+       used_bits += save_bits[gr][ch];
+       
+     } /* for ch */
+   } /* for gr */
+ 
+ 
+ #ifdef  RH_SIDE_VBR
+   /* my experiences are, that side channel reduction  
+    * does more harm than good when VBR encoding
+    * (Robert.Hegemann@gmx.de 2000-02-18)
+    */
+ #else	
+   if (reduce_sidechannel) {
+     /* number of bits needed was found for MID channel above.  Use formula
+      * (fixed bitrate code) to set the side channel bits */
+     for (gr = 0; gr < gfp->mode_gr; gr++) {
+       FLOAT8 fac = .33*(.5-ms_ener_ratio[gr])/.5;
+       save_bits[gr][1]=((1-fac)/(1+fac))*save_bits[gr][0];
+       save_bits[gr][1]=Max(125,save_bits[gr][1]);
+       used_bits += save_bits[gr][1];
+     }
+   }
+ #endif
+ 
+   /******************************************************************
+    * find lowest bitrate able to hold used bits
+    ******************************************************************/
+   for( gfp->bitrate_index =   (analog_silence ? 1 : gfp->VBR_min_bitrate );
+        gfp->bitrate_index < gfp->VBR_max_bitrate;
+        gfp->bitrate_index++    )
+     if( used_bits <= frameBits[gfp->bitrate_index] ) break;
+ 
+   /*******************************************************************
+    * calculate quantization for this bitrate
+    *******************************************************************/  
+   getframebits (gfp,&bitsPerFrame, &mean_bits);
+   bits=ResvFrameBegin (gfp,l3_side, mean_bits, bitsPerFrame);
+ 
+   /* repartion available bits in same proportion */
+   if (used_bits > bits ) {
+     reparted = 1;
+     for( gr = 0; gr < gfp->mode_gr; gr++) {
+       for(ch = 0; ch < gfp->stereo; ch++) {
+ 	save_bits[gr][ch]=(save_bits[gr][ch]*frameBits[gfp->bitrate_index])/used_bits;
+       }
+     }
+     used_bits=0;
+     for( gr = 0; gr < gfp->mode_gr; gr++) {
+       for(ch = 0; ch < gfp->stereo; ch++) {
+ 	used_bits += save_bits[gr][ch];
+       }
+     }
+   }
+   assert(used_bits <= bits);
+ 
+   for(gr = 0; gr < gfp->mode_gr; gr++) {
+     for(ch = 0; ch < gfp->stereo; ch++) {
+ #ifdef RH_SIDE_VBR
+       if (reparted)
+ #else
+       if (reparted || (reduce_sidechannel && ch == 1))
+ #endif
+       {
+         cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 	       
+ 	if (!init_outer_loop(gfp,xr[gr][ch], cod_info))
+         {
+           /* xr contains no energy 
+            * cod_info was set in init_outer_loop above
+ 	   */
+           memset(&scalefac[gr][ch],0,sizeof(III_scalefac_t));
+           memset(l3_enc[gr][ch],0,576*sizeof(int));
+ 	  noise[0]=noise[1]=noise[2]=noise[3]=0;
+         }
+ 	else
+ 	{
+ #ifdef RH_QUALITY_CONTROL
+           /*
+            * masking lower already set in the beginning
+            */
+ #else
+           /* quality setting */
+           set_masking_lower( gfp->VBR_q,save_bits[gr][ch] );
+ #endif
+           calc_xmin(gfp,xr[gr][ch], &ratio[gr][ch], cod_info, &l3_xmin);
+ 	
+           outer_loop( gfp,xr[gr][ch], save_bits[gr][ch], noise,
+ 	 	      &l3_xmin, l3_enc[gr][ch], 
+ 		      &scalefac[gr][ch], cod_info, xfsf, ch);
+ 	}
+ #ifdef HAVEGTK
+ 	if (gfp->gtkflag)
+ 	  set_pinfo(cod_info, &ratio[gr][ch], &scalefac[gr][ch], xr[gr][ch], xfsf, noise, gr, ch);
+ #endif
+       }
+     }
+   }
+ 
+   /*******************************************************************
+    * update reservoir status after FINAL quantization/bitrate 
+    *******************************************************************/
+   for (gr = 0; gr < gfp->mode_gr; gr++)
+     for (ch = 0; ch < gfp->stereo; ch++) {
+       cod_info = &l3_side->gr[gr].ch[ch].tt;
+       best_scalefac_store(gfp,gr, ch, l3_enc, l3_side, scalefac);
+       if (cod_info->block_type == NORM_TYPE) {
+ 	best_huffman_divide(gr, ch, cod_info, l3_enc[gr][ch]);
+       }
+ #ifdef HAVEGTK
+       if (gfp->gtkflag)
+ 	pinfo->LAMEmainbits[gr][ch]=cod_info->part2_3_length;
+ #endif
+       ResvAdjust (gfp,cod_info, l3_side, mean_bits);
+     }
+ 
+   /*******************************************************************
+    * set the sign of l3_enc 
+    *******************************************************************/
+   for (gr = 0; gr < gfp->mode_gr; gr++)
+     for (ch = 0; ch < gfp->stereo; ch++) {
+ /*
+  * is the following code correct?
+  *
+       int      *pi = &l3_enc[gr][ch][0];
+ 
+       for (i = 0; i < 576; i++) {
+         FLOAT8    pr = xr[gr][ch][i];
+ 
+         if ((pr < 0) && (pi[i] > 0))
+           pi[i] *= -1;
+       }
+  *
+  * or is the code used for CBR correct?
+  */
+       for ( i = 0; i < 576; i++) {
+         if (xr[gr][ch][i] < 0) l3_enc[gr][ch][i] *= -1;
+       }
+     }
+ 
+   ResvFrameEnd (gfp,l3_side, mean_bits);
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************/
+ /*  init_outer_loop  mt 6/99                                            */
+ /*  returns 0 if all energies in xr are zero, else 1                    */
+ /************************************************************************/
+ int init_outer_loop(lame_global_flags *gfp,
+     FLOAT8 xr[576],        /*  could be L/R OR MID/SIDE */
+     gr_info *cod_info)
+ {
+   int i;
+ 
+ 
+   for ( i = 0; i < 4; i++ )
+     cod_info->slen[i] = 0;
+   cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
+ 
+   cod_info->part2_3_length    = 0;
+   cod_info->big_values        = 0;
+   cod_info->count1            = 0;
+   cod_info->scalefac_compress = 0;
+   cod_info->table_select[0]   = 0;
+   cod_info->table_select[1]   = 0;
+   cod_info->table_select[2]   = 0;
+   cod_info->subblock_gain[0]  = 0;
+   cod_info->subblock_gain[1]  = 0;
+   cod_info->subblock_gain[2]  = 0;
+   cod_info->region0_count     = 0;
+   cod_info->region1_count     = 0;
+   cod_info->part2_length      = 0;
+   cod_info->preflag           = 0;
+   cod_info->scalefac_scale    = 0;
+   cod_info->global_gain       = 210;
+   cod_info->count1table_select= 0;
+   cod_info->count1bits        = 0;
+   
+   
+   if (gfp->experimentalZ) {
+     /* compute subblock gains */
+     int j,b;  FLOAT8 en[3],mx;
+     if ((cod_info->block_type==SHORT_TYPE) ) {
+       /* estimate energy within each subblock */
+       for (b=0; b<3; b++) en[b]=0;
+       for ( i=0,j = 0; j < 192; j++ ) {
+ 	for (b=0; b<3; b++) {
+ 	  en[b]+=xr[i] * xr[i];
+ 	  i++;
+ 	}
+       }
+       mx = 1e-12;
+       for (b=0; b<3; b++) mx=Max(mx,en[b]);
+       for (b=0; b<3; b++) en[b] = Max(en[b],1e-12)/mx;
+       /*printf("ener = %4.2f  %4.2f  %4.2f  \n",en[0],en[1],en[2]);*/
+       /* pick gain so that 2^(2gain)*en[0] = 1  */
+       /* gain = .5* log( 1/en[0] )/LOG2 = -.5*log(en[])/LOG2 */
+       for (b=0; b<3; b++) {
+ 	cod_info->subblock_gain[b] = (int)(-.5*log(en[b])/LOG2 + 0.5);
+ 	if (cod_info->subblock_gain[b] > 2) 
+ 	  cod_info->subblock_gain[b]=2;
+ 	if (cod_info->subblock_gain[b] < 0) 
+ 	  cod_info->subblock_gain[b]=0;
+       }
+       /*
+        *  check if there is some energy we have to quantize
+        *  if so, then return 1 else 0
+        */
+       if (1e-99 < en[0]+en[1]+en[2])
+         return 1;
+       else
+         return 0;
+     }
+   }
+   /*
+    *  check if there is some energy we have to quantize
+    *  if so, then return 1 else 0
+    */
+   for (i=0; i<576; i++) 
+     if ( 1e-99 < fabs (xr[i]) )
+       return 1;
+   
+   return 0;
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************/
+ /*  outer_loop                                                         */
+ /************************************************************************/
+ /*  Function: The outer iteration loop controls the masking conditions  */
+ /*  of all scalefactorbands. It computes the best scalefac and          */
+ /*  global gain. This module calls the inner iteration loop             
+  * 
+  *  mt 5/99 completely rewritten to allow for bit reservoir control,   
+  *  mid/side channels with L/R or mid/side masking thresholds, 
+  *  and chooses best quantization instead of last quantization when 
+  *  no distortion free quantization can be found.  
+  *  
+  *  added VBR support mt 5/99
+  ************************************************************************/
+ void outer_loop(
+     lame_global_flags *gfp,
+     FLOAT8 xr[576],        
+     int targ_bits,
+     FLOAT8 best_noise[4],
+     III_psy_xmin *l3_xmin,   /* the allowed distortion of the scalefactor */
+     int l3_enc[576],         /* vector of quantized values ix(0..575) */
+     III_scalefac_t *scalefac, /* scalefactors */
+     gr_info *cod_info,
+     FLOAT8 xfsf[4][SBPSY_l],
+     int ch)
+ {
+   III_scalefac_t scalefac_w;
+   gr_info save_cod_info;
+   int l3_enc_w[576]; 
+   int i, iteration;
+   int status,bits_found=0;
+   int huff_bits;
+   FLOAT8 xrpow[576],temp;
+   int better;
+   int over=0;
+   FLOAT8 max_noise;
+   FLOAT8 over_noise;
+   FLOAT8 tot_noise;
+   int best_over=100;
+   FLOAT8 best_max_noise=0;
+   FLOAT8 best_over_noise=0;
+   FLOAT8 best_tot_noise=0;
+   FLOAT8 xfsf_w[4][SBPSY_l];
+   FLOAT8 distort[4][SBPSY_l];
+ 
+   int compute_stepsize=1;
+   int notdone=1;
+ 
+   /* BEGIN MAIN LOOP */
+   iteration = 0;
+   while ( notdone  ) {
+     static int OldValue[2] = {180, 180};
+     int try_scale=0;
+     iteration ++;
+ 
+     if (compute_stepsize) {
+       /* init and compute initial quantization step */
+       compute_stepsize=0;
+       /* reset of iteration variables */
+       memset(&scalefac_w, 0, sizeof(III_scalefac_t));
+       for (i=0;i<576;i++) {
+ 	temp=fabs(xr[i]);
+ 	xrpow[i]=sqrt(sqrt(temp)*temp);
+       }
+       bits_found=bin_search_StepSize2(gfp,targ_bits,OldValue[ch],
+ 				      l3_enc_w,xrpow,cod_info);
+       OldValue[ch] = cod_info->global_gain;
+     }
+ 
+ 
+     /* inner_loop starts with the initial quantization step computed above
+      * and slowly increases until the bits < huff_bits.
+      * Thus it is important not to start with too large of an inital
+      * quantization step.  Too small is ok, but inner_loop will take longer 
+      */
+     huff_bits = targ_bits - cod_info->part2_length;
+     if (huff_bits < 0) {
+       assert(iteration != 1);
+       /* scale factors too large, not enough bits. use previous quantizaton */
+       notdone=0;
+     } else {
+       /* if this is the first iteration, see if we can reuse the quantization
+        * computed in bin_search_StepSize above */
+       int real_bits;
+       if (iteration==1) {
+ 	if(bits_found>huff_bits) {
+ 	  cod_info->global_gain++;
+ 	  real_bits = inner_loop(gfp,xrpow, l3_enc_w, huff_bits, cod_info);
+ 	} else real_bits=bits_found;
+       }
+       else 
+ 	real_bits=inner_loop(gfp,xrpow, l3_enc_w, huff_bits, cod_info);
+       cod_info->part2_3_length = real_bits;
+ 
+       /* compute the distortion in this quantization */
+       if (gfp->noise_shaping==0) {
+       	over=0;
+       }else{
+ 	/* coefficients and thresholds both l/r (or both mid/side) */
+ 	over=calc_noise1( xr, l3_enc_w, cod_info, 
+ 			  xfsf_w,distort, l3_xmin, &scalefac_w, &over_noise, 
+ 			  &tot_noise, &max_noise);
+ 
+       }
+ 
+       /* check if this quantization is better the our saved quantization */
+       if (iteration == 1) better=1;
+       else 
+ 	better=quant_compare(gfp->experimentalX,
+ 	     best_over,best_tot_noise,best_over_noise,best_max_noise,
+                   over,     tot_noise,     over_noise,     max_noise);
+ 
+       /* save data so we can restore this quantization later */    
+       if (better) {
+ 	best_over=over;
+ 	best_max_noise=max_noise;
+ 	best_over_noise=over_noise;
+ 	best_tot_noise=tot_noise;
+ 	
+ 	memcpy(scalefac, &scalefac_w, sizeof(III_scalefac_t));
+ 	memcpy(l3_enc,l3_enc_w,sizeof(int)*576);
+ 	memcpy(&save_cod_info,cod_info,sizeof(save_cod_info));
+ 
+ #ifdef HAVEGTK
+ 	if (gfp->gtkflag) {
+ 	  memcpy(xfsf, xfsf_w, sizeof(xfsf_w));
+ 	}
+ #endif
+       }
+     }
+     
+     /* if no bands with distortion, we are done */
+     if (gfp->noise_shaping_stop==0)
+       if (over==0) notdone=0;
+ 
+     if (notdone) {
+ 	amp_scalefac_bands( xrpow, cod_info, &scalefac_w, distort);
+ 	/* check to make sure we have not amplified too much */
+ 	/* loop_break returns 0 if there is an unamplified scalefac */
+ 	/* scale_bitcount returns 0 if no scalefactors are too large */
+ 	if ( (status = loop_break(&scalefac_w, cod_info)) == 0 ) {
+ 	    if ( gfp->version == 1 ) {
+ 		status = scale_bitcount(&scalefac_w, cod_info);
+ 	    }else{
+ 		status = scale_bitcount_lsf(&scalefac_w, cod_info);
+ 	    }
+ 	    if (status && (cod_info->scalefac_scale==0)) try_scale=1; 
+ 	}
+ 	notdone = !status;
+     }
+ 
+     if (try_scale && gfp->experimentalY) {
+       init_outer_loop(gfp,xr, cod_info);
+       compute_stepsize=1;  /* compute a new global gain */
+       notdone=1;
+       cod_info->scalefac_scale=1;
+     }
+   }    /* done with main iteration */
+ 
+   memcpy(cod_info,&save_cod_info,sizeof(save_cod_info));
+   cod_info->part2_3_length += cod_info->part2_length;
+ 
+   /* finish up */
+   assert( cod_info->global_gain < 256 );
+ 
+   best_noise[0]=best_over;
+   best_noise[1]=best_max_noise;
+   best_noise[2]=best_over_noise;
+   best_noise[3]=best_tot_noise;
+ }
+ 
+ 
+ 
+ 
+ 
+   
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            calc_noise                                                 */
+ /*************************************************************************/
+ /*  mt 5/99:  Function: Improved calc_noise for a single channel   */
+ int calc_noise1( FLOAT8 xr[576], int ix[576], gr_info *cod_info,
+ 		 FLOAT8 xfsf[4][SBPSY_l], FLOAT8 distort[4][SBPSY_l],
+ 		 III_psy_xmin *l3_xmin, III_scalefac_t *scalefac,
+ 		 FLOAT8 *over_noise,
+ 		 FLOAT8 *tot_noise, FLOAT8 *max_noise)
+ {
+     int start, end, l, i, over=0;
+ 	u_int sfb;
+     FLOAT8 sum,step,bw;
+ #ifdef RH_ATH
+     FLOAT8 ath_max;
+ #endif
+ 
+     int count=0;
+     FLOAT8 noise;
+     *over_noise=0;
+     *tot_noise=0;
+     *max_noise = -999;
+ 
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ ) {
+ 	FLOAT8 step;
+ 	int s = scalefac->l[sfb];
+ 
+ 	if (cod_info->preflag)
+ 	    s += pretab[sfb];
+ 
+ 	s = cod_info->global_gain - (s << (cod_info->scalefac_scale + 1));
+ 	assert(s<Q_MAX);
+ 	assert(s>=0);
+ 	step = POW20(s);
+ 
+ 	start = scalefac_band.l[ sfb ];
+         end   = scalefac_band.l[ sfb+1 ];
+         bw = end - start;
+ 
+ #ifdef RH_ATH
+         ath_max = 0;
+ #endif
+         for ( sum = 0.0, l = start; l < end; l++ )
+         {
+             FLOAT8 temp;
+             temp = fabs(xr[l]) - pow43[ix[l]] * step;
+ #ifdef MAXNOISE
+ 	    temp = bw*temp*temp;
+ 	    sum = Max(sum,temp);
+ #elif RH_ATH
+ 	    temp = temp*temp;
+             sum += temp;
+ 	    ath_max = Max( ath_max, temp/ATH_mdct_long[l] );
+ #else
+             sum += temp * temp;
+ #endif
+ 	    
+         }
+         xfsf[0][sfb] = sum / bw;
+ 
+ 	/* max -30db noise below threshold */
+ #ifdef RH_ATH
+ 	noise = 10*log10(Max(.001,Min(ath_max,xfsf[0][sfb]/l3_xmin->l[sfb])));
+ #else
+ 	noise = 10*log10(Max(.001,xfsf[0][sfb] / l3_xmin->l[sfb]));
+ #endif
+         distort[0][sfb] = noise;
+         if (noise>0) {
+ 	  over++;
+ 	  *over_noise += noise;
+ 	}
+ 	*tot_noise += noise;
+ 	*max_noise=Max(*max_noise,noise);
+ 	count++;
+ 
+     }
+ 
+ 
+     for ( i = 0; i < 3; i++ ) {
+         for ( sfb = cod_info->sfb_smax; sfb < SBPSY_s; sfb++ ) {
+ 	    int s;
+ 
+ 	    s = (scalefac->s[sfb][i] << (cod_info->scalefac_scale + 1))
+ 		+ cod_info->subblock_gain[i] * 8;
+ 	    s = cod_info->global_gain - s;
+ 
+ 	    assert(s<Q_MAX);
+ 	    assert(s>=0);
+ 	    step = POW20(s);
+ 	    start = scalefac_band.s[ sfb ];
+ 	    end   = scalefac_band.s[ sfb+1 ];
+             bw = end - start;
+ #ifdef RH_ATH
+ 	    ath_max = 0;
+ #endif
+ 	    for ( sum = 0.0, l = start; l < end; l++ ) {
+ 		FLOAT8 temp;
+ 		temp = fabs(xr[l * 3 + i]) - pow43[ix[l * 3 + i]] * step;
+ #ifdef MAXNOISE
+ 		temp = bw*temp*temp;
+ 		sum = Max(sum,temp);
+ #elif RH_ATH
+ 		temp = temp*temp;
+ 		sum += temp;
+ 		ath_max = Max( ath_max, temp/ATH_mdct_short[l] );
+ #else
+ 		sum += temp * temp;
+ #endif
+             }       
+ 	    xfsf[i+1][sfb] = sum / bw;
+ 	    /* max -30db noise below threshold */
+ #ifdef RH_ATH
+ 	    noise = 10*log10(Max(.001,Min(ath_max,xfsf[i+1][sfb]/l3_xmin->s[sfb][i])));
+ #else
+ 	    noise = 10*log10(Max(.001,xfsf[i+1][sfb] / l3_xmin->s[sfb][i] ));
+ #endif
+             distort[i+1][sfb] = noise;
+             if (noise > 0) {
+ 		over++;
+ 		*over_noise += noise;
+ 	    }
+ 	    *tot_noise += noise;
+ 	    *max_noise=Max(*max_noise,noise);
+ 	    count++;	    
+         }
+     }
+ 
+     if (count>1) *tot_noise /= count;
+     if (over>1) *over_noise /= over;
+ 
+     return over;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            amp_scalefac_bands                                         */
+ /*************************************************************************/
+ 
+ /* 
+   Amplify the scalefactor bands that violate the masking threshold.
+   See ISO 11172-3 Section C.1.5.4.3.5
+ */
+ void amp_scalefac_bands(FLOAT8 xrpow[576], 
+ 			gr_info *cod_info,
+ 			III_scalefac_t *scalefac,
+ 			FLOAT8 distort[4][SBPSY_l])
+ {
+     int start, end, l,i;
+ 	u_int	sfb;
+     FLOAT8 ifqstep34;
+     FLOAT8 distort_thresh;
+ 
+     if ( cod_info->scalefac_scale == 0 )
+ 	ifqstep34 = 1.29683955465100964055;
+     else
+ 	ifqstep34 = 1.68179283050742922612;
+ 
+     /* distort_thresh = 0, unless all bands have distortion 
+      * less than masking.  In that case, just amplify bands with distortion
+      * within 95% of largest distortion/masking ratio */
+     distort_thresh = -900;
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ ) {
+ 	distort_thresh = Max(distort[0][sfb],distort_thresh);
+     }
+ 
+     for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ ) {
+ 	for ( i = 0; i < 3; i++ ) {
+ 	    distort_thresh = Max(distort[i+1][sfb],distort_thresh);
+ 	}
+     }
+     distort_thresh=Min(distort_thresh * 1.05, 0.0);
+ 
+ 
+ 
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ ) {
+ 	if ( distort[0][sfb]>distort_thresh  ) {
+ 	    scalefac->l[sfb]++;
+ 	    start = scalefac_band.l[sfb];
+ 	    end   = scalefac_band.l[sfb+1];
+ 	    for ( l = start; l < end; l++ )
+ 		xrpow[l] *= ifqstep34;
+ 	}
+     }
+ 
+ 
+     for ( i = 0; i < 3; i++ ) {
+ 	for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ ) {
+             if ( distort[i+1][sfb]>distort_thresh) {
+                 scalefac->s[sfb][i]++;
+                 start = scalefac_band.s[sfb];
+                 end   = scalefac_band.s[sfb+1];
+ 		for (l = start; l < end; l++)
+ 		    xrpow[l * 3 + i] *= ifqstep34;
+             }
+ 	}
+     }
+ }
+ 
+ 
+ 
+ int quant_compare(int experimentalX,
+ int best_over,FLOAT8 best_tot_noise,FLOAT8 best_over_noise,FLOAT8 best_max_noise,
+ int over,FLOAT8 tot_noise, FLOAT8 over_noise, FLOAT8 max_noise)
+ {
+   /*
+     noise is given in decibals (db) relative to masking thesholds.
+ 
+     over_noise:  sum of quantization noise > masking
+     tot_noise:   sum of all quantization noise
+     max_noise:   max quantization noise 
+ 
+    */
+   int better=0;
+ 
+   if (experimentalX==0) {
+     better = ((over < best_over) ||
+ 	      ((over==best_over) && (over_noise<=best_over_noise)) ) ;
+   }
+ 
+   if (experimentalX==1) 
+     better = max_noise < best_max_noise;
+ 
+   if (experimentalX==2) {
+     better = tot_noise < best_tot_noise;
+   }
+   if (experimentalX==3) {
+     better = (tot_noise < best_tot_noise) &&
+       (max_noise < best_max_noise + 2);
+   }
+   if (experimentalX==4) {
+     better = ( ( (0>=max_noise) && (best_max_noise>2)) ||
+      ( (0>=max_noise) && (best_max_noise<0) && ((best_max_noise+2)>max_noise) && (tot_noise<best_tot_noise) ) ||
+      ( (0>=max_noise) && (best_max_noise>0) && ((best_max_noise+2)>max_noise) && (tot_noise<(best_tot_noise+best_over_noise)) ) ||
+      ( (0<max_noise) && (best_max_noise>-0.5) && ((best_max_noise+1)>max_noise) && ((tot_noise+over_noise)<(best_tot_noise+best_over_noise)) ) ||
+      ( (0<max_noise) && (best_max_noise>-1) && ((best_max_noise+1.5)>max_noise) && ((tot_noise+over_noise+over_noise)<(best_tot_noise+best_over_noise+best_over_noise)) ) );
+   }
+   if (experimentalX==5) {
+     better =   (over_noise <  best_over_noise)
+       || ((over_noise == best_over_noise)&&(tot_noise < best_tot_noise));
+   }
+   if (experimentalX==6) {
+     better = (over_noise < best_over_noise)
+            ||( (over_noise == best_over_noise)
+              &&( (max_noise < best_max_noise)
+                ||( (max_noise == best_max_noise)
+                  &&(tot_noise <= best_tot_noise)
+                  )
+                ) 
+ 	     );
+   }
+ 
+   return better;
+ }
+ 
+ 
+ int VBR_compare(
+ int best_over,FLOAT8 best_tot_noise,FLOAT8 best_over_noise,FLOAT8 best_max_noise,
+ int over,FLOAT8 tot_noise, FLOAT8 over_noise, FLOAT8 max_noise)
+ {
+   /*
+     noise is given in decibals (db) relative to masking thesholds.
+ 
+     over_noise:  sum of quantization noise > masking
+     tot_noise:   sum of all quantization noise
+     max_noise:   max quantization noise 
+ 
+    */
+   int better=0;
+ 
+   better = ((over <= best_over) &&
+ 	    (over_noise<=best_over_noise) &&
+ 	    (tot_noise<=best_tot_noise) &&
+ 	    (max_noise<=best_max_noise));
+   return better;
+ }
+   
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/quantize.h lame3.70/quantize.h
*** encoder/quantize.h	Wed Dec 31 17:00:00 1969
--- lame3.70/quantize.h	Thu Apr  6 12:50:51 2000
***************
*** 0 ****
--- 1,70 ----
+ /**********************************************************************
+  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
+  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
+  *
+  * $Id: quantize.h,v 1.5 2000/03/21 23:02:17 markt Exp $
+  *
+  * $Log: quantize.h,v $
+  * Revision 1.5  2000/03/21 23:02:17  markt
+  * replaced all "gf." by gfp->
+  *
+  * Revision 1.4  2000/03/14 21:01:47  markt
+  * removed fr_ps struct
+  *
+  * Revision 1.3  2000/02/01 14:09:14  takehiro
+  * code clean up. changed definition of structure to optimize array index calculation
+  *
+  * Revision 1.2  2000/02/01 11:26:32  takehiro
+  * scalefactor's structure changed
+  *
+  * Revision 1.1.1.1  1999/11/24 08:43:45  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
+  * Revision 1.1  1996/02/14 04:04:23  rowlands
+  * Initial revision
+  *
+  * Received from Mike Coleman
+  **********************************************************************/
+ 
+ #ifndef LOOP_DOT_H
+ #define LOOP_DOT_H
+ #include "util.h"
+ #include "l3side.h"
+ 
+ /**********************************************************************
+  *   date   programmers                comment                        *
+  * 25. 6.92  Toshiyuki Ishino          Ver 1.0                        *
+  * 29.10.92  Masahiro Iwadare          Ver 2.0                        *
+  * 17. 4.93  Masahiro Iwadare          Updated for IS Modification    *
+  *                                                                    *
+  *********************************************************************/
+ 
+ extern int cont_flag;
+ 
+ 
+ extern int pretab[];
+ 
+ void iteration_loop( lame_global_flags *gfp,
+                      FLOAT8 pe[2][2], FLOAT8 ms_ratio[2], 
+ 		     FLOAT8 xr_org[2][2][576], III_psy_ratio ratio[2][2],
+ 		     III_side_info_t *l3_side, int l3_enc[2][2][576], 
+ 		     III_scalefac_t scalefac[2][2]);
+ 
+ void VBR_iteration_loop( lame_global_flags *gfp,
+                      FLOAT8 pe[2][2], FLOAT8 ms_ratio[2], 
+ 		     FLOAT8 xr_org[2][2][576], III_psy_ratio ratio[2][2],
+ 		     III_side_info_t *l3_side, int l3_enc[2][2][576], 
+ 		     III_scalefac_t scalefac[2][2]);
+ 
+ 
+ 
+ 
+ #define maximum(A,B) ( (A) > (B) ? (A) : (B) )
+ #define minimum(A,B) ( (A) < (B) ? (A) : (B) )
+ #define signum( A ) ( (A) > 0 ? 1 : -1 )
+ 
+ 
+ extern int bit_buffer[50000];
+ 
+ #endif
diff -r -c -N encoder/reservoir.c lame3.70/reservoir.c
*** encoder/reservoir.c	Wed Jan 22 02:43:18 1997
--- lame3.70/reservoir.c	Thu Apr  6 12:50:51 2000
***************
*** 2,14 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
-  * $Id: reservoir.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: reservoir.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
   **********************************************************************/
  /*
    Revision History:
--- 2,7 ----
***************
*** 22,32 ****
  #include <stdlib.h>
  #include <math.h>
  #include <assert.h>
! #include "l3side.h"
! #include "loop.h"
! #include "huffman.h"
! #include "l3bitstream.h"
! #include "reservoir.h"
  
  /*
    Layer3 bit reservoir:
--- 15,25 ----
  #include <stdlib.h>
  #include <math.h>
  #include <assert.h>
! #include "util.h"
! #ifdef HAVEGTK
! #include "gtkanal.h"
! #endif
! 
  
  /*
    Layer3 bit reservoir:
***************
*** 38,63 ****
  
  /*
    ResvFrameBegin:
!   Called at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! void
! ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
!     layer *info;
!     int fullFrameBits, mode_gr;
!     int expectedResvSize, resvLimit;
  
!     info = fr_ps->header;
!     if ( info->version == 1 )
      {
- 	mode_gr = 2;
  	resvLimit = 4088; /* main_data_begin has 9 bits in MPEG 1 */
      }
      else
      {
- 	mode_gr = 1;
  	resvLimit = 2040; /* main_data_begin has 8 bits in MPEG 2 */
      }
  
--- 31,57 ----
  
  /*
    ResvFrameBegin:
!   Called (repeatedly) at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! int
! ResvFrameBegin(lame_global_flags *gfp,III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
!     int fullFrameBits;
!     int resvLimit;
  
!     if (gfp->frameNum==0) {
!       ResvSize=0;
!     }
! 
! 
!     if ( gfp->version == 1 )
      {
  	resvLimit = 4088; /* main_data_begin has 9 bits in MPEG 1 */
      }
      else
      {
  	resvLimit = 2040; /* main_data_begin has 8 bits in MPEG 2 */
      }
  
***************
*** 66,78 ****
        expected value for the next call -- this should
        agree with our reservoir size
      */
!     expectedResvSize = l3_side->main_data_begin * 8;
  #ifdef DEBUG
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
!     assert( expectedResvSize == ResvSize );
! 
!     fullFrameBits = mean_bits * mode_gr;
  
      /*
        determine maximum size of reservoir:
--- 60,72 ----
        expected value for the next call -- this should
        agree with our reservoir size
      */
! 
  #ifdef DEBUG
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
!     /* check expected resvsize */
!     assert( (l3_side->main_data_begin * 8) == ResvSize );
!     fullFrameBits = mean_bits * gfp->mode_gr + ResvSize;
  
      /*
        determine maximum size of reservoir:
***************
*** 82,87 ****
--- 76,83 ----
  	ResvMax = 0;
      else
  	ResvMax = 7680 - frameLength;
+     if (gfp->disable_reservoir) ResvMax=0;
+ 
  
      /*
        limit max size to resvLimit bits because
***************
*** 90,136 ****
        */
      if ( ResvMax > resvLimit )
  	ResvMax = resvLimit;
  }
  
  /*
!   ResvMaxBits:
!   Called at the beginning of each granule to get the max bit
!   allowance for the current granule based on reservoir size
!   and perceptual entropy.
  */
! int
! ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits )
  {
!     int more_bits, max_bits, add_bits, over_bits;
  
!     mean_bits /= fr_ps->stereo;
!     max_bits = mean_bits;
! 
!     if ( max_bits > 4095 )
! 	max_bits = 4095;
! 
!     if ( ResvMax == 0 )
! 	return max_bits;
! 
!     more_bits = *pe * 3.1 - mean_bits;
!     add_bits = 0;
!     if ( more_bits > 100 )
!     {
! 	int frac = (ResvSize * 6) / 10;
! 
! 	if ( frac < more_bits )
! 	    add_bits = frac;
! 	else
! 	    add_bits = more_bits;
!     }
!     over_bits = ResvSize - ((ResvMax * 8) / 10) - add_bits;
!     if ( over_bits > 0 )
! 	add_bits += over_bits;
! 
!     max_bits += add_bits;
!     if ( max_bits > 4095 )
! 	max_bits = 4095;
!     return max_bits;
  }
  
  /*
--- 86,133 ----
        */
      if ( ResvMax > resvLimit )
  	ResvMax = resvLimit;
+ 
+ #ifdef HAVEGTK
+   if (gfp->gtkflag){
+     pinfo->mean_bits=mean_bits/2;  /* expected bits per channel per granule */
+     pinfo->resvsize=ResvSize;
+   }
+ #endif
+ 
+     return fullFrameBits;
  }
  
+ 
  /*
!   ResvMaxBits2:
!   As above, but now it *really* is bits per granule (both channels).  
!   Mark Taylor 4/99
  */
! void ResvMaxBits(int mean_bits, int *targ_bits, int *extra_bits, int gr)
  {
!   int add_bits;
!   *targ_bits = mean_bits ;
!   /* extra bits if the reservoir is almost full */
!   if (ResvSize > ((ResvMax * 9) / 10)) {
!     add_bits= ResvSize-((ResvMax * 9) / 10);
!     *targ_bits += add_bits;
!   }else {
!     add_bits =0 ;
!     /* build up reservoir.  this builds the reservoir a little slower
!      * than FhG.  It could simple be mean_bits/15, but this was rigged
!      * to always produce 100 (the old value) at 128kbs */
!     *targ_bits -= (int) (mean_bits/15.2);
!   }
! 
!   
!   /* amount from the reservoir we are allowed to use. ISO says 6/10 */
!   *extra_bits =    
!     (ResvSize  < (ResvMax*6)/10  ? ResvSize : (ResvMax*6)/10);
!   *extra_bits -= add_bits;
!   
!   if (*extra_bits < 0) *extra_bits=0;
  
!   
  }
  
  /*
***************
*** 139,149 ****
    the reservoir to reflect the granule's usage.
  */
  void
! ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits )
  {
!     ResvSize += (mean_bits / fr_ps->stereo) - gi->part2_3_length;
  }
  
  /*
    ResvFrameEnd:
    Called after all granules in a frame have been allocated. Makes sure
--- 136,147 ----
    the reservoir to reflect the granule's usage.
  */
  void
! ResvAdjust(lame_global_flags *gfp,gr_info *gi, III_side_info_t *l3_side, int mean_bits )
  {
!     ResvSize += (mean_bits / gfp->stereo) - gi->part2_3_length;
  }
  
+ 
  /*
    ResvFrameEnd:
    Called after all granules in a frame have been allocated. Makes sure
***************
*** 153,182 ****
    appropriate stuffing bits to the bitstream.
  */
  void
! ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits )
  {
!     layer *info;
!     gr_info *gi;
!     int mode_gr, gr, ch, stereo, ancillary_pad, stuffingBits;
      int over_bits;
  
-     info   = fr_ps->header;
-     stereo = fr_ps->stereo;
-     mode_gr = (info->version == 1) ? 2 : 1;
-     ancillary_pad = 0;
- 
- #if 1
      /* just in case mean_bits is odd, this is necessary... */
!     if ( (stereo == 2) && (mean_bits & 1) )
  	ResvSize += 1;
- #endif
  
      over_bits = ResvSize - ResvMax;
      if ( over_bits < 0 )
  	over_bits = 0;
      
      ResvSize -= over_bits;
!     stuffingBits = over_bits + ancillary_pad;
  
      /* we must be byte aligned */
      if ( (over_bits = ResvSize % 8) )
--- 151,171 ----
    appropriate stuffing bits to the bitstream.
  */
  void
! ResvFrameEnd(lame_global_flags *gfp,III_side_info_t *l3_side, int mean_bits)
  {
!     int stuffingBits;
      int over_bits;
  
      /* just in case mean_bits is odd, this is necessary... */
!     if ( gfp->stereo == 2 && mean_bits & 1)
  	ResvSize += 1;
  
      over_bits = ResvSize - ResvMax;
      if ( over_bits < 0 )
  	over_bits = 0;
      
      ResvSize -= over_bits;
!     stuffingBits = over_bits;
  
      /* we must be byte aligned */
      if ( (over_bits = ResvSize % 8) )
***************
*** 185,228 ****
  	ResvSize -= over_bits;
      }
  
!     if ( stuffingBits )
!     {
! 	/*
! 	  plan a: put all into the first granule
! 	  This was preferred by someone designing a
! 	  real-time decoder...
! 	*/
! 	gi = (gr_info *) &(l3_side->gr[0].ch[0]);	
! 	
! 	if ( gi->part2_3_length + stuffingBits < 4095 )
! 	    gi->part2_3_length += stuffingBits;
! 	else
! 	{
! 	    /* plan b: distribute throughout the granules */
! 	    for (gr = 0; gr < mode_gr; gr++ )
! 		for (ch = 0; ch < stereo; ch++ )
! 		{
! 		    int extraBits, bitsThisGr;
! 		    gr_info *gi = (gr_info *) &(l3_side->gr[gr].ch[ch]);
! 		    if ( stuffingBits == 0 )
! 			break;
! 		    extraBits = 4095 - gi->part2_3_length;
! 		    bitsThisGr = extraBits < stuffingBits ? extraBits : stuffingBits;
! 		    gi->part2_3_length += bitsThisGr;
! 		    stuffingBits -= bitsThisGr;
! 		}
! 	    /*
! 	      If any stuffing bits remain, we elect to spill them
! 	      into ancillary data. The bitstream formatter will do this if
! 	      l3side->resvDrain is set
! 	    */
! #ifdef DEBUG
! 	    if ( stuffingBits )
! 		fprintf( stderr, "spilling %d stuffing bits into ancillary data\n", stuffingBits );
! #endif
! 	    l3_side->resvDrain = stuffingBits;
! 	}
!     }
  }
  
  
--- 174,183 ----
  	ResvSize -= over_bits;
      }
  
! 
!     l3_side->resvDrain = stuffingBits;
!     return;
! 
  }
  
  
diff -r -c -N encoder/reservoir.h lame3.70/reservoir.h
*** encoder/reservoir.h	Wed Jan 22 02:43:18 1997
--- lame3.70/reservoir.h	Tue Mar 21 16:02:17 2000
***************
*** 2,10 ****
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: reservoir.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
   *
   * $Log: reservoir.h,v $
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
--- 2,23 ----
   * ISO MPEG Audio Subgroup Software Simulation Group (1996)
   * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
   *
!  * $Id: reservoir.h,v 1.4 2000/03/21 23:02:17 markt Exp $
   *
   * $Log: reservoir.h,v $
+  * Revision 1.4  2000/03/21 23:02:17  markt
+  * replaced all "gf." by gfp->
+  *
+  * Revision 1.3  2000/03/14 21:01:47  markt
+  * removed fr_ps struct
+  *
+  * Revision 1.2  2000/01/13 16:26:50  takehiro
+  * moved info.stereo into gf.stereo
+  *
+  * Revision 1.1.1.1  1999/11/24 08:43:40  markt
+  * initial checkin of LAME
+  * Starting with LAME 3.57beta with some modifications
+  *
   * Revision 1.1  1996/02/14 04:04:23  rowlands
   * Initial revision
   *
***************
*** 22,30 ****
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! void ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength );
! int  ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits );
! void ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits );
! void ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits );
  
  #endif
--- 35,43 ----
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! int ResvFrameBegin( lame_global_flags *gfp,III_side_info_t *l3_side, int mean_bits, int frameLength );
! void ResvMaxBits( int mean_bits, int *targ_bits, int *max_bits, int gr);
! void ResvAdjust(lame_global_flags *gfp,gr_info *gi, III_side_info_t *l3_side, int mean_bits );
! void ResvFrameEnd(lame_global_flags *gfp,III_side_info_t *l3_side, int mean_bits );
  
  #endif
diff -r -c -N encoder/rtp.c lame3.70/rtp.c
*** encoder/rtp.c	Wed Dec 31 17:00:00 1969
--- lame3.70/rtp.c	Wed Jan 26 21:35:48 2000
***************
*** 0 ****
--- 1,102 ----
+ #include <stdlib.h>
+ #include <string.h>
+ #include <netinet/in.h>
+ #include <unistd.h>
+ #include <stdlib.h>
+ #include <stdio.h>
+ #include <sys/types.h>
+ #include <sys/socket.h>
+ #include <arpa/inet.h>
+ 
+ struct rtpbits {
+   int sequence:16;	/* sequence number: random */
+   int pt:7;	/* payload type: 14 for MPEG audio */
+   int m:1;	/* marker: 0 */
+   int cc:4;	/* number of CSRC identifiers: 0 */
+   int x:1;	/* number of extension headers: 0 */
+   int p:1;	/* is there padding appended: 0 */
+   int v:2;	/* version: 2 */
+ };
+ 
+ struct rtpheader {	/* in network byte order */
+   struct rtpbits b;
+   int timestamp;	/* start: random */
+   int ssrc;		/* random */
+   int iAudioHeader;	/* =0?! */
+ };
+ 
+ void initrtp(struct rtpheader *foo) {
+   foo->b.v=2;
+   foo->b.p=0;
+   foo->b.x=0;
+   foo->b.cc=0;
+   foo->b.m=0;
+   foo->b.pt=14;		/* MPEG Audio */
+ #ifdef FEFE
+   foo->b.sequence=42;
+   foo->timestamp=0;
+ #else
+   foo->b.sequence=rand() & 65535;
+   foo->timestamp=rand();
+ #endif
+   foo->ssrc=rand();
+   foo->iAudioHeader=0;
+ }
+ 
+ int sendrtp(int fd, struct sockaddr_in *sSockAddr, struct rtpheader *foo, void *data, int len) {
+   char *buf=alloca(len+sizeof(struct rtpheader));
+   int *cast=(int *)foo;
+   int *outcast=(int *)buf;
+   outcast[0]=htonl(cast[0]);
+   outcast[1]=htonl(cast[1]);
+   outcast[2]=htonl(cast[2]);
+   outcast[3]=htonl(cast[3]);
+   memmove(buf+sizeof(struct rtpheader),data,len);
+   return sendto(fd,buf,len+sizeof(*foo),0,(struct sockaddr *)sSockAddr,sizeof(*sSockAddr));
+ /*  return write(fd,buf,len+sizeof(*foo))==len+sizeof(*foo); */
+ }
+ 
+ /* create a sender socket. */
+ int makesocket(char *szAddr,unsigned short port,int TTL,struct sockaddr_in *sSockAddr) {
+   int          iRet, iLoop = 1;
+   struct       sockaddr_in sin;
+   char         cTtl = (char)TTL;
+   char         cLoop=0;
+   unsigned int tempaddr;
+ 
+   int iSocket = socket( AF_INET, SOCK_DGRAM, 0 );
+   if (iSocket < 0) {
+     fprintf(stderr,"socket() failed.\n");
+     exit(1);
+   }
+ 
+   tempaddr=inet_addr(szAddr);
+   sSockAddr->sin_family = sin.sin_family = AF_INET;
+   sSockAddr->sin_port = sin.sin_port = htons(port);
+   sSockAddr->sin_addr.s_addr = tempaddr;
+ 
+   iRet = setsockopt(iSocket, SOL_SOCKET, SO_REUSEADDR, &iLoop, sizeof(int));
+   if (iRet < 0) {
+     fprintf(stderr,"setsockopt SO_REUSEADDR failed\n");
+     exit(1);
+   }
+ 
+   if ((ntohl(tempaddr) >> 28) == 0xe) {
+     /* only set multicast parameters for multicast destination IPs */
+     iRet = setsockopt(iSocket, IPPROTO_IP, IP_MULTICAST_TTL, &cTtl, sizeof(char));
+     if (iRet < 0) {
+       fprintf(stderr,"setsockopt IP_MULTICAST_TTL failed.  multicast in kernel?\n");
+       exit(1);
+     }
+ 
+     cLoop = 1;	/* !? */
+     iRet = setsockopt(iSocket, IPPROTO_IP, IP_MULTICAST_LOOP,
+ 		      &cLoop, sizeof(char));
+     if (iRet < 0) {
+       fprintf(stderr,"setsockopt IP_MULTICAST_LOOP failed.  multicast in kernel?\n");
+       exit(1);
+     }
+   }
+ 
+   return iSocket;
+ }
diff -r -c -N encoder/rtp.h lame3.70/rtp.h
*** encoder/rtp.h	Wed Dec 31 17:00:00 1969
--- lame3.70/rtp.h	Tue Jan 25 10:48:23 2000
***************
*** 0 ****
--- 1,24 ----
+ #include <sys/socket.h>
+ #include <netinet/in.h>
+ 
+ struct rtpbits {
+   int sequence:16;	/* sequence number: random */
+   int pt:7;	/* payload type: 14 for MPEG audio */
+   int m:1;	/* marker: 0 */
+   int cc:4;	/* number of CSRC identifiers: 0 */
+   int x:1;	/* number of extension headers: 0 */
+   int p:1;	/* is there padding appended: 0 */
+   int v:2;	/* version: 2 */
+ };
+ 
+ struct rtpheader {      /* in network byte order */
+   struct rtpbits b;
+   int timestamp;        /* start: random */
+   int ssrc;             /* random */
+   int iAudioHeader;	/* =0?! */
+ };
+ 
+ void initrtp(struct rtpheader *foo);
+ int sendrtp(int fd, struct sockaddr_in *sSockAddr, struct rtpheader *foo, void *data, int len);
+ int makesocket(char *szAddr,unsigned short port,int TTL,struct sockaddr_in *sSockAddr);
+ void rtp_output(char *mp3buffer,int mp3size);
diff -r -c -N encoder/subs.c lame3.70/subs.c
*** encoder/subs.c	Wed Jan 22 02:43:18 1997
--- lame3.70/subs.c	Wed Dec 31 17:00:00 1969
***************
*** 1,163 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: subs.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: subs.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos from Macintosh        *
-  *                              Replacement of one float with FLOAT   *
-  * 2/11/92  W. Joseph Carter    Added type casting to memset() args.  *
-  * 4/27/92  Masahiro Iwadare    Added 256 point version for Layer III *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- 
- /*****************************************************************************
-  ************************** Start of Subroutines *****************************
-  *****************************************************************************/
- 
- /*****************************************************************************
-  * FFT computes fast fourier transform of BLKSIZE samples of data            *
-  *   uses decimation-in-frequency algorithm described in "Digital            *
-  *   Signal Processing" by Oppenheim and Schafer, refer to pages 304         *
-  *   (flow graph) and 330-332 (Fortran program in problem 5)                 *
-  *   to get the inverse fft, change line 20 from                             *
-  *                 w_imag[L] = -sin(PI/le1);                                 *
-  *                          to                                               *
-  *                 w_imag[L] = sin(PI/le1);                                  *
-  *                                                                           *
-  *   required constants:                                                     *
-  *         #define      PI          3.14159265358979                         *
-  *         #define      BLKSIZE     1024                                     *
-  *         #define      LOGBLKSIZE  10                                       *
-  *         #define      BLKSIZE_S   256                                      *
-  *         #define      LOGBLKSIZE_S 8                                       *
-  *                                                                           *
-  *****************************************************************************/
- #define      BLKSIZE_S   256
- #define      LOGBLKSIZE_S 8
- 
- void fft(x_real,x_imag, energy, phi, N)
- FLOAT x_real[BLKSIZE], x_imag[BLKSIZE], energy[BLKSIZE], phi[BLKSIZE];
- int	N;
- {
-  int     M,MM1;
-  static int     init=0;
-  int     NV2, NM1, MP;
-  static double  w_real[2][LOGBLKSIZE], w_imag[2][LOGBLKSIZE];
-  int            i,j,k,L;
-  int            ip, le,le1;
-  double         t_real, t_imag, u_real, u_imag;
- 
-  if(init==0) {
-     memset((char *) w_real, 0, sizeof(w_real));  /* preset statics to 0 */
-     memset((char *) w_imag, 0, sizeof(w_imag));  /* preset statics to 0 */
-     M = LOGBLKSIZE;
-     for(L=0; L<M; L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_real[0][L] = cos(PI/le1);
-        w_imag[0][L] = -sin(PI/le1);
-     }          
-     M = LOGBLKSIZE_S;
-     for(L=0; L<M; L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_real[1][L] = cos(PI/le1);
-        w_imag[1][L] = -sin(PI/le1);
-     }          
-     init++;
-  }
-  switch(N) {
- 	case BLKSIZE:
- 			M = LOGBLKSIZE;
- 			MP = 0;
- 			break;
- 	case BLKSIZE_S:
- 			M = LOGBLKSIZE_S;
- 			MP = 1;
- 			break;
- 	default:	printf("Error: Bad FFT Size in subs.c\n");
- 			exit(-1);
-  }
-  MM1 = M-1;
-  NV2 = N >> 1;
-  NM1 = N - 1;
-  for(L=0; L<MM1; L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_real = 1;
-     u_imag = 0;
-     for(j=0; j<le1; j++){
-        for(i=j; i<N; i+=le){
-           ip = i + le1;
-           t_real = x_real[i] + x_real[ip];
-           t_imag = x_imag[i] + x_imag[ip];
-           x_real[ip] = x_real[i] - x_real[ip];
-           x_imag[ip] = x_imag[i] - x_imag[ip];
-           x_real[i] = t_real;
-           x_imag[i] = t_imag;
-           t_real = x_real[ip];
-           x_real[ip] = x_real[ip]*u_real - x_imag[ip]*u_imag;
-           x_imag[ip] = x_imag[ip]*u_real + t_real*u_imag;
-        }
-        t_real = u_real;
-        u_real = u_real*w_real[MP][L] - u_imag*w_imag[MP][L];
-        u_imag = u_imag*w_real[MP][L] + t_real*w_imag[MP][L];
-     }
-  }
-  /* special case: L = M-1; all Wn = 1 */
-  for(i=0; i<N; i+=2){
-     ip = i + 1;
-     t_real = x_real[i] + x_real[ip];
-     t_imag = x_imag[i] + x_imag[ip];
-     x_real[ip] = x_real[i] - x_real[ip];
-     x_imag[ip] = x_imag[i] - x_imag[ip];
-     x_real[i] = t_real;
-     x_imag[i] = t_imag;
-     energy[i] = x_real[i]*x_real[i] + x_imag[i]*x_imag[i];
-     if(energy[i] <= 0.0005){phi[i] = 0;energy[i] = 0.0005;}
-     else phi[i] = atan2((double) x_imag[i],(double) x_real[i]);
-     energy[ip] = x_real[ip]*x_real[ip] + x_imag[ip]*x_imag[ip];
-     if(energy[ip] == 0)phi[ip] = 0;
-     else phi[ip] = atan2((double) x_imag[ip],(double) x_real[ip]);
-  }
-  /* this section reorders the data to the correct ordering */
-  j = 0;
-  for(i=0; i<NM1; i++){
-     if(i<j){
- /* use this section only if you need the FFT in complex number form *
-  * (and in the correct ordering)                                    */
-        t_real = x_real[j];
-        t_imag = x_imag[j];
-        x_real[j] = x_real[i];
-        x_imag[j] = x_imag[i];
-        x_real[i] = t_real;
-        x_imag[i] = t_imag;
- /* reorder the energy and phase, phi                                        */
-        t_real = energy[j];
-        energy[j] = energy[i];
-        energy[i] = t_real;
-        t_real = phi[j];
-        phi[j] = phi[i];
-        phi[i] = t_real;
-     }
-     k=NV2;
-     while(k<=j){
-        j = j-k;
-        k = k >> 1;
-     }
-     j = j+k;
-  }
- }
--- 0 ----
diff -r -c -N encoder/tables.c lame3.70/tables.c
*** encoder/tables.c	Wed Dec 31 17:00:00 1969
--- lame3.70/tables.c	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,1215 ----
+ #include "util.h"
+ #include "tables.h"
+ 
+ /*
+   Here are MPEG1 Table B.8 and MPEG2 Table B.1
+   -- Layer III scalefactor bands. 
+   Index into this using a method such as:
+     idx  = fr_ps->header->sampling_frequency
+            + (fr_ps->header->version * 3)
+ */
+ 
+ 
+ 
+ 
+ unsigned int hs = sizeof(HUFFBITS)*8;
+ 
+ static HUFFBITS      t1HB[]   = {
+   1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  1, 0}; 
+ 
+ static HUFFBITS      t2HB[]   = {
+   1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 2, 0};
+ 
+ static HUFFBITS      t3HB[]   = {
+   3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 2, 0};
+ 
+ static HUFFBITS      t5HB[]   = {
+   1, 2, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 5, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 1, 1, 0};
+ 
+ static HUFFBITS      t6HB[]   = {
+   7, 3, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 2, 0};
+ 
+ static HUFFBITS      t7HB[]   = {
+    1, 2,10,19,16,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    3, 3, 7,10, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   11, 4,13,17, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   12,11,18,15,11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    7, 6, 9,14, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    6, 4, 5, 3, 2, 0};
+ 
+ static HUFFBITS      t8HB[]   = {
+   3, 4, 6, 18,12, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 1, 2, 16, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 3, 5, 14, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  19,17,15, 13,10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  13, 5, 8, 11, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  12, 4, 4,  1, 1, 0};
+ 
+ static HUFFBITS      t9HB[]   = {
+   7, 5, 9, 14, 15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 4, 5,  5,  6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 6, 8,  8,  8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  15, 6, 9, 10,  5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  11, 7, 9,  6,  4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  14, 4, 6,  2,  6, 0};
+ 
+ static HUFFBITS      t10HB[]   = {
+   1, 2, 10, 23, 35, 30, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3,  8, 12, 18, 21, 12,  7, 0, 0, 0, 0, 0, 0, 0, 0,
+  11, 9, 15, 21, 32, 40, 19,  6, 0, 0, 0, 0, 0, 0, 0, 0,
+  14,13, 22, 34, 46, 23, 18,  7, 0, 0, 0, 0, 0, 0, 0, 0,
+  20,19, 33, 47, 27, 22,  9,  3, 0, 0, 0, 0, 0, 0, 0, 0,
+  31,22, 41, 26, 21, 20,  5,  3, 0, 0, 0, 0, 0, 0, 0, 0,
+  14,13, 10, 11, 16,  6,  5,  1, 0, 0, 0, 0, 0, 0, 0, 0,
+   9, 8,  7,  8,  4,  4,  2,  0};
+ 
+ static HUFFBITS      t11HB[]   = {
+   3, 4, 10, 24, 34, 33, 21, 15, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 3,  4, 10, 32, 17, 11, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+  11, 7, 13, 18, 30, 31, 20,  5, 0, 0, 0, 0, 0, 0, 0, 0,
+  25,11, 19, 59, 27, 18, 12,  5, 0, 0, 0, 0, 0, 0, 0, 0,
+  35,33, 31, 58, 30, 16,  7,  5, 0, 0, 0, 0, 0, 0, 0, 0,
+  28,26, 32, 19, 17, 15,  8, 14, 0, 0, 0, 0, 0, 0, 0, 0,
+  14,12,  9, 13, 14,  9,  4,  1, 0, 0, 0, 0, 0, 0, 0, 0,
+  11, 4,  6,  6,  6,  3,  2,  0};
+ 
+ static HUFFBITS      t12HB[]   = {
+   9,  6, 16, 33, 41, 39, 38,26, 0, 0, 0, 0, 0, 0, 0, 0,
+   7,  5,  6,  9, 23, 16, 26,11, 0, 0, 0, 0, 0, 0, 0, 0,
+  17,  7, 11, 14, 21, 30, 10, 7, 0, 0, 0, 0, 0, 0, 0, 0,
+  17, 10, 15, 12, 18, 28, 14, 5, 0, 0, 0, 0, 0, 0, 0, 0,
+  32, 13, 22, 19, 18, 16,  9, 5, 0, 0, 0, 0, 0, 0, 0, 0,
+  40, 17, 31, 29, 17, 13,  4, 2, 0, 0, 0, 0, 0, 0, 0, 0,
+  27, 12, 11, 15, 10,  7,  4, 1, 0, 0, 0, 0, 0, 0, 0, 0,
+  27, 12,  8, 12,  6,  3,  1, 0};
+ 
+ static HUFFBITS      t13HB[]   = {
+   1,  5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19,
+   3,  4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14,
+  15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16,
+  22, 20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14,
+  35, 16, 60, 57, 97, 75,114, 91, 54, 73, 55, 41, 48, 53, 23, 24,
+  58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17,
+  47, 45, 78, 74,115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15,
+  72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42,
+  43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16,
+  53, 25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11,
+  35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22,
+  53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14,  9,  7,
+  34, 32, 28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17,  9,  5,
+  45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10,  7,  6,  3,
+  48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10,  6,  1,  4,  2,
+  16, 15, 17, 27, 25, 20, 29, 11, 17, 12, 16,  8,  1,  1,  0,  1};
+ 
+ static HUFFBITS      t15HB[]   = {
+    7, 12, 18, 53, 47, 76,124,108, 89,123,108,119,107, 81,122, 63,
+   13,  5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36,
+   19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 33,
+   29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29,
+   52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27,
+   77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,
+  125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30,
+  109, 53, 49, 94, 88, 75, 66,122, 91, 73, 56, 42, 64, 44, 21, 25,
+   90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,
+   71, 34, 67, 60, 58, 49, 88, 76, 67,106, 71, 54, 38, 39, 23, 15,
+  109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62,  9,
+   86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11, 
+  118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14,  7,
+   91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14,  8,  9,  3,
+  123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10,  2,  1,
+   71, 37, 34, 30, 28, 20, 17, 26, 21, 16, 10,  6,  8,  6,  2,  0};
+ 
+ static HUFFBITS      t16HB[]   = {
+    1,   5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17,
+    3,   4, 12, 20, 35, 62,  53, 47,  83,  75,  68, 119, 201, 107, 207,  9,
+   15,  13, 23, 38, 67, 58, 103, 90, 161,  72, 127, 117, 110, 209, 206, 16,
+   45,  21, 39, 69, 64,114,  99, 87, 158, 140, 252, 212, 199, 387, 365, 26,
+   75,  36, 68, 65,115,101, 179,164, 155, 264, 246, 226, 395, 382, 362,  9,
+   66,  30, 59, 56,102,185, 173,265, 142, 253, 232, 400, 388, 378, 445, 16,
+  111,  54, 52,100,184,178, 160,133, 257, 244, 228, 217, 385, 366, 715, 10,
+   98,  48, 91, 88,165,157, 148,261, 248, 407, 397, 372, 380, 889, 884,  8,
+   85,  84, 81,159,156,143, 260,249, 427, 401, 392, 383, 727, 713, 708,  7,
+  154,  76, 73,141,131,256, 245,426, 406, 394, 384, 735, 359, 710, 352, 11,
+  139, 129, 67,125,247,233, 229,219, 393, 743, 737, 720, 885, 882, 439,  4,
+  243, 120,118,115,227,223, 396,746, 742, 736, 721, 712, 706, 223, 436,  6,
+  202, 224,222,218,216,389, 386,381, 364, 888, 443, 707, 440, 437,1728,  4,
+  747, 211,210,208,370, 379,734,723, 714,1735, 883, 877, 876,3459, 865,  2,
+  377, 369,102,187, 726,722,358,711, 709, 866,1734, 871,3458, 870, 434,  0,
+   12,  10,  7, 11,  10, 17, 11,  9,  13,  12,  10,   7,   5,   3,   1,  3};
+ 
+ static HUFFBITS      t24HB[]   = {
+    15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88,
+    14, 12, 21, 38,  71, 130, 122, 216, 209, 198, 327, 345, 319, 297,  279, 42,
+    47, 22, 41, 74,  68, 128, 120, 221, 207, 194, 182, 340, 315, 295,  541, 18,
+    81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293,  271, 16,
+   147, 72, 69,135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285,  540, 14,
+   263, 66,129,126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281,  262, 12,
+   249,123,121,117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272,  520, 10,
+   435,115,111,109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531,  381, 17,
+   427,212,208,205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514,  377, 16,
+   335,199,197,191, 189, 181, 174, 333, 321, 305, 289, 275, 521, 379,  371, 11,
+   668,184,183,179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373,  366, 10,
+   652,346,171,168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 368,  362,  6,
+   648,322,316,312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364,  359,  4,
+   620,300,296,294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361,  357,  2,
+  1033,280,278,274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358,  356,  0,
+    43, 20, 19, 17,  15,  13,  11,   9,   7,   6,   4,   7,   5,   3,    1,  3};
+ 
+ static HUFFBITS      t32HB[]   = {
+   1, 5, 4, 5, 6, 5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1};
+ static HUFFBITS      t33HB[]   = {
+   15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
+ 
+ static unsigned char t1l[]  = {
+   1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   2, 3};
+ 
+ static unsigned char t2l[]  = {
+   1, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 5, 6};
+ 
+ static unsigned char t3l[]  = {
+   2, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 5, 6};
+ 
+ static unsigned char t5l[]  = {
+   1, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 6, 7, 8};
+ 
+ static unsigned char t6l[]  = {
+   3, 3, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 2, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   4, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 5, 6, 7};
+ 
+ static unsigned char t7l[]  = {
+   1, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 4, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 5, 7, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 7, 8, 9, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 9,10,10,10};
+ 
+ static unsigned char t8l[]  = {
+   2, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 2, 4, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 4, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 8, 9, 9,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 8, 9,10,10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   9, 8, 9, 9,11,11};
+ 
+ static unsigned char t9l[]  = {
+   3, 3, 5, 6, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 4, 5, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   4, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 5, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 6, 7, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 8, 8, 9, 9};
+ 
+ static unsigned char t10l[]  = {
+   1, 3, 6, 8, 9, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 4, 6, 7, 8, 9, 8,  8, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 6, 7, 8, 9,10, 9,  9, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 7, 8, 9,10,10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 9,10,10,10,10, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+   9, 9,10,10,11,11,10, 11, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 9,10,10,10,11, 11, 0, 0, 0, 0, 0, 0, 0, 0,
+   9, 8, 9,10,10,11,11, 11};
+ 
+ static unsigned char t11l[]  = {
+   2, 3, 5, 7, 8,  9,  8,  9, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 4, 6, 8,  8,  7,  8, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 5, 6, 7, 8,  9,  8,  8, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 6, 7, 9, 8, 10,  8,  9, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 8, 9, 9, 10,  9, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 8, 9,10,10, 11, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 7, 8, 9, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 8, 9,10, 10, 10, 10};
+ 
+ static unsigned char t12l[]  = {
+   4, 3, 5, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,
+   3, 3, 4, 5, 7, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
+   5, 4, 5, 6, 7, 8, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0,
+   6, 5, 6, 6, 7, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0,
+   7, 6, 7, 7, 8, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 8, 8, 8, 9, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0,
+   8, 7, 7, 8, 8, 9, 9,10, 0, 0, 0, 0, 0, 0, 0, 0,
+   9, 8, 8, 9, 9, 9, 9,10};
+ 
+ static unsigned char t13l[]  = {
+   1,  4,  6,  7,  8,  9,  9, 10,  9, 10, 11, 11, 12, 12, 13, 13,
+   3,  4,  6,  7,  8,  8,  9,  9,  9,  9, 10, 10, 11, 12, 12, 12,
+   6,  6,  7,  8,  9,  9, 10, 10,  9, 10, 10, 11, 11, 12, 13, 13,
+   7,  7,  8,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13,
+   8,  7,  9,  9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14,
+   9,  8,  9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14,
+   9,  9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14,
+  10,  9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16,
+   9,  8,  9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15,
+  10,  9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15,
+  10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17,
+  11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16,
+  11, 11, 11, 12, 12, 13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16,
+  12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16,
+  13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16,
+  12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}; 
+ 
+ static unsigned char t15l[]  = {
+   3,  4,  5,  7,  7,  8,  9,  9,  9, 10, 10, 11, 11, 11, 12, 13,
+   4,  3,  5,  6,  7,  7,  8,  8,  8,  9,  9, 10, 10, 10, 11, 11,
+   5,  5,  5,  6,  7,  7,  8,  8,  8,  9,  9, 10, 10, 11, 11, 11,
+   6,  6,  6,  7,  7,  8,  8,  9,  9,  9, 10, 10, 10, 11, 11, 11,
+   7,  6,  7,  7,  8,  8,  9,  9,  9,  9, 10, 10, 10, 11, 11, 11,
+   8,  7,  7,  8,  8,  8,  9,  9,  9,  9, 10, 10, 11, 11, 11, 12,
+   9,  7,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 11, 11, 12, 12,
+   9,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11, 11, 12,
+   9,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11, 12, 12, 12,
+   9,  8,  9,  9,  9,  9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12,
+  10,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12,
+  10,  9,  9,  9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13,
+  11, 10,  9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13,
+  11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13,
+  12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13,
+  12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13};
+ 
+ static unsigned char t16l[]  = {
+   1,  4,  6,  8,  9,  9, 10, 10, 11, 11, 11, 12, 12, 12, 13,  9,
+   3,  4,  6,  7,  8,  9,  9,  9, 10, 10, 10, 11, 12, 11, 12,  8,
+   6,  6,  7,  8,  9,  9, 10, 10, 11, 10, 11, 11, 11, 12, 12,  9,
+   8,  7,  8,  9,  9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13, 10,
+   9,  8,  9,  9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13,  9,
+   9,  8,  9,  9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10,
+  10,  9,  9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10,
+  10,  9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10,
+  10, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10,
+  11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11,
+  11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10,
+  12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11,
+  12, 12, 12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11,
+  14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11,
+  13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11,
+   9,  8,  8,  9,  9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8};
+ 
+ static unsigned char t24l[]  = {
+   4,  4,  6,  7,  8,  9,  9, 10, 10, 11, 11, 11, 11, 11, 12,  9,
+   4,  4,  5,  6,  7,  8,  8,  9,  9,  9, 10, 10, 10, 10, 10,  8,
+   6,  5,  6,  7,  7,  8,  8,  9,  9,  9,  9, 10, 10, 10, 11,  7,
+   7,  6,  7,  7,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10,  7,
+   8,  7,  7,  8,  8,  8,  8,  9,  9,  9, 10, 10, 10, 10, 11,  7,
+   9,  7,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10,  7,
+   9,  8,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11,  7,
+  10,  8,  8,  8,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11,  8,
+  10,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 11, 11,  8,
+  10,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 11, 11, 11,  8,
+  11,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11,  8,
+  11, 10,  9,  9,  9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11,  8,
+  11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11,  8,
+  11, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11,  8,
+  12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11,  8,
+   8,  7,  7,  7,  7,  7,  7,  7,  7,  7,  7,  8,  8,  8,  8,  4};
+ 
+ static unsigned char t32l[]  = {
+   1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6};
+ static unsigned char t33l[]  = {
+   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4};
+ 
+ struct huffcodetab ht[HTN] =
+ {
+   /* xlen, linmax, table, hlen */
+   { 0,   0,NULL,NULL},
+   { 2,   0,t1HB, t1l},
+   { 3,   0,t2HB, t2l},
+   { 3,   0,t3HB, t3l},
+   { 0,   0,NULL,NULL},/* Apparently not used */
+   { 4,   0,t5HB, t5l},
+   { 4,   0,t6HB, t6l},
+   { 6,   0,t7HB, t7l},
+   { 6,   0,t8HB, t8l},
+   { 6,   0,t9HB, t9l},
+   { 8,   0,t10HB, t10l},
+   { 8,   0,t11HB, t11l},
+   { 8,   0,t12HB, t12l},
+   {16,   0,t13HB, t13l},
+   { 0,   0,NULL,NULL},/* Apparently not used */
+   {16,   0,t15HB, t15l},
+ 
+   { 1,   1,t16HB, t16l},
+   { 2,   3,t16HB, t16l},
+   { 3,   7,t16HB, t16l},
+   { 4,  15,t16HB, t16l},
+   { 6,  63,t16HB, t16l},
+   { 8, 255,t16HB, t16l},
+   {10,1023,t16HB, t16l},
+   {13,8191,t16HB, t16l},
+ 
+   { 4,  15,t24HB, t24l},
+   { 5,  31,t24HB, t24l},
+   { 6,  63,t24HB, t24l},
+   { 7, 127,t24HB, t24l},
+   { 8, 255,t24HB, t24l},
+   { 9, 511,t24HB, t24l},
+   {11,2047,t24HB, t24l},
+   {13,8191,t24HB, t24l},
+ 
+   { 0,   0,t32HB, t32l},
+   { 0,   0,t33HB, t33l},
+ };	
+ 
+ 
+ 
+ 
+ 
+ FLOAT8 psy_data[] =
+ {48000.0, 61,
+  0, 1, 24.5, 4.532, 0.970, 0.000,
+  1, 1, 24.5, 4.532, 0.755, 0.469,
+  2, 1, 24.5, 4.532, 0.738, 0.938,
+  3, 1, 24.5, 0.904, 0.730, 1.406,
+  4, 1, 24.5, 0.904, 0.724, 1.875,
+  5, 1, 20.0, 0.090, 0.723, 2.344,
+  6, 1, 20.0, 0.090, 0.723, 2.813,
+  7, 1, 20.0, 0.029, 0.723, 3.281,
+  8, 1, 20.0, 0.029, 0.718, 3.750,
+  9, 1, 20.0, 0.009, 0.690, 4.199,
+  10, 1, 20.0, 0.009, 0.660, 4.625,
+  11, 1, 18.0, 0.009, 0.641, 5.047,
+  12, 1, 18.0, 0.009, 0.600, 5.438,
+  13, 1, 18.0, 0.009, 0.584, 5.828,
+  14, 1, 12.0, 0.009, 0.532, 6.188,
+  15, 1, 12.0, 0.009, 0.537, 6.522,
+  16, 2, 6.0, 0.018, 0.857, 7.174,
+  17, 2, 6.0, 0.018, 0.858, 7.801,
+  18, 2, 3.0, 0.018, 0.853, 8.402,
+  19, 2, 3.0, 0.018, 0.824, 8.966,
+  20, 2, 3.0, 0.018, 0.778, 9.484,
+  21, 2, 3.0, 0.018, 0.740, 9.966,
+  22, 2, 0.0, 0.018, 0.709, 10.426,
+  23, 2, 0.0, 0.018, 0.676, 10.866,
+  24, 2, 0.0, 0.018, 0.632, 11.279,
+  25, 2, 0.0, 0.018, 0.592, 11.669,
+  26, 2, 0.0, 0.018, 0.553, 12.042,
+  27, 2, 0.0, 0.018, 0.510, 12.386,
+  28, 2, 0.0, 0.018, 0.513, 12.721,
+  29, 3, 0.0, 0.027, 0.608, 13.115,
+  30, 3, 0.0, 0.027, 0.673, 13.562,
+  31, 3, 0.0, 0.027, 0.637, 13.984,
+  32, 3, 0.0, 0.027, 0.586, 14.371,
+  33, 3, 0.0, 0.027, 0.571, 14.741,
+  34, 4, 0.0, 0.036, 0.616, 15.140,
+  35, 4, 0.0, 0.036, 0.640, 15.563,
+  36, 4, 0.0, 0.036, 0.598, 15.962,
+  37, 4, 0.0, 0.036, 0.538, 16.324,
+  38, 4, 0.0, 0.036, 0.512, 16.665,
+  39, 5, 0.0, 0.045, 0.528, 17.020,
+  40, 5, 0.0, 0.045, 0.517, 17.373,
+  41, 5, 0.0, 0.045, 0.493, 17.708,
+  42, 6, 0.0, 0.054, 0.499, 18.045,
+  43, 7, 0.0, 0.063, 0.525, 18.398,
+  44, 7, 0.0, 0.063, 0.541, 18.762,
+  45, 8, 0.0, 0.072, 0.528, 19.120,
+  46, 8, 0.0, 0.072, 0.510, 19.466,
+  47, 8, 0.0, 0.072, 0.506, 19.807,
+  48, 10, 0.0, 0.180, 0.525, 20.159,
+  49, 10, 0.0, 0.180, 0.536, 20.522,
+  50, 10, 0.0, 0.180, 0.518, 20.874,
+  51, 13, 0.0, 0.372, 0.501, 21.214,
+  52, 13, 0.0, 0.372, 0.497, 21.553,
+  53, 14, 0.0, 0.400, 0.497, 21.892,
+  54, 18, 0.0, 1.627, 0.495, 22.231,
+  55, 18, 0.0, 1.627, 0.494, 22.569,
+  56, 20, 0.0, 1.808, 0.497, 22.909,
+  57, 25, 0.0, 22.607, 0.494, 23.248,
+  58, 25, 0.0, 22.607, 0.487, 23.583,
+  59, 35, 0.0, 31.650, 0.483, 23.915,
+  60, 67, 0.0, 605.867, 0.482, 24.246,
+  61, 67, 0.0, 605.867, 0.524, 24.576,
+  44100.0, 62,
+  0, 1, 24.5, 4.532, 0.951, 0.000,
+  1, 1, 24.5, 4.532, 0.700, 0.431,
+  2, 1, 24.5, 4.532, 0.681, 0.861,
+  3, 1, 24.5, 0.904, 0.675, 1.292,
+  4, 1, 24.5, 0.904, 0.667, 1.723,
+  5, 1, 20.0, 0.090, 0.665, 2.153,
+  6, 1, 20.0, 0.090, 0.664, 2.584,
+  7, 1, 20.0, 0.029, 0.664, 3.015,
+  8, 1, 20.0, 0.029, 0.664, 3.445,
+  9, 1, 20.0, 0.029, 0.655, 3.876,
+  10, 1, 20.0, 0.009, 0.616, 4.279,
+  11, 1, 20.0, 0.009, 0.597, 4.670,
+  12, 1, 18.0, 0.009, 0.578, 5.057,
+  13, 1, 18.0, 0.009, 0.541, 5.416,
+  14, 1, 18.0, 0.009, 0.575, 5.774,
+  15, 2, 12.0, 0.018, 0.856, 6.422,
+  16, 2, 6.0, 0.018, 0.846, 7.026,
+  17, 2, 6.0, 0.018, 0.840, 7.609,
+  18, 2, 3.0, 0.018, 0.822, 8.168,
+  19, 2, 3.0, 0.018, 0.800, 8.710,
+  20, 2, 3.0, 0.018, 0.753, 9.207,
+  21, 2, 3.0, 0.018, 0.704, 9.662,
+  22, 2, 0.0, 0.018, 0.674, 10.099,
+  23, 2, 0.0, 0.018, 0.640, 10.515,
+  24, 2, 0.0, 0.018, 0.609, 10.917,
+  25, 2, 0.0, 0.018, 0.566, 11.293,
+  26, 2, 0.0, 0.018, 0.535, 11.652,
+  27, 2, 0.0, 0.018, 0.531, 11.997,
+  28, 3, 0.0, 0.027, 0.615, 12.394,
+  29, 3, 0.0, 0.027, 0.686, 12.850,
+  30, 3, 0.0, 0.027, 0.650, 13.277,
+  31, 3, 0.0, 0.027, 0.612, 13.681,
+  32, 3, 0.0, 0.027, 0.567, 14.062,
+  33, 3, 0.0, 0.027, 0.520, 14.411,
+  34, 3, 0.0, 0.027, 0.513, 14.751,
+  35, 4, 0.0, 0.036, 0.557, 15.119,
+  36, 4, 0.0, 0.036, 0.584, 15.508,
+  37, 4, 0.0, 0.036, 0.570, 15.883,
+  38, 5, 0.0, 0.045, 0.579, 16.263,
+  39, 5, 0.0, 0.045, 0.585, 16.654,
+  40, 5, 0.0, 0.045, 0.548, 17.020,
+  41, 6, 0.0, 0.054, 0.536, 17.374,
+  42, 6, 0.0, 0.054, 0.550, 17.744,
+  43, 7, 0.0, 0.063, 0.532, 18.104,
+  44, 7, 0.0, 0.063, 0.504, 18.447,
+  45, 7, 0.0, 0.063, 0.496, 18.782,
+  46, 9, 0.0, 0.081, 0.517, 19.130,
+  47, 9, 0.0, 0.081, 0.527, 19.487,
+  48, 9, 0.0, 0.081, 0.516, 19.838,
+  49, 10, 0.0, 0.180, 0.497, 20.179,
+  50, 10, 0.0, 0.180, 0.489, 20.510,
+  51, 11, 0.0, 0.198, 0.502, 20.852,
+  52, 14, 0.0, 0.400, 0.501, 21.196,
+  53, 14, 0.0, 0.400, 0.491, 21.531,
+  54, 15, 0.0, 0.429, 0.497, 21.870,
+  55, 20, 0.0, 1.808, 0.504, 22.214,
+  56, 20, 0.0, 1.808, 0.504, 22.558,
+  57, 21, 0.0, 1.898, 0.495, 22.898,
+  58, 27, 0.0, 24.416, 0.486, 23.232,
+  59, 27, 0.0, 24.416, 0.484, 23.564,
+  60, 36, 0.0, 32.554, 0.483, 23.897,
+  61, 73, 0.0, 660.124, 0.475, 24.229,
+  62, 18, 0.0, 162.770, 0.515, 24.442,
+  32000.0, 58,
+  0, 2, 24.5, 4.532, 0.997, 0.313,
+  1, 2, 24.5, 4.532, 0.893, 0.938,
+  2, 2, 24.5, 1.809, 0.881, 1.563,
+  3, 2, 20.0, 0.181, 0.873, 2.188,
+  4, 2, 20.0, 0.181, 0.872, 2.813,
+  5, 2, 20.0, 0.057, 0.871, 3.438,
+  6, 2, 20.0, 0.018, 0.860, 4.045,
+  7, 2, 20.0, 0.018, 0.839, 4.625,
+  8, 2, 18.0, 0.018, 0.812, 5.173,
+  9, 2, 18.0, 0.018, 0.784, 5.698,
+  10, 2, 12.0, 0.018, 0.741, 6.185,
+  11, 2, 12.0, 0.018, 0.697, 6.634,
+  12, 2, 6.0, 0.018, 0.674, 7.070,
+  13, 2, 6.0, 0.018, 0.651, 7.492,
+  14, 2, 6.0, 0.018, 0.633, 7.905,
+  15, 2, 3.0, 0.018, 0.611, 8.305,
+  16, 2, 3.0, 0.018, 0.589, 8.695,
+  17, 2, 3.0, 0.018, 0.575, 9.064,
+  18, 3, 3.0, 0.027, 0.654, 9.484,
+  19, 3, 3.0, 0.027, 0.724, 9.966,
+  20, 3, 0.0, 0.027, 0.701, 10.426,
+  21, 3, 0.0, 0.027, 0.673, 10.866,
+  22, 3, 0.0, 0.027, 0.631, 11.279,
+  23, 3, 0.0, 0.027, 0.592, 11.669,
+  24, 3, 0.0, 0.027, 0.553, 12.042,
+  25, 3, 0.0, 0.027, 0.510, 12.386,
+  26, 3, 0.0, 0.027, 0.506, 12.721,
+  27, 4, 0.0, 0.036, 0.562, 13.091,
+  28, 4, 0.0, 0.036, 0.598, 13.488,
+  29, 4, 0.0, 0.036, 0.589, 13.873,
+  30, 5, 0.0, 0.045, 0.607, 14.268,
+  31, 5, 0.0, 0.045, 0.620, 14.679,
+  32, 5, 0.0, 0.045, 0.580, 15.067,
+  33, 5, 0.0, 0.045, 0.532, 15.424,
+  34, 5, 0.0, 0.045, 0.517, 15.771,
+  35, 6, 0.0, 0.054, 0.517, 16.120,
+  36, 6, 0.0, 0.054, 0.509, 16.466,
+  37, 6, 0.0, 0.054, 0.506, 16.807,
+  38, 8, 0.0, 0.072, 0.522, 17.158,
+  39, 8, 0.0, 0.072, 0.531, 17.518,
+  40, 8, 0.0, 0.072, 0.519, 17.869,
+  41, 10, 0.0, 0.090, 0.512, 18.215,
+  42, 10, 0.0, 0.090, 0.509, 18.563,
+  43, 10, 0.0, 0.090, 0.498, 18.902,
+  44, 12, 0.0, 0.109, 0.494, 19.239,
+  45, 12, 0.0, 0.109, 0.501, 19.580,
+  46, 13, 0.0, 0.118, 0.508, 19.925,
+  47, 14, 0.0, 0.252, 0.502, 20.269,
+  48, 14, 0.0, 0.252, 0.493, 20.606,
+  49, 16, 0.0, 0.288, 0.497, 20.944,
+  50, 20, 0.0, 0.572, 0.506, 21.288,
+  51, 20, 0.0, 0.572, 0.510, 21.635,
+  52, 23, 0.0, 0.658, 0.504, 21.980,
+  53, 27, 0.0, 2.441, 0.496, 22.319,
+  54, 27, 0.0, 2.441, 0.493, 22.656,
+  55, 32, 0.0, 2.893, 0.490, 22.993,
+  56, 37, 0.0, 33.458, 0.482, 23.326,
+  57, 37, 0.0, 33.458, 0.458, 23.656,
+  58, 12, 0.0, 10.851, 0.500, 23.937,
+  24000, 59,
+  0, 2, 15, 17.8250179, 0.697374165, 0.236874461,
+  1, 2, 15, 17.8250179, 0.455024809, 0.71016103,
+  2, 2, 15, 1.78250182, 0.431440443, 1.18193281,
+  3, 2, 15, 1.78250182, 0.42391625, 1.65102732,
+  4, 2, 13, 0.178250194, 0.418206781, 2.11632562,
+  5, 2, 13, 0.178250194, 0.41158545, 2.57676744,
+  6, 2, 13, 0.0563676581, 0.405409157, 3.03136396,
+  7, 2, 13, 0.0563676581, 0.399695486, 3.47920918,
+  8, 2, 13, 0.0563676581, 0.393753231, 3.91948748,
+  9, 2, 12, 0.0178250186, 0.387357473, 4.35147953,
+  10, 2, 12, 0.0178250186, 0.38045457, 4.77456427,
+  11, 2, 10, 0.0178250186, 0.373053908, 5.18822002,
+  12, 2, 10, 0.0178250186, 0.365188122, 5.59202194,
+  13, 2, 10, 0.0178250186, 0.356897771, 5.98564005,
+  14, 2, 9, 0.0178250186, 0.348700613, 6.36883163,
+  15, 2, 9, 0.0178250186, 0.340260029, 6.74143791,
+  16, 2, 6, 0.0178250186, 0.332341045, 7.10337448,
+  17, 2, 6, 0.0178250186, 0.330462843, 7.45462418,
+  18, 2, 6, 0.0178250186, 0.345568359, 7.79523182,
+  19, 3, 3, 0.0267375279, 0.377859652, 8.20455742,
+  20, 3, 3, 0.0267375279, 0.396689415, 8.67640114,
+  21, 3, 3, 0.0267375279, 0.391237885, 9.12561035,
+  22, 3, 3, 0.0267375279, 0.37761277, 9.55298138,
+  23, 3, 3, 0.0267375279, 0.362836808, 9.95940971,
+  24, 3, 0, 0.0267375279, 0.349010617, 10.3458519,
+  25, 3, 0, 0.0267375279, 0.339673489, 10.7132998,
+  26, 3, 0, 0.0267375279, 0.343845725, 11.0627575,
+  27, 4, 0, 0.0356500372, 0.355822682, 11.447506,
+  28, 4, 0, 0.0356500372, 0.358104348, 11.8627586,
+  29, 4, 0, 0.0356500372, 0.34745428, 12.2520256,
+  30, 4, 0, 0.0356500372, 0.334927917, 12.6173973,
+  31, 4, 0, 0.0356500372, 0.331643254, 12.9608269,
+  32, 5, 0, 0.0445625484, 0.333368897, 13.3219252,
+  33, 5, 0, 0.0445625484, 0.332313001, 13.6976833,
+  34, 5, 0, 0.0445625484, 0.3314417, 14.047802,
+  35, 6, 0, 0.0534750558, 0.330947191, 14.405302,
+  36, 6, 0, 0.0534750558, 0.332477689, 14.7684803,
+  37, 7, 0, 0.062387567, 0.332647532, 15.1315956,
+  38, 7, 0, 0.062387567, 0.330841452, 15.4940481,
+  39, 8, 0, 0.0713000745, 0.327769846, 15.8516159,
+  40, 8, 0, 0.0713000745, 0.324572712, 16.204628,
+  41, 9, 0, 0.0802125856, 0.323825002, 16.5502281,
+  42, 10, 0, 0.0891250968, 0.321414798, 16.9067478,
+  43, 10, 0, 0.0891250968, 0.318189293, 17.2537231,
+  44, 11, 0, 0.0980376005, 0.315934151, 17.5901108,
+  45, 12, 0, 0.106950112, 0.315639287, 17.931406,
+  46, 13, 0, 0.115862623, 0.316569835, 18.2750721,
+  47, 14, 0, 0.124775134, 0.31656, 18.6191597,
+  48, 15, 0, 0.133687645, 0.315465957, 18.9621754,
+  49, 16, 0, 0.142600149, 0.313576341, 19.3029613,
+  50, 17, 0, 0.151512653, 0.311635971, 19.6405869,
+  51, 18, 0, 0.160425171, 0.311066717, 19.9742699,
+  52, 20, 0, 0.355655879, 0.311465651, 20.3115921,
+  53, 21, 0, 0.373438686, 0.311872005, 20.6507797,
+  54, 23, 0, 0.409004271, 0.311015964, 20.9890823,
+  55, 24, 0, 0.676411927, 0.309207708, 21.3251152,
+  56, 26, 0, 0.732779562, 0.3081128, 21.6565971,
+  57, 28, 0, 0.789147198, 0.310006589, 21.9881554,
+  58, 31, 0, 2.76287794, 0.327113092, 22.3222847,
+  59, 34, 0, 3.03025317, 0.416082352, 22.6605186,
+  22050, 59,
+  0, 2, 15, 17.8250179, 0.658683598, 0.217637643,
+  1, 2, 15, 17.8250179, 0.432554901, 0.652563453,
+  2, 2, 15, 1.78250182, 0.405113578, 1.08633137,
+  3, 2, 15, 1.78250182, 0.397231787, 1.51803517,
+  4, 2, 15, 1.78250182, 0.392088681, 1.94679713,
+  5, 2, 13, 0.178250194, 0.386788279, 2.37177849,
+  6, 2, 13, 0.178250194, 0.380574644, 2.79218864,
+  7, 2, 13, 0.0563676581, 0.375309765, 3.20729256,
+  8, 2, 13, 0.0563676581, 0.370087624, 3.61641645,
+  9, 2, 12, 0.0178250186, 0.364568561, 4.01895428,
+  10, 2, 12, 0.0178250186, 0.358959526, 4.4143672,
+  11, 2, 12, 0.0178250186, 0.352938265, 4.80218887,
+  12, 2, 10, 0.0178250186, 0.3465029, 5.18202305,
+  13, 2, 10, 0.0178250186, 0.33968094, 5.55354261,
+  14, 2, 10, 0.0178250186, 0.332571507, 5.91648674,
+  15, 2, 9, 0.0178250186, 0.326015651, 6.27065945,
+  16, 2, 9, 0.0178250186, 0.325442046, 6.61592293,
+  17, 2, 9, 0.0178250186, 0.341315031, 6.95219517,
+  18, 3, 6, 0.0267375279, 0.374984443, 7.3584404,
+  19, 3, 6, 0.0267375279, 0.396138102, 7.8290925,
+  20, 3, 3, 0.0267375279, 0.39271906, 8.27975655,
+  21, 3, 3, 0.0267375279, 0.380755007, 8.71083069,
+  22, 3, 3, 0.0267375279, 0.367386311, 9.12284088,
+  23, 3, 3, 0.0267375279, 0.354351997, 9.51640987,
+  24, 3, 3, 0.0267375279, 0.341508389, 9.89222908,
+  25, 3, 0, 0.0267375279, 0.333577901, 10.2510386,
+  26, 3, 0, 0.0267375279, 0.338108748, 10.5936022,
+  27, 4, 0, 0.0356500372, 0.350744486, 10.9723492,
+  28, 4, 0, 0.0356500372, 0.354519457, 11.38272,
+  29, 4, 0, 0.0356500372, 0.345274031, 11.7689981,
+  30, 4, 0, 0.0356500372, 0.333828837, 12.1329184,
+  31, 4, 0, 0.0356500372, 0.331436664, 12.4761295,
+  32, 5, 0, 0.0445625484, 0.334172577, 12.8381901,
+  33, 5, 0, 0.0445625484, 0.334024847, 13.2160273,
+  34, 5, 0, 0.0445625484, 0.33392629, 13.5690479,
+  35, 6, 0, 0.0534750558, 0.334218502, 13.9303951,
+  36, 6, 0, 0.0534750558, 0.336405039, 14.298193,
+  37, 7, 0, 0.062387567, 0.337080389, 14.666563,
+  38, 7, 0, 0.062387567, 0.335603535, 15.0346909,
+  39, 8, 0, 0.0713000745, 0.332515866, 15.398139,
+  40, 8, 0, 0.0713000745, 0.327727586, 15.7570457,
+  41, 9, 0, 0.0802125856, 0.322346836, 16.1083431,
+  42, 9, 0, 0.0802125856, 0.317575186, 16.4528522,
+  43, 10, 0, 0.0891250968, 0.31632933, 16.7886105,
+  44, 11, 0, 0.0980376005, 0.317602783, 17.132,
+  45, 12, 0, 0.106950112, 0.319945186, 17.4796028,
+  46, 13, 0, 0.115862623, 0.320881754, 17.8287659,
+  47, 14, 0, 0.124775134, 0.320346534, 18.1774921,
+  48, 15, 0, 0.133687645, 0.318628669, 18.5243168,
+  49, 16, 0, 0.142600149, 0.316125751, 18.8681736,
+  50, 17, 0, 0.151512653, 0.313746184, 19.2082729,
+  51, 18, 0, 0.160425171, 0.312971771, 19.5440025,
+  52, 20, 0, 0.178250194, 0.313278913, 19.8831882,
+  53, 21, 0, 0.373438686, 0.313735574, 20.224247,
+  54, 23, 0, 0.409004271, 0.31308493, 20.5646286,
+  55, 24, 0, 0.426787049, 0.31156227, 20.903141,
+  56, 26, 0, 0.732779562, 0.310435742, 21.2376747,
+  57, 28, 0, 0.789147198, 0.31132248, 21.5730591,
+  58, 30, 0, 0.845514894, 0.32730341, 21.9066811,
+  59, 33, 0, 2.94112802, 0.414659739, 22.2411156,
+  16000, 55,
+  0, 3, 15, 26.7375278, 0.697374165, 0.236874461,
+  1, 3, 15, 26.7375278, 0.455024809, 0.71016103,
+  2, 3, 15, 2.67375278, 0.431440443, 1.18193281,
+  3, 3, 15, 2.67375278, 0.42391625, 1.65102732,
+  4, 3, 13, 0.26737529, 0.418206781, 2.11632562,
+  5, 3, 13, 0.26737529, 0.41158545, 2.57676744,
+  6, 3, 13, 0.0845514908, 0.405409157, 3.03136396,
+  7, 3, 13, 0.0845514908, 0.399695486, 3.47920918,
+  8, 3, 13, 0.0845514908, 0.393753231, 3.91948748,
+  9, 3, 12, 0.0267375279, 0.387357473, 4.35147953,
+  10, 3, 12, 0.0267375279, 0.38045457, 4.77456427,
+  11, 3, 10, 0.0267375279, 0.373053908, 5.18822002,
+  12, 3, 10, 0.0267375279, 0.365188122, 5.59202194,
+  13, 3, 10, 0.0267375279, 0.356897742, 5.98564005,
+  14, 3, 9, 0.0267375279, 0.34869957, 6.36883163,
+  15, 3, 9, 0.0267375279, 0.340241522, 6.74143791,
+  16, 3, 6, 0.0267375279, 0.332089454, 7.10337448,
+  17, 3, 6, 0.0267375279, 0.328292668, 7.45462418,
+  18, 3, 6, 0.0267375279, 0.336574793, 7.79523182,
+  19, 4, 3, 0.0356500372, 0.354600489, 8.17827797,
+  20, 4, 3, 0.0356500372, 0.364343345, 8.59994984,
+  21, 4, 3, 0.0356500372, 0.359369367, 9.00363636,
+  22, 4, 3, 0.0356500372, 0.347775847, 9.38988018,
+  23, 4, 3, 0.0356500372, 0.335562587, 9.7592926,
+  24, 4, 0, 0.0356500372, 0.326988578, 10.1125278,
+  25, 4, 0, 0.0356500372, 0.327966213, 10.4502735,
+  26, 5, 0, 0.0445625484, 0.334450752, 10.811614,
+  27, 5, 0, 0.0445625484, 0.335228145, 11.1935263,
+  28, 5, 0, 0.0445625484, 0.329595625, 11.5549288,
+  29, 5, 0, 0.0445625484, 0.326683223, 11.8971443,
+  30, 6, 0, 0.0534750558, 0.326986551, 12.2520256,
+  31, 6, 0, 0.0534750558, 0.325072199, 12.6173973,
+  32, 6, 0, 0.0534750558, 0.323560268, 12.9608269,
+  33, 7, 0, 0.062387567, 0.322494298, 13.3093863,
+  34, 7, 0, 0.062387567, 0.323403448, 13.6617231,
+  35, 8, 0, 0.0713000745, 0.323232353, 14.0134668,
+  36, 8, 0, 0.0713000745, 0.322662383, 14.3639784,
+  37, 9, 0, 0.0802125856, 0.324054241, 14.7098465,
+  38, 10, 0, 0.0891250968, 0.323228806, 15.0686541,
+  39, 10, 0, 0.0891250968, 0.320751846, 15.4191036,
+  40, 11, 0, 0.0980376005, 0.318823338, 15.7594051,
+  41, 12, 0, 0.106950112, 0.318418682, 16.104557,
+  42, 13, 0, 0.115862623, 0.318762124, 16.451416,
+  43, 14, 0, 0.124775134, 0.317806393, 16.7975388,
+  44, 15, 0, 0.133687645, 0.315653771, 17.1411018,
+  45, 16, 0, 0.142600149, 0.313369036, 17.4808159,
+  46, 17, 0, 0.151512653, 0.312513858, 17.8158207,
+  47, 19, 0, 0.169337675, 0.312785119, 18.1543369,
+  48, 20, 0, 0.178250194, 0.31343773, 18.4948578,
+  49, 22, 0, 0.196075201, 0.313258767, 18.8350143,
+  50, 23, 0, 0.20498772, 0.312570423, 19.1740704,
+  51, 25, 0, 0.222812727, 0.312572777, 19.5104179,
+  52, 27, 0, 0.240637749, 0.313047856, 19.8497677,
+  53, 29, 0, 0.515701056, 0.315029174, 20.1900635,
+  54, 31, 0, 0.551266611, 0.330613613, 20.5294952,
+  55, 33, 0, 0.586832225, 0.41819948, 20.8664398,
+  48000.0, 37,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.989, -8.240, 1.875,
+  2, 1, 0.029, 0.989, -8.240, 3.750,
+  3, 1, 0.009, 0.981, -8.240, 5.438,
+  4, 1, 0.009, 0.985, -8.240, 6.857,
+  5, 1, 0.009, 0.984, -8.240, 8.109,
+  6, 1, 0.009, 0.980, -8.240, 9.237,
+  7, 1, 0.009, 0.968, -8.240, 10.202,
+  8, 1, 0.009, 0.954, -8.240, 11.083,
+  9, 1, 0.009, 0.929, -8.240, 11.865,
+  10, 1, 0.009, 0.906, -7.447, 12.554,
+  11, 1, 0.009, 0.883, -7.447, 13.195,
+  12, 1, 0.009, 0.844, -7.447, 13.781,
+  13, 1, 0.009, 0.792, -7.447, 14.309,
+  14, 1, 0.009, 0.747, -7.447, 14.803,
+  15, 1, 0.009, 0.689, -7.447, 15.250,
+  16, 1, 0.009, 0.644, -7.447, 15.667,
+  17, 1, 0.009, 0.592, -7.447, 16.068,
+  18, 1, 0.009, 0.553, -7.447, 16.409,
+  19, 2, 0.018, 0.850, -7.447, 17.045,
+  20, 2, 0.018, 0.811, -6.990, 17.607,
+  21, 2, 0.018, 0.736, -6.990, 18.097,
+  22, 2, 0.018, 0.665, -6.990, 18.528,
+  23, 2, 0.018, 0.610, -6.990, 18.931,
+  24, 2, 0.018, 0.544, -6.990, 19.295,
+  25, 2, 0.018, 0.528, -6.990, 19.636,
+  26, 3, 0.054, 0.621, -6.990, 20.038,
+  27, 3, 0.054, 0.673, -6.990, 20.486,
+  28, 3, 0.054, 0.635, -6.990, 20.900,
+  29, 4, 0.114, 0.626, -6.990, 21.306,
+  30, 4, 0.114, 0.636, -6.020, 21.722,
+  31, 5, 0.452, 0.615, -6.020, 22.128,
+  32, 5, 0.452, 0.579, -6.020, 22.513,
+  33, 5, 0.452, 0.551, -6.020, 22.877,
+  34, 7, 6.330, 0.552, -5.229, 23.241,
+  35, 7, 6.330, 0.559, -5.229, 23.616,
+  36, 11, 9.947, 0.528, -5.229, 23.974,
+  37, 17, 153.727, 0.479, -5.229, 24.313,
+  44100.0, 38,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.983, -8.240, 1.723,
+  2, 1, 0.029, 0.983, -8.240, 3.445,
+  3, 1, 0.009, 0.982, -8.240, 5.057,
+  4, 1, 0.009, 0.985, -8.240, 6.422,
+  5, 1, 0.009, 0.983, -8.240, 7.609,
+  6, 1, 0.009, 0.978, -8.240, 8.710,
+  7, 1, 0.009, 0.967, -8.240, 9.662,
+  8, 1, 0.009, 0.948, -8.240, 10.515,
+  9, 1, 0.009, 0.930, -8.240, 11.293,
+  10, 1, 0.009, 0.914, -7.447, 12.009,
+  11, 1, 0.009, 0.870, -7.447, 12.625,
+  12, 1, 0.009, 0.845, -7.447, 13.210,
+  13, 1, 0.009, 0.800, -7.447, 13.748,
+  14, 1, 0.009, 0.749, -7.447, 14.241,
+  15, 1, 0.009, 0.701, -7.447, 14.695,
+  16, 1, 0.009, 0.653, -7.447, 15.125,
+  17, 1, 0.009, 0.590, -7.447, 15.508,
+  18, 1, 0.009, 0.616, -7.447, 15.891,
+  19, 2, 0.018, 0.860, -7.447, 16.537,
+  20, 2, 0.018, 0.823, -6.990, 17.112,
+  21, 2, 0.018, 0.762, -6.990, 17.621,
+  22, 2, 0.018, 0.688, -6.990, 18.073,
+  23, 2, 0.018, 0.612, -6.990, 18.470,
+  24, 2, 0.018, 0.594, -6.990, 18.849,
+  25, 3, 0.027, 0.658, -6.990, 19.271,
+  26, 3, 0.027, 0.706, -6.990, 19.741,
+  27, 3, 0.054, 0.660, -6.990, 20.177,
+  28, 3, 0.054, 0.606, -6.990, 20.576,
+  29, 3, 0.054, 0.565, -6.990, 20.950,
+  30, 4, 0.114, 0.560, -6.020, 21.316,
+  31, 4, 0.114, 0.579, -6.020, 21.699,
+  32, 5, 0.452, 0.567, -6.020, 22.078,
+  33, 5, 0.452, 0.534, -6.020, 22.438,
+  34, 5, 0.452, 0.514, -5.229, 22.782,
+  35, 7, 6.330, 0.520, -5.229, 23.133,
+  36, 7, 6.330, 0.518, -5.229, 23.484,
+  37, 7, 6.330, 0.507, -5.229, 23.828,
+  38, 19, 171.813, 0.447, -4.559, 24.173,
+  32000.0, 41,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.985, -8.240, 1.250,
+  2, 1, 0.090, 0.983, -8.240, 2.500,
+  3, 1, 0.029, 0.983, -8.240, 3.750,
+  4, 1, 0.009, 0.981, -8.240, 4.909,
+  5, 1, 0.009, 0.975, -8.240, 5.958,
+  6, 1, 0.009, 0.959, -8.240, 6.857,
+  7, 1, 0.009, 0.944, -8.240, 7.700,
+  8, 1, 0.009, 0.933, -8.240, 8.500,
+  9, 1, 0.009, 0.920, -8.240, 9.237,
+  10, 1, 0.009, 0.892, -7.447, 9.895,
+  11, 1, 0.009, 0.863, -7.447, 10.500,
+  12, 1, 0.009, 0.839, -7.447, 11.083,
+  13, 1, 0.009, 0.786, -7.447, 11.604,
+  14, 1, 0.009, 0.755, -7.447, 12.107,
+  15, 1, 0.009, 0.698, -7.447, 12.554,
+  16, 1, 0.009, 0.673, -7.447, 13.000,
+  17, 1, 0.009, 0.605, -7.447, 13.391,
+  18, 1, 0.009, 0.629, -7.447, 13.781,
+  19, 2, 0.018, 0.883, -7.447, 14.474,
+  20, 2, 0.018, 0.858, -6.990, 15.096,
+  21, 2, 0.018, 0.829, -6.990, 15.667,
+  22, 2, 0.018, 0.767, -6.990, 16.177,
+  23, 2, 0.018, 0.705, -6.990, 16.636,
+  24, 2, 0.018, 0.637, -6.990, 17.057,
+  25, 2, 0.018, 0.564, -6.990, 17.429,
+  26, 2, 0.018, 0.550, -6.990, 17.786,
+  27, 3, 0.027, 0.603, -6.990, 18.177,
+  28, 3, 0.027, 0.635, -6.990, 18.597,
+  29, 3, 0.027, 0.592, -6.990, 18.994,
+  30, 3, 0.027, 0.533, -6.020, 19.352,
+  31, 3, 0.027, 0.518, -6.020, 19.693,
+  32, 4, 0.072, 0.568, -6.020, 20.066,
+  33, 4, 0.072, 0.594, -6.020, 20.462,
+  34, 4, 0.072, 0.568, -5.229, 20.841,
+  35, 5, 0.143, 0.536, -5.229, 21.201,
+  36, 5, 0.143, 0.522, -5.229, 21.549,
+  37, 6, 0.172, 0.542, -5.229, 21.911,
+  38, 7, 0.633, 0.539, -4.559, 22.275,
+  39, 7, 0.633, 0.519, -4.559, 22.625,
+  40, 8, 0.723, 0.514, -3.980, 22.971,
+  41, 10, 9.043, 0.518, -3.980, 23.321,
+  24000, 44,
+  0, 1, 8.91250896, 0.971850038, 0.150000006, 0,
+  1, 1, 8.91250896, 0.874727964, 0.150000006, 0.946573138,
+  2, 1, 0.891250908, 0.85779953, 0.150000006, 1.88476217,
+  3, 1, 0.0891250968, 0.839743853, 0.150000006, 2.8056457,
+  4, 1, 0.028183829, 0.82260257, 0.150000006, 3.70133615,
+  5, 1, 0.00891250931, 0.80018574, 0.150000006, 4.56532001,
+  6, 1, 0.00891250931, 0.771475196, 0.150000006, 5.39263105,
+  7, 1, 0.00891250931, 0.737389982, 0.150000006, 6.17986727,
+  8, 1, 0.00891250931, 0.701111019, 0.150000006, 6.92507982,
+  9, 1, 0.00891250931, 0.65977633, 0.150000006, 7.62757969,
+  10, 1, 0.00891250931, 0.615037441, 0.150000006, 8.28770351,
+  11, 1, 0.00891250931, 0.568658054, 0.150000006, 8.90657234,
+  12, 1, 0.00891250931, 0.522260666, 0.180000007, 9.48587132,
+  13, 1, 0.00891250931, 0.478903115, 0.180000007, 10.0276566,
+  14, 1, 0.00891250931, 0.43808648, 0.180000007, 10.5341988,
+  15, 1, 0.00891250931, 0.412505627, 0.180000007, 11.0078659,
+  16, 1, 0.00891250931, 0.39070797, 0.180000007, 11.4510288,
+  17, 1, 0.00891250931, 0.371887118, 0.180000007, 11.866004,
+  18, 1, 0.00891250931, 0.367617637, 0.180000007, 12.2550087,
+  19, 1, 0.00891250931, 0.422220588, 0.180000007, 12.6201363,
+  20, 2, 0.0178250186, 0.564990044, 0.180000007, 13.2772083,
+  21, 2, 0.0178250186, 0.519700944, 0.180000007, 13.871047,
+  22, 2, 0.0178250186, 0.455360681, 0.200000003, 14.4024391,
+  23, 2, 0.0178250186, 0.408867925, 0.200000003, 14.8811684,
+  24, 2, 0.0178250186, 0.381538749, 0.200000003, 15.3153324,
+  25, 2, 0.0178250186, 0.362357527, 0.200000003, 15.7116165,
+  26, 2, 0.0178250186, 0.365735918, 0.200000003, 16.0755405,
+  27, 3, 0.0267375279, 0.38064, 0.200000003, 16.4882088,
+  28, 3, 0.0267375279, 0.379183382, 0.200000003, 16.9410992,
+  29, 3, 0.0267375279, 0.360672712, 0.200000003, 17.3513336,
+  30, 3, 0.0267375279, 0.343065977, 0.200000003, 17.7264423,
+  31, 3, 0.0267375279, 0.339290261, 0.200000003, 18.0722466,
+  32, 4, 0.0356500372, 0.342963994, 0.200000003, 18.4426575,
+  33, 4, 0.0356500372, 0.343128443, 0.200000003, 18.8344078,
+  34, 4, 0.0356500372, 0.343988508, 0.25, 19.1955795,
+  35, 5, 0.0445625484, 0.343928397, 0.25, 19.5697021,
+  36, 5, 0.0445625484, 0.339527696, 0.25, 19.9551182,
+  37, 5, 0.0889139697, 0.336541563, 0.280000001, 20.3115921,
+  38, 6, 0.106696762, 0.334955156, 0.280000001, 20.6737747,
+  39, 6, 0.169102982, 0.335601568, 0.300000012, 21.0404968,
+  40, 7, 0.1972868, 0.334716886, 0.300000012, 21.4060211,
+  41, 7, 0.1972868, 0.331676662, 0.300000012, 21.7696877,
+  42, 8, 0.713000774, 0.328550965, 0.400000006, 22.1267223,
+  43, 8, 0.713000774, 0.339241952, 0.400000006, 22.4769249,
+  44, 9, 0.802125871, 0.425207615, 0.400000006, 22.8164864,
+  22050, 44,
+  0, 1, 8.91250896, 0.954045713, 0.150000006, 0,
+  1, 1, 8.91250896, 0.833381653, 0.150000006, 0.869851649,
+  2, 1, 0.891250908, 0.815945923, 0.150000006, 1.73325908,
+  3, 1, 0.0891250968, 0.794244766, 0.150000006, 2.58322191,
+  4, 1, 0.028183829, 0.776486695, 0.150000006, 3.4134295,
+  5, 1, 0.00891250931, 0.755260408, 0.150000006, 4.21850443,
+  6, 1, 0.00891250931, 0.731070817, 0.150000006, 4.99414825,
+  7, 1, 0.00891250931, 0.701775849, 0.150000006, 5.73718691,
+  8, 1, 0.00891250931, 0.667876124, 0.150000006, 6.44553185,
+  9, 1, 0.00891250931, 0.630284071, 0.150000006, 7.11807632,
+  10, 1, 0.00891250931, 0.590170324, 0.150000006, 7.75455618,
+  11, 1, 0.00891250931, 0.548788548, 0.150000006, 8.3553915,
+  12, 1, 0.00891250931, 0.507795513, 0.150000006, 8.92152882,
+  13, 1, 0.00891250931, 0.469515711, 0.180000007, 9.45430183,
+  14, 1, 0.00891250931, 0.432291716, 0.180000007, 9.95530319,
+  15, 1, 0.00891250931, 0.411131173, 0.180000007, 10.4262848,
+  16, 1, 0.00891250931, 0.390771538, 0.180000007, 10.8690758,
+  17, 1, 0.00891250931, 0.373318017, 0.180000007, 11.2855215,
+  18, 1, 0.00891250931, 0.36956048, 0.180000007, 11.6774378,
+  19, 1, 0.00891250931, 0.42595759, 0.180000007, 12.0465794,
+  20, 2, 0.0178250186, 0.576900065, 0.180000007, 12.7141209,
+  21, 2, 0.0178250186, 0.533114731, 0.180000007, 13.3197365,
+  22, 2, 0.0178250186, 0.469967514, 0.180000007, 13.8634901,
+  23, 2, 0.0178250186, 0.417268544, 0.200000003, 14.3544445,
+  24, 2, 0.0178250186, 0.389299124, 0.200000003, 14.8002586,
+  25, 2, 0.0178250186, 0.362824857, 0.200000003, 15.2073727,
+  26, 2, 0.0178250186, 0.346801281, 0.200000003, 15.5811834,
+  27, 2, 0.0178250186, 0.349400043, 0.200000003, 15.926218,
+  28, 3, 0.0267375279, 0.364026934, 0.200000003, 16.3194923,
+  29, 3, 0.0267375279, 0.36560446, 0.200000003, 16.752903,
+  30, 3, 0.0267375279, 0.354275256, 0.200000003, 17.1470814,
+  31, 3, 0.0267375279, 0.351219416, 0.200000003, 17.5086212,
+  32, 4, 0.0356500372, 0.354364097, 0.200000003, 17.8938141,
+  33, 4, 0.0356500372, 0.348915905, 0.200000003, 18.2992878,
+  34, 4, 0.0356500372, 0.337649345, 0.200000003, 18.6713982,
+  35, 4, 0.0356500372, 0.332076877, 0.25, 19.015646,
+  36, 5, 0.0445625484, 0.330793113, 0.25, 19.3734016,
+  37, 5, 0.0445625484, 0.327528268, 0.25, 19.7430382,
+  38, 5, 0.0889139697, 0.32551071, 0.280000001, 20.0859604,
+  39, 6, 0.106696762, 0.324436843, 0.280000001, 20.4354992,
+  40, 6, 0.106696762, 0.325835049, 0.280000001, 20.7905579,
+  41, 7, 0.1972868, 0.326221824, 0.300000012, 21.1458054,
+  42, 7, 0.1972868, 0.325960994, 0.300000012, 21.5005951,
+  43, 8, 0.225470632, 0.339019388, 0.300000012, 21.8504524,
+  44, 8, 0.713000774, 0.426850349, 0.400000006, 22.1951065,
+  16000, 45,
+  0, 1, 8.91250896, 0.834739447, 0.150000006, 0,
+  1, 1, 8.91250896, 0.623757005, 0.150000006, 0.631518543,
+  2, 1, 0.891250908, 0.60420388, 0.150000006, 1.2606914,
+  3, 1, 0.891250908, 0.591974258, 0.150000006, 1.88476217,
+  4, 1, 0.0891250968, 0.575301588, 0.150000006, 2.50111985,
+  5, 1, 0.028183829, 0.561547697, 0.150000006, 3.1073606,
+  6, 1, 0.028183829, 0.546665847, 0.150000006, 3.70133615,
+  7, 1, 0.00891250931, 0.52986443, 0.150000006, 4.28118753,
+  8, 1, 0.00891250931, 0.511183441, 0.150000006, 4.84536505,
+  9, 1, 0.00891250931, 0.490902334, 0.150000006, 5.39263105,
+  10, 1, 0.00891250931, 0.46938166, 0.150000006, 5.92205667,
+  11, 1, 0.00891250931, 0.447003782, 0.150000006, 6.43299866,
+  12, 1, 0.00891250931, 0.428170592, 0.150000006, 6.92507982,
+  13, 1, 0.00891250931, 0.414536625, 0.150000006, 7.39815664,
+  14, 1, 0.00891250931, 0.401033074, 0.150000006, 7.85228777,
+  15, 1, 0.00891250931, 0.38779071, 0.150000006, 8.28770351,
+  16, 1, 0.00891250931, 0.374230444, 0.150000006, 8.704772,
+  17, 1, 0.00891250931, 0.360547513, 0.180000007, 9.10397339,
+  18, 1, 0.00891250931, 0.348256677, 0.180000007, 9.48587132,
+  19, 1, 0.00891250931, 0.350327015, 0.180000007, 9.85109234,
+  20, 1, 0.00891250931, 0.406330824, 0.180000007, 10.200304,
+  21, 2, 0.0178250186, 0.554098248, 0.180000007, 10.846529,
+  22, 2, 0.0178250186, 0.528312504, 0.180000007, 11.4447651,
+  23, 2, 0.0178250186, 0.476527005, 0.180000007, 11.9928398,
+  24, 2, 0.0178250186, 0.428205669, 0.180000007, 12.495945,
+  25, 2, 0.0178250186, 0.402271926, 0.180000007, 12.9588718,
+  26, 2, 0.0178250186, 0.378024429, 0.180000007, 13.3859692,
+  27, 2, 0.0178250186, 0.36254698, 0.180000007, 13.7811394,
+  28, 2, 0.0178250186, 0.368058592, 0.200000003, 14.1478529,
+  29, 3, 0.0267375279, 0.385963261, 0.200000003, 14.5674343,
+  30, 3, 0.0267375279, 0.38640517, 0.200000003, 15.0304852,
+  31, 3, 0.0267375279, 0.367834061, 0.200000003, 15.4513416,
+  32, 3, 0.0267375279, 0.349686563, 0.200000003, 15.836277,
+  33, 3, 0.0267375279, 0.345709383, 0.200000003, 16.1904697,
+  34, 4, 0.0356500372, 0.34871915, 0.200000003, 16.5683517,
+  35, 4, 0.0356500372, 0.347054332, 0.200000003, 16.9660263,
+  36, 4, 0.0356500372, 0.346329987, 0.200000003, 17.3304482,
+  37, 5, 0.0445625484, 0.344658494, 0.200000003, 17.7055588,
+  38, 5, 0.0445625484, 0.338779271, 0.200000003, 18.0899811,
+  39, 5, 0.0445625484, 0.334878683, 0.200000003, 18.4440536,
+  40, 6, 0.0534750558, 0.332811534, 0.200000003, 18.8030052,
+  41, 6, 0.0534750558, 0.333717585, 0.25, 19.1665268,
+  42, 7, 0.062387567, 0.333986402, 0.25, 19.5299358,
+  43, 7, 0.062387567, 0.334142625, 0.25, 19.8934898,
+  44, 8, 0.142262354, 0.34677428, 0.280000001, 20.2535706,
+  45, 8, 0.142262354, 0.436254472, 0.280000001, 20.610569,
+  48000.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.639,
+  5, 2, 17, 19, 0.361, 0.417,
+  6, 3, 19, 22, 0.583, 0.083,
+  7, 2, 22, 24, 0.917, 0.750,
+  8, 3, 24, 27, 0.250, 0.417,
+  9, 3, 27, 30, 0.583, 0.648,
+  10, 3, 30, 33, 0.352, 0.611,
+  11, 3, 33, 36, 0.389, 0.625,
+  12, 4, 36, 40, 0.375, 0.144,
+  13, 3, 40, 43, 0.856, 0.389,
+  14, 3, 43, 46, 0.611, 0.160,
+  15, 3, 46, 49, 0.840, 0.217,
+  16, 3, 49, 52, 0.783, 0.184,
+  17, 2, 52, 54, 0.816, 0.886,
+  18, 3, 54, 57, 0.114, 0.313,
+  19, 2, 57, 59, 0.687, 0.452,
+  20, 1, 59, 60, 0.548, 0.908,
+  44100.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.139,
+  5, 1, 17, 18, 0.861, 0.917,
+  6, 3, 18, 21, 0.083, 0.583,
+  7, 3, 21, 24, 0.417, 0.250,
+  8, 3, 24, 27, 0.750, 0.805,
+  9, 3, 27, 30, 0.194, 0.574,
+  10, 3, 30, 33, 0.426, 0.537,
+  11, 3, 33, 36, 0.463, 0.819,
+  12, 4, 36, 40, 0.180, 0.100,
+  13, 3, 40, 43, 0.900, 0.468,
+  14, 3, 43, 46, 0.532, 0.623,
+  15, 3, 46, 49, 0.376, 0.450,
+  16, 3, 49, 52, 0.550, 0.552,
+  17, 3, 52, 55, 0.448, 0.403,
+  18, 2, 55, 57, 0.597, 0.643,
+  19, 2, 57, 59, 0.357, 0.722,
+  20, 2, 59, 61, 0.278, 0.960,
+  32000, 20,
+  0, 1, 0, 2, 1.000, 0.528,
+  1, 2, 2, 4, 0.472, 0.305,
+  2, 2, 4, 6, 0.694, 0.083,
+  3, 1, 6, 7, 0.917, 0.861,
+  4, 2, 7, 9, 0.139, 0.639,
+  5, 2, 9, 11, 0.361, 0.417,
+  6, 3, 11, 14, 0.583, 0.083,
+  7, 2, 14, 16, 0.917, 0.750,
+  8, 3, 16, 19, 0.250, 0.870,
+  9, 3, 19, 22, 0.130, 0.833,
+  10, 4, 22, 26, 0.167, 0.389,
+  11, 4, 26, 30, 0.611, 0.478,
+  12, 4, 30, 34, 0.522, 0.033,
+  13, 3, 34, 37, 0.967, 0.917,
+  14, 4, 37, 41, 0.083, 0.617,
+  15, 3, 41, 44, 0.383, 0.995,
+  16, 4, 44, 48, 0.005, 0.274,
+  17, 3, 48, 51, 0.726, 0.480,
+  18, 3, 51, 54, 0.519, 0.261,
+  19, 2, 54, 56, 0.739, 0.884,
+  20, 2, 56, 58, 0.116, 1.000,
+  24000, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.537036896,
+  7, 3, 20, 23, 0.462963104, 0.5,
+  8, 4, 23, 27, 0.5, 0.0555559993,
+  9, 3, 27, 30, 0.944444001, 0.402778625,
+  10, 3, 30, 33, 0.597221375, 0.766667187,
+  11, 3, 33, 36, 0.233332828, 0.805555999,
+  12, 3, 36, 39, 0.194444016, 0.769841909,
+  13, 3, 39, 42, 0.23015812, 0.611111104,
+  14, 3, 42, 45, 0.388888896, 0.449494779,
+  15, 3, 45, 48, 0.550505221, 0.194444954,
+  16, 2, 48, 50, 0.805555046, 0.913194656,
+  17, 3, 50, 53, 0.0868053436, 0.580555737,
+  18, 3, 53, 56, 0.419444263, 0.113426208,
+  19, 2, 56, 58, 0.886573792, 0.533730626,
+  20, 2, 58, 60, 0.466269344, 0.691176474,
+  22050, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.203703582,
+  7, 3, 20, 23, 0.796296418, 0.166666687,
+  8, 3, 23, 26, 0.833333313, 0.722222686,
+  9, 4, 26, 30, 0.277777344, 0.152778625,
+  10, 3, 30, 33, 0.847221375, 0.566667199,
+  11, 3, 33, 36, 0.433332831, 0.93518573,
+  12, 4, 36, 40, 0.0648142472, 0.118056297,
+  13, 3, 40, 43, 0.881943703, 0.0925937295,
+  14, 2, 43, 45, 0.907406271, 0.934344172,
+  15, 3, 45, 48, 0.0656557977, 0.575398028,
+  16, 3, 48, 51, 0.424601972, 0.232026935,
+  17, 2, 51, 53, 0.767973065, 0.758334339,
+  18, 3, 53, 56, 0.241665646, 0.187501252,
+  19, 2, 56, 58, 0.812498748, 0.533731699,
+  20, 2, 58, 60, 0.466268271, 0.257577598,
+  16000, 20,
+  0, 1, 0, 2, 1, 0.944444478,
+  1, 2, 2, 4, 0.0555555038, 0.722222328,
+  2, 2, 4, 6, 0.277777672, 0.5,
+  3, 2, 6, 8, 0.5, 0.27777797,
+  4, 2, 8, 10, 0.72222203, 0.0555559993,
+  5, 1, 10, 11, 0.944444001, 0.833333313,
+  6, 3, 11, 14, 0.166666672, 0.203703582,
+  7, 3, 14, 17, 0.796296418, 0.166666687,
+  8, 3, 17, 20, 0.833333313, 0.54166698,
+  9, 3, 20, 23, 0.458333015, 0.652778625,
+  10, 4, 23, 27, 0.347221375, 0.166667163,
+  11, 3, 27, 30, 0.833332837, 0.722222924,
+  12, 4, 30, 34, 0.277777106, 0.277778625,
+  13, 3, 34, 37, 0.722221375, 0.604167938,
+  14, 3, 37, 40, 0.395832062, 0.627778649,
+  15, 3, 40, 43, 0.37222138, 0.542736351,
+  16, 3, 43, 46, 0.457263649, 0.371528625,
+  17, 3, 46, 49, 0.628471375, 0.00833433867,
+  18, 2, 49, 51, 0.991665661, 0.500001311,
+  19, 2, 51, 53, 0.499998659, 0.886832893,
+  20, 2, 53, 55, 0.113167092, 0.629034221,
+  48000.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 4, 15, 19, 0.833, 0.583,
+  6, 3, 19, 22, 0.417, 0.917,
+  7, 4, 22, 26, 0.083, 0.944,
+  8, 4, 26, 30, 0.055, 0.042,
+  9, 2, 30, 32, 0.958, 0.567,
+  10, 3, 32, 35, 0.433, 0.167,
+  11, 2, 35, 37, 0.833, 0.618,
+  44100.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 3, 20, 23, 0.750, 0.583,
+  7, 4, 23, 27, 0.417, 0.055,
+  8, 3, 27, 30, 0.944, 0.375,
+  9, 3, 30, 33, 0.625, 0.300,
+  10, 3, 33, 36, 0.700, 0.167,
+  11, 2, 36, 38, 0.833, 1.000,
+  32000, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 4, 20, 24, 0.750, 0.250,
+  7, 5, 24, 29, 0.750, 0.055,
+  8, 4, 29, 33, 0.944, 0.375,
+  9, 4, 33, 37, 0.625, 0.472,
+  10, 3, 37, 40, 0.528, 0.937,
+  11, 1, 40, 41, 0.062, 1.000,
+  24000, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 5, 13, 18, 0.5, 0.833333969,
+  5, 5, 18, 23, 0.166666031, 0.25,
+  6, 4, 23, 27, 0.75, 0.25,
+  7, 3, 27, 30, 0.75, 0.611111999,
+  8, 4, 30, 34, 0.388888031, 0.208333969,
+  9, 3, 34, 37, 0.791666031, 0.766667187,
+  10, 4, 37, 41, 0.233332828, 0.45238167,
+  11, 4, 41, 45, 0.54761833, 0.277778625,
+  22050, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 4, 13, 17, 0.5, 0.5,
+  5, 4, 17, 21, 0.5, 0.916666985,
+  6, 4, 21, 25, 0.0833330154, 0.25,
+  7, 4, 25, 29, 0.75, 0.611111999,
+  8, 4, 29, 33, 0.388888031, 0.458333969,
+  9, 4, 33, 37, 0.541666031, 0.633334339,
+  10, 4, 37, 41, 0.366665661, 0.583334565,
+  11, 4, 41, 45, 0.416665405, 0.437500954,
+  16000, 11,
+  0, 0, 0, 4, 1, 0.166666746,
+  1, 0, 4, 6, 0.833333254, 0.833333492,
+  2, 0, 6, 9, 0.166666508, 0.5,
+  3, 0, 9, 13, 0.5, 0.5,
+  4, 0, 13, 18, 0.5, 0.833333969,
+  5, 0, 18, 23, 0.166666031, 0.75,
+  6, 0, 23, 27, 0.25, 0.75,
+  7, 0, 27, 31, 0.25, 0.611111999,
+  8, 0, 31, 35, 0.388888031, 0.458333969,
+  9, 0, 35, 39, 0.541666031, 0.166667163,
+  10, 0, 39, 42, 0.833332837, 0.805555999,
+  11, 0, 42, 46, 0.194444016, 0.4375};
+ 
diff -r -c -N encoder/tables.h lame3.70/tables.h
*** encoder/tables.h	Wed Dec 31 17:00:00 1969
--- lame3.70/tables.h	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,43 ----
+ /*
+ ** Copyright (C) 1999 Albert L. Faber
+ **  
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ #ifndef TABLES_H_INCLUDED
+ #define TABLES_H_INCLUDED
+ #include "encoder.h"
+ extern FLOAT8 psy_data[];
+ 
+ #define HUFFBITS unsigned long int
+ #define HTN	34
+  
+ struct huffcodetab {
+   unsigned int xlen; 	/*max. x-index+			      	*/ 
+   unsigned int linmax;	/*max number to be stored in linbits	*/
+   HUFFBITS *table;	/*pointer to array[xlen][ylen]		*/
+   unsigned char *hlen;	/*pointer to array[xlen][ylen]		*/
+ };
+ 
+ extern struct huffcodetab ht[HTN];/* global memory block		*/
+ 				/* array of all huffcodtable headers	*/
+ 				/* 0..31 Huffman code table 0..31	*/
+ 				/* 32,33 count1-tables			*/
+ 
+ 
+ 
+ 
+ #endif
diff -r -c -N encoder/takehiro.c lame3.70/takehiro.c
*** encoder/takehiro.c	Wed Dec 31 17:00:00 1969
--- lame3.70/takehiro.c	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,765 ----
+ /*
+  *	MP3 huffman table selecting and bit counting
+  *
+  *	Copyright (c) 1999 Takehiro TOMINAGA
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #include "util.h"
+ #include "l3side.h"
+ #include "tables.h"
+ #include "quantize-pvt.h"
+ 
+ 
+ 
+ 
+ struct
+ {
+     unsigned region0_count;
+     unsigned region1_count;
+ } subdv_table[ 23 ] =
+ {
+ {0, 0}, /* 0 bands */
+ {0, 0}, /* 1 bands */
+ {0, 0}, /* 2 bands */
+ {0, 0}, /* 3 bands */
+ {0, 0}, /* 4 bands */
+ {0, 1}, /* 5 bands */
+ {1, 1}, /* 6 bands */
+ {1, 1}, /* 7 bands */
+ {1, 2}, /* 8 bands */
+ {2, 2}, /* 9 bands */
+ {2, 3}, /* 10 bands */
+ {2, 3}, /* 11 bands */
+ {3, 4}, /* 12 bands */
+ {3, 4}, /* 13 bands */
+ {3, 4}, /* 14 bands */
+ {4, 5}, /* 15 bands */
+ {4, 5}, /* 16 bands */
+ {4, 6}, /* 17 bands */
+ {5, 6}, /* 18 bands */
+ {5, 6}, /* 19 bands */
+ {5, 7}, /* 20 bands */
+ {6, 7}, /* 21 bands */
+ {6, 7}, /* 22 bands */
+ };
+ 
+ 
+ /*************************************************************************/
+ /*	      ix_max							 */
+ /*************************************************************************/
+ 
+  static int ix_max(int *ix, int *end)
+ {
+     int max = 0;
+ 
+     while (ix < end) {
+ 	int x =	 *ix++;
+ 	if (max < x) 
+ 	    max = x;
+ 
+ 	x = *ix++;
+ 	if (max < x) 
+ 	    max = x;
+     }
+     return max;
+ }
+ 
+ 
+ /*************************************************************************/
+ /*	      count_bit							 */
+ /*************************************************************************/
+ 
+ /*
+  Function: Count the number of bits necessary to code the subregion. 
+ */
+ 
+ static int cb_esc_buf[288];
+ static int cb_esc_sign;
+ static int *cb_esc_end;
+ static const int huf_tbl_noESC[15] = {
+     1, 2, 5, 7, 7,10,10,13,13,13,13,13,13,13,13
+ };
+ 
+  static int
+ count_bit_ESC(int *ix, int *end, int t1, int t2, int *s)
+ {
+     /* ESC-table is used */
+     int linbits1 = ht[t1].xlen;
+     int linbits2 = ht[t2].xlen;
+     int	sum = 0;
+     int	sum1 = 0;
+     int	sum2 = 0;
+ 
+     while (ix < end) {
+ 	int x = *ix++;
+ 	int y = *ix++;
+ 
+ 	if (x != 0) {
+ 	    sum++;
+ 	    if (x > 14) {
+ 		x = 15;
+ 		sum1 += linbits1;
+ 		sum2 += linbits2;
+ 	    }
+ 	    x *= 16;
+ 	}
+ 
+ 	if (y != 0) {
+ 	    sum++;
+ 	    if (y > 14) {
+ 		y = 15;
+ 		sum1 += linbits1;
+ 		sum2 += linbits2;
+ 	    }
+ 	    x += y;
+ 	}
+ 
+ 	sum1 += ht[16].hlen[x];
+ 	sum2 += ht[24].hlen[x];
+     }
+ 
+     if (sum1 > sum2)  {
+ 	sum1 = sum2;
+ 	t1 = t2;
+     }
+ 
+     *s += sum + sum1;
+     return t1;
+ }
+ 
+  static int
+ count_bit_noESC(int *ix, int *end, unsigned int table) 
+ {
+     /* No ESC-words */
+     int	sum = 0, sign = 0;
+     unsigned char *hlen = ht[table].hlen;
+     int *p = cb_esc_buf;
+ 
+     do {
+ 	int x = *ix++;
+ 	int y = *ix++;
+ 	if (x != 0) {
+ 	    sign++;
+ 	    x *= 16;
+ 	}
+ 
+ 	if (y != 0) {
+ 	    sign++;
+ 	    x += y;
+ 	}
+ 
+ 	*p++ = x;
+ 	sum += hlen[x];
+     } while (ix < end);
+ 
+     cb_esc_sign = sign;
+     cb_esc_end = p;
+     return sum + sign;
+ }
+ 
+ 
+ 
+  static int
+ count_bit_noESC2(unsigned int table) 
+ {
+     /* No ESC-words */
+     int	sum = cb_esc_sign;
+     int *p = cb_esc_buf;
+ 
+     do {
+ 	sum += ht[table].hlen[*p++];
+     } while (p < cb_esc_end);
+ 
+     return sum;
+ }
+ 
+ 
+ 
+  static int
+ count_bit_short_ESC(int *ix, int *end, int t1, int t2, int *s)
+ {
+     /* ESC-table is used */
+     int linbits1 = ht[t1].xlen;
+     int linbits2 = ht[t2].xlen;
+     int	sum = 0;
+     int	sum1 = 0;
+     int	sum2 = 0;
+ 
+     do {
+ 	int i;
+ 	for (i = 0; i < 3; i++) {
+ 	    int y = *(ix + 3);
+ 	    int x = *ix++;
+ 
+ 	    if (x != 0) {
+ 		sum++;
+ 		if (x > 14) {
+ 		    x = 15;
+ 		    sum1 += linbits1;
+ 		    sum2 += linbits2;
+ 		}
+ 		x *= 16;
+ 	    }
+ 
+ 	    if (y != 0) {
+ 		sum++;
+ 		if (y > 14) {
+ 		    y = 15;
+ 		    sum1 += linbits1;
+ 		    sum2 += linbits2;
+ 		}
+ 		x += y;
+ 	    }
+ 
+ 	    sum1 += ht[16].hlen[x];
+ 	    sum2 += ht[24].hlen[x];
+ 	}
+ 	ix += 3;
+     } while (ix < end);
+ 
+     if (sum1 > sum2)  {
+ 	sum1 = sum2;
+ 	t1 = t2;
+     }
+ 
+     *s += sum + sum1;
+     return t1;
+ }
+ 
+ 
+ 
+  static int
+ count_bit_short_noESC(int *ix, int *end, unsigned int table) 
+ {
+     /* No ESC-words */
+     int	sum = 0, sign = 0;
+     unsigned char *hlen = ht[table].hlen;
+     int *p = cb_esc_buf;
+ 
+     do {
+ 	int i;
+ 	for (i = 0; i < 3; i++) {
+ 	    int y = *(ix + 3);
+ 	    int x = *ix++;
+ 	    if (x != 0) {
+ 		sign++;
+ 		x *= 16;
+ 	    }
+ 
+ 	    if (y != 0) {
+ 		sign++;
+ 		x += y;
+ 	    }
+ 
+ 	    *p++ = x;
+ 	    sum += hlen[x];
+ 	}
+ 	ix += 3;
+     } while (ix < end);
+ 
+     cb_esc_sign = sign;
+     cb_esc_end = p;
+     return sum + sign;
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*	      new_choose table						 */
+ /*************************************************************************/
+ 
+ /*
+   Choose the Huffman table that will encode ix[begin..end] with
+   the fewest bits.
+ 
+   Note: This code contains knowledge about the sizes and characteristics
+   of the Huffman tables as defined in the IS (Table B.7), and will not work
+   with any arbitrary tables.
+ */
+ 
+ static int choose_table(int *ix, int *end, int *s)
+ {
+     int max;
+     int choice0, sum0;
+     int choice1, sum1;
+ 
+     max = ix_max(ix, end);
+ 
+     if (max > IXMAX_VAL) {
+         *s = 100000;
+         return -1;
+     }
+ 
+     if (max <= 15)  {
+ 	if (max == 0) {
+ 	    return 0;
+ 	}
+ 	/* try tables with no linbits */
+ 	choice0 = huf_tbl_noESC[max - 1];
+ 	sum0 = count_bit_noESC(ix, end, choice0);
+ 	choice1 = choice0;
+ 
+ 	switch (choice0) {
+ 	case 7:
+ 	case 10:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    /*fall*/
+ 	case 2:
+ 	case 5:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	case 13:
+ 	    choice1 += 2;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	default:
+ 	    break;
+ 	}
+ 	*s += sum0;
+     } else {
+ 	/* try tables with linbits */
+ 	max -= 15;
+ 
+ 	for (choice1 = 24; choice1 < 32; choice1++) {
+ 	    if ((int)ht[choice1].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	for (choice0 = choice1 - 8; choice0 < 24; choice0++) {
+ 	    if ((int)ht[choice0].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	choice0 = count_bit_ESC(ix, end, choice0, choice1, s);
+     }
+ 
+     return choice0;
+ }
+ 
+ static int choose_table_short(int *ix, int *end, int * s)
+ {
+     int max;
+     int choice0, sum0;
+     int choice1, sum1;
+ 
+     max = ix_max(ix, end);
+ 
+     if (max > IXMAX_VAL) {
+         *s = 100000;
+         return -1;
+     }
+ 
+     if (max <= 15)  {
+ 	if (max == 0) {
+ 	    return 0;
+ 	}
+ 	/* try tables with no linbits */
+ 	choice0 = huf_tbl_noESC[max - 1];
+ 	sum0 = count_bit_short_noESC(ix, end, choice0);
+ 	choice1 = choice0;
+ 
+ 	switch (choice0) {
+ 	case 7:
+ 	case 10:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    /*fall*/
+ 	case 2:
+ 	case 5:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	case 13:
+ 	    choice1 += 2;
+ 	    sum1 = count_bit_noESC2(choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	default:
+ 	    break;
+ 	}
+ 	*s += sum0;
+     } else {
+ 	/* try tables with linbits */
+ 	max -= 15;
+ 	for (choice1 = 24; choice1 < 32; choice1++) {
+ 	    if ((int)ht[choice1].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	for (choice0 = choice1 - 8; choice0 < 24; choice0++) {
+ 	    if ((int)ht[choice0].linmax >= max) {
+ 		break;
+ 	}
+ 	}
+ 	choice0 = count_bit_short_ESC(ix, end, choice0, choice1, s);
+     }
+ 
+     return choice0;
+ }
+ 
+ 
+ 
+ static int count_bits_long(int ix[576], gr_info *gi)
+ {
+     int i, a1, a2;
+     int bits = 0;
+ 
+     i=576;
+     for (; i > 1; i -= 2) 
+ 	if (ix[i - 1] | ix[i - 2])
+ 	    break;
+ 
+     /* Determines the number of bits to encode the quadruples. */
+     gi->count1 = i;
+     a1 = 0;
+     for (; i > 3; i -= 4) {
+ 	int p, v;
+ 	if ((unsigned int)(ix[i-1] | ix[i-2] | ix[i-3] | ix[i-4]) > 1)
+ 	    break;
+ 
+ 	v = ix[i-1];
+ 	p = v;
+ 	bits += v;
+ 
+ 	v = ix[i-2];
+ 	if (v != 0) {
+ 	    p += 2;
+ 	    bits++;
+ 	}
+ 
+ 	v = ix[i-3];
+ 	if (v != 0) {
+ 	    p += 4;
+ 	    bits++;
+ 	}
+ 
+ 	v = ix[i-4];
+ 	if (v != 0) {
+ 	    p += 8;
+ 	    bits++;
+ 	}
+ 
+ 	a1 += ht[32].hlen[p];
+     }
+     a2 = gi->count1 - i;
+     if (a1 < a2) {
+ 	bits += a1;
+ 	gi->count1table_select = 0;
+     } else {
+ 	bits += a2;
+ 	gi->count1table_select = 1;
+     }
+ 
+     gi->count1bits = bits;
+     gi->big_values = i;
+     if (i == 0)
+ 	return bits;
+ 
+     if (gi->block_type == NORM_TYPE) {
+ 	int index;
+ 	int scfb_anz = 0;
+ 
+ 	while (scalefac_band.l[++scfb_anz] < i) 
+ 	    ;
+ 	index = subdv_table[scfb_anz].region0_count;
+ 	while (scalefac_band.l[index + 1] > i)
+ 	    index--;
+ 	gi->region0_count = index;
+ 
+ 	index = subdv_table[scfb_anz].region1_count;
+ 	while (scalefac_band.l[index + gi->region0_count + 2] > i)
+ 	    index--;
+ 	gi->region1_count = index;
+ 
+ 	a1 = scalefac_band.l[gi->region0_count + 1];
+ 	a2 = scalefac_band.l[index + gi->region0_count + 2];
+ 	gi->table_select[2] = choose_table(ix + a2, ix + i, &bits);
+ 
+     } else {
+ 	gi->region0_count = 7;
+ 	/*gi->region1_count = SBPSY_l - 7 - 1;*/
+ 	gi->region1_count = SBMAX_l -1 - 7 - 1;
+ 	a1 = scalefac_band.l[7 + 1];
+ 	a2 = i;
+ 	if (a1 > a2) {
+ 	    a1 = a2;
+ 	}
+     }
+ 
+     /* Count the number of bits necessary to code the bigvalues region. */
+     gi->table_select[0] = choose_table(ix, ix + a1, &bits);
+     gi->table_select[1] = choose_table(ix + a1, ix + a2, &bits);
+     return bits;
+ }
+ 
+ 
+ 
+ 
+ int count_bits(lame_global_flags *gfp,int *ix, FLOAT8 *xr, gr_info *cod_info)  
+ {
+   int bits=0,i;
+   /* since quantize_xrpow uses table lookup, we need to check this first: */
+   FLOAT8 w = (IXMAX_VAL) / IPOW20(cod_info->global_gain);
+   for ( i = 0; i < 576; i++ )  {
+     if (xr[i] > w)
+       return 100000;
+   }
+   if (gfp->quantization) 
+     quantize_xrpow(xr, ix, cod_info);
+   else
+     quantize_xrpow_ISO(xr, ix, cod_info);
+ 
+ 
+ 
+   if (cod_info->block_type==SHORT_TYPE) {
+     cod_info->table_select[0] = choose_table_short(ix, ix + 36, &bits);
+     cod_info->table_select[1] = choose_table_short(ix + 36, ix + 576, &bits);
+     cod_info->big_values = 288;
+   }else{
+     bits=count_bits_long(ix, cod_info);
+     cod_info->count1 = (cod_info->count1 - cod_info->big_values) / 4;
+     cod_info->big_values /= 2;
+   }
+   return bits;
+ 
+ }
+ 
+ void best_huffman_divide(int gr, int ch, gr_info *gi, int *ix)
+ {
+     int *bits, r0, r1, a1, a2, bigv;
+     int r1_bits;
+     int r3_bits[7 + 15 + 2 + 1];
+     int r3_tbl[7 + 15 + 2 + 1];
+     gr_info cod_info;
+ 
+     memcpy(&cod_info, gi, sizeof(gr_info));
+     bigv = cod_info.big_values * 2;
+     bits = (int *) &cod_info.part2_3_length;
+ 
+     for (r0 = 2; r0 < SBMAX_l + 1; r0++) {
+ 	a2 = scalefac_band.l[r0];
+ 	if (a2 > bigv)
+ 	    break;
+ 
+ 	r3_bits[r0] = cod_info.count1bits + cod_info.part2_length;
+ 	r3_tbl[r0] = choose_table(ix + a2, ix + bigv, &r3_bits[r0]);
+     }
+     for (; r0 <= 7 + 15 + 2; r0++) {
+ 	r3_bits[r0] = 100000;
+     }
+ 
+     for (r0 = 0; r0 < 16; r0++) {
+ 	a1 = scalefac_band.l[r0 + 1];
+ 	if (a1 > bigv)
+ 	    break;
+ 	cod_info.region0_count = r0;
+ 	r1_bits = 0;
+ 	cod_info.table_select[0] = choose_table(ix, ix + a1, &r1_bits);
+ 	if ((int)gi->part2_3_length < r1_bits)
+ 	    break;
+ 
+ 	for (r1 = 0; r1 < 8; r1++) {
+ 	    *bits = r1_bits + r3_bits[r0 + r1 + 2];
+ 	    if ((int)gi->part2_3_length < *bits)
+ 		continue;
+ 
+ 	    a2 = scalefac_band.l[r0 + r1 + 2];
+ 
+ 	    cod_info.table_select[1] = choose_table(ix + a1, ix + a2, bits);
+ 	    if ((int)gi->part2_3_length < *bits)
+ 		continue;
+ 
+ 	    cod_info.region1_count = r1;
+ 	    cod_info.table_select[2] = r3_tbl[r0 + r1 + 2];
+ 	    memcpy(gi, &cod_info, sizeof(gr_info));
+ 	}
+     }
+ }
+ 
+ static void
+ scfsi_calc(int ch,
+ 	   III_side_info_t *l3_side,
+ 	   III_scalefac_t scalefac[2][2])
+ {
+     int i, s1, s2, c1, c2;
+     int sfb;
+     gr_info *gi = &l3_side->gr[1].ch[ch].tt;
+ 
+     static const int scfsi_band[5] = { 0, 6, 11, 16, 21 };
+ 
+     static const int slen1_n[16] = { 0, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8,16,16 };
+     static const int slen2_n[16] = { 0, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8 };
+ 
+     static const int slen1_tab[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
+     static const int slen2_tab[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
+ 
+     for (i = 0; i < 4; i++) 
+ 	l3_side->scfsi[ch][i] = 0;
+ 
+     for (i = 0; i < (int)(sizeof(scfsi_band) / sizeof(int)) - 1; i++) {
+ 	for (sfb = scfsi_band[i]; sfb < scfsi_band[i + 1]; sfb++) {
+ 	    if (scalefac[0][ch].l[sfb] != scalefac[1][ch].l[sfb])
+ 		break;
+ 	}
+ 	if (sfb == scfsi_band[i + 1]) {
+ 	    for (sfb = scfsi_band[i]; sfb < scfsi_band[i + 1]; sfb++) {
+ 		scalefac[1][ch].l[sfb] = -1;
+ 	    }
+ 	    l3_side->scfsi[ch][i] = 1;
+ 	}
+     }
+ 
+     s1 = c1 = 0;
+     for (sfb = 0; sfb < 11; sfb++) {
+ 	if (scalefac[1][ch].l[sfb] < 0)
+ 	    continue;
+ 	c1++;
+ 	if (s1 < scalefac[1][ch].l[sfb])
+ 	    s1 = scalefac[1][ch].l[sfb];
+     }
+ 
+     s2 = c2 = 0;
+     for (; sfb < SBPSY_l; sfb++) {
+ 	if (scalefac[1][ch].l[sfb] < 0)
+ 	    continue;
+ 	c2++;
+ 	if (s2 < scalefac[1][ch].l[sfb])
+ 	    s2 = scalefac[1][ch].l[sfb];
+     }
+     for (i = 0; i < 16; i++) {
+ 	if (s1 < slen1_n[i] && s2 < slen2_n[i]) {
+ 	    int c = slen1_tab[i] * c1 + slen2_tab[i] * c2;
+ 	    if ((int)gi->part2_length > c) {
+ 		gi->part2_length = c;
+ 		gi->scalefac_compress = i;
+ 	    }
+ 	}
+     }
+ }
+ 
+ void best_scalefac_store(lame_global_flags *gfp,int gr, int ch,
+ 			 int l3_enc[2][2][576],
+ 			 III_side_info_t *l3_side,
+ 			 III_scalefac_t scalefac[2][2])
+ {
+     /* use scalefac_scale if we can */
+     gr_info *gi = &l3_side->gr[gr].ch[ch].tt;
+ 
+     /* remove scalefacs from bands with ix=0.  This idea comes
+      * from the AAC ISO docs.  added mt 3/00 */
+     int sfb,i,l,start,end;
+     /* check if l3_enc=0 */
+     for ( sfb = 0; sfb < gi->sfb_lmax; sfb++ ) {
+       if (scalefac[gr][ch].l[sfb]>0) { 
+ 	start = scalefac_band.l[ sfb ];
+ 	end   = scalefac_band.l[ sfb+1 ];
+ 	for ( l = start; l < end; l++ ) if (l3_enc[gr][ch][l]!=0) break;
+ 	if (l==end) scalefac[gr][ch].l[sfb]=0;
+       }
+     }
+     for ( i = 0; i < 3; i++ ) {
+       for ( sfb = gi->sfb_smax; sfb < SBPSY_s; sfb++ ) {
+ 	if (scalefac[gr][ch].s[sfb][i]>0) {
+ 	  start = scalefac_band.s[ sfb ];
+ 	  end   = scalefac_band.s[ sfb+1 ];
+ 	  for ( l = start; l < end; l++ ) 
+ 	    if (l3_enc[gr][ch][3*l+i]!=0) break;
+ 	  if (l==end) scalefac[gr][ch].s[sfb][i]=0;
+         }
+       }
+     }
+ 
+ 
+     gi->part2_3_length -= gi->part2_length;
+     if (!gi->scalefac_scale && !gi->preflag) {
+ 	u_int sfb;
+ 	int b, s = 0;
+ 	for (sfb = 0; sfb < gi->sfb_lmax; sfb++) {
+ 	    s |= scalefac[gr][ch].l[sfb];
+ 	}
+ 
+ 	for (sfb = gi->sfb_smax; sfb < SBPSY_s; sfb++) {
+ 	    for (b = 0; b < 3; b++) {
+ 		s |= scalefac[gr][ch].s[sfb][b];
+ 	    }
+ 	}
+ 
+ 	if (!(s & 1) && s != 0) {
+ 	    for (sfb = 0; sfb < gi->sfb_lmax; sfb++) {
+ 		scalefac[gr][ch].l[sfb] /= 2;
+ 	    }
+ 	    for (sfb = gi->sfb_smax; sfb < SBPSY_s; sfb++) {
+ 		for (b = 0; b < 3; b++) {
+ 		    scalefac[gr][ch].s[sfb][b] /= 2;
+ 		}
+ 	    }
+ 
+ 	    gi->scalefac_scale = 1;
+ 	    gi->part2_length = 99999999;
+ 	    if (gfp->mode_gr == 2) {
+ 	        scale_bitcount(&scalefac[gr][ch], gi);
+ 	    } else {
+ 		scale_bitcount_lsf(&scalefac[gr][ch], gi);
+ 	    }
+ 	}
+     }
+ 
+     if (gfp->mode_gr == 2 && gr == 1
+ 	&& l3_side->gr[0].ch[ch].tt.block_type != SHORT_TYPE
+ 	&& l3_side->gr[1].ch[ch].tt.block_type != SHORT_TYPE
+ 	&& l3_side->gr[0].ch[ch].tt.scalefac_scale
+ 	== l3_side->gr[1].ch[ch].tt.scalefac_scale
+ 	&& l3_side->gr[0].ch[ch].tt.preflag
+ 	== l3_side->gr[1].ch[ch].tt.preflag) {
+       	scfsi_calc(ch, l3_side, scalefac);
+     }
+     gi->part2_3_length += gi->part2_length;
+ }
Binary files encoder/testcase.mp3 and lame3.70/testcase.mp3 differ
Binary files encoder/testcase.wav and lame3.70/testcase.wav differ
diff -r -c -N encoder/timestatus.c lame3.70/timestatus.c
*** encoder/timestatus.c	Wed Dec 31 17:00:00 1969
--- lame3.70/timestatus.c	Thu Mar 16 09:44:22 2000
***************
*** 0 ****
--- 1,146 ----
+ #include "timestatus.h"
+ #include "util.h"
+ #include <time.h>
+ 
+ #if defined(CLOCKS_PER_SEC)
+ /* ANSI/ISO systems */
+ # define TS_CLOCKS_PER_SEC CLOCKS_PER_SEC
+ #elif defined(CLK_TCK)
+ /* Non-standard systems */
+ # define TS_CLOCKS_PER_SEC CLK_TCK
+ #elif defined(HZ)
+ /* Older BSD systems */
+ # define TS_CLOCKS_PER_SEC HZ
+ #else
+ # error no suitable value for TS_CLOCKS_PER_SEC
+ #endif
+ 
+ /*********************************************************/
+ /* ts_real_time: real time elapsed in seconds            */
+ /*********************************************************/
+ FLOAT ts_real_time(long frame) {
+ 
+   static time_t initial_time;
+   time_t current_time;
+ 
+   time(&current_time);
+ 
+   if (frame==0) {
+     initial_time = current_time;
+   }
+ 
+   return (FLOAT) difftime(current_time, initial_time);
+ }
+ 
+ /*********************************************************/
+ /* ts_process_time: process time elapsed in seconds      */
+ /*********************************************************/
+ FLOAT ts_process_time(long frame) {
+   static clock_t initial_time;
+   clock_t current_time;
+ 
+ #if ( defined(_MSC_VER) || defined(__BORLANDC__) ) 
+ 
+   { static HANDLE hProcess;
+     FILETIME Ignored1, Ignored2, KernelTime, UserTime;
+ 
+     if ( frame==0 ) {
+       hProcess = GetCurrentProcess();
+     }
+         
+     /* GetProcessTimes() always fails under Win9x */
+     if (GetProcessTimes(hProcess, &Ignored1, &Ignored2, &KernelTime, &UserTime)) {
+       LARGE_INTEGER Kernel = { KernelTime.dwLowDateTime, KernelTime.dwHighDateTime };
+       LARGE_INTEGER User = { UserTime.dwLowDateTime, UserTime.dwHighDateTime };
+ 
+       current_time = (clock_t)((FLOAT)(Kernel.QuadPart + User.QuadPart) * TS_CLOCKS_PER_SEC / 10000000);
+     } else {
+       current_time = clock();
+ 	}
+   }
+ #else
+   current_time = clock();
+ #endif
+ 
+   if (frame==0) {
+     initial_time = current_time;
+   }
+ 
+   return (FLOAT)(current_time - initial_time) / TS_CLOCKS_PER_SEC;
+ }
+ 
+ #undef TS_CLOCKS_PER_SEC
+ 
+ typedef struct ts_times {
+   FLOAT so_far;
+   FLOAT estimated;
+   FLOAT speed;
+   FLOAT eta;
+ } ts_times;
+ 
+ /*********************************************************/
+ /* ts_calc_times: calculate time info (eta, speed, etc.) */
+ /*********************************************************/
+ void ts_calc_times(ts_times *time, int samp_rate, long frame, long frames,int framesize)
+ {
+   if (frame > 0) {
+     time->estimated = time->so_far * frames / frame;
+     if (samp_rate * time->estimated > 0) {
+       time->speed = frames * framesize / (samp_rate * time->estimated);
+     } else {
+       time->speed = 0;
+     }
+     time->eta = time->estimated - time->so_far;
+   } else {
+     time->estimated = 0;
+ 	time->speed = 0;
+ 	time->eta = 0;
+   }
+ }
+ 
+ /*********************************************************/
+ /* timestatus: display encoding process time information */
+ /*********************************************************/
+ void timestatus(int samp_rate,long frameNum,long totalframes,int framesize)
+ {
+   ts_times real_time, process_time;
+   int percent;
+ 
+   real_time.so_far = ts_real_time(frameNum);
+   process_time.so_far = ts_process_time(frameNum);
+ 
+   if (frameNum == 0) {
+     fprintf(stderr, "    Frame          |  CPU/estimated  |  time/estimated | play/CPU |   ETA\n");
+     return;
+   }  
+ 
+   ts_calc_times(&real_time, samp_rate, frameNum, totalframes, framesize);
+   ts_calc_times(&process_time, samp_rate, frameNum, totalframes, framesize);
+ 
+   if (totalframes > 1) {
+     percent = (int)(100.0 * frameNum / (totalframes - 1));
+   } else {
+     percent = 100;
+   }
+ 
+ #  define TS_TIME_DECOMPOSE(time) \
+     (int)((long)(time+.5) / 3600), \
+     (int)((long)((time+.5) / 60) % 60), \
+     (int)((long)(time+.5) % 60)
+ 
+   fprintf(stderr,
+     "\r%6ld/%6ld(%3d%%)|%2d:%02d:%02d/%2d:%02d:%02d|%2d:%02d:%02d/%2d:%02d:%02d|%10.4f|%2d:%02d:%02d ",
+     frameNum,
+     totalframes - 1,
+     percent,
+     TS_TIME_DECOMPOSE(process_time.so_far),
+     TS_TIME_DECOMPOSE(process_time.estimated),
+     TS_TIME_DECOMPOSE(real_time.so_far),
+ 	TS_TIME_DECOMPOSE(real_time.estimated),
+     process_time.speed,
+     TS_TIME_DECOMPOSE(real_time.eta)
+   );
+ 
+   fflush(stderr);
+ }
+ 
diff -r -c -N encoder/timestatus.h lame3.70/timestatus.h
*** encoder/timestatus.h	Wed Dec 31 17:00:00 1969
--- lame3.70/timestatus.h	Tue Mar 14 13:45:04 2000
***************
*** 0 ****
--- 1,8 ----
+ #ifndef TIMESTATUS_H_INCLUDED
+ #define TIMESTATUS_H_INCLUDED
+ 
+ 
+ void timestatus(int samp_rate,long frameNum,long totalframes, int framesize);
+ 
+ 
+ #endif
diff -r -c -N encoder/tonal.c lame3.70/tonal.c
*** encoder/tonal.c	Wed Jan 22 02:43:23 1997
--- lame3.70/tonal.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1051 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: tonal.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: tonal.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Douglas Wong        start of version 1.1 records          *
-  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
-  *                              updated I_psycho_one and II_psycho_one*
-  * 3/11/91  W. J. Carter        Added Douglas Wong's updates dated    *
-  *                              3/9/91 for I_Psycho_One() and for     *
-  *                              II_Psycho_One().                      *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 6/11/91  Davis Pan           corrected several bugs                *
-  *                              based on comments from H. Fuchs       *
-  * 01jul91  dpwe (Aware Inc.)   Made pow() args float                 *
-  *                              Removed logical bug in I_tonal_label: *
-  *                              Sometimes *tone returned == STOP      *
-  * 7/10/91  Earle Jennings      no change necessary in port to MsDos  *
-  * 11sep91  dpwe@aware.com      Subtracted 90.3dB from II_f_f_t peaks *
-  * 10/1/91  Peter W. Farrett    Updated II_Psycho_One(),I_Psycho_One()*
-  *                              to include comments.                  *
-  *11/29/91  Masahiro Iwadare    Bug fix regarding POWERNORM           *
-  *                              fixed several other miscellaneous bugs*
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 2/12/92  Masahiro Iwadare    Fixed some potential bugs in          *
-  *          Davis Pan           subsampling()                         *
-  * 2/25/92  Masahiro Iwadare    Fixed some more potential bugs        *
-  * 6/24/92  Tan Ah Peng         Modified window for FFT               * 
-  *                              (denominator N-1 to N)                *
-  *                              Updated all critical band rate &      *
-  *                              absolute threshold tables and critical*
-  *                              boundaries for use with Layer I & II  *  
-  *                              Corrected boundary limits for tonal   *
-  *                              component computation                 *
-  *                              Placement of non-tonal component at   *
-  *                              geometric mean of critical band       *
-  *                              (previous placement method commented  *
-  *                               out - can be used if desired)        *
-  * 3/01/93  Mike Li             Infinite looping fix in noise_label() *
-  * 3/19/93  Jens Spille         fixed integer overflow problem in     *
-  *                              psychoacoutic model 1                 *
-  * 3/19/93  Giorgio Dimino      modifications to better account for   *
-  *                              tonal and non-tonal components        *
-  * 5/28/93 Sriram Jayasimha     "London" mod. to psychoacoustic model1*
-  * 8/05/93 Masahiro Iwadare     noise_label modification "option"     *
-  * 1/21/94 Seymore Shlien       fixed another infinite looping problem*
-  * 7/12/95 Soeren H. Nielsen    Changes for LSF, new tables           *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- #define LONDON                  /* enable "LONDON" modification */
- #define MAKE_SENSE              /* enable "MAKE_SENSE" modification */
- #define MI_OPTION               /* enable "MI_OPTION" modification */
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer II. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- int crit_band;
- int FAR *cbound;
- int sub_size;
- 
- void read_cbound(lay,freq)  /* this function reads in critical */
- int lay, freq;              /* band boundaries                 */
- {
-  int i,j,k;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2cb1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){       /* check boundary values */
-     printf("Please check %s boundary table\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);               /* read input for critical bands */
-  sscanf(t,"%d\n",&crit_band);
-  cbound = (int FAR *) mem_alloc(sizeof(int) * crit_band, "cbound");
-  for(i=0;i<crit_band;i++){   /* continue to read input for */
-     fgets(t,80,fp);            /* critical band boundaries   */
-     sscanf(t,"%d %d\n",&j, &k);
-     if(i==j) cbound[j] = k;
-     else {                     /* error */
-        printf("Please check index %d in cbound table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }        
- 
- void read_freq_band(ltg,lay,freq)  /* this function reads in   */
- int lay, freq;                     /* frequency bands and bark */
- g_ptr FAR *ltg;                /* values                   */
- {
-  int i,j, k;
-  double b,c;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2th1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){   /* check freq. values  */
-     printf("Please check frequency and cband table %s\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);              /* read input for freq. subbands */
-  sscanf(t,"%d\n",&sub_size);
-  *ltg = (g_ptr FAR ) mem_alloc(sizeof(g_thres) * sub_size, "ltg");
-  (*ltg)[0].line = 0;          /* initialize global masking threshold */
-  (*ltg)[0].bark = 0;
-  (*ltg)[0].hear = 0;
-  for(i=1;i<sub_size;i++){    /* continue to read freq. subband */
-     fgets(t,80,fp);          /* and assign                     */
-     sscanf(t,"%d %d %lf %lf\n",&j, &k, &b, &c);
-     if(i == j){
-        (*ltg)[j].line = k;
-        (*ltg)[j].bark = b;
-        (*ltg)[j].hear = c;
-     }
-     else {                   /* error */
-        printf("Please check index %d in freq-cb table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }
- 
- void make_map(power, ltg)       /* this function calculates the */
- mask FAR power[HAN_SIZE];   /* global masking threshold     */
- g_thres FAR *ltg;
- {
-  int i,j;
- 
-  for(i=1;i<sub_size;i++) for(j=ltg[i-1].line;j<=ltg[i].line;j++)
-     power[j].map = i;
- }
- 
- double add_db(a,b)
- double a,b;
- {
-  a = pow(10.0,a/10.0);
-  b = pow(10.0,b/10.0);
-  return 10 * log10(a+b);
- }
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void II_f_f_t(sample, power)      /* this function calculates an */
- double FAR sample[FFT_SIZE];  /* FFT analysis for the freq.  */
- mask FAR power[HAN_SIZE];     /* domain                      */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT), "energy");
-  for(i=0;i<FFT_SIZE;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT), "rev");
-     w_r = (double *) mem_alloc(sizeof(D10), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D10), "w_i");
-     M = 10;
-     MM1 = 9;
-     N = FFT_SIZE;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE;rev[i] = l,i++) for(j=0,l=0;j<10;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(9-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE;i++){    /* calculate power density spectrum */
-     if (energy[i] < 1E-20) energy[i] = 1E-20;
-     power[i].x = 10 * log10(energy[i]) + POWERNORM;
-     power[i].next = STOP;
-     power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void II_hann_win(sample)          /* this function calculates a  */
- double FAR sample[FFT_SIZE];  /* Hann window for PCM (input) */
- {                                 /* samples for a 1024-pt. FFT  */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE;i++){
-        /* Hann window formula */
-        window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE)))/FFT_SIZE;
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double max;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = max, i+=16)      /* calculate the      */
-  for(j=0, max = DBMIN;j<16;j++)                    /* maximum spectral   */
-     max = (max>power[i+j].x) ? max : power[i+j].x; /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #else
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = 10.0*log10(sum), i+=16)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<16;j++)      /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #endif
- 
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void II_tonal_label(power, tone)  /* this function extracts (tonal) */
- mask FAR power[HAN_SIZE];     /* sinusoidals from the spectrum  */
- int *tone;
- {
-  int i,j, last = LAST, first, run, last_but_one = LAST; /* dpwe */
-  double max;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE-12;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){               /* the conditions for the tonal          */
-     if(first<3 || first>500) run = 0;/* otherwise k+/-j will be out of bounds */
-     else if(first<63) run = 2;       /* components in layer II, which         */
-     else if(first<127) run = 3;      /* are the boundaries for calc.          */
-     else if(first<255) run = 6;      /* the tonal components                  */
-     else run = 12;
-     max = power[first].x - 7;        /* after calculation of tonal   */
-     for(j=2;j<=run;j++)              /* components, set to local max */
-        if(max < power[first-j].x || max < power[first+j].x){
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){   /* extract tonal components */
-        int help=first;
-        if(*tone==LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<500){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP;
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST); /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function groups all the remaining non-tonal
- * spectral lines into critical band where they are replaced by
- * one single line.
- *
- ****************************************************************/
-         
- void noise_label(power, noise, ltg)
- g_thres FAR *ltg;
- mask FAR *power;
- int *noise;
- {
-  int i,j, centre, last = LAST;
-  double index, weight, sum;
-                               /* calculate the remaining spectral */
-  for(i=0;i<crit_band-1;i++){  /* lines for non-tonal components   */
-      for(j=cbound[i],weight = 0.0,sum = DBMIN;j<cbound[i+1];j++){
-         if(power[j].type != TONE){
-            if(power[j].x != DBMIN){
-               sum = add_db(power[j].x,sum);
- /* the line below and others under the "MAKE_SENSE" condition are an alternate
-    interpretation of "geometric mean". This approach may make more sense but
-    it has not been tested with hardware. */
- #ifdef MAKE_SENSE
- /* weight += pow(10.0, power[j].x/10.0) * (ltg[power[j].map].bark-i);
-    bad code [SS] 21-1-93
-  */
-     weight += pow(10.0,power[j].x/10.0) * (double) (j-cbound[i]) /
-      (double) (cbound[i+1]-cbound[i]);  /* correction */
- #endif
-               power[j].x = DBMIN;
-            }
-         }   /*  check to see if the spectral line is low dB, and if  */
-      }      /* so replace the center of the critical band, which is */
-             /* the center freq. of the noise component              */
- 
- #ifdef MAKE_SENSE
-      if(sum <= DBMIN)  centre = (cbound[i+1]+cbound[i]) /2;
-      else {
-         index = weight/pow(10.0,sum/10.0);
-         centre = cbound[i] + (int) (index * (double) (cbound[i+1]-cbound[i]) );
-      } 
- #else
-      index = (double)( ((double)cbound[i]) * ((double)(cbound[i+1]-1)) );
-      centre = (int)(pow(index,0.5)+0.5);
- #endif
- 
-     /* locate next non-tonal component until finished; */
-     /* add to list of non-tonal components             */
- #ifdef MI_OPTION
-      /* Masahiro Iwadare's fix for infinite looping problem? */
-      if(power[centre].type == TONE) 
-        if (power[centre+1].type == TONE) centre++; else centre--;
- #else
-      /* Mike Li's fix for infinite looping problem */
-      if(power[centre].type == FALSE) centre++;
- 
-      if(power[centre].type == NOISE){
-        if(power[centre].x >= ltg[power[i].map].hear){
-          if(sum >= ltg[power[i].map].hear) sum = add_db(power[j].x,sum);
-          else
-          sum = power[centre].x;
-        }
-      }
- #endif
-      if(last == LAST) *noise = centre;
-      else {
-         power[centre].next = LAST;
-         power[last].next = centre;
-      }
-      power[centre].x = sum;
-      power[centre].type = NOISE;        
-      last = centre;
-  }        
- }
- 
- /****************************************************************
- *
- *        This function reduces the number of noise and tonal
- * component for further threshold analysis.
- *
- ****************************************************************/
- 
- void subsampling(power, ltg, tone, noise)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise;
- {
-  int i, old;
- 
-  i = *tone; old = STOP;    /* calculate tonal components for */
-  while(i!=LAST){           /* reduction of spectral lines    */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *tone = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *noise; old = STOP;    /* calculate non-tonal components for */
-  while(i!=LAST){            /* reduction of spectral lines        */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *noise = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *tone; old = STOP;
-  while(i != LAST){                              /* if more than one */
-     if(power[i].next == LAST)break;             /* tonal component  */
-     if(ltg[power[power[i].next].map].bark -     /* is less than .5  */
-        ltg[power[i].map].bark < 0.5) {          /* bark, take the   */
-        if(power[power[i].next].x > power[i].x ){/* maximum          */
-           if(old == STOP) *tone = power[i].next;
-           else power[old].next = power[i].next;
-           power[i].type = FALSE;
-           power[i].x = DBMIN;
-           i = power[i].next;
-        }
-        else {
-           power[power[i].next].type = FALSE;
-           power[power[i].next].x = DBMIN;
-           power[i].next = power[power[i].next].next;
-           old = i;
-        }
-     }
-     else {
-       old = i;
-       i = power[i].next;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function calculates the individual threshold and
- * sum with the quiet threshold to find the global threshold.
- *
- ****************************************************************/
- 
- void threshold(power, ltg, tone, noise, bit_rate)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise, bit_rate;
- {
-  int k, t;
-  double dz, tmps, vf;
- 
-  for(k=1;k<sub_size;k++){
-     ltg[k].x = DBMIN;
-     t = *tone;          /* calculate individual masking threshold for */
-     while(t != LAST){   /* components in order to find the global     */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 && /*threshold (LTG)*/
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value*/
-           tmps = -1.525-0.275*ltg[power[t].map].bark - 4.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;        
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
- 
-     t = *noise;        /* calculate individual masking threshold  */
-     while(t != LAST){  /* for non-tonal components to find LTG    */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 &&
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value */
-           tmps = -1.525-0.175*ltg[power[t].map].bark -0.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
-     if(bit_rate<96)ltg[k].x = add_db(ltg[k].hear, ltg[k].x);
-     else ltg[k].x = add_db(ltg[k].hear-12.0, ltg[k].x);
-  }
- }
- 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void II_minimum_mask(ltg,ltmin,sblimit)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- int sblimit;
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<sblimit;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>4 == i && j < sub_size){
-        if(min>ltg[j].x)  min = ltg[j].x;
-        j++;
-     }
-     ltmin[i] = min;
-  }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void II_smr(ltmin, spike, scale, sblimit)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- int sblimit;
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<sblimit;i++){                     /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10; /* level for each subband */
-     if(spike[i]>max) max = spike[i];         /* for the maximum scale  */
-     max -= ltmin[i];                         /* factors                */
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void II_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  layer *info = fr_ps->header;
-  int   stereo = fr_ps->stereo;
-  int   sblimit = fr_ps->sblimit;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D1408 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-      /* call functions for critical boundaries, freq. */
-  if(!init){  /* bands, bark values, and mapping */
-     fft_buf = (D1408 *) mem_alloc((long) sizeof(D1408) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for (i=0;i<1408;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){  /* check pcm input for 3 blocks of 384 samples */
-     for(i=0;i<1152;i++) fft_buf[k][(i+off[k])%1408]= (double)buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE;i++) sample[i] = fft_buf[k][(i+1216+off[k])%1408];
-     off[k] += 1152;
-     off[k] %= 1408;
-                             /* call functions for windowing PCM samples,*/
-     II_hann_win(sample);    /* location of spectral components in each  */
-     for(i=0;i<HAN_SIZE;i++) power[i].x = DBMIN;  /*subband with labeling*/
-     II_f_f_t(sample, power);                     /*locate remaining non-*/
-     II_pick_max(power, &spike[k][0]);            /*tonal sinusoidals,   */
-     II_tonal_label(power, &tone);                /*reduce noise & tonal */
-     noise_label(power, &noise, ltg);             /*components, find     */
-     subsampling(power, ltg, &tone, &noise);      /*global & minimal     */
-     threshold(power, ltg, &tone, &noise,         /*threshold, and sgnl- */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo); /*to-mask ratio*/
-     II_minimum_mask(ltg, &ltmin[k][0], sblimit);
-     II_smr(&ltmin[k][0], &spike[k][0], &scale[k][0], sblimit);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
- 
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer I. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void I_f_f_t(sample, power)         /* this function calculates */
- double FAR sample[FFT_SIZE/2];  /* an FFT analysis for the  */
- mask FAR power[HAN_SIZE/2];     /* freq. domain             */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT2), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT2), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT2), "energy");
-  for(i=0;i<FFT_SIZE/2;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT2), "rev");
-     w_r = (double *) mem_alloc(sizeof(D9), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D9), "w_i");
-     M = 9;
-     MM1 = 8;
-     N = FFT_SIZE/2;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE/2;rev[i] = l,i++) for(j=0,l=0;j<9;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(8-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE/2);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE/2;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE/2;i++){                     /* calculate power  */
-     if(energy[i] < 1E-20) energy[i] = 1E-20;    /* density spectrum */
-        power[i].x = 10 * log10(energy[i]) + POWERNORM;
-        power[i].next = STOP;
-        power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void I_hann_win(sample)             /* this function calculates a  */
- double FAR sample[FFT_SIZE/2];  /* Hann window for PCM (input) */
- {                                   /* samples for a 512-pt. FFT   */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT2), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE/2;i++){
-       /* Hann window formula */
-       window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE/2)))/(FFT_SIZE/2);
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE/2;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE/2];
- {
-  double max;
-  int i,j;
- 
-  /* calculate the spectral component in each subband */
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = max, i+=8)
-     for(j=0, max = DBMIN;j<8;j++) max = (max>power[i+j].x) ? max : power[i+j].x;
- }
- #else
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = 10.0*log10(sum), i+=8)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<8;j++)       /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
- #endif
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void I_tonal_label(power, tone)     /* this function extracts   */
- mask FAR power[HAN_SIZE/2];     /* (tonal) sinusoidals from */
- int *tone;                          /* the spectrum             */
- {
-  int i,j, last = LAST, first, run;
-  double max;
-  int last_but_one= LAST;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE/2-6;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){                /* conditions for the tonal     */
-     if(first<3 || first>250) run = 0; /* otherwise k+/-j will be out of bounds*/
-     else if(first<63) run = 2;        /* components in layer I, which */
-     else if(first<127) run = 3;       /* are the boundaries for calc.   */
-     else run = 6;                     /* the tonal components          */
-     max = power[first].x - 7;
-     for(j=2;j<=run;j++)  /* after calc. of tonal components, set to loc.*/
-        if(max < power[first-j].x || max < power[first+j].x){   /* max   */
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){    /* extract tonal components */
-        int help=first;
-        if(*tone == LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<255){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP; /*dpwe: 2nd was .x*/
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST) ; /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }                        
-                                 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void I_minimum_mask(ltg,ltmin)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<SBLIMIT;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>3 == i && j < sub_size){
-           if (min>ltg[j].x)  min = ltg[j].x;
-           j++;
-        }
-        ltmin[i] = min;
-     }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void I_smr(ltmin, spike, scale)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<SBLIMIT;i++){                      /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10;  /* level for each subband */
-     if(spike[i]>max) max = spike[i];          /* for the scalefactor    */
-     max -= ltmin[i];
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void I_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  int stereo = fr_ps->stereo;
-  the_layer info = fr_ps->header;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D640 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT2), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-             /* call functions for critical boundaries, freq. */
-  if(!init){ /* bands, bark values, and mapping              */
-     fft_buf = (D640 *) mem_alloc(sizeof(D640) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE/2, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for(i=0;i<640;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){    /* check PCM input for a block of */
-     for(i=0;i<384;i++)     /* 384 samples for a 512-pt. FFT  */
-        fft_buf[k][(i+off[k])%640]= (double) buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE/2;i++)
-        sample[i] = fft_buf[k][(i+448+off[k])%640];
-     off[k] += 384;
-     off[k] %= 640;
-                         /* call functions for windowing PCM samples,   */
-     I_hann_win(sample); /* location of spectral components in each     */
-     for(i=0;i<HAN_SIZE/2;i++) power[i].x = DBMIN;   /* subband with    */
-     I_f_f_t(sample, power);              /* labeling, locate remaining */
-     I_pick_max(power, &spike[k][0]);     /* non-tonal sinusoidals,     */
-     I_tonal_label(power, &tone);         /* reduce noise & tonal com., */
-     noise_label(power, &noise, ltg);     /* find global & minimal      */
-     subsampling(power, ltg, &tone, &noise);  /* threshold, and sgnl-   */
-     threshold(power, ltg, &tone, &noise,     /* to-mask ratio          */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo);
-     I_minimum_mask(ltg, &ltmin[k][0]);
-     I_smr(&ltmin[k][0], &spike[k][0], &scale[k][0]);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
--- 0 ----
diff -r -c -N encoder/util.c lame3.70/util.c
*** encoder/util.c	Wed Dec 31 17:00:00 1969
--- lame3.70/util.c	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,342 ----
+ #include "util.h"
+ #include <assert.h>
+ 
+ /***********************************************************************
+ *
+ *  Global Variable Definitions
+ *
+ ***********************************************************************/
+ 
+ 
+ /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
+ FLOAT8  s_freq_table[2][4] = {{22.05, 24, 16, 0}, {44.1, 48, 32, 0}};
+ 
+ /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
+ int     bitrate_table[2][15] = {
+           {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
+           {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}};
+ 
+ 
+ enum byte_order NativeByteOrder = order_unknown;
+ 
+ /***********************************************************************
+ *
+ *  Global Function Definitions
+ *
+ ***********************************************************************/
+ 
+ 
+ /***********************************************************************
+  * compute bitsperframe and mean_bits for a layer III frame 
+  **********************************************************************/
+ void getframebits(lame_global_flags *gfp,int *bitsPerFrame, int *mean_bits) {
+   int whole_SpF;
+   FLOAT8 bit_rate,samp;
+   int bitsPerSlot;
+   int sideinfo_len;
+   
+   samp =      gfp->out_samplerate/1000.0;
+   bit_rate = bitrate_table[gfp->version][gfp->bitrate_index];
+   bitsPerSlot = 8;
+ 
+   /* determine the mean bitrate for main data */
+   sideinfo_len = 32;
+   if ( gfp->version == 1 )
+     {   /* MPEG 1 */
+       if ( gfp->stereo == 1 )
+ 	sideinfo_len += 136;
+       else
+ 	sideinfo_len += 256;
+     }
+   else
+     {   /* MPEG 2 */
+       if ( gfp->stereo == 1 )
+ 	sideinfo_len += 72;
+       else
+ 	sideinfo_len += 136;
+     }
+   
+   if (gfp->error_protection) sideinfo_len += 16;
+   
+   /* -f fast-math option causes some strange rounding here, be carefull: */  
+   whole_SpF = floor( (gfp->framesize /samp)*(bit_rate /  (FLOAT8)bitsPerSlot) + 1e-9);
+   *bitsPerFrame = 8 * whole_SpF + (gfp->padding * 8);
+   *mean_bits = (*bitsPerFrame - sideinfo_len) / gfp->mode_gr;
+ }
+ 
+ 
+ 
+ 
+ void display_bitrates(FILE *out_fh)
+ {
+   int index,version;
+ 
+   version = 1;
+   fprintf(out_fh,"\n");
+   fprintf(out_fh,"MPEG1 samplerates(kHz): 32 44.1 48 \n");
+ 
+   fprintf(out_fh,"bitrates(kbs): ");
+   for (index=1;index<15;index++) {
+     fprintf(out_fh,"%i ",bitrate_table[version][index]);
+   }
+   fprintf(out_fh,"\n");
+   
+   
+   version = 0;
+   fprintf(out_fh,"\n");
+   fprintf(out_fh,"MPEG2 samplerates(kHz): 16 22.05 24 \n");
+   fprintf(out_fh,"bitrates(kbs): ");
+   for (index=1;index<15;index++) {
+     fprintf(out_fh,"%i ",bitrate_table[version][index]);
+   }
+   fprintf(out_fh,"\n");
+ }
+ 
+ 
+ int BitrateIndex(
+ int bRate,        /* legal rates from 32 to 448 */
+ int version,      /* MPEG-1 or MPEG-2 LSF */
+ int samplerate)   /* convert bitrate in kbps to index */
+ {
+ int     index = 0;
+ int     found = 0;
+ 
+     while(!found && index<15)   {
+         if(bitrate_table[version][index] == bRate)
+             found = 1;
+         else
+             ++index;
+     }
+     if(found)
+         return(index);
+     else {
+         fprintf(stderr,"Bitrate %dkbs not legal for %iHz output sampling.\n",
+                 bRate, samplerate);
+         return(-1);     /* Error! */
+     }
+ }
+ 
+ int SmpFrqIndex(  /* convert samp frq in Hz to index */
+ long sRate,             /* legal rates 16000, 22050, 24000, 32000, 44100, 48000 */
+ int  *version)
+ {
+ 	/* Assign default value */
+ 	*version=0;
+ 
+     if (sRate == 44100L) {
+         *version = 1; return(0);
+     }
+     else if (sRate == 48000L) {
+         *version = 1; return(1);
+     }
+     else if (sRate == 32000L) {
+         *version = 1; return(2);
+     }
+     else if (sRate == 24000L) {
+         *version = 0; return(1);
+     }
+     else if (sRate == 22050L) {
+         *version = 0; return(0);
+     }
+     else if (sRate == 16000L) {
+         *version = 0; return(2);
+     }
+     else {
+         fprintf(stderr, "SmpFrqIndex: %ldHz is not a legal sample rate\n", sRate);
+         return(-1);     /* Error! */
+     }
+ }
+ 
+ /*******************************************************************************
+ *
+ *  Allocate number of bytes of memory equal to "block".
+ *
+ *******************************************************************************/
+ /* exit(0) changed to exit(1) on memory allocation
+  * error -- 1999/06 Alvaro Martinez Echevarria */
+ 
+ void  *mem_alloc(unsigned long block, char *item)
+ {
+ 
+     void    *ptr;
+ 
+     /* what kind of shit does ISO put out?  */
+     ptr = (void *) malloc((size_t) block /* <<1 */ ); /* allocate twice as much memory as needed. fixes dodgy
+ 					    memory problem on most systems */
+ 
+ 
+     if (ptr != NULL) {
+         memset(ptr, 0, (size_t) block);
+     } else {
+         fprintf(stderr,"Unable to allocate %s\n", item);
+         exit(1);
+     }
+     return(ptr);
+ }
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  Routines to determine byte order and swap bytes
+ *
+ *****************************************************************************/
+ 
+ enum byte_order DetermineByteOrder(void)
+ {
+     char s[ sizeof(long) + 1 ];
+     union
+     {
+         long longval;
+         char charval[ sizeof(long) ];
+     } probe;
+     probe.longval = 0x41424344L;  /* ABCD in ASCII */
+     strncpy( s, probe.charval, sizeof(long) );
+     s[ sizeof(long) ] = '\0';
+     /* fprintf( stderr, "byte order is %s\n", s ); */
+     if ( strcmp(s, "ABCD") == 0 )
+         return order_bigEndian;
+     else
+         if ( strcmp(s, "DCBA") == 0 )
+             return order_littleEndian;
+         else
+             return order_unknown;
+ }
+ 
+ void SwapBytesInWords( short *loc, int words )
+ {
+     int i;
+     short thisval;
+     char *dst, *src;
+     src = (char *) &thisval;
+     for ( i = 0; i < words; i++ )
+     {
+         thisval = *loc;
+         dst = (char *) loc++;
+         dst[0] = src[1];
+         dst[1] = src[0];
+     }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  bit_stream.c package
+ *  Author:  Jean-Georges Fritsch, C-Cube Microsystems
+ *
+ *****************************************************************************/
+ 
+ /********************************************************************
+   This package provides functions to write (exclusive or read)
+   information from (exclusive or to) the bit stream.
+ 
+   If the bit stream is opened in read mode only the get functions are
+   available. If the bit stream is opened in write mode only the put
+   functions are available.
+ ********************************************************************/
+ 
+ /*alloc_buffer();      open and initialize the buffer;                    */
+ /*desalloc_buffer();   empty and close the buffer                         */
+ /*back_track_buffer();     goes back N bits in the buffer                 */
+ /*unsigned int get1bit();  read 1 bit from the bit stream                 */
+ /*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
+ /*                            changing the buffer pointer                   */
+ /*putbits(); write N bits from the bit stream */
+ /*int seek_sync(); return 1 if a sync word was found in the bit stream      */
+ /*                 otherwise returns 0                                      */
+ 
+ 
+ 
+ void empty_buffer(Bit_stream_struc *bs)
+ {
+    int minimum=1+bs->buf_byte_idx;    /* end of the buffer to empty */
+    if (bs->buf_size-minimum <= 0) return;
+    bs->buf_byte_idx = bs->buf_size -1;
+    bs->buf_bit_idx = 8;
+ 
+    bs->buf[bs->buf_byte_idx] = 0;  /* what does this do? */
+ 
+ }
+ int copy_buffer(char *buffer,int size,Bit_stream_struc *bs)
+ {
+   int i,j=0;
+   if (size!=0 && (bs->buf_size-1 - bs->buf_byte_idx) > size ) return -1;
+   for (i=bs->buf_size-1 ; i > bs->buf_byte_idx ; (i-- ))
+     buffer[j++]=bs->buf[i];
+   assert(j == (bs->buf_size-1 - bs->buf_byte_idx));
+   empty_buffer(bs);  /* empty buffer, (changes bs->buf_size) */
+   return j;
+ }
+ 
+ 
+ 
+ 
+ 
+ void init_bit_stream_w(Bit_stream_struc* bs)
+ {
+    alloc_buffer(bs, BUFFER_SIZE);
+    bs->buf_byte_idx = BUFFER_SIZE-1;
+    bs->buf_bit_idx=8;
+    bs->totbit=0;
+ }
+ 
+ 
+ /*open and initialize the buffer; */
+ void alloc_buffer(
+ Bit_stream_struc *bs,   /* bit stream structure */
+ int size)
+ {
+    bs->buf = (unsigned char *)
+ 	mem_alloc((unsigned long) (size * sizeof(unsigned char)), "buffer");
+    bs->buf_size = size;
+ }
+ 
+ /*empty and close the buffer */
+ void desalloc_buffer(Bit_stream_struc *bs)   /* bit stream structure */
+ {
+    free(bs->buf);
+ }
+ 
+ int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
+ 
+ 
+ /*write N bits into the bit stream */
+ void putbits(
+ Bit_stream_struc *bs,   /* bit stream structure */
+ unsigned int val,       /* val to write into the buffer */
+ int N)                  /* number of bits of val */
+ {
+  register int j = N;
+  register int k, tmp;
+ 
+  if (N > MAX_LENGTH)
+     fprintf(stderr,"Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
+ 
+  bs->totbit += N;
+  while (j > 0) {
+    k = Min(j, bs->buf_bit_idx);
+    tmp = val >> (j-k);
+    bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
+    bs->buf_bit_idx -= k;
+    if (!bs->buf_bit_idx) {
+        bs->buf_bit_idx = 8;
+        bs->buf_byte_idx--;
+        assert(bs->buf_byte_idx >= 0);
+        bs->buf[bs->buf_byte_idx] = 0;
+    }
+    j -= k;
+  }
+ }
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  End of bit_stream.c package
+ *
+ *****************************************************************************/
+ 
diff -r -c -N encoder/util.h lame3.70/util.h
*** encoder/util.h	Wed Dec 31 17:00:00 1969
--- lame3.70/util.h	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,158 ----
+ #ifndef UTIL_DOT_H
+ #define UTIL_DOT_H
+ /***********************************************************************
+ *
+ *  Global Include Files
+ *
+ ***********************************************************************/
+ #include "machine.h"
+ #include "encoder.h"
+ #include "lame.h"
+ 
+ /***********************************************************************
+ *
+ *  Global Definitions
+ *
+ ***********************************************************************/
+ 
+ /* General Definitions */
+ #ifndef FALSE
+ #define         FALSE                   0
+ #endif
+ 
+ #ifndef TRUE
+ #define         TRUE                    1
+ #endif
+ 
+ #define         MAX_U_32_NUM            0xFFFFFFFF
+ 
+ #ifndef PI
+ # ifdef M_PI
+ #  define       PI                      M_PI
+ # else
+ #  define       PI                      3.14159265358979323846
+ # endif
+ #endif
+ 
+ 
+ #ifdef M_LN2
+ # define        LOG2                    M_LN2
+ #else
+ # define        LOG2                    0.69314718055994530942
+ #endif
+ 
+ #ifdef M_LN10
+ # define        LOG10                   M_LN10
+ #else
+ # define        LOG10                   2.30258509299404568402
+ #endif
+ 
+ 
+ #ifdef M_SQRT2
+ # define        SQRT2                   M_SQRT2
+ #else
+ # define        SQRT2                   1.41421356237309504880
+ #endif
+ 
+ 
+ #define         BITS_IN_A_BYTE          8
+ #define         HAN_SIZE                512
+ #define         CRC16_POLYNOMIAL        0x8005
+ 
+ /* MPEG Header Definitions - Mode Values */
+ 
+ #define         MPG_MD_STEREO           0
+ #define         MPG_MD_JOINT_STEREO     1
+ #define         MPG_MD_DUAL_CHANNEL     2
+ #define         MPG_MD_MONO             3
+ 
+ /* Mode Extention */
+ 
+ #define         MPG_MD_LR_LR             0
+ #define         MPG_MD_LR_I              1
+ #define         MPG_MD_MS_LR             2
+ #define         MPG_MD_MS_I              3
+ 
+ 
+ /* "bit_stream.h" Definitions */
+ 
+ #define         MINIMUM         4    /* Minimum size of the buffer in bytes */
+ #define         MAX_LENGTH      32   /* Maximum length of word written or
+                                         read from bit stream */
+ #define         BUFFER_SIZE     LAME_MAXMP3BUFFER 
+ 
+ #define         Min(A, B)       ((A) < (B) ? (A) : (B))
+ #define         Max(A, B)       ((A) > (B) ? (A) : (B))
+ 
+ /***********************************************************************
+ *
+ *  Global Type Definitions
+ *
+ ***********************************************************************/
+ 
+ /* Structure for Reading Layer II Allocation Tables from File */
+ 
+ typedef struct {
+     unsigned int    steps;
+     unsigned int    bits;
+     unsigned int    group;
+     unsigned int    quant;
+ } sb_alloc, *alloc_ptr;
+ 
+ typedef sb_alloc        al_table[SBLIMIT][16]; 
+ 
+ /* Header Information Structure */
+ 
+ 
+ 
+ enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
+ extern enum byte_order NativeByteOrder;
+ 
+ /* "bit_stream.h" Type Definitions */
+ 
+ typedef struct  bit_stream_struc {
+     unsigned char*		pbtOutBuf;   /* for .DLL code */
+     int 			nOutBufPos;  /* for .DLL code */
+     FILE        *pt;            /* pointer to bit stream device */
+     unsigned char *buf;         /* bit stream buffer */
+     int         buf_size;       /* size of buffer (in number of bytes) */
+     unsigned long        totbit;         /* bit counter of bit stream */
+     int         buf_byte_idx;   /* pointer to top byte in buffer */
+     int         buf_bit_idx;    /* pointer to top bit of top byte in buffer */
+     
+     /* format of file in rd mode (BINARY/ASCII) */
+ } Bit_stream_struc;
+ 
+ #include "l3side.h"
+ 
+ /***********************************************************************
+ *
+ *  Global Variable External Declarations
+ *
+ ***********************************************************************/
+ 
+ extern int      bitrate_table[2][15];
+ 
+ /***********************************************************************
+ *
+ *  Global Function Prototype Declarations
+ *
+ ***********************************************************************/
+ 
+ extern void           display_bitrates(FILE *out_fh);
+ extern int            BitrateIndex(int, int,int);
+ extern int            SmpFrqIndex(long, int*);
+ extern void           *mem_alloc(unsigned long, char*);
+ extern int            copy_buffer(char *buffer,int buffer_size,Bit_stream_struc *bs);
+ extern void           init_bit_stream_w(Bit_stream_struc*);
+ extern void           alloc_buffer(Bit_stream_struc*, int);
+ extern void           desalloc_buffer(Bit_stream_struc*);
+ extern void           putbits(Bit_stream_struc*, unsigned int, int);
+ 
+ extern enum byte_order DetermineByteOrder(void);
+ extern void SwapBytesInWords( short *loc, int words );
+ 
+ extern void 
+ getframebits(lame_global_flags *gfp,int *bitsPerFrame, int *mean_bits);
+ 
+ #endif
diff -r -c -N encoder/vbrquantize.c lame3.70/vbrquantize.c
*** encoder/vbrquantize.c	Wed Dec 31 17:00:00 1969
--- lame3.70/vbrquantize.c	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,342 ----
+ /*
+  *	MP3 quantization
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ #include <assert.h>
+ #include "util.h"
+ #include "l3side.h"
+ #include "quantize.h"
+ #include "l3bitstream.h"
+ #include "reservoir.h"
+ #include "quantize-pvt.h"
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #endif
+ 
+ 
+ 
+ #define DEBUGXX
+ FLOAT8 calc_sfb_ave_noise(FLOAT8 *xr, FLOAT8 *xr34, int stride, int bw, FLOAT8 sfpow)
+ {
+   int j;
+   FLOAT8 xfsf=0;
+   FLOAT8 sfpow34 = pow(sfpow,3.0/4.0);
+ 
+   for ( j=0; j < stride*bw ; j += stride) {
+     int ix;
+     FLOAT8 temp,temp2;
+ 
+     /*    ix=(int)( xr34[j]/sfpow34  + 0.4054);*/
+     ix=floor( xr34[j]/sfpow34);
+     if (ix > IXMAX_VAL) return -1.0;
+ 
+     temp = fabs(xr[j])- pow43[ix]*sfpow;
+     if (ix < IXMAX_VAL) {
+       temp2 = fabs(xr[j])- pow43[ix+1]*sfpow;
+       if (fabs(temp2)<fabs(temp)) temp=temp2;
+     }
+ #ifdef MAXQUANTERROR
+     temp *= temp;
+     xfsf = bw*Max(xfsf,temp);
+ #else
+     xfsf += temp * temp;
+ #endif
+   }
+   return xfsf/bw;
+ }
+ 
+ 
+ 
+ FLOAT8 find_scalefac(FLOAT8 *xr,FLOAT8 *xr34,int stride,int sfb,
+ 		     FLOAT8 l3_xmin,int bw)
+ {
+   FLOAT8 xfsf,sfpow,sf,sf_ok,delsf;
+   int sf4,sf_ok4,delsf4;
+   int i;
+ 
+   /* search will range from sf:  -52.25 -> 11.25  */
+   /* search will range from sf4:  -209 -> 45  */
+   sf = -20.5;
+   sf4 = -82;
+   delsf = 32;
+   delsf4 = 128;
+ 
+   sf_ok =10000; 
+   sf_ok4=10000;
+   for (i=0; i<7; i++) {
+     delsf /= 2;
+     delsf4 /= 2;
+     sfpow = pow(2.0,sf);
+     /* sfpow = pow(2.0,sf4/4.0); */
+     xfsf = calc_sfb_ave_noise(xr,xr34,stride,bw,sfpow);
+ 
+     if (xfsf < 0) {
+       /* scalefactors too small */
+       sf += delsf; 
+       sf4 += delsf4;
+     }else{
+       if (sf_ok==10000) sf_ok=sf;  
+       if (sf_ok4==10000) sf_ok4=sf4;  
+       if (xfsf > l3_xmin)  {
+ 	/* distortion.  try a smaller scalefactor */
+ 	sf -= delsf;
+ 	sf4 -= delsf4;
+       }else{
+ 	sf_ok=sf;
+ 	sf_ok4 = sf4;
+ 	sf += delsf;
+ 	sf4 += delsf4;
+       }
+     }
+   } 
+   /* sf_ok accurate to within +/- 2*final_value_of_delsf */
+   assert(sf_ok!=10000);
+ 
+   /* NOTE: noise is not a monotone function of the sf, even though
+    * the number of bits used is!  do a brute force search in the 
+    * neighborhood of sf_ok: 
+    * 
+    *  sf = sf_ok + 1.75     works  1% of the time 
+    *  sf = sf_ok + 1.50     works  1% of the time 
+    *  sf = sf_ok + 1.25     works  2% of the time 
+    *  sf = sf_ok + 1.00     works  3% of the time 
+    *  sf = sf_ok + 0.75     works  9% of the time 
+    *  sf = sf_ok + 0.50     0 %  (because it was tried above)
+    *  sf = sf_ok + 0.25     works 39% of the time 
+    *  sf = sf_ok + 0.00     works the rest of the time
+    */
+ 
+   sf = sf_ok + 0.75;
+   sf4 = sf_ok4 + 3;
+ 
+   while (sf>(sf_ok+.01)) { 
+     /* sf = sf_ok + 2*delsf was tried above, skip it:  */
+     if (fabs(sf-(sf_ok+2*delsf))  < .01) sf -=.25;
+     if (sf4 == sf_ok4+2*delsf4) sf4 -=1;
+ 
+     sfpow = pow(2.0,sf);
+     /* sfpow = pow(2.0,sf4/4.0) */
+     xfsf = calc_sfb_ave_noise(xr,xr34,stride,bw,sfpow);
+     if (xfsf > 0) {
+       if (xfsf <= l3_xmin) return sf;
+     }
+     sf -= .25;
+     sf4 -= 1;
+   }
+   return sf_ok;
+ }
+ 
+ 
+ 
+ /*
+     sfb=0..5  scalefac < 16 
+     sfb>5     scalefac < 8
+ 
+     ifqstep = ( cod_info->scalefac_scale == 0 ) ? .5 : 1.0;
+     ol_sf =  (cod_info->global_gain-210.0)/4.0;
+     ol_sf -= 2*cod_info->subblock_gain[i];
+     ol_sf -= ifqstep*scalefac[gr][ch].s[sfb][i];
+ */
+ FLOAT8 compute_scalefacs_short(FLOAT8 vbrsf[SBPSY_s][3],gr_info *cod_info,int scalefac[SBPSY_s][3])
+ {
+   FLOAT8 maxrange,maxover;
+   FLOAT8 sf[SBPSY_s][3];
+   int sfb,i;
+   int ifqstep_inv = ( cod_info->scalefac_scale == 0 ) ? 2 : 1;
+ 
+   /* make a working copy of the desired scalefacs */
+   memcpy(sf,vbrsf,SBPSY_s*3*sizeof(FLOAT8));
+ 
+   /* see if we should use subblock gain */
+ 
+ 
+   maxover=0;
+   for ( sfb = 0; sfb < SBPSY_s; sfb++ ) {
+     for (i=0; i<3; ++i) {
+       /* ifqstep*scalefac + 2*subblock_gain >= -sf[sfb] */
+       scalefac[sfb][i]=floor( -sf[sfb][i]*ifqstep_inv  +.75 + .0001)   ;
+       
+       if (sfb < 6) maxrange = 15.0/ifqstep_inv;
+       else maxrange = 7.0/ifqstep_inv;
+       
+       if (maxrange + sf[sfb][i] > maxover) maxover = maxrange+sf[sfb][i];
+     }
+   }
+   return maxover;
+ }
+ 
+ 
+ 
+ 
+ /*
+ 	  sfb=0..10  scalefac < 16 
+ 	  sfb>10     scalefac < 8
+ 		
+ 	  ifqstep = ( cod_info->scalefac_scale == 0 ) ? .5 : 1.0;
+ 	  ol_sf =  (cod_info->global_gain-210.0)/4.0;
+ 	  ol_sf -= ifqstep*scalefac[gr][ch].l[sfb];
+ 	  if (cod_info->preflag && sfb>=11) 
+ 	  ol_sf -= ifqstep*pretab[sfb];
+ */
+ FLOAT8 compute_scalefacs_long(FLOAT8 vbrsf[SBPSY_l],gr_info *cod_info,int scalefac[SBPSY_l])
+ {
+   int sfb;
+   FLOAT8 sf[SBPSY_l];
+   FLOAT8 maxrange,maxover;
+   int ifqstep_inv = ( cod_info->scalefac_scale == 0 ) ? 2 : 1;
+ 
+   /* make a working copy of the desired scalefacs */
+   memcpy(sf,vbrsf,SBPSY_l*sizeof(FLOAT8));
+ 
+   cod_info->preflag=0;
+   for ( sfb = 11; sfb < SBPSY_l; sfb++ ) {
+     if (sf[sfb] + pretab[sfb]/ifqstep_inv > 0) break;
+   }
+   if (sfb==SBPSY_l) {
+     cod_info->preflag=1;
+     for ( sfb = 11; sfb < SBPSY_l; sfb++ ) 
+       sf[sfb] += pretab[sfb]/ifqstep_inv;
+   }
+ 
+   maxover=0;
+   for ( sfb = 0; sfb < SBPSY_l; sfb++ ) {
+     /* ifqstep*scalefac >= -sf[sfb] */
+     scalefac[sfb]=floor( -sf[sfb]*ifqstep_inv  +.75 + .0001)   ;
+ 
+     if (sfb < 11) maxrange = 15.0/ifqstep_inv;
+     else maxrange = 7.0/ifqstep_inv;
+ 
+     if (maxrange + sf[sfb] > maxover) maxover = maxrange+sf[sfb];
+   }
+   return maxover;
+ }
+   
+   
+ 
+ 
+ 
+ /************************************************************************
+  *
+  * VBR_iteration_loop()   
+  *
+  *
+  ************************************************************************/
+ void
+ VBR_iteration_loop_new (lame_global_flags *gfp,
+                 FLOAT8 pe[2][2], FLOAT8 ms_ener_ratio[2],
+                 FLOAT8 xr[2][2][576], III_psy_ratio ratio[2][2],
+                 III_side_info_t * l3_side, int l3_enc[2][2][576],
+                 III_scalefac_t scalefac[2][2])
+ {
+   III_psy_xmin l3_xmin[2][2];
+   FLOAT8    masking_lower_db;
+   FLOAT8    ifqstep;
+   int       start,end,bw,sfb, i,ch, gr, over;
+   III_psy_xmin vbrsf;
+   FLOAT8 vbrmax;
+ 
+ 
+   iteration_init(gfp,l3_side,l3_enc);
+ 
+   /* Adjust allowed masking based on quality setting */
+   /* db_lower varies from -10 to +8 db */
+   masking_lower_db = -10 + 2*gfp->VBR_q;
+   /* adjust by -6(min)..0(max) depending on bitrate */
+   masking_lower = pow(10.0,masking_lower_db/10);
+   masking_lower = 1;
+ 
+ 
+   for (gr = 0; gr < gfp->mode_gr; gr++) {
+     if (convert_mdct)
+       ms_convert(xr[gr],xr[gr]);
+     for (ch = 0; ch < gfp->stereo; ch++) { 
+       FLOAT8 xr34[576];
+       gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
+       int shortblock;
+       over = 0;
+       shortblock = (cod_info->block_type == SHORT_TYPE);
+ 
+       for(i=0;i<576;i++) {
+ 	FLOAT8 temp=fabs(xr[gr][ch][i]);
+ 	xr34[i]=sqrt(sqrt(temp)*temp);
+       }
+ 
+       calc_xmin( gfp,xr[gr][ch], &ratio[gr][ch], cod_info, &l3_xmin[gr][ch]);
+ 
+       vbrmax=0;
+       if (shortblock) {
+ 	for ( sfb = 0; sfb < SBPSY_s; sfb++ )  {
+ 	  for ( i = 0; i < 3; i++ ) {
+ 	    start = scalefac_band.s[ sfb ];
+ 	    end   = scalefac_band.s[ sfb+1 ];
+ 	    bw = end - start;
+ 	    vbrsf.s[sfb][i] = find_scalefac(&xr[gr][ch][3*start+i],&xr34[3*start+i],3,sfb,
+ 		   masking_lower*l3_xmin[gr][ch].s[sfb][i],bw);
+ 	    if (vbrsf.s[sfb][i]>vbrmax) vbrmax=vbrsf.s[sfb][i];
+ 	  }
+ 	}
+       }else{
+ 	for ( sfb = 0; sfb < SBPSY_l; sfb++ )   {
+ 	  start = scalefac_band.l[ sfb ];
+ 	  end   = scalefac_band.l[ sfb+1 ];
+ 	  bw = end - start;
+ 	  vbrsf.l[sfb] = find_scalefac(&xr[gr][ch][start],&xr34[start],1,sfb,
+ 	  		 masking_lower*l3_xmin[gr][ch].l[sfb],bw);
+ 	  if (vbrsf.l[sfb]>vbrmax) vbrmax = vbrsf.l[sfb];
+ 	}
+ 
+       } /* compute scalefactors */
+ 
+       /* sf =  (cod_info->global_gain-210.0)/4.0; */
+       cod_info->global_gain = floor(4*vbrmax +210 + .5);
+ 
+ 
+       if (shortblock) {
+ 	for ( sfb = 0; sfb < SBPSY_s; sfb++ ) {
+ 	  for ( i = 0; i < 3; i++ ) {
+ 	    vbrsf.s[sfb][i] -= vbrmax;
+ 	  }
+ 	}
+ 	cod_info->scalefac_scale = 0;
+ 	if (compute_scalefacs_short(vbrsf.s,cod_info,scalefac[gr][ch].s) > 0) {
+ 	  cod_info->scalefac_scale = 1;
+ 	  if (compute_scalefacs_short(vbrsf.s,cod_info,scalefac[gr][ch].s) >0) {
+ 	    /* what do we do now? */
+ 	    exit(32);
+ 	  }
+ 	}
+       }else{
+ 	for ( sfb = 0; sfb < SBPSY_l; sfb++ )   
+ 	  vbrsf.l[sfb] -= vbrmax;
+ 
+ 	/* can we get away with scalefac_scale=0? */
+ 	cod_info->scalefac_scale = 0;
+ 	if (compute_scalefacs_long(vbrsf.l,cod_info,scalefac[gr][ch].l) > 0) {
+ 	  cod_info->scalefac_scale = 1;
+ 	  if (compute_scalefacs_long(vbrsf.l,cod_info,scalefac[gr][ch].l) >0) {
+ 	    /* what do we do now? */
+ 	    exit(32);
+ 	  }
+ 	}
+       } 
+     } /* ch */
+   } /* gr */
+ }
+ 
+ 
+ 
diff -r -c -N encoder/version.c lame3.70/version.c
*** encoder/version.c	Wed Dec 31 17:00:00 1969
--- lame3.70/version.c	Fri Mar 10 13:56:35 2000
***************
*** 0 ****
--- 1,69 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ 
+ #include "version.h"
+ #include "lame.h"
+ #include <stdio.h>
+ 
+ static char lpszVersion[80];
+ 
+ void lame_print_version(FILE *ofile) {
+   fprintf(ofile,"LAME version %s (www.sulaco.org/mp3) \n",get_lame_version());
+   fprintf(ofile,"GPSYCHO: GPL psycho-acoustic and noise shaping model version %s. \n",get_psy_version());
+ #ifdef LIBSNDFILE
+   fprintf(ofile,"Input handled by libsndfile (www.zip.com.au/~erikd/libsndfile)\n");
+ #endif
+ }
+ 
+ 
+ char* get_lame_version(void)
+ {
+ 	if (LAME_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_ALPHAVERSION);
+ 	else if (LAME_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",LAME_MAJOR_VERSION,LAME_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_psy_version(void)
+ {
+ 	if (PSY_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_ALPHAVERSION);
+ 	else if (PSY_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",PSY_MAJOR_VERSION,PSY_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_mp3x_version(void)
+ {
+ 	if (MP3X_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (alpha %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_ALPHAVERSION);
+ 	else if (MP3X_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (beta %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d:%02d",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION);
+ 	return lpszVersion;
+ }
diff -r -c -N encoder/version.h lame3.70/version.h
*** encoder/version.h	Wed Dec 31 17:00:00 1969
--- lame3.70/version.h	Thu Apr  6 12:50:52 2000
***************
*** 0 ****
--- 1,46 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This library is free software; you can redistribute it and/or
+  * modify it under the terms of the GNU Library General Public
+  * License as published by the Free Software Foundation; either
+  * version 2 of the License, or (at your option) any later version.
+  *
+  * This library is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+  * Library General Public License for more details.
+  *
+  * You should have received a copy of the GNU Library General Public
+  * License along with this library; if not, write to the
+  * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  * Boston, MA 02111-1307, USA.
+  */
+ 
+ #ifndef LAME_H_INCLUDED
+ #define LAME_H_INCLUDED
+ 
+ #define LAME_MAJOR_VERSION	3	/* Major version number */
+ #define LAME_MINOR_VERSION	70	/* Minor version number */
+ #define LAME_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define LAME_BETAVERSION        0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define PSY_MAJOR_VERSION	0	/* Major version number */
+ #define PSY_MINOR_VERSION	77	/* Minor version number */
+ #define PSY_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define PSY_BETAVERSION		0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define MP3X_MAJOR_VERSION	0	/* Major version number */
+ #define MP3X_MINOR_VERSION	82	/* Minor version number */
+ #define MP3X_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define MP3X_BETAVERSION	0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #include "machine.h"
+ void lame_print_version(FILE *);
+ char* get_lame_version(void);		/* returns lame version number string */
+ char* get_psy_version(void);		/* returns psy model version number string */
+ char* get_mp3x_version(void);		/* returns mp3x version number string */
+ 
+ #endif

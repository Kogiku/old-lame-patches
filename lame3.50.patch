diff -r -c -N encoder/COPYING lame3.50/COPYING
*** encoder/COPYING	Wed Dec 31 17:00:00 1969
--- lame3.50/COPYING	Mon Nov  1 18:17:59 1999
***************
*** 0 ****
--- 1,340 ----
+ 		    GNU GENERAL PUBLIC LICENSE
+ 		       Version 2, June 1991
+ 
+  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+      59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+  Everyone is permitted to copy and distribute verbatim copies
+  of this license document, but changing it is not allowed.
+ 
+ 			    Preamble
+ 
+   The licenses for most software are designed to take away your
+ freedom to share and change it.  By contrast, the GNU General Public
+ License is intended to guarantee your freedom to share and change free
+ software--to make sure the software is free for all its users.  This
+ General Public License applies to most of the Free Software
+ Foundation's software and to any other program whose authors commit to
+ using it.  (Some other Free Software Foundation software is covered by
+ the GNU Library General Public License instead.)  You can apply it to
+ your programs, too.
+ 
+   When we speak of free software, we are referring to freedom, not
+ price.  Our General Public Licenses are designed to make sure that you
+ have the freedom to distribute copies of free software (and charge for
+ this service if you wish), that you receive source code or can get it
+ if you want it, that you can change the software or use pieces of it
+ in new free programs; and that you know you can do these things.
+ 
+   To protect your rights, we need to make restrictions that forbid
+ anyone to deny you these rights or to ask you to surrender the rights.
+ These restrictions translate to certain responsibilities for you if you
+ distribute copies of the software, or if you modify it.
+ 
+   For example, if you distribute copies of such a program, whether
+ gratis or for a fee, you must give the recipients all the rights that
+ you have.  You must make sure that they, too, receive or can get the
+ source code.  And you must show them these terms so they know their
+ rights.
+ 
+   We protect your rights with two steps: (1) copyright the software, and
+ (2) offer you this license which gives you legal permission to copy,
+ distribute and/or modify the software.
+ 
+   Also, for each author's protection and ours, we want to make certain
+ that everyone understands that there is no warranty for this free
+ software.  If the software is modified by someone else and passed on, we
+ want its recipients to know that what they have is not the original, so
+ that any problems introduced by others will not reflect on the original
+ authors' reputations.
+ 
+   Finally, any free program is threatened constantly by software
+ patents.  We wish to avoid the danger that redistributors of a free
+ program will individually obtain patent licenses, in effect making the
+ program proprietary.  To prevent this, we have made it clear that any
+ patent must be licensed for everyone's free use or not licensed at all.
+ 
+   The precise terms and conditions for copying, distribution and
+ modification follow.
+ 
+ 		    GNU GENERAL PUBLIC LICENSE
+    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+ 
+   0. This License applies to any program or other work which contains
+ a notice placed by the copyright holder saying it may be distributed
+ under the terms of this General Public License.  The "Program", below,
+ refers to any such program or work, and a "work based on the Program"
+ means either the Program or any derivative work under copyright law:
+ that is to say, a work containing the Program or a portion of it,
+ either verbatim or with modifications and/or translated into another
+ language.  (Hereinafter, translation is included without limitation in
+ the term "modification".)  Each licensee is addressed as "you".
+ 
+ Activities other than copying, distribution and modification are not
+ covered by this License; they are outside its scope.  The act of
+ running the Program is not restricted, and the output from the Program
+ is covered only if its contents constitute a work based on the
+ Program (independent of having been made by running the Program).
+ Whether that is true depends on what the Program does.
+ 
+   1. You may copy and distribute verbatim copies of the Program's
+ source code as you receive it, in any medium, provided that you
+ conspicuously and appropriately publish on each copy an appropriate
+ copyright notice and disclaimer of warranty; keep intact all the
+ notices that refer to this License and to the absence of any warranty;
+ and give any other recipients of the Program a copy of this License
+ along with the Program.
+ 
+ You may charge a fee for the physical act of transferring a copy, and
+ you may at your option offer warranty protection in exchange for a fee.
+ 
+   2. You may modify your copy or copies of the Program or any portion
+ of it, thus forming a work based on the Program, and copy and
+ distribute such modifications or work under the terms of Section 1
+ above, provided that you also meet all of these conditions:
+ 
+     a) You must cause the modified files to carry prominent notices
+     stating that you changed the files and the date of any change.
+ 
+     b) You must cause any work that you distribute or publish, that in
+     whole or in part contains or is derived from the Program or any
+     part thereof, to be licensed as a whole at no charge to all third
+     parties under the terms of this License.
+ 
+     c) If the modified program normally reads commands interactively
+     when run, you must cause it, when started running for such
+     interactive use in the most ordinary way, to print or display an
+     announcement including an appropriate copyright notice and a
+     notice that there is no warranty (or else, saying that you provide
+     a warranty) and that users may redistribute the program under
+     these conditions, and telling the user how to view a copy of this
+     License.  (Exception: if the Program itself is interactive but
+     does not normally print such an announcement, your work based on
+     the Program is not required to print an announcement.)
+ 
+ These requirements apply to the modified work as a whole.  If
+ identifiable sections of that work are not derived from the Program,
+ and can be reasonably considered independent and separate works in
+ themselves, then this License, and its terms, do not apply to those
+ sections when you distribute them as separate works.  But when you
+ distribute the same sections as part of a whole which is a work based
+ on the Program, the distribution of the whole must be on the terms of
+ this License, whose permissions for other licensees extend to the
+ entire whole, and thus to each and every part regardless of who wrote it.
+ 
+ Thus, it is not the intent of this section to claim rights or contest
+ your rights to work written entirely by you; rather, the intent is to
+ exercise the right to control the distribution of derivative or
+ collective works based on the Program.
+ 
+ In addition, mere aggregation of another work not based on the Program
+ with the Program (or with a work based on the Program) on a volume of
+ a storage or distribution medium does not bring the other work under
+ the scope of this License.
+ 
+   3. You may copy and distribute the Program (or a work based on it,
+ under Section 2) in object code or executable form under the terms of
+ Sections 1 and 2 above provided that you also do one of the following:
+ 
+     a) Accompany it with the complete corresponding machine-readable
+     source code, which must be distributed under the terms of Sections
+     1 and 2 above on a medium customarily used for software interchange; or,
+ 
+     b) Accompany it with a written offer, valid for at least three
+     years, to give any third party, for a charge no more than your
+     cost of physically performing source distribution, a complete
+     machine-readable copy of the corresponding source code, to be
+     distributed under the terms of Sections 1 and 2 above on a medium
+     customarily used for software interchange; or,
+ 
+     c) Accompany it with the information you received as to the offer
+     to distribute corresponding source code.  (This alternative is
+     allowed only for noncommercial distribution and only if you
+     received the program in object code or executable form with such
+     an offer, in accord with Subsection b above.)
+ 
+ The source code for a work means the preferred form of the work for
+ making modifications to it.  For an executable work, complete source
+ code means all the source code for all modules it contains, plus any
+ associated interface definition files, plus the scripts used to
+ control compilation and installation of the executable.  However, as a
+ special exception, the source code distributed need not include
+ anything that is normally distributed (in either source or binary
+ form) with the major components (compiler, kernel, and so on) of the
+ operating system on which the executable runs, unless that component
+ itself accompanies the executable.
+ 
+ If distribution of executable or object code is made by offering
+ access to copy from a designated place, then offering equivalent
+ access to copy the source code from the same place counts as
+ distribution of the source code, even though third parties are not
+ compelled to copy the source along with the object code.
+ 
+   4. You may not copy, modify, sublicense, or distribute the Program
+ except as expressly provided under this License.  Any attempt
+ otherwise to copy, modify, sublicense or distribute the Program is
+ void, and will automatically terminate your rights under this License.
+ However, parties who have received copies, or rights, from you under
+ this License will not have their licenses terminated so long as such
+ parties remain in full compliance.
+ 
+   5. You are not required to accept this License, since you have not
+ signed it.  However, nothing else grants you permission to modify or
+ distribute the Program or its derivative works.  These actions are
+ prohibited by law if you do not accept this License.  Therefore, by
+ modifying or distributing the Program (or any work based on the
+ Program), you indicate your acceptance of this License to do so, and
+ all its terms and conditions for copying, distributing or modifying
+ the Program or works based on it.
+ 
+   6. Each time you redistribute the Program (or any work based on the
+ Program), the recipient automatically receives a license from the
+ original licensor to copy, distribute or modify the Program subject to
+ these terms and conditions.  You may not impose any further
+ restrictions on the recipients' exercise of the rights granted herein.
+ You are not responsible for enforcing compliance by third parties to
+ this License.
+ 
+   7. If, as a consequence of a court judgment or allegation of patent
+ infringement or for any other reason (not limited to patent issues),
+ conditions are imposed on you (whether by court order, agreement or
+ otherwise) that contradict the conditions of this License, they do not
+ excuse you from the conditions of this License.  If you cannot
+ distribute so as to satisfy simultaneously your obligations under this
+ License and any other pertinent obligations, then as a consequence you
+ may not distribute the Program at all.  For example, if a patent
+ license would not permit royalty-free redistribution of the Program by
+ all those who receive copies directly or indirectly through you, then
+ the only way you could satisfy both it and this License would be to
+ refrain entirely from distribution of the Program.
+ 
+ If any portion of this section is held invalid or unenforceable under
+ any particular circumstance, the balance of the section is intended to
+ apply and the section as a whole is intended to apply in other
+ circumstances.
+ 
+ It is not the purpose of this section to induce you to infringe any
+ patents or other property right claims or to contest validity of any
+ such claims; this section has the sole purpose of protecting the
+ integrity of the free software distribution system, which is
+ implemented by public license practices.  Many people have made
+ generous contributions to the wide range of software distributed
+ through that system in reliance on consistent application of that
+ system; it is up to the author/donor to decide if he or she is willing
+ to distribute software through any other system and a licensee cannot
+ impose that choice.
+ 
+ This section is intended to make thoroughly clear what is believed to
+ be a consequence of the rest of this License.
+ 
+   8. If the distribution and/or use of the Program is restricted in
+ certain countries either by patents or by copyrighted interfaces, the
+ original copyright holder who places the Program under this License
+ may add an explicit geographical distribution limitation excluding
+ those countries, so that distribution is permitted only in or among
+ countries not thus excluded.  In such case, this License incorporates
+ the limitation as if written in the body of this License.
+ 
+   9. The Free Software Foundation may publish revised and/or new versions
+ of the General Public License from time to time.  Such new versions will
+ be similar in spirit to the present version, but may differ in detail to
+ address new problems or concerns.
+ 
+ Each version is given a distinguishing version number.  If the Program
+ specifies a version number of this License which applies to it and "any
+ later version", you have the option of following the terms and conditions
+ either of that version or of any later version published by the Free
+ Software Foundation.  If the Program does not specify a version number of
+ this License, you may choose any version ever published by the Free Software
+ Foundation.
+ 
+   10. If you wish to incorporate parts of the Program into other free
+ programs whose distribution conditions are different, write to the author
+ to ask for permission.  For software which is copyrighted by the Free
+ Software Foundation, write to the Free Software Foundation; we sometimes
+ make exceptions for this.  Our decision will be guided by the two goals
+ of preserving the free status of all derivatives of our free software and
+ of promoting the sharing and reuse of software generally.
+ 
+ 			    NO WARRANTY
+ 
+   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+ FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+ OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+ PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+ OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+ TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+ PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+ REPAIR OR CORRECTION.
+ 
+   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+ WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+ REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+ INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+ OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+ TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+ YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+ PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+ POSSIBILITY OF SUCH DAMAGES.
+ 
+ 		     END OF TERMS AND CONDITIONS
+ 
+ 	    How to Apply These Terms to Your New Programs
+ 
+   If you develop a new program, and you want it to be of the greatest
+ possible use to the public, the best way to achieve this is to make it
+ free software which everyone can redistribute and change under these terms.
+ 
+   To do so, attach the following notices to the program.  It is safest
+ to attach them to the start of each source file to most effectively
+ convey the exclusion of warranty; and each file should have at least
+ the "copyright" line and a pointer to where the full notice is found.
+ 
+     <one line to give the program's name and a brief idea of what it does.>
+     Copyright (C) 19yy  <name of author>
+ 
+     This program is free software; you can redistribute it and/or modify
+     it under the terms of the GNU General Public License as published by
+     the Free Software Foundation; either version 2 of the License, or
+     (at your option) any later version.
+ 
+     This program is distributed in the hope that it will be useful,
+     but WITHOUT ANY WARRANTY; without even the implied warranty of
+     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+     GNU General Public License for more details.
+ 
+     You should have received a copy of the GNU General Public License
+     along with this program; if not, write to the Free Software
+     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ 
+ 
+ Also add information on how to contact you by electronic and paper mail.
+ 
+ If the program is interactive, make it output a short notice like this
+ when it starts in an interactive mode:
+ 
+     Gnomovision version 69, Copyright (C) 19yy name of author
+     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+     This is free software, and you are welcome to redistribute it
+     under certain conditions; type `show c' for details.
+ 
+ The hypothetical commands `show w' and `show c' should show the appropriate
+ parts of the General Public License.  Of course, the commands you use may
+ be called something other than `show w' and `show c'; they could even be
+ mouse-clicks or menu items--whatever suits your program.
+ 
+ You should also get your employer (if you work as a programmer) or your
+ school, if any, to sign a "copyright disclaimer" for the program, if
+ necessary.  Here is a sample; alter the names:
+ 
+   Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+   `Gnomovision' (which makes passes at compilers) written by James Hacker.
+ 
+   <signature of Ty Coon>, 1 April 1989
+   Ty Coon, President of Vice
+ 
+ This General Public License does not permit incorporating your program into
+ proprietary programs.  If your program is a subroutine library, you may
+ consider it more useful to permit linking proprietary applications with the
+ library.  If this is what you want to do, use the GNU Library General
+ Public License instead of this License.
diff -r -c -N encoder/Dll/BladeMP3EncDLL.c lame3.50/Dll/BladeMP3EncDLL.c
*** encoder/Dll/BladeMP3EncDLL.c	Wed Dec 31 17:00:00 1969
--- lame3.50/Dll/BladeMP3EncDLL.c	Mon Oct 18 12:25:28 1999
***************
*** 0 ****
--- 1,474 ----
+ /*
+  *	Blade DLL Interface for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "machine.h"
+ #include "BladeMP3EncDLL.h"
+ #include <assert.h>
+ #include "util.h"
+ #include "version.h"
+ #include "VbrTag.h"
+ #include "lame.h"
+ #include "get_audio.h"
+ #include "globalflags.h"
+ 
+ 
+ 
+ const int MAJORVERSION=1;
+ const int MINORVERSION=02;
+ 
+ static short int InputBuffer[2][1152];
+ 
+ int nBladeBufferSize;
+ 
+ // Local variables
+ static int		nPsychoModel=2;
+ static BOOL		bFirstFrame=TRUE;
+ static DWORD	dwSampleBufferSize=0;
+ 
+ 
+ #ifdef _DEBUG
+ void dump_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath);
+ #endif
+ 
+ // Taken from main.c
+ static char			original_file_name[MAX_NAME_SIZE];
+ static char			encoded_file_name[MAX_NAME_SIZE];
+ static int			stereo, error_protection;
+ static layer		info;
+ 
+ 
+ extern Bit_stream_struc   bs;
+ extern III_side_info_t l3_side;
+ extern frame_params fr_ps;
+ 
+ static void InitParams()
+ {
+     // clear buffers
+     memset(InputBuffer, 0,sizeof(InputBuffer));
+     bFirstFrame=TRUE;
+     // Initialize output buffer
+     bs.pbtOutBuf=NULL;
+     bs.nOutBufPos=0;
+     lame_init(1);  /* 1 means LAME will do no output file I/O */
+ //    InitSndFile();  /* only needed because we will not be calling OpenSndFile */
+ 
+ }
+ 
+ #define NORMAL_QUALITY 0
+ #define LOW_QUALITY 1
+ #define HIGH_QUALITY 2
+ 
+ #define GPL_PSYCHOMODEL 0
+ #define ISO_PSYCHOMODEL 1
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream)
+ {
+ #define MAX_ARGV 20
+ 
+ 	char	strTmp[255];
+ 	int		nDllArgC=0;
+ 	char	DllArgV[20][80];
+ 	char*	argv[MAX_ARGV];
+ 	int		i;
+ 	int		nCRC=pbeConfig->format.mp3.bCRC;
+ 	int		nVBR;
+ 	int		nQuality;
+ 
+ 	// Get VBR setting from fourth nibble
+ 	nVBR=(nCRC>>12)&0x0F;
+ 	// Get Quality from third nibble
+ 	nQuality=(nCRC>>8)&0x0F;
+ 	// Get model from lower nibble (to be compatible with standard definition)
+ 	nCRC=(nCRC&0x01);
+ 
+ 	for (i=0;i<MAX_ARGV;i++)
+ 		argv[i]=DllArgV[i];
+ 
+ 	// Clear the external and local paramters
+ 	InitParams();
+ 
+ 	// Clear argument array
+ 	memset(&DllArgV[0][0],0x00,sizeof(DllArgV));
+ 
+ 	// Not used, always assign stream 1
+ 	*phbeStream=1;
+ 
+ 	// Set MP3 buffer size
+ 	*dwBufferSize=BUFFER_SIZE*2;
+ 
+ 
+ 	// Set number of input samples depending on the number of samples
+ 	if ((pbeConfig->format.mp3.byMode&0x0F)== BE_MP3_MODE_MONO)
+ 	{
+ 		// Mono channel, thus MPEGFRAMSIZE samples needed
+ 		*dwSamples=1152;
+ 	}
+ 	else
+ 	{
+ 		// For Stereo.Joint stereo and dual channel, need 2*MPEGFRAMESIZE samples
+ 		*dwSamples=1152*2;
+ 	}
+ 
+ 	// Set the input sample buffer size, so we know what we can expect
+ 	dwSampleBufferSize=*dwSamples;
+ 	
+ 	// --------------- Set arguments for ParseArg function -------------------------
+ 
+ 	// Set zero argument, the filename
+ 	strcpy(DllArgV[nDllArgC++],"LameDLLEncoder");
+ 
+   	switch (pbeConfig->format.mp3.byMode)
+ 	{
+ 		case BE_MP3_MODE_STEREO:
+ 			strcpy(DllArgV[nDllArgC++],"-ms");
+ 		break;
+ 		case BE_MP3_MODE_JSTEREO:
+ 			strcpy(DllArgV[nDllArgC++],"-mj");
+ 		break;
+ 		case BE_MP3_MODE_MONO:
+ 			strcpy(DllArgV[nDllArgC++],"-mm");
+ 		break;
+ 		case BE_MP3_MODE_DUALCHANNEL:
+ 			strcpy(DllArgV[nDllArgC++],"-mf");
+ 		break;
+ 		default:
+ 			return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ 	}
+ 
+ 	switch (nQuality)
+ 	{
+ 		case NORMAL_QUALITY:	// Nothing special
+ 		break;
+ 		case LOW_QUALITY:		// -f flag
+ 			strcpy(DllArgV[nDllArgC++],"-f");
+ 		break;
+ 		case HIGH_QUALITY:		// -k flag for high qualtiy
+ 			strcpy(DllArgV[nDllArgC++],"-k");
+ 		break;
+ 	}
+ 
+ 	if (nVBR)
+ 	{
+ 		// 0=no vbr 1..10 is VBR quality setting -1
+ 		sprintf(DllArgV[nDllArgC++],"-v");
+ 		sprintf(DllArgV[nDllArgC++],"-V%d",nVBR-1);
+ 	}
+ 
+ 	// Set frequency
+ 	sprintf(strTmp,"-s %f",pbeConfig->format.mp3.dwSampleRate/1000.0);
+ 	strcpy(DllArgV[nDllArgC++],strTmp);
+ 
+ 	// Set bitrate
+ 	sprintf(strTmp,"-b %d",pbeConfig->format.mp3.wBitrate);
+ 	strcpy(DllArgV[nDllArgC++],strTmp);
+ 	
+ 	// Set copyright flag?
+     if (pbeConfig->format.mp3.bCopyright)
+ 		strcpy(DllArgV[nDllArgC++],"-c");
+ 
+ 	// Do we have to tag  it as non original 
+     if (!pbeConfig->format.mp3.bOriginal)
+ 		strcpy(DllArgV[nDllArgC++],"-o");
+ 
+ 	// Add CRC?
+     if (nCRC)
+ 		strcpy(DllArgV[nDllArgC++],"-p");
+ 
+ 	// Add input filename
+ 	strcpy(DllArgV[nDllArgC++],"NULL.wav");
+ 
+ 	// Add output filename
+ 	strcpy(DllArgV[nDllArgC++],"NULL.mp3");
+ 
+ 
+ 	// Set the encoder variables
+ 	lame_parse_args(nDllArgC,argv);
+ 
+ 	// Set private bit?
+ 	if (pbeConfig->format.mp3.bPrivate)
+ 	{
+ 		info.extension = 0;
+ 	}
+ 	else
+ 	{
+ 		info.extension = 1;
+ 	}
+ 
+ 
+ 	//hdr_to_frps(&fr_ps);  /* now called in parse_args */
+ 
+     stereo = fr_ps.stereo;
+ 
+     error_protection = info.error_protection;
+ 
+     if (info.lay != 3)
+ 	{
+ 		printf("Only Layer 3 supported\n");
+ 		return BE_ERR_INVALID_FORMAT_PARAMETERS;
+     }
+ 
+ #ifdef _DEBUG
+ 	dump_config(&fr_ps,&nPsychoModel,original_file_name,encoded_file_name);
+ #endif
+ 
+ 	// Everything went OK, thus return SUCCESSFUL
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 	// Set output buffer
+ 	bs.pbtOutBuf=pOutput;
+ 	bs.nOutBufPos=0;
+ 
+ 	// Crank out the last part of the buffer
+ 	if (fr_ps.header->lay == 3 )
+ 		III_FlushBitstream();
+ 
+ 	// close the stream
+ 	//close_bit_stream_w( &bs );  /* routine removed */
+ 
+ 	// Flush last bytes
+ 	//write_buffer(&bs, 1+bs.buf_byte_idx);  /* ouput to mp3 file */
+ 	*pdwOutput = copy_buffer((char*)&bs.pbtOutBuf[bs.nOutBufPos],&bs);
+ 	empty_buffer(&bs);  /* empty buffer */
+ 
+ 	// Number of bytes in output buffer
+ 	bs.nOutBufPos= *pdwOutput;
+ 
+ 	// Deallocate all buffers
+ 	desalloc_buffer(&bs);
+ 
+ 	// Everything went OK, thus return SUCCESSFUL
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream)
+ {
+ 	// DeInit encoder
+ //	return DeInitEncoder();
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ 
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion)
+ {
+ 	// DLL Release date
+ 	char lpszDate[20];
+ 	char lpszTemp[5];
+ 
+ 
+ 	// Set DLL interface version
+ 	pbeVersion->byDLLMajorVersion=MAJORVERSION;
+ 	pbeVersion->byDLLMinorVersion=MINORVERSION;
+ 
+ 	// Set Engine version number (Same as Lame version)
+ 	pbeVersion->byMajorVersion=LAME_MAJOR_VERSION;
+ 	pbeVersion->byMinorVersion=LAME_MINOR_VERSION;
+ 
+ 	// Get compilation date
+ 	strcpy(lpszDate,__DATE__);
+ 
+ 	// Get the first three character, which is the month
+ 	strncpy(lpszTemp,lpszDate,3);
+ 
+ 	// Set month
+ 	if (strcmp(lpszTemp,"Jan")==0)	pbeVersion->byMonth=1;
+ 	if (strcmp(lpszTemp,"Feb")==0)	pbeVersion->byMonth=2;
+ 	if (strcmp(lpszTemp,"Mar")==0)	pbeVersion->byMonth=3;
+ 	if (strcmp(lpszTemp,"Apr")==0)	pbeVersion->byMonth=4;
+ 	if (strcmp(lpszTemp,"May")==0)	pbeVersion->byMonth=5;
+ 	if (strcmp(lpszTemp,"Jun")==0)	pbeVersion->byMonth=6;
+ 	if (strcmp(lpszTemp,"Jul")==0)	pbeVersion->byMonth=7;
+ 	if (strcmp(lpszTemp,"Aug")==0)	pbeVersion->byMonth=8;
+ 	if (strcmp(lpszTemp,"Sep")==0)	pbeVersion->byMonth=9;
+ 	if (strcmp(lpszTemp,"Oct")==0)	pbeVersion->byMonth=10;
+ 	if (strcmp(lpszTemp,"Nov")==0)	pbeVersion->byMonth=11;
+ 	if (strcmp(lpszTemp,"Dec")==0)	pbeVersion->byMonth=12;
+ 
+ 	// Get day of month string (char [4..5])
+ 	pbeVersion->byDay=atoi(lpszDate+4);
+ 
+ 	// Get year of compilation date (char [7..10])
+ 	pbeVersion->wYear=atoi(lpszDate+7);
+ 
+ 	memset(pbeVersion->zHomepage,0x00,BE_MAX_HOMEPAGE);
+ 
+ 	strcpy(pbeVersion->zHomepage,"http://www.surf.to/cdex");
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput)
+ {
+ 	int iSampleIndex;
+ 
+ 	// Set output buffer
+ 	bs.pbtOutBuf=pOutput;
+ 	bs.nOutBufPos=0;
+ /*
+ 	if (g_bFirstFrame)
+ 	{
+ 		// Write initial VBR Header to bitstream
+ 		InitVbrTag(&bs,info->version-1,info->mode,info->sampling_frequency);
+ 		if (!lame_nowrite) 
+ 		  write_buffer(&bs);
+ 		empty_buffer(&bs);
+ 	}
+ */
+ 	// Is this the last (incomplete) frame
+ 	if (nSamples<dwSampleBufferSize)
+ 	{
+ 		// Padd with zeros
+ 		memset(pSamples+nSamples,0x00,(dwSampleBufferSize-nSamples)*sizeof(SHORT));
+ 	}
+ 
+ 	// Set buffer size, in number of bytes
+ 	nBladeBufferSize=nSamples*sizeof(SHORT);
+ 
+ 	if (stereo==2)
+ 	{
+ 		for (iSampleIndex=0;iSampleIndex<1152;iSampleIndex++)
+ 		{
+ 			// Copy new sample data into InputBuffer
+ 			InputBuffer[0][iSampleIndex]=*pSamples++;
+ 			InputBuffer[1][iSampleIndex]=*pSamples++;
+ 		}
+ 	}
+ 	else
+ 	{
+ 		// Mono, only put it data into buffer[0] (=left channel)
+ 		for (iSampleIndex=0;iSampleIndex<1152;iSampleIndex++)
+ 		{
+ 			// Copy new sample data into InputBuffer
+ 			InputBuffer[0][iSampleIndex]=*pSamples++;
+ 		}
+ 	}
+ 
+ 
+ 	// Encode it
+ 	*pdwOutput=lame_encode(InputBuffer,(char*)&bs.pbtOutBuf[bs.nOutBufPos]);
+ 
+ 	// Set number of output bytes
+ 	bs.nOutBufPos=*pdwOutput;
+ 
+ 	return BE_ERR_SUCCESSFUL;
+ }
+ 
+ 
+ __declspec(dllexport) BE_ERR beWriteVBRHeader(LPCSTR lpszFileName)
+ {
+ 	if (g_bWriteVbrTag)
+ 	{
+ 		// Calculate relative quality of VBR stream 
+ 		// 0=best, 100=worst
+ 		int nQuality=VBR_q*100/9;
+ 
+ 		// Write Xing header again
+ 		return PutVbrTag((LPSTR)lpszFileName,nQuality);
+ 	}
+ 	return BE_ERR_INVALID_FORMAT_PARAMETERS;
+ }
+ 
+ 
+ BOOL APIENTRY DllMain(HANDLE hModule, 
+                       DWORD  ul_reason_for_call, 
+                       LPVOID lpReserved)
+ {
+     switch( ul_reason_for_call )
+ 	{
+ 		case DLL_PROCESS_ATTACH:
+ 			OutputDebugString("Attach Process \n");
+ 		break;
+ 		case DLL_THREAD_ATTACH:
+ 			OutputDebugString("Attach Thread \n");
+ 		break;
+ 		case DLL_THREAD_DETACH:
+ 			OutputDebugString("Detach Thread \n");
+ 		break;
+ 		case DLL_PROCESS_DETACH:
+ 			OutputDebugString("Detach Process \n");
+ 		break;
+     }
+     return TRUE;
+ }
+ 
+ 
+ #ifdef _DEBUG
+ void dump_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
+ {
+ 	layer *info = fr_ps->header;
+ 	char strTmp[255];
+ 
+ 	OutputDebugString("Encoding configuration:\n");
+ 
+ 	sprintf(strTmp,"Algorithm=%s\n", version_names[info->version]);
+ 	OutputDebugString(strTmp);
+ 
+ 	if(info->mode != MPG_MD_JOINT_STEREO)
+ 	{
+ 		sprintf(strTmp,"Layer=%s   mode=%s   extn=%d   psy model=%d\n",layer_names[info->lay-1], mode_names[info->mode],info->mode_ext, *psy);
+ 		OutputDebugString(strTmp);
+ 	}
+ 	else
+ 	{
+ 		sprintf(strTmp,"Layer=%s   mode=%s   extn=data dependant   psy model=%d\n",layer_names[info->lay-1], mode_names[info->mode], *psy);
+ 		OutputDebugString(strTmp);
+ 	}
+ 
+ 	sprintf(strTmp,"samp frq=%.1f kHz   total bitrate=%d kbps\n",s_freq[info->version][info->sampling_frequency],bitrate[info->version][info->lay-1][info->bitrate_index]);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",info->emphasis, info->copyright, info->original,((info->error_protection) ? "on" : "off"));
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"16 Khz cut off is %s\n",(sfb21)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Fast mode is %s\n",(fast_mode)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Force ms %s\n",(force_ms)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"GPsycho acoustic model is %s\n",(gpsycho)?"enabled":"disabled");
+ 	OutputDebugString(strTmp);
+ 
+ 
+ 	sprintf(strTmp,"input file: '%s'   output file: '%s'\n", inPath, outPath);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Encoding %s to %s\n",inPath,outPath);
+ 	OutputDebugString(strTmp);
+ 
+ 	sprintf(strTmp,"Encoding as %.1f kHz %d kbps %s MPEG-1 LayerIII file\n",s_freq[info->version][info->sampling_frequency],bitrate[info->version][info->lay-1][info->bitrate_index],mode_names[info->mode]);
+ 	OutputDebugString(strTmp);
+ }
+ 
+ 
+ void DispErr(LPSTR strErr)
+ {
+ 	MessageBox(NULL,strErr,"",MB_OK);
+ }
+ 
+ #endif
diff -r -c -N encoder/Dll/BladeMP3EncDLL.def lame3.50/Dll/BladeMP3EncDLL.def
*** encoder/Dll/BladeMP3EncDLL.def	Wed Dec 31 17:00:00 1969
--- lame3.50/Dll/BladeMP3EncDLL.def	Mon Oct 18 12:27:22 1999
***************
*** 0 ****
--- 1,9 ----
+ LIBRARY  lame_enc.DLL
+ EXPORTS
+ 
+ beInitStream		@1
+ beEncodeChunk		@2
+ beDeinitStream		@3
+ beCloseStream		@4
+ beVersion			@5
+ beWriteVBRHeader	@6
\ No newline at end of file
diff -r -c -N encoder/Dll/BladeMP3EncDLL.h lame3.50/Dll/BladeMP3EncDLL.h
*** encoder/Dll/BladeMP3EncDLL.h	Wed Dec 31 17:00:00 1969
--- lame3.50/Dll/BladeMP3EncDLL.h	Fri Sep 10 09:52:00 1999
***************
*** 0 ****
--- 1,150 ----
+ /*
+ 
+ 	bladedll.h
+ 
+     +++++++++++++++++++++++++++
+ 	+   Blade's Encoder DLL   +
+ 	+++++++++++++++++++++++++++
+ 
+     ------------------------------------------------------
+ 	- Version 1.00 (7 November 1998) - Jukka Poikolainen -
+ 	------------------------------------------------------
+ 
+ 	Initial version
+ 	
+ 	------------------------------------------------------
+ 	- Version x.xx (x xxxxxxxx xxxx) - xxxxx xxxxxxxxxxx -
+ 	------------------------------------------------------
+ 
+ */
+ 
+ #ifndef ___BLADEDLL_H_INCLUDED___
+ #define ___BLADEDLL_H_INCLUDED___
+ 
+ #pragma pack(push)
+ #pragma pack(1)
+ 
+ /* encoding formats */
+ 
+ #define		BE_CONFIG_MP3			0										
+ 
+ /* type definitions */
+ 
+ typedef		unsigned long			HBE_STREAM;
+ typedef		HBE_STREAM				*PHBE_STREAM;
+ typedef		unsigned long			BE_ERR;
+ 
+ /* error codes */
+ 
+ #define		BE_ERR_SUCCESSFUL					0x00000000
+ #define		BE_ERR_INVALID_FORMAT				0x00000001
+ #define		BE_ERR_INVALID_FORMAT_PARAMETERS	0x00000002
+ #define		BE_ERR_NO_MORE_HANDLES				0x00000003
+ #define		BE_ERR_INVALID_HANDLE				0x00000004
+ 
+ /* other constants */
+ 
+ #define		BE_MAX_HOMEPAGE			256
+ 
+ /* format specific variables */
+ 
+ #define		BE_MP3_MODE_STEREO		0
+ #define		BE_MP3_MODE_JSTEREO		1
+ #define		BE_MP3_MODE_DUALCHANNEL	2
+ #define		BE_MP3_MODE_MONO		3
+ 
+ #ifdef _BLADEDLL
+ #undef FLOAT
+ 	#include <Windows.h>
+ #endif
+ 
+ typedef struct	{
+ 	
+ 	DWORD	dwConfig;			// BE_CONFIG_XXXXX
+ 								// Currently only BE_CONFIG_MP3 is supported
+ 	union	{
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;	// 48000, 44100 and 32000 allowed
+ 			BYTE	byMode;			// BE_MP3_MODE_STEREO, BE_MP3_MODE_DUALCHANNEL, BE_MP3_MODE_MONO
+ 			WORD	wBitrate;		// 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256 and 320 allowed
+ 			BOOL	bPrivate;		
+ 			BOOL	bCRC;
+ 			BOOL	bCopyright;
+ 			BOOL	bOriginal;
+ 
+ 			} mp3;					// BE_CONFIG_MP3
+ 
+ 		struct	{
+ 
+ 			DWORD	dwSampleRate;
+ 			BYTE	byMode;
+ 			WORD	wBitrate;
+ 			BYTE	byEncodingMethod;
+ 
+ 		} aac;
+ 
+ 	} format;
+ 		
+ } BE_CONFIG, *PBE_CONFIG;
+ 
+ typedef struct	{
+ 
+ 	// BladeEnc DLL Version number
+ 
+ 	BYTE	byDLLMajorVersion;
+ 	BYTE	byDLLMinorVersion;
+ 
+ 	// BladeEnc Engine Version Number
+ 
+ 	BYTE	byMajorVersion;
+ 	BYTE	byMinorVersion;
+ 
+ 	// DLL Release date
+ 
+ 	BYTE	byDay;
+ 	BYTE	byMonth;
+ 	WORD	wYear;
+ 
+ 	// BladeEnc	Homepage URL
+ 
+ 	CHAR	zHomepage[BE_MAX_HOMEPAGE + 1];	
+ 
+ } BE_VERSION, *PBE_VERSION;			
+ 
+ #ifndef _BLADEDLL
+ 
+ typedef BE_ERR	(*BEINITSTREAM)		(PBE_CONFIG, PDWORD, PDWORD, PHBE_STREAM);
+ typedef BE_ERR	(*BEENCODECHUNK)	(HBE_STREAM, DWORD, PSHORT, PBYTE, PDWORD);
+ typedef BE_ERR	(*BEDEINITSTREAM)	(HBE_STREAM, PBYTE, PDWORD);
+ typedef BE_ERR	(*BECLOSESTREAM)	(HBE_STREAM);
+ typedef VOID	(*BEVERSION)		(PBE_VERSION);
+ 
+ #define	TEXT_BEINITSTREAM	"beInitStream"
+ #define	TEXT_BEENCODECHUNK	"beEncodeChunk"
+ #define	TEXT_BEDEINITSTREAM	"beDeinitStream"
+ #define	TEXT_BECLOSESTREAM	"beCloseStream"
+ #define	TEXT_BEVERSION		"beVersion"
+ 
+ /*	
+ 	BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ 	BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ 	BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ 	VOID	beVersion(PBE_VERSION pbeVersion);		
+ */
+ 	
+ #else
+ 
+ __declspec(dllexport) BE_ERR	beInitStream(PBE_CONFIG pbeConfig, PDWORD dwSamples, PDWORD dwBufferSize, PHBE_STREAM phbeStream);
+ __declspec(dllexport) BE_ERR	beEncodeChunk(HBE_STREAM hbeStream, DWORD nSamples, PSHORT pSamples, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beDeinitStream(HBE_STREAM hbeStream, PBYTE pOutput, PDWORD pdwOutput);
+ __declspec(dllexport) BE_ERR	beCloseStream(HBE_STREAM hbeStream);
+ __declspec(dllexport) VOID		beVersion(PBE_VERSION pbeVersion);
+ 
+ #endif
+ 
+ #pragma pack(pop)
+ 
+ #endif
diff -r -c -N encoder/Dll/MP3EncDll.dsp lame3.50/Dll/MP3EncDll.dsp
*** encoder/Dll/MP3EncDll.dsp	Wed Dec 31 17:00:00 1969
--- lame3.50/Dll/MP3EncDll.dsp	Mon Oct 18 12:36:24 1999
***************
*** 0 ****
--- 1,273 ----
+ # Microsoft Developer Studio Project File - Name="MP3EncDll" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+ 
+ CFG=MP3EncDll - Win32 Debug
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "MP3EncDll.mak" CFG="MP3EncDll - Win32 Debug"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "MP3EncDll - Win32 Release" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE "MP3EncDll - Win32 Debug" (based on\
+  "Win32 (x86) Dynamic-Link Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ MTL=midl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "MP3EncDll - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MT /W3 /GX /O2 /Ob2 /I "..\\" /D "NDEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL" /YX /FD -Qmem -Qip /c
+ # ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "NDEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /map /machine:I386 /out:"..\..\lame_enc.dll"
+ 
+ !ELSEIF  "$(CFG)" == "MP3EncDll - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /Zp2 /MTd /W3 /Gm /GX /Zi /Od /I "..\\" /D "_DEBUG" /D "WIN32" /D "_WINDOWS" /D "_BLADEDLL" /YX /FD /c
+ # ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD MTL /nologo /D "_DEBUG" /mktyplib203 /o NUL /win32
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /dll /debug /machine:I386 /out:"..\..\lame_enc.dll" /pdbtype:sept
+ # SUBTRACT LINK32 /map
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "MP3EncDll - Win32 Release"
+ # Name "MP3EncDll - Win32 Debug"
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.def
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\BladeMP3EncDLL.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fastmdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fastmdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fft.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\fft.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\filterbank.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\globalflags.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gpkplotting.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gpkplotting.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gtkanal.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\gtkanal.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\lame.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\lame.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\psymodel.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\psymodel.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE="..\quantize-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\quantize.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\quantize.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\sqrttab.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\tables.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\takehiro.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\util.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\util.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\version.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=..\wavheader.h
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/Dll/MP3EncDll.dsw lame3.50/Dll/MP3EncDll.dsw
*** encoder/Dll/MP3EncDll.dsw	Wed Dec 31 17:00:00 1969
--- lame3.50/Dll/MP3EncDll.dsw	Fri Sep 10 09:52:00 1999
***************
*** 0 ****
--- 1,29 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "MP3EncDll"=.\MP3EncDll.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/INSTALL lame3.50/INSTALL
*** encoder/INSTALL	Wed Jan 22 02:43:12 1997
--- lame3.50/INSTALL	Mon Sep 27 15:10:17 1999
***************
*** 1,36 ****
  Building the MPEG audio encoding software:
  
- If you have gnu make and are on a Unix-type system, you should only have to
- type:
  
- ./configure
- make
  
! This will create a Makefile customized to your environment, overwriting the
! previous Makefile, using Makefile.in as a template.
  
- For other systems you may have to modify the Makefile. Some flags of
- interest are:
  
- BS_FORMAT
-   Set to BINARY to work with most MPEG audio decoders (and save space). You
-   can set it to ASCII, but your bitstream will only work with musicout().
  
! HAVE_NINT
!   Define this if your math library already has nint().
  
- NDEBUG
-   Define this to turn off all the assertions. Don't define this if you
-   are developing code.
  
- DEBUG
-   Define this to get debugging messages printed to stdout.
  
- For non-Unix systems you may have to define other things. Be sure to look
- at common.h. If you build this on a Macintosh, be sure to use a fairly
- recent set of Universal Headers. I have built this code on SunOS 4.1 and
- Linux 1.3 (using gcc 2.6.3), and on the Power Macintosh (using Metrowerks
- CodeWarrior 6).
  
  
- <mc@fivebats.com> 1995/10/16
--- 1,53 ----
+ LAME 3.xx    9/99 Mark Taylor (http://www.sulaco.org/mp3)
+ 
+ =======================================================================
  Building the MPEG audio encoding software:
+ =======================================================================
+ If you are reading this, you have already applied the patch to the
+ dist10 ISO demonstration source (or downloaded a full source
+ distrubtion).  If you do not have GTK 1.1.16 or higher, or do not want
+ the graphical frame analyzer (it uses a lot of memory), edit the
+ Makefile and dont define GTK and GTKLIBS.  If you have trouble with
+ libncurses/libtermcap, you can also disable that in the Makefile.
+ 
+ Now just type:
+ 
+ % make
+ 
+ If it doesn't work, figure out why and send me the fix!  
+ If you are using a newer version of EGCS, check the Makefile.
+ There are some flags which may improve performance.
+ 
+ LAME has built in support for 16bit raw pcm, aiff and simple wav
+ formats.  Some complex .wav headers will confuse LAME If you have
+ trouble with this, or want to encode from other sound formats, you can
+ now compile LAME to use Erik de Castro Lopo's libsndfile.  To use
+ libsndfile in LAME:
+ 
+   1. install libsndfile (see http://www.zip.com.au/~erikd/libsndfile/).  
+   2. set SNDLIB and LIBSNDFILE as shown in the LAME Makefile.  
+   3. make clean ; make
+ 
+ Thanks to Albert Faber for adding the libsndfile support!
+ 
+ LAME can also be compiled into a BladeEnc compatiable MS Windows .dll 
+ file.  See the Dll/ directory for details. 
  
  
  
! =======================================================================
! To encode:
! =======================================================================
! see the file "USAGE" for some usage guidlines.
  
  
  
! =======================================================================
! Portability
! =======================================================================
! LAME 3.x has been run on every modern OS.  see the Makefile.
  
  
  
  
  
diff -r -c -N encoder/Makefile lame3.50/Makefile
*** encoder/Makefile	Wed Jan 22 02:43:23 1997
--- lame3.50/Makefile	Mon Nov  1 18:23:02 1999
***************
*** 1,68 ****
! # Generated automatically from Makefile.in by configure.
! ############################################################################
! ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
! ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
! ##
! ## $Id: Makefile,v 1.2 1996/08/14 23:18:34 rowlands Exp $
! ##
! ## Makefile for encoder. Requies GNU make.
! ##
! ## $Log: Makefile,v $
! ## Revision 1.2  1996/08/14 23:18:34  rowlands
! ## Cleanups.
! ##
! ## Revision 1.2  1996/02/14 05:18:05  rowlands
! ## Cleanups.
! ##
! ## Revision 1.1  1996/02/14 04:04:23  rowlands
! ## Initial revision
! ##
! ## Received from Mike Coleman
! ############################################################################
  
  CC = gcc
  
  c_sources = \
- 	common.c \
- 	encode.c \
  	formatBitstream.c \
! 	huffman.c \
! 	ieeefloat.c \
  	l3bitstream.c \
! 	l3psy.c \
! 	loop.c \
! 	mdct.c \
! 	musicin.c \
  	portableio.c \
! 	psy.c \
  	reservoir.c \
! 	subs.c \
! 	tonal.c
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
- NINT_SWITCH = 
- 
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
- 
- PGM = encode
- 
- LIBS =  -lm
  
  
  %.o: %.c 
  	$(CC) $(CC_SWITCHES) -c $< -o $@
  
  %.d: %.c
! 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
  
  
! $(PGM):	$(OBJ) Makefile
! 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
  
  clean:
! 	-rm $(OBJ) $(DEP)
  
  tags: TAGS
  
--- 1,254 ----
! # Makefile for LAME 3.xx
! #
! # LAME is reported to work under:  
! # Linux (i86), NetBSD 1.3.2 (StrongARM), FreeBSD (i86)
! # Compaq Alpha(OSF, Linux, Tru64 Unix), Sun Solaris, SGI IRIX,
! # OS2 Warp, Macintosh PPC, BeOS, Amiga and even VC++ 
! # 
! UNAME = $(shell uname)
! ARCH = $(shell uname -m)
  
+ 
+ # defaults:
+ PGM = lame
  CC = gcc
+ CC_OPTS = -O   	
+ GTK = 
+ GTKLIBS = 
+ SNDLIB = 
+ LIBSNDFILE =
+ LIBS = -lm 
+ MAKEDEP = -M
+ BRHIST_SWITCH = 
+ LIBTERMCAP = 
+ 
+ 
+ ##########################################################################
+ # Define these to produce a VBR bitrate histogram.  Requires libtermcap.
+ # You can also use the more modern ncurses but it doesn't work as well.
+ # If you have any trouble, just dont use termcap/ncurses.
+ ##########################################################################
+ #BRHIST_SWITCH = -DBRHIST
+ #LIBTERMCAP = -ltermcap
+ 
+ 
+ ##########################################################################
+ # define these to use Erik de Castro Lopo's libsndfile 
+ # http://www.zip.com.au/~erikd/libsndfile/
+ # otherwise LAME can only read 16bit wav, aiff and pcm inputfiles.
+ # Note: at present, libsndfile does not support input from stdin.  
+ ##########################################################################
+ #SNDLIB = -DLIBSNDFILE
+ #LIBSNDFILE=-lsndfile 
+ # if libsndfile is in a custom location, try:
+ #LIBSNDFILE=-L $(LIBSNDHOME) -lsndfile  -I $(LIBSNDHOME)
+ 
+ 
+ ##########################################################################
+ # define these to use compile in support for the GTK mp3 frame analyzer
+ ##########################################################################
+ #GTK = -DHAVEGTK `gtk-config --cflags`
+ #GTKLIBS = `gtk-config --libs` 
+ 
+ 
+ ##########################################################################
+ # LINUX   
+ ##########################################################################
+ ifeq ($(UNAME),Linux)
+ #  remove if you do not have GTK or do not want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk-config --cflags`
+    GTKLIBS = `gtk-config --libs` 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -ltermcap
+ 
+ #  for debugging:
+ #   CC_OPTS =  -UNDEBUG  -O -Wall -g -DABORTFP 
+ 
+ #  for lots of debugging:
+ #   CC_OPTS =  -DDEBUG -UNDEBUG  -O -Wall -g -DABORTFP -DNO_LEONID
+ 
+ 
+ # suggested for gcc-2.7.x
+ #   CC_OPTS =    -O3 -fomit-frame-pointer -funroll-loops -ffast-math \
+ #                    -finline-functions 
+ 
+ # these options were suggested with egcs-990524
+ #   CC = egcs
+ #   CC_OPTS =    -O9 -fomit-frame-pointer -march=pentiumpro \
+ #                   -ffast-math -funroll-loops \
+ #                  -fprofile-arcs -fbranch-probabilities
+ 
+ 
+ 
+ ##########################################################################
+ # LINUX on Digital/Compaq Alpha CPUs
+ ##########################################################################
+ ifeq ($(ARCH),alpha)
+ # double is faster than float on Alpha
+ CC_OPTS =       -O4 -Wall -fomit-frame-pointer -ffast-math -funroll-loops \
+                 -mfp-regs -fschedule-insns -fschedule-insns2 \
+                 -finline-functions \
+                 -DFLOAT=double
+ # standard Linux libm
+ LIBS	=	-lm  
+ # optimized libffm (free fast math library)
+ #LIBS	=	-lffm  
+ # Compaq's fast math library
+ #LIBS    =       -lcpml 
+ endif
+ endif
+ 
+ 
+ 
+ ##########################################################################
+ # FreeBSD
+ ##########################################################################
+ ifeq ($(UNAME),FreeBSD)
+ #  remove if you do not have GTK or do not want the GTK frame analyzer
+    GTK = -DHAVEGTK `gtk12-config --cflags`
+    GTKLIBS = `gtk12-config --libs` 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -lncurses
+ 
+ endif
+ 
+ 
+ ##########################################################################
+ # SunOS
+ ##########################################################################
+ ifeq ($(UNAME),SunOS) 
+    CC = cc
+    CC_OPTS = -O -xCC  	
+    MAKEDEP = -xM
+ endif
+ 
+ 
+ ##########################################################################
+ # SGI
+ ##########################################################################
+ ifeq ($(UNAME),IRIX64) 
+    CC = cc	
+ endif
+ 
+ 
+ ##########################################################################
+ # Compaq Alpha running Dec Unix (OSF)
+ ##########################################################################
+ ifeq ($(UNAME),OSF1)
+    CC = cc
+    CC_OPTS = -fast -O3 -std -g3 -non_shared
+ endif
+ 
+ ##########################################################################
+ # BeOS
+ ##########################################################################
+ ifeq ($(UNAME),BeOS)
+    CC = $(BE_C_COMPILER)
+    LIBS =
+ ifeq ($(ARCH),BePC)
+    CC_OPTS = -O9 -fomit-frame-pointer -march=pentium \
+    -mcpu=pentium -ffast-math -funroll-loops \
+    -fprofile-arcs -fbranch-probabilities
+ else
+    CC_OPTS = -opt all
+    MAKEDEP = -make
+ endif
+ endif
+ 
+ ##########################################################################
+ # OS/2
+ ##########################################################################
+ # Properly installed EMX runtime & development package is a prerequisite.
+ # tools I used: make 3.76.1, uname 1.12, sed 2.05, PD-ksh 5.2.13
+ #
+ ##########################################################################
+ ifeq ($(UNAME),OS/2)
+    SHELL=sh	
+    CC = gcc
+    CC_OPTS = -O3
+    PGM = lame.exe
+    LIBS =
+ 
+ # I use the following for slightly better performance on my Pentium-II
+ # using pgcc-2.91.66:
+ #   CC_OPTS = -O6 -ffast-math -funroll-loops -mpentiumpro -march=pentiumpro
+ 
+ # Comment out next 2 lines if you want to remove VBR histogram capability
+    BRHIST_SWITCH = -DBRHIST
+    LIBTERMCAP = -ltermcap
+ 
+ # Uncomment & inspect the 2 GTK lines to use MP3x GTK frame analyzer.
+ # Properly installed XFree86/devlibs & GTK+ is a prerequisite.
+ # The following works for me using Xfree86/OS2 3.3.5 and GTK+ 1.2.3:
+ #   GTK = -DHAVEGTK -IC:/XFree86/include/gtk12 -Zmt -D__ST_MT_ERRNO__ -IC:/XFree86/include/glib12 -IC:/XFree86/include
+ #   GTKLIBS = -LC:/XFree86/lib -Zmtd -Zsysv-signals -Zbin-files -lgtk12 -lgdk12 -lgmodule -lglib12 -lXext -lX11 -lshm -lbsd -lsocket -lm
+ endif
+ 
+ 
+ 
  
+ # 10/99 added -D__NO_MATH_INLINES to fix a bug in *all* versions of
+ # gcc 2.8+ as of 10/99.  
+ 
+ CC_SWITCHES = -DNDEBUG -D__NO_MATH_INLINES $(CC_OPTS) $(SNDLIB) $(GTK) $(BRHIST_SWITCH)
  c_sources = \
  	formatBitstream.c \
! 	fastmdct.c \
! 	filterbank.c \
! 	fft.c \
! 	get_audio.c \
  	l3bitstream.c \
!         id3tag.c \
! 	ieeefloat.c \
!         lame.c \
! 	psymodel.c \
  	portableio.c \
! 	quantize.c \
  	reservoir.c \
! 	tables.c \
! 	takehiro.c \
! 	timestatus.c \
! 	util.c \
!         VbrTag.c \
!         version.c \
!         gtkanal.c \
!         gpkplotting.c \
!         mpglib/common.c \
!         mpglib/dct64_i386.c \
!         mpglib/decode_i386.c \
!         mpglib/layer3.c \
!         mpglib/tabinit.c \
!         mpglib/interface.c \
!         mpglib/main.c 
  
  OBJ = $(c_sources:.c=.o)
  DEP = $(c_sources:.c=.d)
  
  
  
  %.o: %.c 
  	$(CC) $(CC_SWITCHES) -c $< -o $@
  
  %.d: %.c
! 	$(SHELL) -ec '$(CC) $(MAKEDEP)  $(CC_SWITCHES)  $< | sed '\''s;$*.o;& $@;g'\'' > $@'
! 
! $(PGM):	main.o $(OBJ) Makefile 
! 	$(CC) -o $(PGM)  main.o $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
+ #$(PGM):	main.o libmp3lame.a Makefile 
+ #	$(CC) -o $(PGM)  main.o -L. -lmp3lame $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
  
! mp3x:	mp3x.o $(OBJ) Makefile 
! 	$(CC) -o mp3x mp3x.o  $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) $(LIBTERMCAP)
! 
! libmp3lame.a:  $(OBJ) Makefile
! 	ar cr libmp3lame.a  $(OBJ) 
  
  clean:
! 	-rm $(OBJ) $(DEP) $(PGM) main.o mp3x.o mp3x libmp3lame.a \
!                       mp3resample.o mp3resample	
  
  tags: TAGS
  
***************
*** 70,72 ****
--- 256,274 ----
  	etags -T ${c_sources}
  
  -include $(DEP)
+ 
+ test15: $(PGM)
+ 	./lame  ../test/castanets.wav
+ 	cmp -l ../test/castanets.wav.mp3 ../test/castanets.ref15.mp3 | head
+ test15h: $(PGM)
+ 	./lame  -h  ../test/castanets.wav
+ 	cmp -l ../test/castanets.wav.mp3 ../test/castanets.ref15h.mp3 | head
+ test14: $(PGM)
+ 	./lame  ../test/castanets.wav
+ 	cmp -l ../test/castanets.wav.mp3 ../test/castanets.ref14.mp3 | head
+ test14h: $(PGM)
+ 	./lame  -h  ../test/castanets.wav
+ 	cmp -l ../test/castanets.wav.mp3 ../test/castanets.ref14h.mp3 | head
+ testg: $(PGM)
+ 	./lame -h -g ../test/castanets.wav
+ 
diff -r -c -N encoder/Makefile.MSVC lame3.50/Makefile.MSVC
*** encoder/Makefile.MSVC	Wed Dec 31 17:00:00 1969
--- lame3.50/Makefile.MSVC	Tue Oct 12 21:19:42 1999
***************
*** 0 ****
--- 1,79 ----
+ # Makefile.MSVC: MSVC Makefile for LAME 3.34
+ 
+ PGM = lame
+ CC = cl
+ LN = link
+ 
+ # debugging options
+ # CC_OPTS = /nologo /Zi
+ # LN_OPTS = /nologo /debug:full /debugtype:cv /fixed:no
+ 
+ # profiling options
+ # CC_OPTS = /nologo /Zi /O2ab2gitwy /G6AFs /DNDEBUG 
+ # LN_OPTS = /nologo /debug:full /debugtype:cv /fixed:no /profile
+ 
+ # release options
+ CC_OPTS = /nologo /O2ab2gitwy /G6AFs /DNDEBUG 
+ LN_OPTS = /nologo
+ 
+ GTK =
+ GTKLIBS =
+ SNDLIB =
+ LIBSNDFILE =
+ LIBS =
+ MAKEDEP =
+ TIMER_SWITCH =
+ BRHIST_SWITCH =
+ LIBTERMCAP =
+ 
+ CC_SWITCHES = $(CC_OPTS) $(DISTRIB) $(SNDLIB) $(GTK) \
+               /DBS_FORMAT=BINARY $(TIMER_SWITCH) $(BRHIST_SWITCH)
+ LN_SWITCHES = $(LN_OPTS)
+ 
+ c_sources = \
+     main.c \
+ 	formatBitstream.c \
+ 	fastmdct.c \
+ 	filterbank.c \
+ 	fft.c \
+ 	get_audio.c \
+ 	l3bitstream.c \
+         id3tag.c \
+ 	ieeefloat.c \
+         lame.c \
+ 	psymodel.c \
+ 	portableio.c \
+ 	quantize.c \
+ 	reservoir.c \
+ 	tables.c \
+ 	takehiro.c \
+ 	timestatus.c \
+ 	util.c \
+         VbrTag.c \
+         version.c \
+         gtkanal.c \
+         gpkplotting.c \
+         mpglib/common.c \
+         mpglib/dct64_i386.c \
+         mpglib/decode_i386.c \
+         mpglib/layer3.c \
+         mpglib/tabinit.c \
+         mpglib/interface.c \
+         mpglib/main.c 
+ 
+ OBJ = $(c_sources:.c=.obj)
+ 
+ .c.obj:
+ 	@$(CC) $(CC_SWITCHES) /c $< /Fo$@
+ 
+ $(PGM).exe: $(OBJ) Makefile Makefile.MSVC
+ 	@echo $(PGM).exe
+ 	@$(LN) $(LN_SWITCHES) $(OBJ) $(LIBS) $(LIBSNDFILE) $(GTKLIBS) \
+ 	  $(LIBTERMCAP) /out:$(PGM).exe /map:$(PGM).map
+ 
+ clean:
+ 	@-del *.obj
+ 	@-del dll\*.obj
+ 	@-del mpglib\*.obj
+ 
+ rebuild: clean $(PGM).exe
diff -r -c -N encoder/Makefile.in lame3.50/Makefile.in
*** encoder/Makefile.in	Wed Jan 22 02:43:12 1997
--- lame3.50/Makefile.in	Wed Dec 31 17:00:00 1969
***************
*** 1,68 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Decoder - Lower Sampling Frequency Extension
- ##
- ## $Id: Makefile.in,v 1.2 1996/02/14 05:18:05 rowlands Exp $
- ##
- ## Makefile for encoder. Requies GNU make.
- ##
- ## $Log: Makefile.in,v $
- ## Revision 1.2  1996/02/14 05:18:05  rowlands
- ## Cleanups.
- ##
- ## Revision 1.1  1996/02/14 04:04:23  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ############################################################################
- 
- CC = gcc
- 
- c_sources = \
- 	common.c \
- 	encode.c \
- 	formatBitstream.c \
- 	huffman.c \
- 	ieeefloat.c \
- 	l3bitstream.c \
- 	l3psy.c \
- 	loop.c \
- 	mdct.c \
- 	musicin.c \
- 	portableio.c \
- 	psy.c \
- 	reservoir.c \
- 	subs.c \
- 	tonal.c
- 
- OBJ = $(c_sources:.c=.o)
- DEP = $(c_sources:.c=.d)
- 
- NINT_SWITCH = @NINTSW@
- 
- CC_SWITCHES = -g -O -DUNIX -DBS_FORMAT=BINARY $(NINT_SWITCH) -DNDEBUG
- 
- PGM = encode
- 
- LIBS = @LIBS@ @MATHLIBS@
- 
- 
- %.o: %.c 
- 	$(CC) $(CC_SWITCHES) -c $< -o $@
- 
- %.d: %.c
- 	$(SHELL) -ec '$(CC) -M $(CC_SWITCHES) $< | sed '\''s/$*.o/& $@/g'\'' > $@'
- 
- 
- $(PGM):	$(OBJ) Makefile
- 	$(CC) -o $(PGM) $(OBJ) $(LIBS)
- 
- clean:
- 	-rm $(OBJ) $(DEP)
- 
- tags: TAGS
- 
- TAGS: ${c_sources}
- 	etags -T ${c_sources}
- 
- -include $(DEP)
--- 0 ----
diff -r -c -N encoder/README lame3.50/README
*** encoder/README	Wed Dec 31 17:00:00 1969
--- lame3.50/README	Mon Nov  1 21:04:53 1999
***************
*** 0 ****
--- 1,44 ----
+                       LAME 3.xx   
+                LAME Ain't an MP3 Encoder
+                http://www.sulaco.org/mp3
+ 	           September 1999
+ 
+ Written by Mike Cheng (www.uq.net.au/~zzmcheng).  Modified
+ and maintained by Mark Taylor (www.sulaco.org/mp3).
+ 
+ This is a patch agains the ISO MPEG1 demonstration source.  The
+ modifications are distributed under the GNU GENERAL PUBLIC LICENSE
+ (see the file COPYING for details).
+ 
+ The graphical frame analyzer uses the MPGLIB decoding engine, from the
+ MPG123 package, written by: Michael Hipp (www.mpg123.de) MPGLIB is
+ released under the GPL, while MPG123 is released under a more
+ restrictive agreement.
+ 
+ Various components of the patch are:
+ 
+ Copyrights (c) 1999 by Mark Taylor: new psy-model, quantization and bit allocation 
+ Copyrights (c) 1998 by Michael Cheng:  new transforms and many other improvements
+ Copyrights (c) 1995,1996,1997 by Michael Hipp: mpglib
+ 
+ 
+ The ISO demonstration source (distributed separately) has its own
+ patent, copyright and distribution issues.  The code is freely
+ available, but any commercial use (including distributing free
+ encoders) may require a patent license from Thomson Multimedia.
+ (see http://www.iis.fhg.de/amm/legal/)
+ 
+ ============================================================================
+ 
+ see the file "INSTALL" for installation instructions.
+ see the file "USAGE" for the most up-to-date guide to the command
+ line options.  
+ 
+ There is HTML documentation and a man page in the doc directory.
+ The HTML docs were contributed by Gabriel Bouvigne (www.mp3tech.org).
+ See www.mp3tech.org for more audio compression information and links.
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/README.WINGTK lame3.50/README.WINGTK
*** encoder/README.WINGTK	Wed Dec 31 17:00:00 1969
--- lame3.50/README.WINGTK	Sun Oct 24 21:31:56 1999
***************
*** 0 ****
--- 1,56 ----
+ 
+ If you got the LAME source from http://www.sulaco.org/mp3, the
+ libraries and binaries mentioned below are not included.  You will
+ need to get the GLIB and GTK developer libraries, available from:
+ http://user.sgic.fi/~tml/gimp/win32/ 
+ (or see http://www.gtk.org, and click on the GTK under win32 link).
+ 
+ -Mark Taylor 
+ May 24,1999
+ 
+ 
+ *************************************************************************** 
+ 
+ 
+ 
+ May 24,1999
+ 
+ Release notes MP3X for WIN2
+ 
+ Installation instructions:
+ 
+ Copy the DLL files: (in GtkWin32Dll.zip)
+ 
+ gdk-1.3.dll
+ glib-1.2.dll
+ gtk-1.3.dll
+ gmodule-1.2.dll
+ 
+ 
+ either into the current working direcory you are running LAME, or 
+ copy them in the windows system directory. 
+ 
+ 
+ This is basically it, you can run LAME with the Graphic Psyco Analysis as follows:
+ 
+ Lame -g my.wav
+ 
+ (just enter Lame at the dos prompt to get all the options) Of course you can ommit the 
+ -g optiont to use lame without GPA.
+ 
+ 
+ 
+ How to compile Lame with GPA for Windows 32 platforms
+ 
+ In order to compile Lame with the Graphic Psyco Analysis (GPA) with MSVC, you have to have the 
+ proper GTK and GLIB include files and lib files. I've put these files together in a 
+ zip file (named GtkWin32Lib.zip). Unzip these files into the Lame source directory, make
+ sure you unpack it with the directory options. The files are created in the WinGTK subdirecory
+ Furthermore, you should have at least Lame version 3.05 beta 2.
+ Open the project files in MSVC 5, and just hit the build button. There will be a few warnings,
+ but you can ignore them.
+ 
+ 
+ 
+ Albert L. Faber
+ 
diff -r -c -N encoder/TODO lame3.50/TODO
*** encoder/TODO	Wed Dec 31 17:00:00 1969
--- lame3.50/TODO	Sat Oct  9 15:15:43 1999
***************
*** 0 ****
--- 1,37 ----
+ When all sfb's have energy below ATH, (analog silence)
+ use a 32kbs frame even if min VBR bandwidth is larger.
+ 
+ User specified min & max bandwidth (scalefactor bands)
+ 
+ 
+ 
+ 
+ Does stdin work when LAME is compiled to use libsndfile? 
+ (new version of libsndfile supports stdin - try this out)
+ 
+ automatic downsampling of input file.  For example, a 22.05kHz input
+ file encoded at 24kbs will sound better if it is first downsampled
+ to 16kHz.  This can be done with sox, but would be nice to have
+ built into LAME.  Use linear resample code from sox 12.16 or higher.
+ 
+ 
+ make use of subblock_gain (crude algorithm enabled with -Z) 
+    One method:  loop over all possible subblock_gains and
+    see which combination gives best distortion?  But this puts a lot
+    of faith in the short block psycho acoustics
+ 
+ make use of scalefactor_select  (crude algorithm enabled with -Y)
+ 
+ 10Hz high-pass filter.  Probably wont help much.
+ 
+ 
+ Modularization:
+ 
+ lame_parse_args():  main.c should parse the argument list, and then
+ call lame_setflags() or some other libmp3lame.a routine to 
+ set all the various flags. 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/USAGE lame3.50/USAGE
*** encoder/USAGE	Wed Dec 31 17:00:00 1969
--- lame3.50/USAGE	Tue Oct 12 15:30:46 1999
***************
*** 0 ****
--- 1,525 ----
+ 
+ % lame [options] inputfile [outputfile]
+ 
+ =======================================================================
+ Examples:
+ =======================================================================
+ fixed bit rate jstereo 128kbs encoding:
+ % lame sample.wav  sample.mp3      
+ 
+ fixed bit rate jstereo 128kbs encoding, highest quality:  (recommended)
+ % lame -h sample.wav  sample.mp3      
+ 
+ To disable joint stereo encoding (slightly faster, but less quality at bitrates<=128kbs)
+ % lame -m s sample.wav  sample.mp3     
+ 
+ Fast encode, low quality  (no psycho-acoustics)
+ % lame -f sample.wav  sample.mp3     
+ 
+ Variable Bitrate (VBR): (use -V n to adjust quality/filesize)
+ % lame -h -v sample.wav sample.mp3
+ 
+ Note: VBR is currently under heavy development.  Right now it can
+ often result in too much compression.  I would recommend using VBR
+ with a minimum bitrate of 112kbs.  This will let LAME increase
+ the bitrate for difficult-to-encode frames, but prevent LAME from
+ being too aggressive for simple frames:
+ 
+ % lame -h -v -b 112  sample.wav sample.mp3
+ 
+ 
+ =======================================================================
+ LOW BITRATES
+ =======================================================================
+ At lower bitrates, (like 24kbs per channel), it is recommended that
+ you use a 16kHz sampling rate.  Some commercial encoders (FhG, Xing)
+ will do this automatically.  With LAME, you can use Sox, but you have
+ to be careful to get good results.
+ 
+ The following information is from John Hayward-Warburton
+ (john@billabong-media.com, http://billabong-media.com)
+ 
+ There seem to be two very important points:
+ 
+ 1)  make sure you have the very latest sox: the `resample' routine
+     was broken in all previous versions before 12.16, and was really 
+     quite awful. (latest version: http://home.sprynet.com/~cbagwell/sox.html)
+ 
+ 2)  use the resample options.  The defaults are not good for encoding
+     music or speech.  
+ 
+ Here are some options which work well, but more experimentation is
+ needed.  When available, I'll update this with recommended settings
+ for speech and music.
+ 
+ 
+ % sox input.wav  -c 1 -r 16000 output.wav  resample 0.66
+ 
+ % sox INFILE.wav -c 1 -r 22050 OUTFILE.wav polyphase -cutoff 0.45
+ 
+ 
+ 
+ 
+ 
+ =======================================================================
+ STREAMING EXAMPLES
+ =======================================================================
+ Streaming mono 22.05kHz raw pcm, 24kbs output:
+ % cat inputfile | lame -r -m m -b 24 -s 22.05 - - > output
+ 
+ Streaming mono 22.05kHz raw pcm, with downsampling to 16kHz:
+ % cat inputfile | sox -t raw -x -w -s -c 1 -r 22050 -  -t raw -x -w -s -c 1 -r 16000 - resample 0.66 | lame -r -m m -b 24 -s 16 - - > output
+ 
+ You may or may not need one or both of the "-x" (swap bytes) option in Sox.  
+ 
+ 
+ 
+ 
+ =======================================================================
+ 
+ For more options, just type:
+ % lame
+ 
+ Scripts are included to run lame on multiple files:
+ 
+ bach script:  mlame     Run "mlame -h" for instructions.
+ sh script:    auenc     Run auenc for instructions
+ 
+ 
+ 
+ =======================================================================
+ options guide:
+ =======================================================================
+ These options are explained in detail below.
+ 
+ 
+ Quality related:
+ 
+ -m m/s/j/f     mode selection
+ -f             disable psycho-acoustics.  Encoding much faster but lower quality
+ -k             disable scalefactor band 21 cutoff
+ -d             allow block types to differ between channels
+ -h             higher quality but slower
+ -b  n          set bitrate (8,16,24,...,320)
+ --athonly      ignore psy-model output, only use masking from the ATH
+ --voice        experimental voice encoding mode
+ 
+ Variable Bit Rate (VBR)
+ -v             VBR
+ -V n           VBR quality setting  (0=highest quality, 9=lowest)
+ -b  n          specify a minimu allowed bitrate (8,16,24,...,320)
+ -t             disable Xing VBR informational tag 
+ --nohist       disable display of VBR bitrate histogram
+ 
+ 
+ Experimental (undocumented):  may work better or worse:
+ 
+ -X n           try different quality measures (when comparing quantizations)
+ -Y             try to use scalefac_select 
+ -Z             try to use subblock_gain
+ 
+ 
+ Operational:
+ 
+ -r             assume input file is raw PCM
+ -s  n          input sampling frequency in kHz (for raw PCM input files)
+ --resample n   output sampling frequency
+ --mp3input     input file is an MP3 file.  decode using mpglib/mpg123
+ -x             swap bytes of input file
+ -a             downmix stereo input file to mono .mp3
+ -e  n/5/c      de-emphasis
+ -p             add CRC error protection
+ -c             mark the encoded file as copyrighted
+ -o             mark the encoded file as a copy
+ -S             don't print progress report, VBR histogram
+ -g             run MP3x, the graphical frame analyzer
+ 
+ 
+ id3 tagging:
+ 
+ --tt <title>     title of song (max 30 chars)
+ --ta <artist>    artist who did the song (max 30 chars)
+ --tl <album>     album where it came from (max 30 chars)
+ --ty <year>      year in which the song/album was made (max 4 chars)
+ --tc <comment>   additional info (max 30 chars)
+ 
+ 
+ 
+ 
+ 
+ 
+ =======================================================================
+ Detailed description of all options in alphabetical order
+ =======================================================================
+ 
+ 
+ =======================================================================
+ downmix
+ =======================================================================
+ -a  
+ 
+ mix the stereo input file to mono and encode as mono.  
+ 
+ This option is only needed in the case of raw PCM stereo input 
+ (because LAME cannot determine the number of channels in the input file).
+ To encode a stereo PCM input file as mono, use "lame -m s -a"
+ 
+ For WAV and AIFF input files, using "-m m" will always produce a
+ mono .mp3 file from both mono and stereo input.
+ 
+ =======================================================================
+ ATH only
+ =======================================================================
+ --athonly
+ 
+ This option causes LAME to ignore the output of the psy-model and
+ only use masking from the ATH.  Might be useful at very high bitrates
+ or for testing the ATH.  
+ 
+ 
+ 
+ 
+ =======================================================================
+ bitrate
+ =======================================================================
+ -b  n
+ 
+ For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)
+ n =   32,40,48,56,64,80,96,112,128,160,192,224,256,320
+ 
+ For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)
+ n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160
+ 
+ 
+ The bitrate to be used.  Default is 128kbs MPEG1, 80kbs MPEG2.
+ 
+ When used with variable bitrate encodings (VBR), -b specifies the
+ minimum bitrate to use.  This is useful to prevent LAME VBR from
+ using some very aggressive compression which can cause some distortion
+ due to small flaws in the psycho-acoustic model.
+ 
+ 
+ 
+ =======================================================================
+ copyright
+ =======================================================================
+ -c   
+ 
+ mark the encoded file as copyrighted
+ 
+ 
+ 
+ =======================================================================
+ block type control
+ =======================================================================
+ -d 
+ 
+ Allows the left and right channels to use different block types.
+ Normally this is not allowed, only because the FhG encoder does
+ not seem to allow it either.  If anyone finds a sample where -d
+ produces better results, let me know.  (mt@sulaco.org)
+ 
+ 
+ 
+ =======================================================================
+ de-emphasis
+ =======================================================================
+ -e  n/5/c   
+ 
+   n = (none, default)
+   5 = 0/15 microseconds
+   c = citt j.17
+ 
+ All this does is set a flag in the bitstream.  If you have a PCM
+ input file where one of the above types of (obsolete) emphasis has
+ been applied, you can set this flag in LAME.  Then the mp3 decoder
+ should de-emphasize the output during playback, although most 
+ decoders ignore this flag.
+ 
+ A better solution would be to apply the de-emphasis with a standalone
+ utility before encoding.
+ 
+ 
+ 
+ =======================================================================
+ fast mode
+ =======================================================================
+ -f   
+ 
+ disable psycho-acoustics.  Encoding much faster but lower quality
+ 
+ 
+ 
+ =======================================================================
+ graphical frame analyzer
+ =======================================================================
+ -g
+ 
+ run MP3x, the graphical frame analyzer analysis on the inputfile.  The
+ inputfile can be either an .mp3 file or uncompressed audio file.  MP3x
+ support must be compiled into LAME, and requires GTK 1.2.
+ Documentation is under the About pull down menu.
+ 
+ 
+ 
+ =======================================================================
+ high quality
+ =======================================================================
+ -h
+ 
+ use (maybe) some quality improvements
+ 
+ LAME 3.21 and up:  -h enables specialized mid/side masking thresholds to
+ be used in jstereo mode.  Will sound better in jstereo mode
+ but is 20% slower.  No effect for mono files
+ 
+ 
+ 
+ 
+ =======================================================================
+ sfb=21 cutoff
+ =======================================================================
+ -k   
+ 
+ At 128kbs and less, LAME will remove data in scalefactor band 21.
+ This amounts to a low pass 16kHz filter.  -k will disable this
+ feature.  However, these coefficients can take up a lot of bits that
+ would be better used for lower, more important frequencies.
+ Furthermore, the MPEG standard does not allow scalefactors or
+ use psycho-acoustic information for this band.
+ 
+ 
+ 
+ =======================================================================
+ Modes:
+ =======================================================================
+ 
+ -m m           mono.  
+ -m s           stereo
+ -m j           jstereo
+ -m f           forced mid/side stereo
+ 
+ mono is the default mode for mono input files.  If "-m m" is specified
+ for a stereo input file, the two channels will be averaged into a mono
+ signal.  
+ 
+ jstereo is the default mode for stereo files with VBR or fixed bitrates
+ of 160kbs or less.  At higher fixed bitrates, the default is stereo.  
+ 
+ jstereo means the encoder can use (on a frame by frame bases) either
+ regular stereo (just encode left and right channels independently)
+ or mid/side stereo.  In mid/side stereo, the mid (L+R) and side (L-R)
+ channels are encoded, and more bits are allocated to the mid channel
+ than the side channel.  This will effectively increase the bandwidth
+ if the signal does not have too much stereo separation.  
+ 
+ Mid/side stereo is basically a trick to increase bandwidth.  At 128kbs,
+ it is clearly worth while.  At higher bitrates it is less usefull.  
+ 
+ Using mid/side stereo inappropriately can result in audible
+ compression artifacts.  To much switching between mid/side and regular
+ stereo can also sound bad.  To determine when to switch to mid/side
+ stereo, LAME uses a much more sophisticated algorithm than that
+ described in the ISO documentation.
+ 
+ -m f (forced mid/side stereo) is slightly faster then jstereo.  But
+ it should only be used if you are sure every frame of the input file
+ has very little stereo seperation.  
+ 
+ 
+ 
+ =======================================================================
+ MP3 input file
+ =======================================================================
+ --mp3input
+ 
+ Assume the input file is a MP3 file.  Usefull for downsampling 
+ from one mp3 to another.  If the filename ends in ".mp3" LAME will
+ assume it is an MP3.  For stdin or MP3 files which dont end in .mp3
+ you need to use this switch.  
+ 
+ 
+ =======================================================================
+ disable historgram display
+ =======================================================================
+ --nohist
+ 
+ By default, LAME will display a bitrate histogram while producing
+ VBR mp3 files.  This will disable that feature.
+ 
+ 
+ =======================================================================
+ non-original
+ =======================================================================
+ -o   
+ 
+ mark the encoded file as a copy
+ 
+ 
+ =======================================================================
+ CRC error protection
+ =======================================================================
+ -p  
+ 
+ turn on CRC error protection.  
+ Yes this really does work correctly in LAME.  However, it takes 
+ 16 bits per frame that would otherwise be used for encoding.
+ 
+ 
+ 
+ =======================================================================
+ input file is raw pcm
+ =======================================================================
+ -r  
+ 
+ Assume the input file is raw pcm.  Sampling rate and mono/stereo/jstereo
+ must be specified on the command line.  Without -r, LAME will perform
+ several fseek()'s on the input file looking for WAV and AIFF headers.
+ 
+ Not supported if LAME is compiled to use LIBSNDFILE.
+ 
+ 
+ 
+ =======================================================================
+ output sampling frequency in kHZ
+ =======================================================================
+ --resample  n
+ 
+ where n = 16, 22.05, 24, 32, 44.1, 48
+ 
+ Output sampling frequency.  Resample the input if necessary.  
+ If not specified, defaults to the input sampling frequency.
+ (resampling code not yet implemented)
+ 
+ =======================================================================
+ sampling frequency in kHZ
+ =======================================================================
+ -s  n
+ 
+ where n = 16, 22.05, 24, 32, 44.1, 48
+ 
+ Required for raw PCM input files.  Otherwise it will be determined
+ from the header information in the input file.
+ 
+ 
+ 
+ =======================================================================
+ silent operation
+ =======================================================================
+ -S
+ 
+ don't print progress report
+ 
+ 
+ 
+ =======================================================================
+ disable Xing VBR tag
+ =======================================================================
+ -t              
+ 
+ Disable writing of the Xing VBR Tag (only valid if -v flag is
+ specified) This tag in embedded in frame 0 of the MP3 file.  It lets
+ VBR aware players correctly seek and compute playing times of VBR
+ files.
+ 
+ 
+ 
+ =======================================================================
+ variable bit rate  (VBR)
+ =======================================================================
+ -v
+ 
+ Turn on VBR.  There are several ways you can use VBR.  I personally
+ like using VBR to get files slightly bigger than 128kbs files, where
+ the extra bits are used for the occasional difficult-to-encode frame.
+ For this, try specifying a minimum bitrate to use with VBR:
+ 
+ lame -v -b 112  input.wav output.mp3
+ 
+ If the file is too big, use -V n, where n=0..9
+ 
+ lame -v -V n   -b 112  input.wav output.mp3
+ 
+ 
+ If you wan to use VBR to get the maximum compression possible,
+ and for this, you can try:  
+ 
+ lame -v  input.wav output.mp3
+ lame -v -V n input.wav output.mp3         (to very quality/filesize)
+ 
+ 
+ 
+ 
+ =======================================================================
+ VBR quality setting
+ =======================================================================
+ -V n       
+ 
+ n=0..9.  Specifies the value of VBR_q.  default=4.  0=highest quality.
+ 
+ 
+ 
+ How is VBR_q used?
+ 
+ OVER = number of scalefactor bands with distortion that exceeds the
+ allowed distortion given by the masking thresholds.  OVER is computed
+ by outer_loop, and the masking thresholds are computed by the
+ psycho-acoustic model. 
+ 
+ VBR_q = the minimum value of OVER which is to be allowed.
+ LAME will choose the smallest bitrate for which OVER <= VBR_q.  
+ (a minimum allowed bitrate can be set with -b.  default=64kbs)
+ 
+ If the frame contains short blocks, then the minimum bitrate is made
+ much larger since the OVER does not adequately measure distortion
+ caused by pre-echo.  LAME uses bitrates of at least 160kbs for short
+ blocks to make sure they sound good.
+ 
+ *NOTE* No psy-model is perfect, so there can often be distortion which
+ is audible even though the psy-model claims it is not!  Thus using a
+ small minimum bitrate can result in some aggressive compression and
+ audible distortion even with -V 0.  Thus using -V 0 does not sound
+ better than a fixed 256kbs encoding.  For example: suppose in the 1kHz
+ frequency band the psy-model claims 20db of distortion will not be
+ detectable by the human ear, so LAME VBR-0 will compress that
+ frequency band as much as possible and introduce at most 20db of
+ distortion.  Using a fixed 256kbit framesize, LAME could end up
+ introducing only 2db of distortion.  If the psy-model was correct,
+ they will both sound the same.  If the psy-model was wrong, the VBR-0
+ result can sound worse.
+ 
+ 
+ =======================================================================
+ voice encoding mode
+ =======================================================================
+ --voice
+ 
+ An experimental voice encoding mode.  Tuned for 44.1kHz input files.
+ 
+ 
+ =======================================================================
+ swapbytes   
+ =======================================================================
+ -x
+ 
+ swap bytes in the input file.  for sorting out little endian/big endian
+ type problems.  If your encodings sound like static, try this first.
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/VbrTag.c lame3.50/VbrTag.c
*** encoder/VbrTag.c	Wed Dec 31 17:00:00 1969
--- lame3.50/VbrTag.c	Wed Oct 27 01:15:22 1999
***************
*** 0 ****
--- 1,489 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "machine.h"
+ #include <math.h>
+ #include "VbrTag.h"
+ #include "version.h"
+ 
+ #ifdef _DEBUG
+ //  #define DEBUG_VBRTAG
+ #endif
+ 
+ 
+ int SizeOfEmptyFrame[2][2]=
+ {
+ 	{32,17},
+ 	{17,9},
+ };
+ 
+ static u_char pbtStreamBuffer[216];   
+ static long g_Position[NUMTOCENTRIES];
+ static int nZeroStreamSize=0;
+ static int TotalFrameSize=0;
+ static char	VBRTag[]={"Xing"};
+ //static char	VBRTag[]={"Lame"};
+ 
+ 
+ int* pVbrFrames=NULL;
+ int nVbrNumFrames=0;
+ int nVbrFrameBufferSize=0;
+ 
+ /****************************************************************************
+  * AddVbrFrame: Add VBR entry, used to fill the VBR the TOC entries
+  * Paramters:
+  *	nStreamPos: how many bytes did we write to the bitstream so far
+  *				(in Bytes NOT Bits)
+  ****************************************************************************
+ */
+ void AddVbrFrame(int nStreamPos)
+ {
+ 	// Simple exponential growing buffer
+ 	if (pVbrFrames==NULL || nVbrFrameBufferSize==0)
+ 	{
+ 		// Start with 100 frames
+ 		nVbrFrameBufferSize=100;
+ 
+ 		// Allocate them 
+ 		pVbrFrames=(int*)malloc((size_t)(nVbrFrameBufferSize*sizeof(int)));
+ 	}
+ 
+ 	// Is buffer big enough to store this new frame
+ 	if (nVbrNumFrames==nVbrFrameBufferSize)
+ 	{
+ 		// Guess not, double th e buffer size
+ 		nVbrFrameBufferSize*=2;
+ 
+ 		// Allocate new buffer
+ 		pVbrFrames=(int*)realloc(pVbrFrames,(size_t)(nVbrFrameBufferSize*sizeof(int)));
+ 	}
+ 
+ 	// Store values
+ 	pVbrFrames[nVbrNumFrames++]=nStreamPos;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ static int ExtractI4(unsigned char *buf)
+ {
+ 	int x;
+ 	// big endian extract
+ 	x = buf[0];
+ 	x <<= 8;
+ 	x |= buf[1];
+ 	x <<= 8;
+ 	x |= buf[2];
+ 	x <<= 8;
+ 	x |= buf[3];
+ 	return x;
+ }
+ 
+ void CreateI4(unsigned char *buf, int nValue)
+ {
+ 	// big endian create
+ 	buf[0]=(nValue>>24)&0xff;
+ 	buf[1]=(nValue>>16)&0xff;
+ 	buf[2]=(nValue>> 8)&0xff;
+ 	buf[3]=(nValue    )&0xff;
+ }
+ 
+ 
+ /*-------------------------------------------------------------*/
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf)
+ {
+ 	int			i, head_flags;
+ 	int			h_id, h_mode, h_sr_index;
+ 	static int	sr_table[4] = { 44100, 48000, 32000, 99999 };
+ 
+ 	// get Vbr header data
+ 	pTagData->flags = 0;     // clear to null incase fail
+ 
+ 	// get selected MPEG header data
+ 	h_id       = (buf[1] >> 3) & 1;
+ 	h_sr_index = (buf[2] >> 2) & 3;
+ 	h_mode     = (buf[3] >> 6) & 3;
+ 
+ 	// determine offset of header
+ 	if( h_id ) 
+ 	{
+ 		// mpeg1
+ 		if( h_mode != 3 )	buf+=(32+4);
+ 		else				buf+=(17+4);
+ 	}
+ 	else
+ 	{
+ 		// mpeg2
+ 		if( h_mode != 3 ) buf+=(17+4);
+ 		else              buf+=(9+4);
+ 	}
+ 
+ 	if( buf[0] != VBRTag[0] ) return 0;    // fail
+ 	if( buf[1] != VBRTag[1] ) return 0;    // header not found
+ 	if( buf[2] != VBRTag[2] ) return 0;
+ 	if( buf[3] != VBRTag[3] ) return 0;
+ 
+ 	buf+=4;
+ 
+ 	pTagData->h_id = h_id;
+ 
+ 	pTagData->samprate = sr_table[h_sr_index];
+ 
+ 	if( h_id == 0 )
+ 		pTagData->samprate >>= 1;
+ 
+ 	head_flags = pTagData->flags = ExtractI4(buf); buf+=4;      // get flags
+ 
+ 	if( head_flags & FRAMES_FLAG )
+ 	{
+ 		pTagData->frames   = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & BYTES_FLAG )
+ 	{
+ 		pTagData->bytes = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ 	if( head_flags & TOC_FLAG )
+ 	{
+ 		if( pTagData->toc != NULL )
+ 		{
+ 			for(i=0;i<NUMTOCENTRIES;i++)
+ 				pTagData->toc[i] = buf[i];
+ 		}
+ 		buf+=NUMTOCENTRIES;
+ 	}
+ 
+ 	pTagData->vbr_scale = -1;
+ 
+ 	if( head_flags & VBR_SCALE_FLAG )
+ 	{
+ 		pTagData->vbr_scale = ExtractI4(buf); buf+=4;
+ 	}
+ 
+ #ifdef DEBUG_VBRTAG
+ 	printf("\n\n********************* VBR TAG INFO *****************\n");
+ 	printf("tag         :%s\n",VBRTag);
+ 	printf("head_flags  :%d\n",head_flags);
+ 	printf("bytes       :%d\n",pTagData->bytes);
+ 	printf("frames      :%d\n",pTagData->frames);
+ 	printf("VBR Scale   :%d\n",pTagData->vbr_scale);
+ 	printf("toc:\n");
+ 	if( pTagData->toc != NULL )
+ 	{
+ 		for(i=0;i<NUMTOCENTRIES;i++)
+ 		{
+ 			if( (i%10) == 0 ) printf("\n");
+ 			printf(" %3d", (int)(pTagData->toc[i]));
+ 		}
+ 	}
+ 	printf("\n***************** END OF VBR TAG INFO ***************\n");
+ #endif
+ 	return 1;       // success
+ }
+ 
+ 
+ /****************************************************************************
+  * InitVbrTag: Initializes the header, and write empty frame to stream
+  * Paramters:
+  *				fpStream: pointer to output file stream
+  *				nVersion: 0= MPEG1 1=MPEG2
+  *				nMode	: Channel Mode: 0=STEREO 1=JS 2=DS 3=MONO
+  ****************************************************************************
+ */
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion, int nMode, int SampIndex)
+ {
+ 	int i;
+ 
+ 	// Clear Frame position array variables
+ 	pVbrFrames=NULL;
+ 	nVbrNumFrames=0;
+ 	nVbrFrameBufferSize=0;
+ 
+ 	// Clear struct
+ 	memset(g_Position,0x00,sizeof(g_Position));
+ 
+ 	// Clear stream buffer
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	// Set TOC values to 255
+ 	for (i=0;i<NUMTOCENTRIES;i++)
+ 	{
+ 		g_Position[i]=-1;
+ 	}
+ 
+ 
+ 
+ 	// Reserve the proper amount of bytes
+ 	if (nMode==3)
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][1]+4;
+ 	}
+ 	else
+ 	{
+ 		nZeroStreamSize=SizeOfEmptyFrame[nVersion][0]+4;
+ 	}
+ 
+ 
+ 	// Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).
+         // what do they do at 48kHz?  frame not big enough for Xing header.
+ 	// let's always embed Xing header inside a 64kbs layer III frame.  
+ 	// this gives us enough room for a LAME version string too.
+ 	// size determined by sampling frequency (MPEG1)
+ 	// 32kHz:    216 bytes@48kbs    288bytes@ 64kbs    
+ 	// 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)
+ 	// 48kHz:    144 bytes          192
+ 	// 
+ 	// MPEG 2 values are half the above.  Need to go to a 128kbs frame
+ 	// to have room for the table of contents.  not yet supported.
+ 	if (nVersion == 0 ) {
+ 	  int tot;
+ #define XING64
+ #ifdef XING64
+ 	  int framesize[3]={208,192,288};
+ #else
+ 	  int framesize[3]={156,144,216}; 
+ #endif
+ 	  if (SampIndex==3) {
+ 	    fprintf(stderr,"illegal sampling frequency index\n");
+ 	    exit(-1);
+ 	  }
+ 	  TotalFrameSize= framesize[SampIndex];
+ 	  tot = (nZeroStreamSize+VBRHEADERSIZE);
+ #ifdef XING64
+ 	  tot += 20;  /* extra 20 bytes for LAME & version string */
+ #endif
+ 	  if (TotalFrameSize < tot ) {
+ 	    fprintf(stderr,"Xing VBR header problem...use -t\n");
+ 	    exit(-1);
+ 	  }
+ 	}
+ 	if (nVersion == 1) {
+ 	  fprintf(stderr,"MPEG 2 Xing VBR header not supported. use -t\n");
+ 	  exit(-1);
+ 	}
+ 
+ 
+ 	// Put empty bytes into the bitstream
+ 	for (i=0;i<TotalFrameSize;i++)
+ 	{
+ 		// Write a byte to the bitstream
+ 		putbits(pBs,0,8);
+ 	}
+ 
+ 	// Success
+ 	return 0;
+ }
+ 
+ 
+ 
+ /****************************************************************************
+  * PutVbrTag: Write final VBR tag to the file
+  * Paramters:
+  *				lpszFileName: filename of MP3 bit stream
+  *				nVbrScale	: encoder quality indicator (0..100)
+  ****************************************************************************
+ */
+ int PutVbrTag(char* lpszFileName,int nVbrScale)
+ {
+ 	int			i;
+ 	long lFileSize;
+ 	int nStreamIndex;
+ 	char abyte;
+ 	u_char		btToc[NUMTOCENTRIES];
+ 	FILE *fpStream;
+ 	char str1[80];
+ 
+ 
+ 	if (nVbrNumFrames==0 || pVbrFrames==NULL)
+ 		return -1;
+ 
+ 	// Open the bitstream again
+ 	fpStream=fopen(lpszFileName,"rb+");
+ 
+ 	// Assert stream is valid
+ 	if (fpStream==NULL)
+ 		return -1;
+ 
+ 	// Clear stream buffer
+ 	memset(pbtStreamBuffer,0x00,sizeof(pbtStreamBuffer));
+ 
+ 	// Seek to end of file
+ 	fseek(fpStream,0,SEEK_END);
+ 
+ 	// Get file size
+ 	lFileSize=ftell(fpStream);
+ 	
+ 	// Seek to first real frame
+ 	fseek(fpStream,(long)TotalFrameSize,SEEK_SET);
+ 
+ 	// Read the header (first valid frame)
+ 	fread(pbtStreamBuffer,4,1,fpStream);
+ 
+ 	/* the default VBR header.  48kbs layer III, no padding, no crc */
+ 	/* but sampling freq, mode andy copyright/copy protection taken */
+ 	/* from first valid frame */
+ 	pbtStreamBuffer[0]=(u_char) 0xff;    
+ 	pbtStreamBuffer[1]=(u_char) 0xfb;    
+ 	abyte = pbtStreamBuffer[2] & (char) 0x0c;   
+ #ifdef XING64
+ 	pbtStreamBuffer[2]=(char) 0x50 | abyte;     /* 64kbs frame */
+ #else
+ 	pbtStreamBuffer[2]=(char) 0x30 | abyte;  /* 48kbs frame */
+ #endif
+ 
+ 	// Seek to the beginning of the stream
+ 	fseek(fpStream,0,SEEK_SET);
+ 
+ 	// Clear all TOC entries
+ 	memset(btToc,0,sizeof(btToc));
+ 
+ #if 0
+ 	// Set unassigned toc value with its neighbor value
+ 	for (i=0;i<nVbrNumFrames;i++)
+ 	{
+ 		// Calculate percentage
+ 		int nPercent= i*(NUMTOCENTRIES-1)/nVbrNumFrames;
+ 
+ 		// Calculate relative file postion, normalized to 0..255
+ 		float fRelStreamPos=255*(float)pVbrFrames[i]/(float)lFileSize;
+ 
+ 		// Just to be safe
+ 		if (nPercent>=NUMTOCENTRIES ) nPercent=NUMTOCENTRIES-1;
+ 		if (fRelStreamPos>255) fRelStreamPos=255;
+ 
+ 		// Assign toc entry value
+ 		btToc[nPercent]=(u_char)fRelStreamPos;
+ 	}
+ #endif
+         for (i=1;i<NUMTOCENTRIES;i++) // Don't touch zero point...
+         {
+                 // Calculate frame from given percentage
+                 int frameNum=floor(0.01*i*nVbrNumFrames);
+ 
+                 //  Calculate relative file postion, normalized to 0..256!(?)
+                 float fRelStreamPos=256.0*(float)pVbrFrames[frameNum]/(float)lFileSize;
+ 
+                 // Just to be safe
+                 if (fRelStreamPos>255) fRelStreamPos=255;
+ 
+                 // Assign toc entry value
+                 btToc[i]=(u_char) fRelStreamPos;
+         }
+ 
+ 
+ 
+ 
+ 	// Fix up empty fields (if we have less than 100 frames)
+ 	for (i=1;i<NUMTOCENTRIES ;i++)
+ 	{
+ 		if (btToc[i]==0)
+ 			btToc[i]=btToc[i-1];
+ 	}
+ 
+ 
+ 	// Start writing the tag after the zero frame
+ 	nStreamIndex=nZeroStreamSize;
+ 
+ 	// Put Vbr tag
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[0];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[1];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[2];
+ 	pbtStreamBuffer[nStreamIndex++]=VBRTag[3];
+ 
+ 	// Put header flags
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],FRAMES_FLAG+BYTES_FLAG+TOC_FLAG+VBR_SCALE_FLAG);
+ 	nStreamIndex+=4;
+ 
+ 	// Put Total Number of frames
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrNumFrames);
+ 	nStreamIndex+=4;
+ 
+ 	// Put Total file size
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],(int)lFileSize);
+ 	nStreamIndex+=4;
+ 
+ 	// Put TOC
+ 	memcpy(&pbtStreamBuffer[nStreamIndex],btToc,sizeof(btToc));
+ 	nStreamIndex+=sizeof(btToc);
+ 
+ 	// Put VBR SCALE
+ 	CreateI4(&pbtStreamBuffer[nStreamIndex],nVbrScale);
+ 	nStreamIndex+=4;
+ 
+ 	// Put LAME id
+ 	sprintf(str1,"LAME%s",get_lame_version());
+ 	strncpy((char *)&pbtStreamBuffer[nStreamIndex],str1,(size_t) 20);
+ 	nStreamIndex+=20;
+ 
+ 
+ #ifdef DEBUG_VBRTAG
+ {
+ 	VBRTAGDATA TestHeader;
+ 	GetVbrTag(&TestHeader,pbtStreamBuffer);
+ }
+ #endif
+ 
+ 	// Put it all to disk again
+ 	if (fwrite(pbtStreamBuffer,TotalFrameSize,1,fpStream)!=1)
+ 	{
+ 		// Could not write header
+ 		return -1;
+ 	}
+ 
+ 	// CLose bitstream 
+ 	fclose(fpStream);
+ 
+ 	// Save to delete the frame buffer
+ 	free(pVbrFrames);
+ 	pVbrFrames=NULL;
+ 
+ 	return 0;       // success
+ }
+ 
+ /*-------------------------------------------------------------*/
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent)
+ {
+ // interpolate in TOC to get file seek point in bytes
+ int a, seekpoint;
+ float fa, fb, fx;
+ 
+ 
+ if( percent < 0.0f )   percent = 0.0f;
+ if( percent > 100.0f ) percent = 100.0f;
+ 
+ a = (int)percent;
+ if( a > 99 ) a = 99;
+ fa = TOC[a];
+ if( a < 99 ) {
+     fb = TOC[a+1];
+ }
+ else {
+     fb = 256.0f;
+ }
+ 
+ 
+ fx = fa + (fb-fa)*(percent-a);
+ 
+ seekpoint = (int)((1.0f/256.0f)*fx*file_bytes); 
+ 
+ 
+ return seekpoint;
+ }
+ /*-------------------------------------------------------------*/
diff -r -c -N encoder/VbrTag.h lame3.50/VbrTag.h
*** encoder/VbrTag.h	Wed Dec 31 17:00:00 1969
--- lame3.50/VbrTag.h	Sun Oct 17 12:30:36 1999
***************
*** 0 ****
--- 1,83 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #ifndef VRBTAG_H_INCLUDED
+ #define VRBTAG_H_INCLUDED
+ 
+ /* -----------------------------------------------------------
+  * A Vbr header may be present in the ancillary
+  * data field of the first frame of an mp3 bitstream
+  * The Vbr header (optionally) contains
+  *      frames      total number of audio frames in the bitstream
+  *      bytes       total number of bytes in the bitstream
+  *      toc         table of contents
+ 
+  * toc (table of contents) gives seek points
+  * for random access
+  * the ith entry determines the seek point for
+  * i-percent duration
+  * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes
+  * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes
+  */
+ 
+ #include "l3bitstream.h"
+ 
+ #define FRAMES_FLAG     0x0001
+ #define BYTES_FLAG      0x0002
+ #define TOC_FLAG        0x0004
+ #define VBR_SCALE_FLAG  0x0008
+ 
+ #define NUMTOCENTRIES 100
+ 
+ #define FRAMES_AND_BYTES (FRAMES_FLAG | BYTES_FLAG)
+ 
+ // structure to receive extracted header
+ // toc may be NULL
+ typedef struct
+ {
+     int		h_id;			// from MPEG header, 0=MPEG2, 1=MPEG1
+     int		samprate;		// determined from MPEG header
+     int		flags;			// from Vbr header data
+     int		frames;			// total bit stream frames from Vbr header data
+     int		bytes;			// total bit stream bytes from Vbr header data
+     int		vbr_scale;		// encoded vbr scale from Vbr header data
+     u_char	toc[NUMTOCENTRIES];		// may be NULL if toc not desired
+ }   VBRTAGDATA;
+ 
+ //    4 bytes for Header Tag
+ //    4 bytes for Header Flags
+ //  100 bytes for entry (NUMTOCENTRIES)
+ //    4 bytes for FRAME SIZE
+ //    4 bytes for STREAM_SIZE
+ //    4 bytes for VBR SCALE. a VBR quality indicator: 0=best 100=worst
+ //   20 bytes for LAME tag.  for example, "LAME3.12 (beta 6)"
+ // ___________
+ //  140 bytes
+ 
+ #define VBRHEADERSIZE (NUMTOCENTRIES+4+4+4+4+4)
+ 
+ int GetVbrTag(VBRTAGDATA *pTagData,  unsigned char *buf);
+ int SeekPoint(unsigned char TOC[NUMTOCENTRIES], int file_bytes, float percent);
+ int InitVbrTag(Bit_stream_struc* pBs,int nVersion,int nMode, int SampIndex);
+ int PutVbrTag(char* lpszFileName,int nVbrScale);
+ void AddVbrFrame(int nStreamPos);
+ 
+ 
+ #endif
diff -r -c -N encoder/auenc lame3.50/auenc
*** encoder/auenc	Wed Dec 31 17:00:00 1969
--- lame3.50/auenc	Fri Sep 10 09:52:07 1999
***************
*** 0 ****
--- 1,39 ----
+ #!/bin/sh
+ # 
+ # auenc -- version 0.1
+ #
+ # A wrapper for lame to encode multiple files.  By default, a .wav
+ # extension is removed and replaced by .mp3 .
+ #
+ # (C) 1999 Gerhard Wesp <gwesp@cosy.sbg.ac.at> under the GPL.
+ 
+ # set the variables below according to your taste
+ LAME=/usr/bin/lame
+ LAME_OPTS="-S -h -v -V 0 -b 256" # high quality, silent operation
+ 
+ if [ $# -lt 1 ] ; then
+   exec 1>&2
+   cat << _EOF_
+ usage: $0 [options] file...
+ options:
+   -d --delete: delete original file after successful encoding
+ _EOF_
+   exit 1
+ fi
+ 
+ unset DELETE
+ case "$1" in ( -d | --delete )
+   DELETE=1
+   shift ;;
+ esac
+ 
+ for f in $* ; do
+   if ! $LAME $LAME_OPTS "$f" `basename "$f" .wav`.mp3 ; then
+     exec 1>&2
+     echo "encoding of $f failed, aborting..."
+     exit 1
+   fi
+   if [ -n "$DELETE" ] ; then
+     rm -f "$f"
+   fi
+ done
diff -r -c -N encoder/common.c lame3.50/common.c
*** encoder/common.c	Wed Jan 22 02:43:13 1997
--- lame3.50/common.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1439 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: common.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: common.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
-  *          Davis Pan                                                 *
-  * 5/10/91  W. Joseph Carter    Created this file for all common      *
-  *                              functions and global variables.       *
-  *                              Ported to Macintosh and Unix.         *
-  *                              Added Jean-Georges Fritsch's          *
-  *                              "bitstream.c" package.                *
-  *                              Added routines to handle AIFF PCM     *
-  *                              sound files.                          *
-  *                              Added "mem_alloc()" and "mem_free()"  *
-  *                              routines for memory allocation        *
-  *                              portability.                          *
-  *                              Added routines to convert between     *
-  *                              Apple SANE extended floating point    *
-  *                              format and IEEE double precision      *
-  *                              floating point format.  For AIFF.     *
-  * 02jul91 dpwe (Aware Inc)     Moved allocation table input here;    *
-  *                              Tables read from subdir TABLES_PATH.  *
-  *                              Added some debug printout fns (Write*)*
-  * 7/10/91 Earle Jennings       replacement of the one float by FLOAT *
-  *                              port to MsDos from MacIntosh version  *
-  * 8/ 5/91 Jean-Georges Fritsch fixed bug in open_bit_stream_r()      *
-  *10/ 1/91 S.I. Sudharsanan,    Ported to IBM AIX platform.           *
-  *         Don H. Lee,                                                *
-  *         Peter W. Farrett                                           *
-  *10/3/91  Don H. Lee           implemented CRC-16 error protection   *
-  *                              newly introduced functions are        *
-  *                              I_CRC_calc, II_CRC_calc and           *
-  *                              update_CRC. Additions and revisions   *
-  *                              are marked with dhl for clarity       *
-  *10/18/91 Jean-Georges Fritsch fixed bug in update_CRC(),            *
-  *                              II_CRC_calc() and I_CRC_calc()        *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 3/20/92 Jean-Georges Fritsch  fixed bug in start-of-frame search   *
-  * 6/15/92 Juan Pineda          added refill_buffer(bs) "n"           *
-  *                              initialization                        *
-  * 7/08/92 Susanne Ritscher     MS-DOS, MSC6.0 port fixes             *
-  * 7/27/92 Mike Li               (re-)Port to MS-DOS                  *
-  * 8/19/92 Soren H. Nielsen     Fixed bug in I_CRC_calc and in        *
-  *                              II_CRC_calc.  Added function: new_ext *
-  *                              for better MS-DOS compatability       *
-  * 3/10/93 Kevin Peterson       changed aiff_read_headers to handle   *
-  *                              chunks in any order.  now returns     *
-  *                              position of sound data in file.       *
-  * 3/31/93 Jens Spille          changed IFF_* string compares to use  *
-  *                              strcmp()                              *
-  * 5/30/93 Masahiro Iwadare     removed the previous modification     *
-  *                              for UNIX.                             *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  *--------------------------------------------------------------------*
-  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
-  *                              Changed for 1 pass decoding.          *
-  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
-  *--------------------------------------------------------------------*
-  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      rewind of bitbuffer added             *
-  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
-  *  7/11/95 Soeren H. Nielsen   Changes for MPEG-2 LSF Layer I and II *
-  *--------------------------------------------------------------------*
-  * 8/02/95  mc@fivebats.com     Added code to determine byte-order,   *
-  *                              fixes to AIFF routines. Modified Mac  *
-  *                              code to work with new Apple headers   *
-  **********************************************************************/
- 
- /***********************************************************************
- *
- *  Global Include Files
- *
- ***********************************************************************/
- 
- #include    "common.h"
- #include	<string.h> /* 1995-07-11 shn */
- #include	<ctype.h>
- #include <stdlib.h>
- 
- /***********************************************************************
- *
- *  Global Variable Definitions
- *
- ***********************************************************************/
- 
- char *mode_names[4] = { "stereo", "j-stereo", "dual-ch", "single-ch" };
- char *layer_names[3] = { "I", "II", "III" };
- char *version_names[2] = { "MPEG-2 LSF", "MPEG-1" };
- 
- /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
- double  s_freq[2][4] = {{22.05, 24, 16, 0}, {44.1, 48, 32, 0}};
- 
- /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
- int     bitrate[2][3][15] = {
-           {{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256},
-            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
-            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160}},
- 	  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
-            {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
-            {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}}
-         };
- 
- double FAR multiple[64] = {
- 2.00000000000000, 1.58740105196820, 1.25992104989487,
- 1.00000000000000, 0.79370052598410, 0.62996052494744, 0.50000000000000,
- 0.39685026299205, 0.31498026247372, 0.25000000000000, 0.19842513149602,
- 0.15749013123686, 0.12500000000000, 0.09921256574801, 0.07874506561843,
- 0.06250000000000, 0.04960628287401, 0.03937253280921, 0.03125000000000,
- 0.02480314143700, 0.01968626640461, 0.01562500000000, 0.01240157071850,
- 0.00984313320230, 0.00781250000000, 0.00620078535925, 0.00492156660115,
- 0.00390625000000, 0.00310039267963, 0.00246078330058, 0.00195312500000,
- 0.00155019633981, 0.00123039165029, 0.00097656250000, 0.00077509816991,
- 0.00061519582514, 0.00048828125000, 0.00038754908495, 0.00030759791257,
- 0.00024414062500, 0.00019377454248, 0.00015379895629, 0.00012207031250,
- 0.00009688727124, 0.00007689947814, 0.00006103515625, 0.00004844363562,
- 0.00003844973907, 0.00003051757813, 0.00002422181781, 0.00001922486954,
- 0.00001525878906, 0.00001211090890, 0.00000961243477, 0.00000762939453,
- 0.00000605545445, 0.00000480621738, 0.00000381469727, 0.00000302772723,
- 0.00000240310869, 0.00000190734863, 0.00000151386361, 0.00000120155435,
- 1E-20
- };
- 
- enum byte_order NativeByteOrder = order_unknown;
- 
- /***********************************************************************
- *
- *  Global Function Definitions
- *
- ***********************************************************************/
- 
- /* The system uses a variety of data files.  By opening them via this
-    function, we can accommodate various locations. */
- 
- FILE *OpenTableFile(name)
- char *name;
- {
-     char fulname[80];
-     char *envdir;
-     FILE *f;
-     
-     fulname[0] = '\0';
-     
- #ifdef TABLES_PATH
-     strcpy(fulname, TABLES_PATH);   /* default relative path for tables */
- #endif /* TABLES_PATH */          /* (includes terminal path seperator */
-     
- #ifdef UNIX                       /* envir. variables for UNIX only */
- {
-     char *getenv();
-     
-     envdir = getenv(MPEGTABENV);   /* check for environment */
-     if(envdir != NULL)
- 	strcpy(fulname, envdir);
-     strcat(fulname, PATH_SEPARATOR);  /* add a "/" on the end */
- }
- #endif /* UNIX */
- 
- strcat(fulname, name);
- if( (f=fopen(fulname,"r"))==NULL ) {
-     fprintf(stderr,"OpenTable: could not find %s\n", fulname);
-     
- #ifdef UNIX
-     if(envdir != NULL)
- 	fprintf(stderr,"Check %s directory '%s'\n",MPEGTABENV, envdir);
-           else
-             fprintf(stderr,"Check local directory './%s' or setenv %s\n",
-                     TABLES_PATH, MPEGTABENV);
- #else /* not unix : no environment variables */
- 
- #ifdef TABLES_PATH
-             fprintf(stderr,"Check local directory './%s'\n",TABLES_PATH);
- #endif /* TABLES_PATH */
- 
- #endif /* UNIX */
- 
-     }
-     return f;
- }
- 
- /***********************************************************************
- *
- * Read one of the data files ("alloc_*") specifying the bit allocation/
- * quatization parameters for each subband in layer II encoding
- *
- **********************************************************************/
- 
- int read_bit_alloc(table, alloc)        /* read in table, return # subbands */
- int table;
- al_table *alloc;
- {
-         unsigned int a, b, c, d, i, j;
-         FILE *fp;
-         char name[16], t[80];
-         int sblim;
- 
-         strcpy(name, "alloc_0");
- 
-         switch (table) {
-                 case 0 : name[6] = '0';         break;
-                 case 1 : name[6] = '1';         break;
-                 case 2 : name[6] = '2';         break;
-                 case 3 : name[6] = '3';         break;
- 		case 4 : name[6] = '4';		break; /* LSF, added 1995-07-11 shn */
-                 default : name[6] = '0';
-         }
- 
-         if (!(fp = OpenTableFile(name))) {
-                 printf("Please check bit allocation table %s\n", name);
-                 exit(1);
-         }
- 
-         printf("using bit allocation table %s\n", name);
- 
-         fgets(t, 80, fp);
-         sscanf(t, "%d\n", &sblim);
-         while (!feof(fp)) {
-                 fgets(t, 80, fp);
-                 sscanf(t, "%d %d %d %d %d %d\n", &i, &j, &a, &b, &c, &d);
-                         (*alloc)[i][j].steps = a;
-                         (*alloc)[i][j].bits  = b;
-                         (*alloc)[i][j].group = c;
-                         (*alloc)[i][j].quant = d;
-         }
-         fclose(fp);
-         return sblim;
- }
- 
- /***********************************************************************
- *
- * Using the decoded info the appropriate possible quantization per
- * subband table is loaded
- *
- **********************************************************************/
- 
- int pick_table(fr_ps)   /* choose table, load if necess, return # sb's */
- frame_params *fr_ps;
- {
-         int table, lay, ws, bsp, br_per_ch, sfrq;
-         int sblim = fr_ps->sblimit;     /* return current value if no load */
- 
-         lay = fr_ps->header->lay - 1;
-         bsp = fr_ps->header->bitrate_index;
-         br_per_ch = bitrate[fr_ps->header->version][lay][bsp] / fr_ps->stereo;
-         ws = fr_ps->header->sampling_frequency;
-         sfrq = s_freq[fr_ps->header->version][ws];
-         /* decision rules refer to per-channel bitrates (kbits/sec/chan) */
- 	if (fr_ps->header->version == MPEG_AUDIO_ID) { /* MPEG-1 */
- 	    if ((sfrq == 48 && br_per_ch >= 56) ||
- 		(br_per_ch >= 56 && br_per_ch <= 80)) table = 0;
- 	    else if (sfrq != 48 && br_per_ch >= 96) table = 1;
- 	    else if (sfrq != 32 && br_per_ch <= 48) table = 2;
- 	    else table = 3;
- 	}
- 	else { /* MPEG-2 LSF */
- 	    table = 4;
- 	}
-         if (fr_ps->tab_num != table) {
-            if (fr_ps->tab_num >= 0)
-               mem_free((void **)&(fr_ps->alloc));
-            fr_ps->alloc = (al_table FAR *) mem_alloc(sizeof(al_table),
-                                                          "alloc");
-            sblim = read_bit_alloc(fr_ps->tab_num = table, fr_ps->alloc);
-         }
-         return sblim;
- }
- 
- int js_bound(lay, m_ext)
- int lay, m_ext;
- {
- static int jsb_table[3][4] =  { { 4, 8, 12, 16 }, { 4, 8, 12, 16},
-                                 { 0, 4, 8, 16} };  /* lay+m_e -> jsbound */
- 
-     if(lay<1 || lay >3 || m_ext<0 || m_ext>3) {
-         fprintf(stderr, "js_bound bad layer/modext (%d/%d)\n", lay, m_ext);
-         exit(1);
-     }
-     return(jsb_table[lay-1][m_ext]);
- }
- 
- void hdr_to_frps(fr_ps) /* interpret data in hdr str to fields in fr_ps */
- frame_params *fr_ps;
- {
- layer *hdr = fr_ps->header;     /* (or pass in as arg?) */
- 
-     fr_ps->actual_mode = hdr->mode;
-     fr_ps->stereo = (hdr->mode == MPG_MD_MONO) ? 1 : 2;
-     if (hdr->lay == 2)          fr_ps->sblimit = pick_table(fr_ps);
-     else                        fr_ps->sblimit = SBLIMIT;
-     if(hdr->mode == MPG_MD_JOINT_STEREO)
-         fr_ps->jsbound = js_bound(hdr->lay, hdr->mode_ext);
-     else
-         fr_ps->jsbound = fr_ps->sblimit;
-     /* alloc, tab_num set in pick_table */
- }
- 
- void WriteHdr(fr_ps, s)
- frame_params *fr_ps;
- FILE *s;
- {
- layer *info = fr_ps->header;
- 
-    fprintf(s, "HDR: s=FFF, id=%X, l=%X, ep=%s, br=%X, sf=%X, pd=%X, ",
-            info->version, info->lay, ((info->error_protection) ? "on" : "off"),
-            info->bitrate_index, info->sampling_frequency, info->padding);
-    fprintf(s, "pr=%X, m=%X, js=%X, c=%X, o=%X, e=%X\n",
-            info->extension, info->mode, info->mode_ext,
-            info->copyright, info->original, info->emphasis);
-    fprintf(s, "alg.=%s, layer=%s, tot bitrate=%d, sfrq=%.1f\n",
-            version_names[info->version], layer_names[info->lay-1],
- 	   bitrate[info->version][info->lay-1][info->bitrate_index],
-            s_freq[info->version][info->sampling_frequency]);
-    fprintf(s, "mode=%s, sblim=%d, jsbd=%d, ch=%d\n",
-            mode_names[info->mode], fr_ps->sblimit, fr_ps->jsbound, fr_ps->stereo);
-    fflush(s);
- }
- 
- void WriteBitAlloc(bit_alloc, f_p, s)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *f_p;
- FILE *s;
- {
- int i,j;
- int st = f_p->stereo;
- int sbl = f_p->sblimit;
- int jsb = f_p->jsbound;
- 
-     fprintf(s, "BITA ");
-     for(i=0; i<sbl; ++i) {
-         if(i == jsb) fprintf(s,"-");
-         for(j=0; j<st; ++j)
-             fprintf(s, "%1x", bit_alloc[j][i]);
-     }
-     fprintf(s, "\n");   fflush(s);
- }
- 
- void WriteScale(bit_alloc, scfsi, scalar, fr_ps, s)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT], scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int stereo  = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- int lay     = fr_ps->header->lay;
- int i,j,k;
- 
-         if(lay == 2) {
-             fprintf(s, "SFSI ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%d",scfsi[k][i]);
-             fprintf(s, "\nSCFs ");
-             for (k=0;k<stereo;k++) {
-                 for (i=0;i<sblimit;i++)
-                     if (bit_alloc[k][i])
-                         switch (scfsi[k][i]) {
-                           case 0: for (j=0;j<3;j++)
-                                   fprintf(s,"%2d%c",scalar[k][j][i],
-                                           (j==2)?';':'-');
-                                   break;
-                           case 1:
-                           case 3: fprintf(s,"%2d-",scalar[k][0][i]);
-                                   fprintf(s,"%2d;",scalar[k][2][i]);
-                                   break;
-                           case 2: fprintf(s,"%2d;",scalar[k][0][i]);
-                         }
-                 fprintf(s, "\n");
-             }
-         }
-         else{   /* lay == 1 */
-             fprintf(s, "SCFs ");
-             for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-                 if (bit_alloc[k][i])  fprintf(s,"%2d;",scalar[k][0][i]);
-             fprintf(s, "\n");
-         }
- }
- 
- void WriteSamples(ch, sample, bit_alloc, fr_ps, s)
- int ch;
- unsigned int FAR sample[SBLIMIT];
- unsigned int bit_alloc[SBLIMIT];
- frame_params *fr_ps;
- FILE *s;
- {
- int i;
- int stereo = fr_ps->stereo;
- int sblimit = fr_ps->sblimit;
- 
-         fprintf(s, "SMPL ");
-         for (i=0;i<sblimit;i++)
-                 if ( bit_alloc[i] != 0)
-                     fprintf(s, "%d:", sample[i]);
-         if(ch==(stereo-1) )     fprintf(s, "\n");
-         else                    fprintf(s, "\t");
- }
- 
- int NumericQ(s) /* see if a string lookd like a numeric argument */
- char *s;
- {
- char    c;
- 
-     while( (c = *s++)!='\0' && isspace((int)c)) /* strip leading ws */
-         ;
-     if( c == '+' || c == '-' )
-         c = *s++;               /* perhaps skip leading + or - */
-     return isdigit((int)c);
- }
- 
- int BitrateIndex(layr, bRate, version)   /* convert bitrate in kbps to index */
- int     layr;           /* 1 or 2 */
- int     bRate;          /* legal rates from 32 to 448 */
- int	version;	/* MPEG-1 or MPEG-2 LSF */
- {
- int     index = 0;
- int     found = 0;
- 
-     while(!found && index<15)   {
-         if(bitrate[version][layr-1][index] == bRate)
-             found = 1;
-         else
-             ++index;
-     }
-     if(found)
-         return(index);
-     else {
-         fprintf(stderr, "BitrateIndex: %d (layer %d) is not a legal bitrate\n",
-                 bRate, layr);
-         return(-1);     /* Error! */
-     }
- }
- 
- int SmpFrqIndex(sRate, version)  /* convert samp frq in Hz to index */
- long sRate;             /* legal rates 16000, 22050, 24000, 32000, 44100, 48000 */
- int  *version;
- {
-     if (sRate == 44100L) {
-         *version = MPEG_AUDIO_ID; return(0);
-     }
-     else if (sRate == 48000L) {
-         *version = MPEG_AUDIO_ID; return(1);
-     }
-     else if (sRate == 32000L) {
-         *version = MPEG_AUDIO_ID; return(2);
-     }
-     else if (sRate == 24000L) {
-         *version = MPEG_PHASE2_LSF; return(1);
-     }
-     else if (sRate == 22050L) {
-         *version = MPEG_PHASE2_LSF; return(0);
-     }
-     else if (sRate == 16000L) {
-         *version = MPEG_PHASE2_LSF; return(2);
-     }
-     else {
-         fprintf(stderr, "SmpFrqIndex: %ld is not a legal sample rate\n", sRate);
-         return(-1);     /* Error! */
-     }
- }
- 
- /*******************************************************************************
- *
- *  Allocate number of bytes of memory equal to "block".
- *
- *******************************************************************************/
- 
- void  FAR *mem_alloc(block, item)
- unsigned long   block;
- char            *item;
- {
- 
-     void    *ptr;
- 
- #ifdef  MACINTOSH
-     ptr = NewPtr(block);
- #endif
- 
- #ifdef MSC60
-     /*ptr = (void FAR *) _fmalloc((unsigned int)block);*/ /* far memory, 92-07-08 sr */
-     ptr = (void FAR *) malloc((unsigned int)block); /* far memory, 93-08-24 ss */
- #endif
- 
- #if ! defined (MACINTOSH) && ! defined (MSC60)
-     ptr = (void FAR *) malloc(block);
- #endif
- 
-     if (ptr != NULL){
- #ifdef  MSC60
-         _fmemset(ptr, 0, (unsigned int)block); /* far memory, 92-07-08 sr */
- #else
-         memset(ptr, 0, block);
- #endif
-     }
-     else{
-         printf("Unable to allocate %s\n", item);
-         exit(0);
-     }
-     return(ptr);
- }
- 
- 
- /****************************************************************************
- *
- *  Free memory pointed to by "*ptr_addr".
- *
- *****************************************************************************/
- 
- void    mem_free(ptr_addr)
- void    **ptr_addr;
- {
- 
-     if (*ptr_addr != NULL){
- #ifdef  MACINTOSH
-         DisposPtr(*ptr_addr);
- #else
-         free(*ptr_addr);
- #endif
-         *ptr_addr = NULL;
-     }
- 
- }
- 
- /*******************************************************************************
- *
- *  Check block of memory all equal to a single byte, else return FALSE
- *
- *******************************************************************************/
- 
- int memcheck(array, test, num)
- char *array;
- int test;       /* but only tested as a char (bottom 8 bits) */
- int num;
- {
-  int i=0;
- 
-    while (array[i] == test && i<num) i++;
-    if (i==num) return TRUE;
-    else return FALSE;
- }
- 
- /*****************************************************************************
- *
- *  Routines to determine byte order and swap bytes
- *
- *****************************************************************************/
- 
- enum byte_order DetermineByteOrder()
- {
-     char s[ sizeof(long) + 1 ];
-     union
-     {
-         long longval;
-         char charval[ sizeof(long) ];
-     } probe;
-     probe.longval = 0x41424344L;  /* ABCD in ASCII */
-     strncpy( s, probe.charval, sizeof(long) );
-     s[ sizeof(long) ] = '\0';
-     /* fprintf( stderr, "byte order is %s\n", s ); */
-     if ( strcmp(s, "ABCD") == 0 )
-         return order_bigEndian;
-     else
-         if ( strcmp(s, "DCBA") == 0 )
-             return order_littleEndian;
-         else
-             return order_unknown;
- }
- 
- void SwapBytesInWords( short *loc, int words )
- {
-     int i;
-     short thisval;
-     char *dst, *src;
-     src = (char *) &thisval;
-     for ( i = 0; i < words; i++ )
-     {
-         thisval = *loc;
-         dst = (char *) loc++;
-         dst[0] = src[1];
-         dst[1] = src[0];
-     }
- }
- 
- /*****************************************************************************
-  *
-  *  Read Audio Interchange File Format (AIFF) headers.
-  *
-  *****************************************************************************/
- 
- int aiff_read_headers( FILE *file_ptr, IFF_AIFF *aiff_ptr )
- {
-     int chunkSize, subSize, sound_position;
-     
-     if ( fseek(file_ptr, 0, SEEK_SET) != 0 )
-         return -1;
-     
-     if ( Read32BitsHighLow(file_ptr) != IFF_ID_FORM )
-         return -1;
-     
-     chunkSize = Read32BitsHighLow( file_ptr );
-     
-     if ( Read32BitsHighLow(file_ptr) != IFF_ID_AIFF )
-         return -1;
-     
-     sound_position = 0;
-     while ( chunkSize > 0 )
-     {
-         chunkSize -= 4;
-         switch ( Read32BitsHighLow(file_ptr) )
- 	{
-             
-           case IFF_ID_COMM:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             aiff_ptr->numChannels = Read16BitsHighLow( file_ptr );
-             subSize -= 2;
-             aiff_ptr->numSampleFrames = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             aiff_ptr->sampleSize = Read16BitsHighLow( file_ptr );
-             subSize -= 2;
-             aiff_ptr->sampleRate  = ReadIeeeExtendedHighLow( file_ptr );
-             subSize -= 10;
-             while ( subSize > 0 )
- 	    {
-                 getc( file_ptr );
-                 subSize -= 1;
- 	    }
-             break;
-             
-           case IFF_ID_SSND:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             aiff_ptr->blkAlgn.offset = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             aiff_ptr->blkAlgn.blockSize = Read32BitsHighLow( file_ptr );
-             subSize -= 4;
-             sound_position = ftell( file_ptr ) + aiff_ptr->blkAlgn.offset;
-             if ( fseek(file_ptr, (long) subSize, SEEK_CUR) != 0 )
-                 return -1;
-             aiff_ptr->sampleType = IFF_ID_SSND;
-             break;
-             
-           default:
-             chunkSize -= subSize = Read32BitsHighLow( file_ptr );
-             while ( subSize > 0 )
- 	    {
-                 getc( file_ptr );
-                 subSize -= 1;
- 	    }
-             break;
- 	}
-     }
-     return sound_position;
- }
- 
- /*****************************************************************************
-  *
-  *  Seek past some Audio Interchange File Format (AIFF) headers to sound data.
-  *
-  *****************************************************************************/
- 
- int aiff_seek_to_sound_data( FILE *file_ptr )
- {
- 	if ( fseek(file_ptr, AIFF_FORM_HEADER_SIZE + AIFF_SSND_HEADER_SIZE, SEEK_SET) != 0 )
-         return(-1);
-     return(0);
- }
- 
- /*******************************************************************************
-  *
-  *  Write Audio Interchange File Format (AIFF) headers.
-  *
-  *******************************************************************************/
- 
- int aiff_write_headers( FILE *file_ptr, IFF_AIFF *aiff_ptr )
- {
-     int chunkSize;
-     int sampleBytes = (aiff_ptr->sampleSize / 8) + (aiff_ptr->sampleSize % 8 ? 1 : 0);
-     
-     if ( fseek(file_ptr, 0L, SEEK_SET) != 0 )
-         return -1;
-     
-     /* write FORM chunk */
-     chunkSize = 8 + 18 + 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
-     Write32BitsHighLow( file_ptr, IFF_ID_FORM );
-     Write32BitsHighLow( file_ptr, chunkSize );
-     Write32BitsHighLow( file_ptr, IFF_ID_AIFF );
-     /* write COMM chunk */
-     Write32BitsHighLow( file_ptr, IFF_ID_COMM );
-     Write32BitsHighLow( file_ptr, 18 ); /* chunk size */
-     Write16BitsHighLow( file_ptr, aiff_ptr->numChannels );
-     Write32BitsHighLow( file_ptr, aiff_ptr->numSampleFrames );
-     Write16BitsHighLow( file_ptr, aiff_ptr->sampleSize );
-     WriteIeeeExtendedHighLow( file_ptr, aiff_ptr->sampleRate );
-     /* write SSND chunk header */
-     chunkSize = 8 + aiff_ptr->numChannels * aiff_ptr->numSampleFrames * sampleBytes;
-     Write32BitsHighLow( file_ptr, IFF_ID_SSND );
-     Write32BitsHighLow( file_ptr, chunkSize );
-     Write32BitsHighLow( file_ptr, 0 ); /* offset */
-     Write32BitsHighLow( file_ptr, 0 ); /* block size */
-     return 0;
- }
- 
- /*****************************************************************************
- *
- *  bit_stream.c package
- *  Author:  Jean-Georges Fritsch, C-Cube Microsystems
- *
- *****************************************************************************/
- 
- /********************************************************************
-   This package provides functions to write (exclusive or read)
-   information from (exclusive or to) the bit stream.
- 
-   If the bit stream is opened in read mode only the get functions are
-   available. If the bit stream is opened in write mode only the put
-   functions are available.
- ********************************************************************/
- 
- /*open_bit_stream_w(); open the device to write the bit stream into it    */
- /*open_bit_stream_r(); open the device to read the bit stream from it     */
- /*close_bit_stream();  close the device containing the bit stream         */
- /*alloc_buffer();      open and initialize the buffer;                    */
- /*desalloc_buffer();   empty and close the buffer                         */
- /*back_track_buffer();     goes back N bits in the buffer                 */
- /*unsigned int get1bit();  read 1 bit from the bit stream                 */
- /*unsigned long getbits(); read N bits from the bit stream                */
- /*unsigned long byte_ali_getbits();   read the next byte aligned N bits from*/
- /*                                    the bit stream                        */
- /*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
- /*                            changing the buffer pointer                   */
- /*put1bit(); write 1 bit from the bit stream  */
- /*put1bit(); write 1 bit from the bit stream  */
- /*putbits(); write N bits from the bit stream */
- /*byte_ali_putbits(); write byte aligned the next N bits into the bit stream*/
- /*unsigned long sstell(); return the current bit stream length (in bits)    */
- /*int end_bs(); return 1 if the end of bit stream reached otherwise 0       */
- /*int seek_sync(); return 1 if a sync word was found in the bit stream      */
- /*                 otherwise returns 0                                      */
- 
- /* refill the buffer from the input device when the buffer becomes empty    */
- int refill_buffer(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    register int i=bs->buf_size-2-bs->buf_byte_idx;
-    register unsigned long n=1;
-    register int index=0;
-    char val[2];
- 
-    while ((i>=0) && (!bs->eob)) {
- 
-       if (bs->format == BINARY)
-          n = fread(&bs->buf[i--], sizeof(unsigned char), 1, bs->pt);
- 
-       else {
-          while((index < 2) && n) {
-             n = fread(&val[index], sizeof(char), 1, bs->pt);
-             switch (val[index]) {
-                   case 0x30:
-                   case 0x31:
-                   case 0x32:
-                   case 0x33:
-                   case 0x34:
-                   case 0x35:
-                   case 0x36:
-                   case 0x37:
-                   case 0x38:
-                   case 0x39:
-                   case 0x41:
-                   case 0x42:
-                   case 0x43:
-                   case 0x44:
-                   case 0x45:
-                   case 0x46:
-                   index++;
-                   break;
-                   default: break;
-             }
-          }
- 
-          if (val[0] <= 0x39)   bs->buf[i] = (val[0] - 0x30) << 4;
-                  else  bs->buf[i] = (val[0] - 0x37) << 4;
-          if (val[1] <= 0x39)   bs->buf[i--] |= (val[1] - 0x30);
-                  else  bs->buf[i--] |= (val[1] - 0x37);
-          index = 0;
-       }
- 
-       if (!n) {
-          bs->eob= i+1;
-       }
- 
-     }
-    return 0;
- }
- 
- static char *he = "0123456789ABCDEF";
- 
- /* empty the buffer to the output device when the buffer becomes full */
- void empty_buffer(bs, minimum)
- Bit_stream_struc *bs;   /* bit stream structure */
- int minimum;            /* end of the buffer to empty */
- {
-    register int i;
- 
- #if BS_FORMAT == BINARY
-    for (i=bs->buf_size-1;i>=minimum;i--)
-       fwrite(&bs->buf[i], sizeof(unsigned char), 1, bs->pt);
- #else
-    for (i=bs->buf_size-1;i>=minimum;i--) {
-        char val[2];
-        val[0] = he[((bs->buf[i] >> 4) & 0x0F)];
-        val[1] = he[(bs->buf[i] & 0x0F)];
-        fwrite(val, sizeof(char), 2, bs->pt);
-    }
- #endif
- fflush(bs->pt); /* NEW SS to assist in debugging*/
- 
-    for (i=minimum-1; i>=0; i--)
-        bs->buf[bs->buf_size - minimum + i] = bs->buf[i];
- 
-    bs->buf_byte_idx = bs->buf_size -1 - minimum;
-    bs->buf_bit_idx = 8;
- }
- 
- /* open the device to write the bit stream into it */
- void open_bit_stream_w(bs, bs_filenam, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- char *bs_filenam;       /* name of the bit stream file */
- int size;               /* size of the buffer */
- {
-    if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
-       printf("Could not create \"%s\".\n", bs_filenam);
-       exit(1);
-    }
-    alloc_buffer(bs, size);
-    bs->buf_byte_idx = size-1;
-    bs->buf_bit_idx=8;
-    bs->totbit=0;
-    bs->mode = WRITE_MODE;
-    bs->eob = FALSE;
-    bs->eobs = FALSE;
- }
- 
- /* open the device to read the bit stream from it */
- void open_bit_stream_r(bs, bs_filenam, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- char *bs_filenam;       /* name of the bit stream file */
- int size;               /* size of the buffer */
- {
-    register unsigned long n;
-    register unsigned char flag = 1;
-    unsigned char val;
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    do {
-      n = fread(&val, sizeof(unsigned char), 1, bs->pt);
-      switch (val) {
-       case 0x30:
-       case 0x31:
-       case 0x32:
-       case 0x33:
-       case 0x34:
-       case 0x35:
-       case 0x36:
-       case 0x37:
-       case 0x38:
-       case 0x39:
-       case 0x41:
-       case 0x42:
-       case 0x43:
-       case 0x44:
-       case 0x45:
-       case 0x46:
-       case 0xa:  /* \n */
-       case 0xd:  /* cr */
-       case 0x1a:  /* sub */
-           break;
- 
-       default: /* detection of an binary character */
-           flag--;
-           break;
-      }
- 
-    } while (flag & n);
- 
-    if (flag) {
-       printf ("the bit stream file %s is an ASCII file\n", bs_filenam);
-       bs->format = ASCII;
-    }
-    else {
-       bs->format = BINARY;
-       printf ("the bit stream file %s is a BINARY file\n", bs_filenam);
-    }
- 
-    fclose(bs->pt);
- 
-    if ((bs->pt = fopen(bs_filenam, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", bs_filenam);
-       exit(1);
-    }
- 
-    alloc_buffer(bs, size);
-    bs->buf_byte_idx=0;
-    bs->buf_bit_idx=0;
-    bs->totbit=0;
-    bs->mode = READ_MODE;
-    bs->eob = FALSE;
-    bs->eobs = FALSE;
- }
- 
- /*close the device containing the bit stream after a read process*/
- void close_bit_stream_r(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    fclose(bs->pt);
-    desalloc_buffer(bs);
- }
- 
- /*close the device containing the bit stream after a write process*/
- void close_bit_stream_w(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    empty_buffer(bs, bs->buf_byte_idx);
-    fclose(bs->pt);
-    desalloc_buffer(bs);
- }
- 
- /*open and initialize the buffer; */
- void alloc_buffer(bs, size)
- Bit_stream_struc *bs;   /* bit stream structure */
- int size;
- {
-    bs->buf = (unsigned char FAR *) mem_alloc(size*sizeof(unsigned
-               char), "buffer");
-    bs->buf_size = size;
- }
- 
- /*empty and close the buffer */
- void desalloc_buffer(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    free(bs->buf);
- }
- 
- int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
- int clearmask[9]={0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x0};
- 
- void back_track_buffer(bs, N) /* goes back N bits in the buffer */
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;
- {
-    int tmp = N - (N/8)*8;
-    register int i;
- 
-    bs->totbit -= N;
-    for (i=bs->buf_byte_idx;i< bs->buf_byte_idx+N/8-1;i++) bs->buf[i] = 0;
-    bs->buf_byte_idx += N/8;
-    if ( (tmp + bs->buf_bit_idx) <= 8) {
-       bs->buf_bit_idx += tmp;
-    }
-    else {
-       bs->buf_byte_idx ++;
-       bs->buf_bit_idx += (tmp - 8);
-    }
-    bs->buf[bs->buf_byte_idx] &= clearmask[bs->buf_bit_idx];
- }
- 
- int mask[8]={0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80};
- 
- /*read 1 bit from the bit stream */
- unsigned int get1bit(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-    unsigned int bit;
-    register int i;
- 
-    bs->totbit++;
- 
-    if (!bs->buf_bit_idx) {
-         bs->buf_bit_idx = 8;
-         bs->buf_byte_idx--;
-         if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
-              if (bs->eob)
-                 bs->eobs = TRUE;
-              else {
-                 for (i=bs->buf_byte_idx; i>=0;i--)
-                   bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
-                 refill_buffer(bs);
-                 bs->buf_byte_idx = bs->buf_size-1;
-              }
-         }
-    }
-    bit = bs->buf[bs->buf_byte_idx]&mask[bs->buf_bit_idx-1];
-    bit = bit >> (bs->buf_bit_idx-1);
-    bs->buf_bit_idx--;
-    return(bit);
- }
- 
- /*write 1 bit from the bit stream */
- void put1bit(bs, bit)
- Bit_stream_struc *bs;   /* bit stream structure */
- int bit;                /* bit to write into the buffer */
- {
-    bs->totbit++;
- 
-    bs->buf[bs->buf_byte_idx] |= (bit&0x1) << (bs->buf_bit_idx-1);
-    bs->buf_bit_idx--;
-    if (!bs->buf_bit_idx) {
-        bs->buf_bit_idx = 8;
-        bs->buf_byte_idx--;
-        if (bs->buf_byte_idx < 0)
-           empty_buffer(bs, MINIMUM);
-        bs->buf[bs->buf_byte_idx] = 0;
-    }
- }
- 
- /*look ahead for the next N bits from the bit stream */
- unsigned long look_ahead(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
-  register int bit_idx = bs->buf_bit_idx;
-  register int byte_idx = bs->buf_byte_idx;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  while (j > 0) {
-     if (!bit_idx) {
-         bit_idx = 8;
-         byte_idx--;
-     }
-     k = MIN (j, bit_idx);
-     tmp = bs->buf[byte_idx]&putmask[bit_idx];
-     tmp = tmp >> (bit_idx-k);
-     val |= tmp << (j-k);
-     bit_idx -= k;
-     j -= k;
-  }
-  return(val);
- }
- 
- /*read N bit from the bit stream */
- unsigned long getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int i;
-  register int j = N;
-  register int k, tmp;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  bs->totbit += N;
-  while (j > 0) {
-    if (!bs->buf_bit_idx) {
-         bs->buf_bit_idx = 8;
-         bs->buf_byte_idx--;
-         if ((bs->buf_byte_idx < MINIMUM) || (bs->buf_byte_idx < bs->eob)) {
-              if (bs->eob)
-                 bs->eobs = TRUE;
-              else {
-                 for (i=bs->buf_byte_idx; i>=0;i--)
-                    bs->buf[bs->buf_size-1-bs->buf_byte_idx+i] = bs->buf[i];
-                 refill_buffer(bs);
-                 bs->buf_byte_idx = bs->buf_size-1;
-              }
-         }
-    }
-    k = MIN (j, bs->buf_bit_idx);
-    tmp = bs->buf[bs->buf_byte_idx]&putmask[bs->buf_bit_idx];
-    tmp = tmp >> (bs->buf_bit_idx-k);
-    val |= tmp << (j-k);
-    bs->buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
- 
- /*write N bits into the bit stream */
- void putbits(bs, val, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-  register int j = N;
-  register int k, tmp;
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- 
-  bs->totbit += N;
-  while (j > 0) {
-    k = MIN(j, bs->buf_bit_idx);
-    tmp = val >> (j-k);
-    bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
-    bs->buf_bit_idx -= k;
-    if (!bs->buf_bit_idx) {
-        bs->buf_bit_idx = 8;
-        bs->buf_byte_idx--;
-        if (bs->buf_byte_idx < 0)
-           empty_buffer(bs, MINIMUM);
-        bs->buf[bs->buf_byte_idx] = 0;
-    }
-    j -= k;
-  }
- }
- 
- /*write N bits byte aligned into the bit stream */
- void byte_ali_putbits(bs, val, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-      putbits(bs, (unsigned int)0, (int)(8-aligning)); 
- 
-  putbits(bs, val, N);
- }
- 
- /*read the next bute aligned N bits from the bit stream */
- unsigned long byte_ali_getbits(bs, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- int N;                  /* number of bits of val */
- {
-  unsigned long aligning, sstell();
- 
-  if (N > MAX_LENGTH)
-     printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
-  aligning = sstell(bs)%8;
-  if (aligning)
-     getbits(bs, (int)(8-aligning));
- 
-  return(getbits(bs, N));
- }
- 
- /*return the current bit stream length (in bits)*/
- unsigned long sstell(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-   return(bs->totbit);
- }
- 
- /*return the status of the bit stream*/
- /* returns 1 if end of bit stream was reached */
- /* returns 0 if end of bit stream was not reached */
- int end_bs(bs)
- Bit_stream_struc *bs;   /* bit stream structure */
- {
-   return(bs->eobs);
- }
- 
- /*this function seeks for a byte aligned sync word in the bit stream and
-   places the bit stream pointer right after the sync.
-   This function returns 1 if the sync was found otherwise it returns 0  */
- int seek_sync(bs, sync, N)
- Bit_stream_struc *bs;   /* bit stream structure */
- long sync;      /* sync word maximum 32 bits */
- int N;          /* sync word length */
- {
- #if defined(MACINTOSH) && !defined(__powerc)
-  double pow();
- #endif
-  unsigned long aligning, stell();
-  unsigned long val;
-  long maxi = (int)pow(2.0, (FLOAT)N) - 1;
- 
-  aligning = sstell(bs)%ALIGNING;
-  if (aligning)
-     getbits(bs, (int)(ALIGNING-aligning));
- 
-   val = getbits(bs, N);
-   while (((val&maxi) != sync) && (!end_bs(bs))) {
-         val <<= ALIGNING;
-         val |= getbits(bs, ALIGNING);
-   }
- 
-  if (end_bs(bs)) return(0);
-  else return(1);
- }
- /*****************************************************************************
- *
- *  End of bit_stream.c package
- *
- *****************************************************************************/
- 
- /*****************************************************************************
- *
- *  CRC error protection package
- *
- *****************************************************************************/
- 
- void I_CRC_calc(fr_ps, bit_alloc, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int jsbound = fr_ps->jsbound;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<SBLIMIT;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], 4, crc);
- }
- 
- void II_CRC_calc(fr_ps, bit_alloc, scfsi, crc)
- frame_params *fr_ps;
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int *crc;
- {
-         int i, k;
-         layer *info = fr_ps->header;
-         int stereo  = fr_ps->stereo;
-         int sblimit = fr_ps->sblimit;
-         int jsbound = fr_ps->jsbound;
-         al_table *alloc = fr_ps->alloc;
- 
-         *crc = 0xffff; /* changed from '0' 92-08-11 shn */
-         update_CRC(info->bitrate_index, 4, crc);
-         update_CRC(info->sampling_frequency, 2, crc);
-         update_CRC(info->padding, 1, crc);
-         update_CRC(info->extension, 1, crc);
-         update_CRC(info->mode, 2, crc);
-         update_CRC(info->mode_ext, 2, crc);
-         update_CRC(info->copyright, 1, crc);
-         update_CRC(info->original, 1, crc);
-         update_CRC(info->emphasis, 2, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<((i<jsbound)?stereo:1);k++)
-                         update_CRC(bit_alloc[k][i], (*alloc)[i][0].bits, crc);
- 
-         for (i=0;i<sblimit;i++)
-                 for (k=0;k<stereo;k++)
-                         if (bit_alloc[k][i])
-                                 update_CRC(scfsi[k][i], 2, crc);
- }
- 
- void update_CRC(data, length, crc)
- unsigned int data, length, *crc;
- {
-         unsigned int  masking, carry;
- 
-         masking = 1 << length;
- 
-         while((masking >>= 1)){
-                 carry = *crc & 0x8000;
-                 *crc <<= 1;
-                 if (!carry ^ !(data & masking))
-                         *crc ^= CRC16_POLYNOMIAL;
-         }
-         *crc &= 0xffff;
- }
- 
- /*****************************************************************************
- *
- *  End of CRC error protection package
- *
- *****************************************************************************/
- 
- #ifdef  MACINTOSH
- /*****************************************************************************
- *
- *  Set Macintosh file attributes.
- *
- *****************************************************************************/
- void set_mac_file_attr( char fileName[MAX_NAME_SIZE], short vRefNum, OSType creator, OSType fileType)
- {
-     char pascal_fileName[MAX_NAME_SIZE];
-     FInfo fndrInfo;
-     OSErr anErr;
-     long dirID = 0L;
-     
-     CtoPstr(strcpy(pascal_fileName, fileName));
-     anErr = HGetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
-     if ( anErr != noErr )
-         return;
-     fndrInfo.fdCreator = creator;
-     fndrInfo.fdType = fileType;
-     anErr = HSetFInfo(vRefNum, dirID, (ConstStr255Param) pascal_fileName, &fndrInfo);
- }
- 
- #endif
- 
- 
- #ifdef  MS_DOS
- /* ------------------------------------------------------------------------
- new_ext()
- Puts a new extension name on a file name <filename>.
- Removes the last extension name, if any.
- 1992-08-19, 1995-06-12 shn
- ------------------------------------------------------------------------ */
- void
- new_ext(char *filename, char *extname, char *newname)
- {
-   int found, dotpos;
- 
-   /* First, strip the extension */
-   dotpos=strlen(filename); found=0;
-   do
-   {
-     switch (filename[dotpos])
-     {
-       case '.' : found=1; break;
-       case '\\':
-       case '/' :
-       case ':' : found=-1; break;
-       default  : dotpos--; if (dotpos<0) found=-1; break;
-     }
-   } while (found==0);
-   if (found==-1) strcpy(newname,filename);
-   if (found== 1) { strncpy(newname,filename,dotpos); newname[dotpos]='\0'; }
-   strcat(newname,extname);
- }
- #endif
- 
- 
- 
- #define BUFSIZE 4096
- static unsigned long offset,totbit=0, buf_byte_idx=0;
- static unsigned int buf[BUFSIZE];
- static unsigned int buf_bit_idx=8;
- 
- /*return the current bit stream length (in bits)*/
- unsigned long hsstell()
- {
-   return(totbit);
- }
- 
- /* int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff}; */
- extern int putmask[9];
- 
- /*read N bit from the bit stream */
- unsigned long hgetbits(N)
- int N;                  /* number of bits to read from the bit stream */
- {
-  unsigned long val=0;
-  register int j = N;
-  register int k, tmp;
- 
- /*
-  if (N > MAX_LENGTH)
-      printf("Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
- */
-  totbit += N;
-  while (j > 0) {
-    if (!buf_bit_idx) {
-         buf_bit_idx = 8;
-         buf_byte_idx++;
- 	if (buf_byte_idx > offset)
- 	  { printf("Buffer overflow !!\n");exit(3); }
-    }
-    k = MIN (j, buf_bit_idx);
-    tmp = buf[buf_byte_idx%BUFSIZE]&putmask[buf_bit_idx];
-    tmp = tmp >> (buf_bit_idx-k);
-    val |= tmp << (j-k);
-    buf_bit_idx -= k;
-    j -= k;
-  }
-  return(val);
- }
- 
- unsigned int hget1bit()
- {
- return(hgetbits(1));
- }
- 
- /*write N bits into the bit stream */
- void hputbuf(val, N)
- unsigned int val;       /* val to write into the buffer */
- int N;                  /* number of bits of val */
- {
-   if (N != 8) { printf("Not Supported yet!!\n"); exit(-3); }
-   buf[offset % BUFSIZE] = val;
-   offset++;
- }
- 
- void rewindNbits( N )
- int N;
- {
-    totbit -= N;
-    buf_bit_idx += N;
-    while( buf_bit_idx >= 8 )
-    {  buf_bit_idx -= 8;
-       buf_byte_idx--;
-    }
- }
- 
- void rewindNbytes( N )
- int N;
- {
-    totbit -= N*8;
-    buf_byte_idx -= N;
- }
--- 0 ----
diff -r -c -N encoder/common.h lame3.50/common.h
*** encoder/common.h	Wed Jan 22 02:43:13 1997
--- lame3.50/common.h	Wed Dec 31 17:00:00 1969
***************
*** 1,491 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: common.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: common.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
-  *          Davis Pan                                                 *
-  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
-  *                              into "common.h" and "encoder.h".      *
-  *                              Ported to Macintosh and Unix.         *
-  *                              Added additional type definitions for *
-  *                              AIFF, double/SANE and "bitstream.c".  *
-  *                              Added function prototypes for more    *
-  *                              rigorous type checking.               *
-  * 27jun91  dpwe (Aware)        Added "alloc_*" defs & prototypes     *
-  *                              Defined new struct 'frame_params'.    *
-  *                              Changed info.stereo to info.mode_ext  *
-  *                              #define constants for mode types      *
-  *                              Prototype arguments if PROTO_ARGS     *
-  * 5/28/91  Earle Jennings      added MS_DOS definition               *
-  *                              MsDos function prototype declarations *
-  * 7/10/91  Earle Jennings      added FLOAT definition as double      *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  *                              Modified some function prototypes.    *
-  *                              Changed BUFFER_SIZE back to 4096.     *
-  * 7/27/92  Michael Li          (re-)Ported to MS-DOS                 *
-  * 7/27/92  Masahiro Iwadare    Ported to Convex                      *
-  * 8/07/92  mc@tv.tek.com                                             *
-  * 8/10/92  Amit Gulati         Ported to the AIX Platform (RS6000)   *
-  *                              AIFF string constants redefined       *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  *--------------------------------------------------------------------*
-  * 4/23/92  J. Pineda           Added code for Layer III.             *
-  * 11/9/92  Amit Gulati         Added defines for layerIII stereo     *
-  *                              modes.                                *
-  *  8/24/93 Masahiro Iwadare    Included IS modification in Layer III.*
-  *                              Changed for 1 pass decoding.          *
-  *  9/07/93 Toshiyuki Ishino    Integrated Layer III with Ver 3.9.    *
-  *--------------------------------------------------------------------*
-  * 11/20/93 Masahiro Iwadare    Integrated Layer III with Ver 4.0.    *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      Fix for HPUX an IRIX in AIFF-Strings  *
-  *  6/12/95 Soeren H. Nielsen   Bug fix in new_ext().                 *
-  *  7/11/95 Soeren H. Nielsen   Added defs. for MPEG-2 LSF            *
-  *--------------------------------------------------------------------*
-  * 8/02/95  mc@fivebats.com     Changes to AIFF stuff for portability *
-  *                              to little-endian machines             *
-  **********************************************************************/
- #ifndef COMMON_DOT_H
- #define COMMON_DOT_H
- /***********************************************************************
- *
- *  Global Conditional Compile Switches
- *
- ***********************************************************************/
- 
- #if 0
- #define      UNIX            /* Unix conditional compile switch */
- #define      MACINTOSH       /* Macintosh conditional compile switch */
- #define      MS_DOS          /* IBM PC conditional compile switch */
- #define      MSC60           /* Compiled for MS_DOS with MSC v6.0 */
- #define      AIX             /* AIX conditional compile switch    */
- #define      CONVEX          /* CONVEX conditional compile switch */
- #endif
- 
- #if defined(MSC60) 
- #ifndef MS_DOS
- #define MS_DOS
- #endif
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
- #ifdef  UNIX
- #define         TABLES_PATH     "tables"  /* to find data files */
- /* name of environment variable holding path of table files */
- #define         MPEGTABENV      "MPEGTABLES"
- #define         PATH_SEPARATOR  "/"        /* how to build paths */
- #endif  /* UNIX */
- 
- #ifdef  MACINTOSH
- #define      TABLES_PATH ":tables:"  /* where to find data files */
- #endif  /* MACINTOSH */
- 
- /* 
-  * Don't define FAR to far unless you're willing to clean up the 
-  * prototypes
-  */
- #define FAR /*far*/
- 
- #ifdef __STDC__
- #ifndef PROTO_ARGS
- #define PROTO_ARGS
- #endif
- #endif
- 
- #ifdef CONVEX
- #define SEEK_SET        0
- #define SEEK_CUR        1
- #define SEEK_END        2
- #endif
- 
- /* MS_DOS and VMS do not define TABLES_PATH, so OpenTableFile will default
-    to finding the data files in the default directory */
- 
- /***********************************************************************
- *
- *  Global Include Files
- *
- ***********************************************************************/
- 
- #include        <stdio.h>
- #include        <string.h>
- #include        <math.h>
- #include "portableio.h"
- #include "ieeefloat.h"
- 
- #ifdef  UNIX
- #include        <unistd.h>
- #endif  /* UNIX */
- 
- #ifdef __sgi
- #include	<stdlib.h>
- #endif
- 
- #ifdef  MACINTOSH
- #include        <stdlib.h>
- #include        <console.h>
- #endif  /* MACINTOSH */
- 
- #ifdef  MS_DOS
- #include        <stdlib.h>
- #ifdef MSC60
- #include        <memory.h>
- #else
- #include        <alloc.h>
- #include        <mem.h>
- #endif  /* MSC60 */
- #endif  /* MS_DOS */
- 
- #ifndef EXIT_SUCCESS
- #define EXIT_SUCCESS 0
- #endif
- 
- #ifndef EXIT_FAILURE
- #define EXIT_FAILURE 1
- #endif
- 
- /***********************************************************************
- *
- *  Global Definitions
- *
- ***********************************************************************/
- 
- /* General Definitions */
- 
- #ifdef  MS_DOS
- #define         FLOAT                   double
- #else
- #define         FLOAT                   float
- #endif
- #ifndef FALSE
- #define         FALSE                   0
- #endif
- 
- #ifndef TRUE
- #define         TRUE                    1
- #endif
- 
- #define         NULL_CHAR               '\0'
- 
- #define         MAX_U_32_NUM            0xFFFFFFFF
- #ifndef PI
- #define         PI                      3.14159265358979
- #endif
- #define         PI4                     PI/4
- #define         PI64                    PI/64
- #define         LN_TO_LOG10             0.2302585093
- 
- #define         VOL_REF_NUM             0
- #define         MPEG_AUDIO_ID           1
- #define		MPEG_PHASE2_LSF		0	/* 1995-07-11 SHN */
- #define         MAC_WINDOW_SIZE         24
- 
- #define         MONO                    1
- #define         STEREO                  2
- #define         BITS_IN_A_BYTE          8
- #define         WORD                    16
- #define         MAX_NAME_SIZE           81
- #define         SBLIMIT                 32
- #define         SSLIMIT                 18
- #define         FFT_SIZE                1024
- #define         HAN_SIZE                512
- #define         SCALE_BLOCK             12
- #define         SCALE_RANGE             64
- #define         SCALE                   32768
- #define         CRC16_POLYNOMIAL        0x8005
- 
- /* MPEG Header Definitions - Mode Values */
- 
- #define         MPG_MD_STEREO           0
- #define         MPG_MD_JOINT_STEREO     1
- #define         MPG_MD_DUAL_CHANNEL     2
- #define         MPG_MD_MONO             3
- 
- /* Mode Extention */
- 
- #define         MPG_MD_LR_LR             0
- #define         MPG_MD_LR_I              1
- #define         MPG_MD_MS_LR             2
- #define         MPG_MD_MS_I              3
- 
- 
- /* "bit_stream.h" Definitions */
- 
- #define         MINIMUM         4    /* Minimum size of the buffer in bytes */
- #define         MAX_LENGTH      32   /* Maximum length of word written or
-                                         read from bit stream */
- #define         READ_MODE       0
- #define         WRITE_MODE      1
- #define         ALIGNING        8
- #define         BINARY          0
- #define         ASCII           1
- 
- #ifndef BS_FORMAT
- #define         BS_FORMAT       ASCII /* BINARY or ASCII = 2x bytes */
- #endif
- 
- #define         BUFFER_SIZE     4096
- 
- #define         MIN(A, B)       ((A) < (B) ? (A) : (B))
- #define         MAX(A, B)       ((A) > (B) ? (A) : (B))
- 
- /***********************************************************************
- *
- *  Global Type Definitions
- *
- ***********************************************************************/
- 
- /* Structure for Reading Layer II Allocation Tables from File */
- 
- typedef struct {
-     unsigned int    steps;
-     unsigned int    bits;
-     unsigned int    group;
-     unsigned int    quant;
- } sb_alloc, *alloc_ptr;
- 
- typedef sb_alloc        al_table[SBLIMIT][16];
- 
- /* Header Information Structure */
- 
- typedef struct {
-     int version;
-     int lay;
-     int error_protection;
-     int bitrate_index;
-     int sampling_frequency;
-     int padding;
-     int extension;
-     int mode;
-     int mode_ext;
-     int copyright;
-     int original;
-     int emphasis;
- } layer, *the_layer;
- 
- /* Parent Structure Interpreting some Frame Parameters in Header */
- 
- typedef struct {
-     layer       *header;        /* raw header information */
-     int         actual_mode;    /* when writing IS, may forget if 0 chs */
-     al_table    *alloc;         /* bit allocation table read in */
-     int         tab_num;        /* number of table as loaded */
-     int         stereo;         /* 1 for mono, 2 for stereo */
-     int         jsbound;        /* first band of joint stereo coding */
-     int         sblimit;        /* total number of sub bands */
- } frame_params;
- 
- 
- /* AIFF Definitions */
- 
- #define IFF_ID_FORM 0x464f524d /* "FORM" */
- #define IFF_ID_AIFF 0x41494646 /* "AIFF" */
- #define IFF_ID_COMM 0x434f4d4d /* "COMM" */
- #define IFF_ID_SSND 0x53534e44 /* "SSND" */
- #define IFF_ID_MPEG 0x4d504547 /* "MPEG" */
- 
- #define AIFF_FORM_HEADER_SIZE 12
- #define AIFF_SSND_HEADER_SIZE 16
- 
- 
- typedef struct  blockAlign_struct {
-     unsigned long   offset;
-     unsigned long   blockSize;
- } blockAlign;
- 
- typedef struct  IFF_AIFF_struct {
-     short           numChannels;
-     unsigned long   numSampleFrames;
-     short           sampleSize;
-     double          sampleRate;
-     unsigned long   sampleType;
-     blockAlign      blkAlgn;
- } IFF_AIFF;
- 
- enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
- extern enum byte_order NativeByteOrder;
- 
- /* "bit_stream.h" Type Definitions */
- 
- typedef struct  bit_stream_struc {
-     FILE        *pt;            /* pointer to bit stream device */
-     unsigned char *buf;         /* bit stream buffer */
-     int         buf_size;       /* size of buffer (in number of bytes) */
-     long        totbit;         /* bit counter of bit stream */
-     int         buf_byte_idx;   /* pointer to top byte in buffer */
-     int         buf_bit_idx;    /* pointer to top bit of top byte in buffer */
-     int         mode;           /* bit stream open in read or write mode */
-     int         eob;            /* end of buffer index */
-     int         eobs;           /* end of bit stream flag */
-     char        format;
-     
-     /* format of file in rd mode (BINARY/ASCII) */
- } Bit_stream_struc;
- 
- #include "l3side.h"
- 
- /***********************************************************************
- *
- *  Global Variable External Declarations
- *
- ***********************************************************************/
- 
- extern char     *mode_names[4];
- extern char     *layer_names[3];
- extern char	*version_names[2];
- extern double   s_freq[2][4];
- extern int      bitrate[2][3][15];
- extern double FAR multiple[64];
- 
- /***********************************************************************
- *
- *  Global Function Prototype Declarations
- *
- ***********************************************************************/
- 
- /* The following functions are in the file "common.c" */
- 
- #ifdef  PROTO_ARGS
- extern FILE           *OpenTableFile(char*);
- extern int            read_bit_alloc(int, al_table*);
- extern int            pick_table(frame_params*);
- extern int            js_bound(int, int);
- extern void           hdr_to_frps(frame_params*);
- extern void           WriteHdr(frame_params*, FILE*);
- extern void           WriteBitAlloc(unsigned int[2][SBLIMIT], frame_params*,
-                         FILE*);
- extern void           WriteScale(unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int[2][3][SBLIMIT],
-                         frame_params*, FILE*);
- extern void           WriteSamples(int, unsigned int FAR [SBLIMIT],
-                         unsigned int[SBLIMIT], frame_params*, FILE*);
- extern int            NumericQ(char*);
- extern int            BitrateIndex(int, int, int);
- extern int            SmpFrqIndex(long, int*);
- extern int            memcheck(char*, int, int);
- extern void           FAR *mem_alloc(unsigned long, char*);
- extern void           mem_free(void**);
- extern void           double_to_extended(double*, char[10]);
- extern void           extended_to_double(char[10], double*);
- extern int            aiff_read_headers(FILE*, IFF_AIFF*);
- extern int            aiff_seek_to_sound_data(FILE*);
- extern int            aiff_write_headers(FILE*, IFF_AIFF*);
- extern int            refill_buffer(Bit_stream_struc*);
- extern void           empty_buffer(Bit_stream_struc*, int);
- extern void           open_bit_stream_w(Bit_stream_struc*, char*, int);
- extern void           open_bit_stream_r(Bit_stream_struc*, char*, int);
- extern void           close_bit_stream_r(Bit_stream_struc*);
- extern void           close_bit_stream_w(Bit_stream_struc*);
- extern void           alloc_buffer(Bit_stream_struc*, int);
- extern void           desalloc_buffer(Bit_stream_struc*);
- extern void           back_track_buffer(Bit_stream_struc*, int);
- extern unsigned int   get1bit(Bit_stream_struc*);
- extern void           put1bit(Bit_stream_struc*, int);
- extern unsigned long  look_ahead(Bit_stream_struc*, int);
- extern unsigned long  getbits(Bit_stream_struc*, int);
- extern void           putbits(Bit_stream_struc*, unsigned int, int);
- extern void           byte_ali_putbits(Bit_stream_struc*, unsigned int, int);
- extern unsigned long  byte_ali_getbits(Bit_stream_struc*, int);
- extern unsigned long  sstell(Bit_stream_struc*);
- extern int            end_bs(Bit_stream_struc*);
- extern int            seek_sync(Bit_stream_struc*, long, int);
- extern void           I_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int*);
- extern void           II_CRC_calc(frame_params*, unsigned int[2][SBLIMIT],
-                         unsigned int[2][SBLIMIT], unsigned int*);
- extern void           update_CRC(unsigned int, unsigned int, unsigned int*);
- extern void           read_absthr(FLOAT*, int);
- extern unsigned int   hget1bit(); /* MI */
- extern unsigned long  hgetbits(int);
- extern unsigned long  hsstell();
- extern void           hputbuf(unsigned int,int);
- extern enum byte_order DetermineByteOrder();
- extern void SwapBytesInWords( short *loc, int words );
- 
- 
- #ifdef  MACINTOSH
- extern void           set_mac_file_attr(char[MAX_NAME_SIZE], short, OSType,
-                         OSType);
- #endif
- #ifdef MS_DOS
- extern void           new_ext(char *filename, char *extname, char *newname); 
- #endif
- 
- #else
- extern FILE           *OpenTableFile();
- extern int            read_bit_alloc();
- extern int            pick_table();
- extern int            js_bound();
- extern void           hdr_to_frps();
- extern void           WriteHdr();
- extern void           WriteBitAlloc();
- extern void           WriteScale();
- extern void           WriteSamples();
- extern int            NumericQ();
- extern int            BitrateIndex();
- extern int            SmpFrqIndex();
- extern int            memcheck();
- extern void           FAR *mem_alloc();
- extern void           mem_free();
- extern void           double_to_extended();
- extern void           extended_to_double();
- extern int            aiff_read_headers();
- extern int            aiff_seek_to_sound_data();
- extern int            aiff_write_headers();
- extern int            refill_buffer();
- extern void           empty_buffer();
- extern void           open_bit_stream_w();
- extern void           open_bit_stream_r();
- extern void           close_bit_stream_r();
- extern void           close_bit_stream_w();
- extern void           alloc_buffer();
- extern void           desalloc_buffer();
- extern void           back_track_buffer();
- extern unsigned int   get1bit();
- extern void           put1bit();
- extern unsigned long  look_ahead();
- extern unsigned long  getbits();
- extern void           putbits();
- extern void           byte_ali_putbits();
- extern unsigned long  byte_ali_getbits();
- extern unsigned long  sstell();
- extern int            end_bs();
- extern int            seek_sync();
- extern void           I_CRC_calc();
- extern void           II_CRC_calc();
- extern void           update_CRC();
- extern void           read_absthr();
- 
- extern unsigned int   hget1bit();
- extern unsigned long  hgetbits();
- extern unsigned long  hsstell();
- extern void           hputbuf();
- 
- #ifdef MS_DOS
- extern void           new_ext(); 
- #endif
- #endif
- #endif
--- 0 ----
diff -r -c -N encoder/configure lame3.50/configure
*** encoder/configure	Wed Jan 22 02:43:13 1997
--- lame3.50/configure	Wed Dec 31 17:00:00 1969
***************
*** 1,742 ****
- #!/bin/sh
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: configure,v 1.1 1996/02/14 04:06:24 rowlands Exp $
- ##
- ## $Log: configure,v $
- ## Revision 1.1  1996/02/14 04:06:24  rowlands
- ## Initial revision
- ##
- ## Received from Mike Coleman
- ##
- ############################################################################
- 
- # Guess values for system-dependent variables and create Makefiles.
- # Generated automatically using autoconf version 2.3 
- # Copyright (C) 1992, 1993, 1994 Free Software Foundation, Inc.
- #
- # This configure script is free software; the Free Software Foundation
- # gives unlimited permission to copy, distribute and modify it.
- 
- # Defaults:
- ac_help=
- ac_default_prefix=/usr/local
- # Any additions from configure.in:
- 
- # Initialize some variables set by options.
- # The variables have the same names as the options, with
- # dashes changed to underlines.
- build=NONE
- cache_file=./config.cache
- exec_prefix=NONE
- host=NONE
- no_create=
- nonopt=NONE
- no_recursion=
- prefix=NONE
- program_prefix=NONE
- program_suffix=NONE
- program_transform_name=s,x,x,
- silent=
- site=
- srcdir=
- target=NONE
- verbose=
- x_includes=NONE
- x_libraries=NONE
- 
- # Initialize some other variables.
- subdirs=
- 
- ac_prev=
- for ac_option
- do
- 
-   # If the previous option needs an argument, assign it.
-   if test -n "$ac_prev"; then
-     eval "$ac_prev=\$ac_option"
-     ac_prev=
-     continue
-   fi
- 
-   case "$ac_option" in
-   -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
-   *) ac_optarg= ;;
-   esac
- 
-   # Accept the important Cygnus configure options, so we can diagnose typos.
- 
-   case "$ac_option" in
- 
-   -build | --build | --buil | --bui | --bu | --b)
-     ac_prev=build ;;
-   -build=* | --build=* | --buil=* | --bui=* | --bu=* | --b=*)
-     build="$ac_optarg" ;;
- 
-   -cache-file | --cache-file | --cache-fil | --cache-fi \
-   | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-     ac_prev=cache_file ;;
-   -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-   | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-     cache_file="$ac_optarg" ;;
- 
-   -disable-* | --disable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     eval "enable_${ac_feature}=no" ;;
- 
-   -enable-* | --enable-*)
-     ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-     fi
-     ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "enable_${ac_feature}='$ac_optarg'" ;;
- 
-   -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-   | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-   | --exec | --exe | --ex)
-     ac_prev=exec_prefix ;;
-   -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-   | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-   | --exec=* | --exe=* | --ex=*)
-     exec_prefix="$ac_optarg" ;;
- 
-   -gas | --gas | --ga | --g)
-     # Obsolete; use --with-gas.
-     with_gas=yes ;;
- 
-   -help | --help | --hel | --he)
-     # Omit some internal or obsolete options to make the list less imposing.
-     # This message is too long to be a string in the A/UX 3.1 sh.
-     cat << EOF
- Usage: configure [options] [host]
- Options: [defaults in brackets after descriptions]
- Configuration:
-   --cache-file=FILE       cache test results in FILE
-   --help                  print this message
-   --no-create             do not create output files
-   --quiet, --silent       do not print \`checking...' messages
-   --version               print the version of autoconf that created configure
- Directory and file names:
-   --prefix=PREFIX         install architecture-independent files in PREFIX
-                           [$ac_default_prefix]
-   --exec-prefix=PREFIX    install architecture-dependent files in PREFIX
-                           [same as prefix]
-   --srcdir=DIR            find the sources in DIR [configure dir or ..]
-   --program-prefix=PREFIX prepend PREFIX to installed program names
-   --program-suffix=SUFFIX append SUFFIX to installed program names
-   --program-transform-name=PROGRAM run sed PROGRAM on installed program names
- Host type:
-   --build=BUILD           configure for building on BUILD [BUILD=HOST]
-   --host=HOST             configure for HOST [guessed]
-   --target=TARGET         configure for TARGET [TARGET=HOST]
- Features and packages:
-   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-   --x-includes=DIR        X include files are in DIR
-   --x-libraries=DIR       X library files are in DIR
- --enable and --with options recognized:$ac_help
- EOF
-     exit 0 ;;
- 
-   -host | --host | --hos | --ho)
-     ac_prev=host ;;
-   -host=* | --host=* | --hos=* | --ho=*)
-     host="$ac_optarg" ;;
- 
-   -nfp | --nfp | --nf)
-     # Obsolete; use --without-fp.
-     with_fp=no ;;
- 
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c)
-     no_create=yes ;;
- 
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-     no_recursion=yes ;;
- 
-   -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-     ac_prev=prefix ;;
-   -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-     prefix="$ac_optarg" ;;
- 
-   -program-prefix | --program-prefix | --program-prefi | --program-pref \
-   | --program-pre | --program-pr | --program-p)
-     ac_prev=program_prefix ;;
-   -program-prefix=* | --program-prefix=* | --program-prefi=* \
-   | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-     program_prefix="$ac_optarg" ;;
- 
-   -program-suffix | --program-suffix | --program-suffi | --program-suff \
-   | --program-suf | --program-su | --program-s)
-     ac_prev=program_suffix ;;
-   -program-suffix=* | --program-suffix=* | --program-suffi=* \
-   | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-     program_suffix="$ac_optarg" ;;
- 
-   -program-transform-name | --program-transform-name \
-   | --program-transform-nam | --program-transform-na \
-   | --program-transform-n | --program-transform- \
-   | --program-transform | --program-transfor \
-   | --program-transfo | --program-transf \
-   | --program-trans | --program-tran \
-   | --progr-tra | --program-tr | --program-t)
-     ac_prev=program_transform_name ;;
-   -program-transform-name=* | --program-transform-name=* \
-   | --program-transform-nam=* | --program-transform-na=* \
-   | --program-transform-n=* | --program-transform-=* \
-   | --program-transform=* | --program-transfor=* \
-   | --program-transfo=* | --program-transf=* \
-   | --program-trans=* | --program-tran=* \
-   | --progr-tra=* | --program-tr=* | --program-t=*)
-     program_transform_name="$ac_optarg" ;;
- 
-   -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-   | -silent | --silent | --silen | --sile | --sil)
-     silent=yes ;;
- 
-   -site | --site | --sit)
-     ac_prev=site ;;
-   -site=* | --site=* | --sit=*)
-     site="$ac_optarg" ;;
- 
-   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-     ac_prev=srcdir ;;
-   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-     srcdir="$ac_optarg" ;;
- 
-   -target | --target | --targe | --targ | --tar | --ta | --t)
-     ac_prev=target ;;
-   -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-     target="$ac_optarg" ;;
- 
-   -v | -verbose | --verbose | --verbos | --verbo | --verb)
-     verbose=yes ;;
- 
-   -version | --version | --versio | --versi | --vers)
-     echo "configure generated by autoconf version 2.3"
-     exit 0 ;;
- 
-   -with-* | --with-*)
-     ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     case "$ac_option" in
-       *=*) ;;
-       *) ac_optarg=yes ;;
-     esac
-     eval "with_${ac_package}='$ac_optarg'" ;;
- 
-   -without-* | --without-*)
-     ac_package=`echo $ac_option|sed -e 's/-*without-//'`
-     # Reject names that are not valid shell variable names.
-     if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
-       { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-     fi
-     ac_package=`echo $ac_package| sed 's/-/_/g'`
-     eval "with_${ac_package}=no" ;;
- 
-   --x)
-     # Obsolete; use --with-x.
-     with_x=yes ;;
- 
-   -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-   | --x-incl | --x-inc | --x-in | --x-i)
-     ac_prev=x_includes ;;
-   -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-   | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-     x_includes="$ac_optarg" ;;
- 
-   -x-libraries | --x-libraries | --x-librarie | --x-librari \
-   | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-     ac_prev=x_libraries ;;
-   -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-     x_libraries="$ac_optarg" ;;
- 
-   -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
-     ;;
- 
-   *) 
-     if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
-       echo "configure: warning: $ac_option: invalid host type" 1>&2
-     fi
-     if test "x$nonopt" != xNONE; then
-       { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
-     fi
-     nonopt="$ac_option"
-     ;;
- 
-   esac
- done
- 
- if test -n "$ac_prev"; then
-   { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
- fi
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- # File descriptor usage:
- # 0 standard input
- # 1 file creation
- # 2 errors and warnings
- # 3 some systems may open it to /dev/tty
- # 4 used on the Kubota Titan
- # 6 checking for... messages and results
- # 5 compiler messages saved in config.log
- if test "$silent" = yes; then
-   exec 6>/dev/null
- else
-   exec 6>&1
- fi
- exec 5>./config.log
- 
- echo "\
- This file contains any messages produced by compilers while
- running configure, to aid debugging if configure makes a mistake.
- " 1>&5
- 
- # Strip out --no-create and --no-recursion so they do not pile up.
- # Also quote any args containing shell metacharacters.
- ac_configure_args=
- for ac_arg
- do
-   case "$ac_arg" in
-   -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-   | --no-cr | --no-c) ;;
-   -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-   | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-   *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
-   ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-   *) ac_configure_args="$ac_configure_args $ac_arg" ;;
-   esac
- done
- 
- # NLS nuisances.
- # Only set LANG and LC_ALL to C if already set.
- # These must not be set unconditionally because not all systems understand
- # e.g. LANG=C (notably SCO).
- if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
- if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
- 
- # confdefs.h avoids OS command line length limits that DEFS can exceed.
- rm -rf conftest* confdefs.h
- # AIX cpp loses on an empty file, so make sure it contains at least a newline.
- echo > confdefs.h
- 
- # A filename unique to this package, relative to the directory that
- # configure is in, which we can look for to find out if srcdir is correct.
- ac_unique_file=musicin.c
- 
- # Find the source files, if location was not specified.
- if test -z "$srcdir"; then
-   ac_srcdir_defaulted=yes
-   # Try the directory containing this script, then its parent.
-   ac_prog=$0
-   ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
-   test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
-   srcdir=$ac_confdir
-   if test ! -r $srcdir/$ac_unique_file; then
-     srcdir=..
-   fi
- else
-   ac_srcdir_defaulted=no
- fi
- if test ! -r $srcdir/$ac_unique_file; then
-   if test "$ac_srcdir_defaulted" = yes; then
-     { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
-   else
-     { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
-   fi
- fi
- srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
- 
- # Prefer explicitly selected file to automatically selected ones.
- if test -z "$CONFIG_SITE"; then
-   if test "x$prefix" != xNONE; then
-     CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-   else
-     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-   fi
- fi
- for ac_site_file in $CONFIG_SITE; do
-   if test -r "$ac_site_file"; then
-     echo "loading site script $ac_site_file"
-     . "$ac_site_file"
-   fi
- done
- 
- if test -r "$cache_file"; then
-   echo "loading cache $cache_file"
-   . $cache_file
- else
-   echo "creating cache $cache_file"
-   > $cache_file
- fi
- 
- ac_ext=c
- # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
- ac_cpp='$CPP $CPPFLAGS'
- ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5 2>&5'
- ac_link='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5 2>&5'
- 
- if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
-   # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
-   if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
-     ac_n= ac_c='
- ' ac_t='	'
-   else
-     ac_n=-n ac_c= ac_t=
-   fi
- else
-   ac_n= ac_c='\c' ac_t=
- fi
- 
- 
- 
- # Extract the first word of "gcc", so it can be a program name with args.
- set dummy gcc; ac_word=$2
- echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   if test -n "$CC"; then
-   ac_cv_prog_CC="$CC" # Let the user override the test.
- else
-   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
-   for ac_dir in $PATH; do
-     test -z "$ac_dir" && ac_dir=.
-     if test -f $ac_dir/$ac_word; then
-       ac_cv_prog_CC="gcc"
-       break
-     fi
-   done
-   IFS="$ac_save_ifs"
-   test -z "$ac_cv_prog_CC" && ac_cv_prog_CC="cc"
- fi
- fi
- CC="$ac_cv_prog_CC"
- if test -n "$CC"; then
-   echo "$ac_t""$CC" 1>&6
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   cat > conftest.c <<EOF
- #ifdef __GNUC__
-   yes;
- #endif
- EOF
- if ${CC-cc} -E conftest.c 2>&5 | egrep yes >/dev/null 2>&1; then
-   ac_cv_prog_gcc=yes
- else
-   ac_cv_prog_gcc=no
- fi
- fi
- echo "$ac_t""$ac_cv_prog_gcc" 1>&6
- if test $ac_cv_prog_gcc = yes; then
-   GCC=yes
-   if test "${CFLAGS+set}" != set; then
-     echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_prog_gcc_g'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   echo 'void f(){}' > conftest.c
- if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-   ac_cv_prog_gcc_g=yes
- else
-   ac_cv_prog_gcc_g=no
- fi
- rm -f conftest*
- 
- fi
-     echo "$ac_t""$ac_cv_prog_gcc_g" 1>&6
-     if test $ac_cv_prog_gcc_g = yes; then
-       CFLAGS="-g -O"
-     else
-       CFLAGS="-O"
-     fi
-   fi
- else
-   GCC=
-   test "${CFLAGS+set}" = set || CFLAGS="-g"
- fi
- 
- 
- MATHLIBS="-lm"
- echo $ac_n "checking for -lieee""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_ieee'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lieee  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 485 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- main()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_ieee=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'ieee`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   MATHLIBS="$MATHLIBS -lieee"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- NINTSW=""
- echo $ac_n "checking for nint() in -lm""... $ac_c" 1>&6
- if eval "test \"`echo '$''{'ac_cv_lib_m'+set}'`\" = set"; then
-   echo $ac_n "(cached) $ac_c" 1>&6
- else
-   ac_save_LIBS="$LIBS"
- LIBS="-lm  $LIBS"
- cat > conftest.$ac_ext <<EOF
- #line 521 "configure"
- #include "confdefs.h"
- 
- int main() { return 0; }
- int t() {
- nint()
- ; return 0; }
- EOF
- if eval $ac_link; then
-   rm -rf conftest*
-   eval "ac_cv_lib_m=yes"
- else
-   rm -rf conftest*
-   eval "ac_cv_lib_m=no"
- fi
- rm -f conftest*
- LIBS="$ac_save_LIBS"
- 
- fi
- if eval "test \"`echo '$ac_cv_lib_'m`\" = yes"; then
-   echo "$ac_t""yes" 1>&6
-   NINTSW="-DHAVE_NINT"
- else
-   echo "$ac_t""no" 1>&6
- fi
- 
- 
- 
- 
- trap '' 1 2 15
- cat > confcache <<\EOF
- # This file is a shell script that caches the results of configure
- # tests run on this system so they can be shared between configure
- # scripts and configure runs.  It is not useful on other systems.
- # If it contains results you don't want to keep, you may remove or edit it.
- #
- # By default, configure uses ./config.cache as the cache file,
- # creating it if it does not exist already.  You can give configure
- # the --cache-file=FILE option to use a different cache file; that is
- # what configure does when it calls configure scripts in
- # subdirectories, so they share the cache.
- # Giving --cache-file=/dev/null disables caching, for debugging configure.
- # config.status only pays attention to the cache file if you give it the
- # --recheck option to rerun configure.
- #
- EOF
- # Ultrix sh set writes to stderr and can't be redirected directly,
- # and sets the high bit in the cache file unless we assign to the vars.
- (set) 2>&1 |
-   sed -n "s/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=\${\1='\2'}/p" \
-   >> confcache
- if cmp -s $cache_file confcache; then
-   :
- else
-   if test -w $cache_file; then
-     echo "updating cache $cache_file"
-     cat confcache > $cache_file
-   else
-     echo "not updating unwritable cache $cache_file"
-   fi
- fi
- rm -f confcache
- 
- trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
- 
- test "x$prefix" = xNONE && prefix=$ac_default_prefix
- # Let make expand exec_prefix.
- test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
- 
- # Any assignment to VPATH causes Sun make to only execute
- # the first set of double-colon rules, so remove it if not needed.
- # If there is a colon in the path, we need to keep it.
- if test "x$srcdir" = x.; then
-   ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
- fi
- 
- trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
- 
- # Transform confdefs.h into DEFS.
- # Protect against shell expansion while executing Makefile rules.
- # Protect against Makefile macro expansion.
- cat > conftest.defs <<\EOF
- s%#define \([A-Za-z_][A-Za-z0-9_]*\) \(.*\)%-D\1=\2%g
- s%[ 	`~#$^&*(){}\\|;'"<>?]%\\&%g
- s%\[%\\&%g
- s%\]%\\&%g
- s%\$%$$%g
- EOF
- DEFS=`sed -f conftest.defs confdefs.h | tr '\012' ' '`
- rm -f conftest.defs
- 
- 
- # Without the "./", some shells look in PATH for config.status.
- : ${CONFIG_STATUS=./config.status}
- 
- echo creating $CONFIG_STATUS
- rm -f $CONFIG_STATUS
- cat > $CONFIG_STATUS <<EOF
- #! /bin/sh
- # Generated automatically by configure.
- # Run this file to recreate the current configuration.
- # This directory was configured as follows,
- # on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
- #
- # $0 $ac_configure_args
- #
- # Compiler output produced by configure, useful for debugging
- # configure, is in ./config.log if it exists.
- 
- ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
- for ac_option
- do
-   case "\$ac_option" in
-   -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-     echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
-     exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
-   -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-     echo "$CONFIG_STATUS generated by autoconf version 2.3"
-     exit 0 ;;
-   -help | --help | --hel | --he | --h)
-     echo "\$ac_cs_usage"; exit 0 ;;
-   *) echo "\$ac_cs_usage"; exit 1 ;;
-   esac
- done
- 
- ac_given_srcdir=$srcdir
- 
- trap 'rm -fr `echo "Makefile" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
- 
- # Protect against being on the right side of a sed subst in config.status. 
- sed 's/%@/@@/; s/@%/@@/; s/%g$/@g/; /@g$/s/[\\\\&%]/\\\\&/g; 
-  s/@@/%@/; s/@@/@%/; s/@g$/%g/' > conftest.subs <<\CEOF
- $ac_vpsub
- $extrasub
- s%@CFLAGS@%$CFLAGS%g
- s%@CPPFLAGS@%$CPPFLAGS%g
- s%@CXXFLAGS@%$CXXFLAGS%g
- s%@DEFS@%$DEFS%g
- s%@LDFLAGS@%$LDFLAGS%g
- s%@LIBS@%$LIBS%g
- s%@exec_prefix@%$exec_prefix%g
- s%@prefix@%$prefix%g
- s%@program_transform_name@%$program_transform_name%g
- s%@CC@%$CC%g
- s%@MATHLIBS@%$MATHLIBS%g
- s%@NINTSW@%$NINTSW%g
- 
- CEOF
- EOF
- cat >> $CONFIG_STATUS <<EOF
- 
- CONFIG_FILES=\${CONFIG_FILES-"Makefile"}
- EOF
- cat >> $CONFIG_STATUS <<\EOF
- for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
-   # Support "outfile[:infile]", defaulting infile="outfile.in".
-   case "$ac_file" in
-   *:*) ac_file_in=`echo "$ac_file"|sed 's%.*:%%'`
-        ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-   *) ac_file_in="${ac_file}.in" ;;
-   esac
- 
-   # Adjust relative srcdir, etc. for subdirectories.
- 
-   # Remove last slash and all that follows it.  Not all systems have dirname.
-   ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-   if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-     # The file is in a subdirectory.
-     test ! -d "$ac_dir" && mkdir "$ac_dir"
-     ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
-     # A "../" for each directory in $ac_dir_suffix.
-     ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
-   else
-     ac_dir_suffix= ac_dots=
-   fi
- 
-   case "$ac_given_srcdir" in
-   .)  srcdir=.
-       if test -z "$ac_dots"; then top_srcdir=.
-       else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
-   /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
-   *) # Relative path.
-     srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
-     top_srcdir="$ac_dots$ac_given_srcdir" ;;
-   esac
- 
-   echo creating "$ac_file"
-   rm -f "$ac_file"
-   configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
-   case "$ac_file" in
-   *Makefile*) ac_comsub="1i\\
- # $configure_input" ;;
-   *) ac_comsub= ;;
-   esac
-   sed -e "$ac_comsub
- s%@configure_input@%$configure_input%g
- s%@srcdir@%$srcdir%g
- s%@top_srcdir@%$top_srcdir%g
- " -f conftest.subs $ac_given_srcdir/$ac_file_in > $ac_file
- fi; done
- rm -f conftest.subs
- 
- 
- 
- exit 0
- EOF
- chmod +x $CONFIG_STATUS
- rm -fr confdefs* $ac_clean_files
- test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
- 
--- 0 ----
diff -r -c -N encoder/doc/html/contributors.html lame3.50/doc/html/contributors.html
*** encoder/doc/html/contributors.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/contributors.html	Tue Sep 21 14:38:25 1999
***************
*** 0 ****
--- 1,108 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <!-- saved from url=(0051)http://internet.roadrunner.com/~mt/mp3/history.html -->
+ <HTML><HEAD><TITLE>Contributors</TITLE>
+ <META content="text/html; charset=iso-8859-1" http-equiv=Content-Type>
+ <META content="MSHTML 5.00.2014.210" name=GENERATOR><link rel="stylesheet" href="lame.css"></HEAD>
+ <BODY aLink=#bbbbbb bgColor=#ffffff link=#888888 text=#000000 vLink=#555555>
+ <CENTER>
+   <H1>Contributors</H1>
+ </CENTER>
+ <HR>
+ <H4>The following people contributed to the LAME development:</H4>
+ <p> Lauri Ahonen<br>
+   Sakari Ailus<br>
+   Tero Auvinen<br>
+   Alex Ballegooy<br>
+   Bob Bell<br>
+   Lionel Bonnet<br>
+   Gabriel Bouvigne<br>
+   Erik de Castro Lopo<br>
+   Michael Cheng<br>
+   Goran Dokic<br>
+   James Droppo<br>
+   Alvaro Martinez Echevarria<br>
+   Joakim Enerstam <br>
+   Albert Faber<br>
+   Nils Faerber<br>
+   Mikhail M. Fedotov<br>
+   Joseph Fourier<br>
+   Jani Frilander<br>
+   Steffan Haeuser<br>
+   John Hayward-Warburton<br>
+   Robert Hegemann<br>
+   Ben "Jacobs"<br>
+   Iwasa Kazmi<br>
+   Leonid A. Kulakov<br>
+   Juha Laukala<br>
+   Rafael Luebbert<br>
+   Macik<br>
+   Lars Magne Ingebrigtsen<br>
+   Scott Manley<br>
+   Chris Matrakidis<br>
+   Greg Maxwell<br>
+   Scott Miller<br>
+   Dan Nelson<br>
+   Mike Oliphant<br>
+   Andr&eacute; Osterhues<br>
+   Johannes Overmann<br>
+   Jan Peman<br>
+   Jan Rafaj<br>
+   Gertjan van Ratingen<br>
+   Miguel Revilla Rodriguez<br>
+   Conrad Sanderson<br>
+   William Schelter<br>
+   Sigbj�rn Skj�ret<br>
+   Nathan Slingerland<br>
+   Stephane Tavenard<br>
+   Mark Taylor<br>
+   Brad Threatt<br>
+   Takehiro Tominaga<br>
+   Warren Toomey<br>
+   Martin Weghofer<br>
+   Gerhard Wesp<br>
+   Alfred Weyers </p>
+ <p>&nbsp;</p>
+ <h4>Original ISO contributors:</h4>
+ <p>Bill Aspromonte<br>
+   Shaun Astarabadi<br>
+   R. Bittner<br>
+   Karlheinz Brandenburg<br>
+   W. Joseph Carter<br>
+   Jack Chang<br>
+   Mike Coleman<br>
+   Johnathan Devine<br>
+   Ernst Eberlein<br>
+   Dan Ellis<br>
+   Peter Farrett<br>
+   Jean-Georges Fritsch<br>
+   Vlad Fruchter<br>
+   Hendrik Fuchs<br>
+   Bernhard Grill<br>
+   Amit Gulati<br>
+   Munsi Haque<br>
+   Chuck Hsiao<br>
+   Toshiyuki Ishino<br>
+   Masahiro Iwadare<br>
+   Earl Jennings<br>
+   James Johnston<br>
+   Leon v.d. Kerkhof<br>
+   Don Lee<br>
+   Mike Li<br>
+   Yu-Tang Lin<br>
+   Soren Neilsen<br>
+   Simao F. Campos Neto<br>
+   Mark Paley<br>
+   Davis Pan<br>
+   Tan Ah Peng<br>
+   Kevin Peterson<br>
+   Juan Pineda<br>
+   Ernst F. Schroeder<br>
+   Peter Siebert<br>
+   Jens Spille<br>
+   Sam Stewart<br>
+   Al Tabayoyon<br>
+   Kathy Wang<br>
+   Franz-Otto Witte<br>
+   Douglas Wong</p>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/history.html lame3.50/doc/html/history.html
*** encoder/doc/html/history.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/history.html	Tue Sep 21 14:38:26 1999
***************
*** 0 ****
--- 1,930 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <HTML>
+ <HEAD>
+    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
+    <META NAME="GENERATOR" CONTENT="Mozilla/4.08 [en] (X11; I; Linux 2.0.36 i686) [Netscape]">
+    <TITLE>Cstarware : Do you remember where you wanted to go yesterday?</TITLE>
+ </HEAD>
+ <BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#888888" VLINK="#555555" ALINK="#BBBBBB">
+ 
+ <CENTER>
+ <H1>
+ History</H1></CENTER>
+ Starting with LAME 3.0:
+ <BR><FONT COLOR="#FF0000">red = features and bug fixes which effect quality</FONT>
+ <BR><FONT COLOR="#3366FF">blue = features and bug fixes which effect speed</FONT>
+ <BR>black = usability, portability, other
+ <H3>
+ 
+ <HR></H3>
+ 
+ <H3>
+ LAME 3.28beta&nbsp; September 15 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">Serious bug fixed in high frequency MDCT coefficients.&nbsp;
+ Huffman coding was reversing the order of the count1 block quadruples.&nbsp;&nbsp;
+ (Leonid A. Kulakov)</FONT></LI>
+ 
+ <LI>
+ nint() problems under Tru64 unix fixed and preprocessor variable HAVE_NINT&nbsp;
+ removed.&nbsp; (Bob Bell)</LI>
+ 
+ <LI>
+ Compiler warning fixes and code cleanup&nbsp;&nbsp; (Sigbj&oslash;rn Skj&aelig;ret,
+ Lionel Bonnet)</LI>
+ 
+ <LI>
+ USAGE&nbsp;file now includes suggestions for downsampling.&nbsp; For low
+ bitrate encodings, proper downsampling can give dramatically better results.&nbsp;
+ (John Hayward-Warburton)</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.27beta&nbsp; September 12 1999</H3>
+ 
+ <UL>
+ <LI>
+ Several bugs in encode.c and l3bitstream.c fixed by Lionel Bonnet.</LI>
+ 
+ <LI>
+ Bugs in new VBR (#define RH) formula for mono input file and mid/side encoding
+ fixed.</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.26beta&nbsp; September 10 1999</H3>
+ 
+ <UL>
+ <LI>
+ The "-m m" option (mono .mp3 file) will automatically mix left and right
+ channels if the input file is stereo.&nbsp; (Alfred Weyers)</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New quant_compare algorithm (method for deciding
+ which of two quantizations is better) enabled with -X4 (Greg Maxwell)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New mid/side VBR bit allocation formula.&nbsp; Mid
+ channel bits are set by the quality requirements, and then the side channel
+ uses a reduced number of bits (in a proportion coming from the fixed bitrate
+ code).&nbsp; This might not be optimal, but it should be pretty good and
+ no one knows what the optimal solution should be.&nbsp; (Greg Maxwell)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New VBR (#define RH) tunings based on detailed listening
+ tests by Macik and Greg Maxwell.</FONT></LI>
+ 
+ <LI>
+ Sigbj&oslash;rn Skj&aelig;ret fixed several compiler warnings (which turned
+ out to be potential bugs)</LI>
+ 
+ <LI>
+ Takehiro Tominaga fixed a low bitrate bug in reduce_side()</LI>
+ 
+ <LI>
+ Alfred Weyers fixed some buffer overflows.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New ATH (absolute threshold of hearing) formula replaces
+ buggy ISO code, and adds&nbsp; analog silence treatment&nbsp; (removal
+ of coefficients below below ATH).&nbsp;&nbsp; These are turned on by default
+ but have not been fully tested.&nbsp; (Robert Hegemann)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in short block spreading function fixed.&nbsp;
+ (Robert Hegemann)</FONT></LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.25beta&nbsp; August 22 1999</H3>
+ 
+ <UL>
+ <LI>
+ Sigbj&oslash;rn Skj&aelig;ret fixed a zero byte malloc call.&nbsp; This
+ bug&nbsp; was introduced in 3.24 and causes problems on non Linux systems.</LI>
+ 
+ <LI>
+ Bit allocation routines would sometimes allocate more than 4095 bits to
+ one channel of one granule.&nbsp; A couple of people reported problems
+ that might be caused by this, especially at higher bitrates.</LI>
+ 
+ <LI>
+ Nils Faerber updated the man page and fixed many of the compiler warnings.</LI>
+ 
+ <BR>&nbsp;</UL>
+ 
+ <H3>
+ LAME 3.24beta&nbsp;&nbsp; August 15 1999</H3>
+ 
+ <UL>
+ <LI>
+ This release contains the following new code (for developers) which is
+ disabled by default:</LI>
+ 
+ <LI>
+ Robert Hegemann:&nbsp; Completely overhauled VBR code.&nbsp; Now computes
+ exact number of bits required for the given qualty and then quantized with
+ the appropriate bitrate.</LI>
+ 
+ <LI>
+ Several new quantization quality measures.</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.23beta&nbsp; August 8 1999</H3>
+ 
+ <UL>
+ <LI>
+ Very nice continuously updated VBR histogram display from Iwasa Kazmi.&nbsp;
+ (disabled with --nohist).</LI>
+ 
+ <LI>
+ More modulerization work.&nbsp; The encoding engine can now be compiled
+ into libmp3lame, but the interface is awkward.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug fixed in FFT Hann window formula (Leonid A. Kulakov).</FONT></LI>
+ 
+ <LI>
+ New LAME logo on the download page.&nbsp; Created by Chris Michalisles.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Several VBR algorithm improvements from Robert Hegemann.&nbsp;
+ New quantization noise metrics and VBR quality measure takes into account
+ mid/side encoding.&nbsp; Should produce smaller files with the same quality,
+ especially when using jstereo.</FONT></LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.22beta&nbsp; July 27 1999</H3>
+ 
+ <UL>
+ <LI>
+ Downsampling (stereo to mono) bug with MPEG2 fixed.&nbsp; (Mike Oliphant)</LI>
+ 
+ <LI>
+ Downsampling now merges L &amp; R channels - before it only took the L
+ channel.</LI>
+ 
+ <LI>
+ More modularization and code cleanup from Albert Faber and myself.</LI>
+ 
+ <LI>
+ Input filesize limit removed for raw pcm input files.&nbsp; For other file
+ types, LAME will still only read the first 2^32 samples, (27 hours of playing
+ time at 44.1kHz).</LI>
+ 
+ <BR>&nbsp;</UL>
+ 
+ <H3>
+ LAME 3.21beta&nbsp; July 26 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">Correct Mid/Side masking thresholds for JSTEREO mode!&nbsp;
+ This is enabled with -h.&nbsp; It&nbsp; makes LAME about 20% slower since
+ it computes psycho-acoustics for L,R Mid and Side channels.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">"Analog silence" threshold added.&nbsp; Keeps VBR
+ from upping the bitrate during very quite passages.&nbsp; (Robert.Hegemann)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New VBR quality setting from Robert Hegemann.&nbsp;
+ It is based on the idea that distortion at lower bit rates sounds worse
+ than at higher bitrates, and so the allowed distortion (VBR quality setting)
+ is proportional to the bitrate.&nbsp; Because of this, default minimum
+ bitrate is now 32kbs.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Expermental subblock gain code enabled with -Z.</FONT></LI>
+ 
+ <LI>
+ New "-r" option for raw pcm input files.&nbsp; With -r, LAME will not do
+ any fseek()'s or look for wav and aiff headers on the input file.</LI>
+ 
+ <LI>
+ Bug fixes in mp3x (frame analyzer) for viewing frames near end of the file.</LI>
+ 
+ <LI>
+ Bug fixed to allow setting the sampling rate of raw pcm input files.</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.20beta&nbsp; July 19 1999</H3>
+ 
+ <UL>
+ <LI>
+ Bug in get_audio.c fixed.&nbsp; Libsndfile wrappers would not compile (Miguel
+ Revilla&nbsp; Rodriguez)</LI>
+ 
+ <LI>
+ Nils Faerber found some unitialized variables and some wierd extranous
+ computations in filter_subband, now fixed.&nbsp; This was causing seg faults
+ on some machines.</LI>
+ 
+ <BR>&nbsp;</UL>
+ 
+ <H3>
+ LAME 3.19beta&nbsp; July 18 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">Oops!&nbsp; Robert Hegemann immediatly found a bug
+ in the new&nbsp; (old -Z option) quantization code.&nbsp; calc_noise1 was
+ not returning tot_noise, so non ms-stereo frames were buggy.</FONT></LI>
+ 
+ <BR>&nbsp;</UL>
+ 
+ <H3>
+ LAME 3.18beta&nbsp; July 17 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">Many psycho-acoustic bug fixes.&nbsp; Dan Nelson
+ discovered a bug in MPEG2: For short blocks, the code assumes 42 partition
+ bands.&nbsp; MPEG1 sometimes has less, MPEG2 can have more.&nbsp; In MPEG1,
+ this bug would not have effected the output if your compiler initializes
+ static variables to 0 on creation.&nbsp; In MPEG2 it leads to array out-of-bounds
+ access errors. Finally, there was a related bug in MPEG1/MPEG2, short &amp;
+ long blocks where the energy above 16kHz was all added to partition band
+ 0. (the lowest frequeny partition band!)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">The -Z option (Gabriel Bouvigne's idea of using total
+ quantization noise to choose between two quantizations with the same value
+ of "over") is now the default.&nbsp; I believe this helps remove the trilling
+ sound in Jan's testsignal4.wav.&nbsp; The quality of testsignal2.wav and
+ testsignal4.wav are now better than Xing and getting closer to FhG.</FONT></LI>
+ 
+ <LI>
+ Bug fixes in frame &amp; sample count for downsampling mode. (ben "jacobs")</LI>
+ 
+ <LI>
+ Patches to improve modulization.&nbsp; (ben "jacobs")</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.17beta&nbsp; July 11 1999</H3>
+ 
+ <UL>
+ <LI>
+ substantial code cleanup towards goal of making LAME more modular.</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.16beta&nbsp; July 11 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">New tunings of window switching, and better bit allocation
+ based on pe.&nbsp; (Jan Rafaj.&nbsp; improves both testsignal2.wav and
+ testsignal4.wav).</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in mid/side quantization when side channel was
+ zero fixed.&nbsp; (Albert Faber)</FONT></LI>
+ 
+ <LI>
+ Removed some extranous computations in l3psy.c (Robert Hegemann)</LI>
+ 
+ <LI>
+ More detailed timing status info, including hours display. (Sakari Ailus)
+ and percentage indicator (Conrad Sanderson).</LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Window_subband and calc_noise1,calc_noise2 speedups.&nbsp;
+ Quantize_xrpow speedup should be significant on non GNU/intel systems.
+ (Mike Cheng)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Better initial guess for VBR bitrate.&nbsp; Should
+ speed up VBR encoding.&nbsp; (Gabriel Bouvigne)</FONT></LI>
+ 
+ <LI>
+ More advanced .wav header parsing.&nbsp; fixes bugs involving click in
+ first frame. (Robert.Hegemann)</LI>
+ 
+ <LI>
+ Correct filesize and total frame computation when using LIBSNDFILE (ben
+ "jacobs")</LI>
+ 
+ <LI>
+ Click in last frame (buffering problem) when using libsndfile fixed.</LI>
+ 
+ <LI>
+ Audio I/O code overhauled.&nbsp; There is now a uniform audio i/o interface
+ to libsndfile or the LAME built in wav/aiff routines.&nbsp; All audio i/o
+ code localized to get_audio.c.</LI>
+ 
+ <BR>&nbsp;</UL>
+ 
+ <H3>
+ LAME 3.15beta</H3>
+ 
+ <UL>
+ <LI>
+ times()/clock() problem fixed for non-unix OS.&nbsp; (Ben "Jacobs")</LI>
+ 
+ <LI>
+ Fixed uninitialized pe[] when using fast mode.&nbsp; (Ben "Jacobs")</LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.13&nbsp; June 24 1999</H3>
+ 
+ <UL>
+ <LI>
+ Patches for BeOS from Gertjan van Ratingen.</LI>
+ 
+ <LI>
+ Makefile info for OS/2 Warp 4.0&nbsp; (from dink.org).</LI>
+ 
+ <LI>
+ Status display now based on wall clock time, not cpu time.</LI>
+ 
+ <LI>
+ mem_alloc no longer allocates twice as much memory as needed (Jan Peman).</LI>
+ </UL>
+ 
+ <H3>
+ 3.12pre9</H3>
+ 
+ <UL>
+ <LI>
+ Updated BLADEDLL code to handle recent changes (Albert Faber).</LI>
+ 
+ <LI>
+ Bug fixed in parsing options when not using GTK (Albert Faber).</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">MPEG2 Layer III psycho acoustics now working.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Improved huffman encoding Chris Matrakidis. (10%
+ faster).&nbsp; I dont know how he finds these improvements!&nbsp; LAME
+ with full quality now encodes faster than real time on my PII 266.</FONT></LI>
+ 
+ <LI>
+ Fixed time display when encoding takes more than 60 minutes.</LI>
+ </UL>
+ 
+ <H3>
+ 3.12pre8</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">New <A HREF="gpsycho/ms_stereo.html">mid/side stereo</A>
+ criterion.&nbsp; LAME will use mid/side stereo only when the difference
+ between L &amp; R masking thresholds (averaged over all scalefactors) is
+ less then 5db.&nbsp; In several test samples it does a very good job mimicking
+ the FhG encoder.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in mid/side stereo fixed:&nbsp; independent variation
+ of mid &amp; side channel scalefactors disabled.&nbsp; Because of the way
+ outer_loop is currently coded, when encoding mid/side coefficietns using
+ left/right thresholds, you have to vary the scalefactors simultaneously.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in side/mid energy ratio calculation fixed. (Thanks
+ to Robert Hegemann)</FONT></LI>
+ 
+ <LI>
+ Default mode is stereo (not jstereo) if bitrate is chosen as 192kbs or
+ higher.&nbsp; Tero Auvinen first pointed out that FhG seems to think at
+ 160kbs, their encoder is so good it doesn't need jstereo tricks. Since
+ LAME is not as good as FhG, I am going to claim that 192kbs LAME is so
+ good it doens't need jstereo tricks, and thus it is disabled by default.</LI>
+ 
+ <LI>
+ WAV header parsing for big-endian machines, and automatic detection of
+ big-endian machines.&nbsp; (Thanks to&nbsp; Sigbj&oslash;rn Skj&aelig;ret).</LI>
+ 
+ <LI>
+ added 56 sample delay to sync LAME with FhG.</LI>
+ 
+ <LI>
+ MP3x (frame analyzer) can now handle MPEG2 streams.</LI>
+ </UL>
+ 
+ <H3>
+ 3.12pre7</H3>
+ 
+ <UL>
+ <LI>
+ MPEG2 layer III now working!&nbsp; lower bit rates (down to 8kbs) and 3
+ more sampling frequencies:&nbsp; 16000, 22050, 24000Hz. Quality is poor
+ - the psy-model does not yet work with these sampling frequencies.</LI>
+ 
+ <LI>
+ Fixed "ERROR: outer_loop(): huff_bits &lt; 0." bug when using VBR.</LI>
+ 
+ <LI>
+ bash and sh scripts to run LAME on multiple files now included.&nbsp; (from
+ Robert Hegemann and Gerhard Wesp respectively)</LI>
+ 
+ <LI>
+ bug fix in encoding times for longer files from&nbsp; (Alvaro Martinez
+ Echevarria)</LI>
+ 
+ <LI>
+ yet another segfault in the frame analyzer fixed.</LI>
+ 
+ <LI>
+ ISO psy-model/bit allocation routines removed.&nbsp; This allowed makeframe()
+ to be made much simpler, and most of the complicated buffering is now gone.
+ Eventually I would like the encoding engine to be a stand alone library.</LI>
+ </UL>
+ 
+ <H3>
+ 3.12pre6</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#FF0000">Better VBR tuning.&nbsp; Find minimum bitrate with
+ distortion less than the allows maximum.&nbsp; A minimum bit rate is imposed
+ on frames with short blocks (where the measured distortion can not be trusted).&nbsp;&nbsp;
+ A minimum frame bitrate can be specified with -b, default=64kbs.</FONT></LI>
+ 
+ <LI>
+ <A HREF="http://www.zip.com.au/~erikd/libsndfile">LIBSNDFILE</A> support.&nbsp;
+ With libsndfile, LAME can encode almost all sound formats.&nbsp; Albert
+ Faber did the work for this, including getting libsndfile running under
+ win32.</LI>
+ 
+ <LI>
+ CRC checksum now working!&nbsp;&nbsp; (Thanks to Johannes Overmann )</LI>
+ 
+ <LI>
+ frame analyzer will now work with mono .mp3 files</LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">more code tweeks from Jan Peman.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Compaq-Alpha(Linux) fixes and speedups from Nils
+ Faerber.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Faster bin_search_StepSize from Juha Laukala.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Faster quantize() from Mike Cheng</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Faster quantize_xrpow() from Chris Matrakidis.&nbsp;
+ xrpow_flag removed since this option is now on by default.</FONT></LI>
+ 
+ <LI>
+ Fixed .wav header parsing from Nils Faerber.</LI>
+ 
+ <LI>
+ Xing VBR frame info header code from Albert Faber.&nbsp;&nbsp; "Xing" and
+ "LAME 3.12" embedded in first frame.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in VBR bit allocation based on "over" value fixed.</FONT></LI>
+ </UL>
+ 
+ <H3>
+ LAME 3.11&nbsp; June 3 1999</H3>
+ 
+ <BLOCKQUOTE>
+ <LI>
+ Almost all warnings (-Wall) now fixed!&nbsp; (Thanks to Jan Peman)</LI>
+ 
+ <LI>
+ More coding improvements from Gabriel Bouvigne and Warren Toomey.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">VBR&nbsp; (variable bit rate).&nbsp;&nbsp; Increases
+ bit rate for short blocks and for frames where the number of bands containing
+ audible distortion is greater than a given value.&nbsp; Much tuning needs
+ to be done.</FONT></LI>
+ 
+ <LI>
+ Patch to remove all atan() calls from James Droppo.</LI>
+ </BLOCKQUOTE>
+ 
+ <H3>
+ LAME 3.10 May 30 1999</H3>
+ 
+ <UL>
+ <LI>
+ <FONT COLOR="#3366FF">Fast mode (-f)&nbsp; disables psycho-acoustic model
+ for real time encoding on older machines.&nbsp; Thanks to Lauri Ahonen
+ who first sent a patch for this.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">New bit reservoir usage scheme to accommodate the
+ new pre-echo detection formulas.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Tuning of AWS and ENER_AWS pre-echo formulas by Gabriel
+ Bouvigne and myself.&nbsp; They work great!&nbsp; now on by default.</FONT></LI>
+ 
+ <LI>
+ In jstereo, force blocktypes for left &amp; right channels to be identical.&nbsp;
+ FhG seems to do this.&nbsp; It can be disabled with "-d".</LI>
+ 
+ <LI>
+ Patches to compile MP3x under win32 (Thanks to Albert Faber).</LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">bin_serach_stepsize limited to a quantizationStepSize
+ of&nbsp; -210 through 45.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">outer_loop()&nbsp; will now vary Mid &amp; Side scalefactors
+ independently.&nbsp; Can lead to better quantizations, but it is slower
+ (twice as many quantizations to look at).&nbsp; Running with "-m f" does
+ not need this and will run at the old speed</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Bug in inner_loop would allow quantizations larger
+ than allowed.&nbsp; (introduced in lame3.04, now fixed.)</FONT></LI>
+ 
+ <LI>
+ Updated HTML documentation from Gabriel Bouvigne.</LI>
+ 
+ <LI>
+ Unix&nbsp; man page from William Schelter.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">numlines[] bug fixed.&nbsp; (Thanks to Rafael Luebbert,
+ MPecker author).</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Quantization speed improvements from Chirs Matrakidis.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">When comparing quantizations with the same number
+ of bands with audible distortion, use the one with the largest scalefactors,
+ not the first one outer_loop happened to find.</FONT></LI>
+ 
+ <LI>
+ Improved defination of best quantization when using -f (fast mode).</LI>
+ 
+ <LI>
+ subblock code now working.&nbsp; But no algorithm to choose subblock gains
+ yet.</LI>
+ 
+ <LI>
+ Linux now segfaults on floating point exceptions.&nbsp; Should prevent
+ me from releasing binaries that crash on other operating systems.</LI>
+ </UL>
+ 
+ <H4>
+ May 22 1999</H4>
+ 
+ <UL>
+ <LI>
+ Version 3.04 released.</LI>
+ 
+ <LI>
+ Preliminary documentation from Gabriel Bouvigne.</LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">I wouldn't have thought it was possible, but now
+ there are even more speed improvements from Chris Matrakidis!&nbsp; Removed
+ one FFT when using joint stereo, and many improvements in loop.c.</FONT></LI>
+ 
+ <LI>
+ "Fake" ms_stereo mode renamed "Force" ms_stereo since it forces mid/side
+ stereo on all frames.&nbsp; For some music this is said to be a problem,
+ but for most music mode is probably better than the default jstereo because
+ it uses specialized mid/side channel masking thresholds.</LI>
+ 
+ <LI>
+ Small bugs in Force ms_stereo mode fixed.</LI>
+ 
+ <LI>
+ Compaq Alpha fixes from Nathan Slingerland.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Some new experimental pre-echo detection formulas
+ in l3psy.c (#ifdef AWS and #ifdef ENER_AWS, both off by default.&nbsp;
+ Thanks to Gabriel Bouvigne and Andre Osterhues)</FONT></LI>
+ 
+ <LI>
+ Several bugs in the syncing of data displayed by mp3x (the frame analyzer)
+ were fixed.</LI>
+ 
+ <LI>
+ highq (-h) option added.&nbsp; This turns on things (just one so far) that
+ should sound better but slow down LAME.</LI>
+ </UL>
+ <B>May 18 1999</B>
+ <UL>
+ <LI>
+ Version 3.03 released.</LI>
+ 
+ <LI>
+ <FONT COLOR="#3366FF">Faster (20%) &amp; cleaner FFT (Thanks to Chris Matrakidis&nbsp;
+ http://www.geocities.com/ResearchTriangle/8869/fft_summary.html)</FONT></LI>
+ 
+ <LI>
+ mods so it works with VC++ (Thanks to Gabriel Bouvigne, www.mp3tech.org)</LI>
+ 
+ <LI>
+ MP3s marked "original" by default&nbsp; (Thanks to Gabriel Bouvigne, www.mp3tech.org)</LI>
+ 
+ <LI>
+ Can now be compiled into a BladeEnc compatible .DLL&nbsp;&nbsp; (Thanks
+ to&nbsp; Albert Faber, CDex author)</LI>
+ 
+ <LI>
+ Patches for "silent mode" and stdin/stdout&nbsp; (Thanks to Lars Magne
+ Ingebrigtsen)</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Fixed rare bug: if a long_block is sandwiched between
+ two short_blocks, it must be changed to a short_block, but the short_block
+ ratios have not been computed in l3psy.c.&nbsp; Now always compute short_block
+ ratios just in case.</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">Fixed bug with initial quantize step size when many
+ coefficients are zero.&nbsp; (Thanks to Martin Weghofer).</FONT></LI>
+ 
+ <LI>
+ Bug fixed in MP3x display of audible distortion.</LI>
+ 
+ <LI>
+ improved status display (Thanks to Lauri Ahonen).</LI>
+ </UL>
+ 
+ <H4>
+ May 12 1999</H4>
+ 
+ <UL>
+ <LI>
+ Version 3.02 released.</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">encoder could use ms_stereo even if channel 0 and
+ 1 block types were different.&nbsp; (Thanks to Jan Rafaj)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">added -k option to disable the 16kHz cutoff at 128kbs.&nbsp;
+ This cutoff is never used at higher bitrates. (Thanks to Jan Rafaj)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">modified pe bit allocation formula to make sense
+ at bit rates other than 128kbs.</FONT></LI>
+ 
+ <LI>
+ fixed l3_xmin initialization problem which showed up under FreeBSD.&nbsp;
+ (Thanks to Warren Toomey)</LI>
+ </UL>
+ <B>May 11 1999</B>
+ <UL>
+ <LI>
+ Version 3.01 released</LI>
+ 
+ <LI>
+ max_name_size increased to 300&nbsp; (Thanks to Mike Oliphant)</LI>
+ 
+ <LI>
+ patch to allow seeks on input file (Thanks to Scott Manley)</LI>
+ 
+ <LI>
+ fixes for mono modes (Thanks to everyone who pointed this out)</LI>
+ 
+ <LI>
+ overflow in calc_noise2 fixed</LI>
+ 
+ <LI>
+ bit reservoir overflow when encoding lots of frames with all zeros&nbsp;
+ (Thanks to Jani Frilander)</LI>
+ </UL>
+ 
+ <P><BR><B>May 10 1999</B>
+ <UL>
+ <LI>
+ Version 3.0 released</LI>
+ 
+ <LI>
+ <FONT COLOR="#FF0000">added GPSYCHO (developed by Mark Taylor)</FONT></LI>
+ 
+ <LI>
+ <FONT COLOR="#000000">added MP3x (developed by Mark Taylor)</FONT></LI>
+ 
+ <LI>
+ LAME now maintained by Mark Taylor</LI>
+ </UL>
+ <B>November 8 1998</B>
+ <UL>
+ <LI>
+ Version 2.1f released</LI>
+ 
+ <LI>
+ 50% faster filter_subband() routine in encode.c contributed by James Droppo</LI>
+ </UL>
+ <B>November 2 1998</B>
+ <UL>
+ <LI>
+ Version 2.1e released.</LI>
+ 
+ <LI>
+ New command line switch <B>-a</B> auto-resamples a stereo input file to
+ mono.</LI>
+ 
+ <LI>
+ New command line switch <B>-r</B> resamples from 44.1khz to 32khz [this
+ switch doesn't work really well. Very tinny sounding output files. Has
+ to do with the way I do the resampling probably]</LI>
+ 
+ <LI>
+ Both of these were put into the ISO code in the encode.c file, and are
+ simply different ways of filling the input buffers from a file.</LI>
+ </UL>
+ <B>October 31 1998</B>
+ <UL>
+ <LI>
+ Version 2.1d released</LI>
+ 
+ <LI>
+ Fixed memory alloc in musicin.c (for l3_sb_sample)</LI>
+ 
+ <LI>
+ Added new command line switch (-x) to force swapping of byte order</LI>
+ 
+ <LI>
+ Cleaned up memory routines in l3psy.c. All the mem_alloc() and free() routines
+ where changed so that it was only done <I>once</I> and not every single
+ time the routine was called.</LI>
+ 
+ <LI>
+ Added a compile time switch -DTIMER that includes all timing info. It's
+ a switch for the time being until some other people have tested on their
+ system. Timing code has a tendency to do different things on different
+ platforms.</LI>
+ </UL>
+ <B>October 18 1998</B>
+ <UL>
+ <LI>
+ Version 2.1b released.</LI>
+ 
+ <LI>
+ Fixed up bug: all PCM files were being read as WAV.</LI>
+ 
+ <LI>
+ Played with the mem_alloc routine to fix crash under amigaos (just allocating
+ twice as much memory as needed). Might see if we can totally do without
+ this routine. Individual malloc()s where they are needed instead</LI>
+ 
+ <LI>
+ Put Jan Peman's quality switch back in. This reduces quality via the '-q&nbsp;<int>'
+ switch. Fun speedup which is mostly harmless if you're not concerned with
+ quality.</LI>
+ 
+ <LI>
+ Compiling with amiga-gcc works fine</LI>
+ </UL>
+ <B>October 16 1998</B>
+ <UL>
+ <LI>
+ Version 2.1a released. User input/output has been cleaned up a bit. WAV
+ file reading is there in a very rudimentary sense ie the program will recognize
+ the header and skip it, but not read it. The WAV file is assumed to be
+ 16bit stereo 44.1khz.</LI>
+ </UL>
+ <B>October 6 1998</B>
+ <UL>
+ <LI>
+ Version 2.1 released with all tables now incorporated into the exe. Thanks
+ to <B>Lars Magne Ingebrigtseni</B>(larsi@ifi.uio.no)</LI>
+ </UL>
+ <B>October 4 1998</B>In response to some concerns about the quality of
+ the encoder, I have rebuilt the encoder from scratch and carefully compared
+ output at all stages with the output of the unmodified ISO encoder. <A HREF="http://www.uq.net.au/~zzmcheng/lame/download.html">Version2.0</A>
+ of LAME is built from the ISO source code (dist10), and incorporates modifications
+ from myself and the 8hz effort. The output file from LAME v2.0 is <I>identical</I>
+ to the output of the ISO encoder for my test file.Since I do not have heaps
+ of time, I left the ISO AIFF file reader in the code, and did not incorporate
+ a WAV file reader.Added section on <A HREF="http://www.uq.net.au/~zzmcheng/lame/quality.html">quality</A><B>October
+ 1 1998</B>
+ <UL>
+ <LI>
+ Updated web page and released LAME v1.0</LI>
+ </UL>
+ <B>Up to September 1998</B>
+ <UL>Working on the 8hz source code...
+ <UL>
+ <LI>
+ Patched the <A HREF="http://www.8hz.com/">8hz</A> source code</LI>
+ 
+ <LI>
+ 45% faster than original source (on my freebsd p166).</LI>
+ 
+ <UL>
+ <LI>
+ m1 - sped up the mdct.c and quantize() functions [MDCTD, MDCTD2, LOOPD]</LI>
+ 
+ <LI>
+ m2 - sped up the filter_subband routine using <B>Stephane Tavenard</B>'s
+ work from musicin [FILTST]</LI>
+ 
+ <LI>
+ m2 - minor cleanup of window_subband [WINDST2]</LI>
+ 
+ <LI>
+ m2 - Cleaned up a few bits in l3psy.c. Replaced a sparse matrix multiply
+ with a hand configured unrolling [PSYD]</LI>
+ 
+ <LI>
+ m3 - (amiga only) Added in the asm FFT for m68k (based on sources from
+ <B>Henryk
+ Richter</B> and <B>Stephane Tavenard</B>)</LI>
+ 
+ <LI>
+ m4 - raw pcm support back in</LI>
+ 
+ <LI>
+ m5 - put in a byte-ordering switch for raw PCM reading (just in case)</LI>
+ 
+ <LI>
+ m6 - reworked the whole fft.c file. fft now 10-15% faster.</LI>
+ 
+ <LI>
+ m7 - totally new fft routine. exploits fact that this is a real->complex
+ fft. About twice as fast as previous fastest fft (in m6). (C fft routine
+ is faster than the asm one on an m68k!)</LI>
+ 
+ <LI>
+ m8</LI>
+ 
+ <UL>
+ <LI>
+ - Now encodes from stdin. Use '-' as the input filename. Thanks to <B>Brad
+ Threatt</B></LI>
+ 
+ <LI>
+ - Worked out that the 1024point FFT only ever uses the first 6 phi values,
+ and the first 465 energy values. Saves a bunch of calculations.</LI>
+ 
+ <LI>
+ - Added a speed-up/quality switch. Speed is increased but quality is decreased
+ <I>slightly</I>.
+ My ears are bad enough not to be able to notice the difference in quality
+ at low settings :). Setting '-q 1' improves speed by about 10%. '-q 100'
+ improves speed by about 26%. Enoding of my test track goes from 111s (at
+ default '-q 0') to 82s (at -q 100). Thanks to <B>Jan Peman</B> for this
+ tip.</LI>
+ </UL>
+ 
+ <LI>
+ m9 - fixed an error in l3psy.c. numlines[] is overwritten with incorrect
+ data. Added a new variable numlines_s[] to fix this. Thanks again to <B>Jan
+ Peman</B>.</LI>
+ 
+ <LI>
+ m10 - Down to 106 seconds by selecting a few more compiler options. Also
+ added a pow20() function in l3loop.c to speed up (ever so slightly) calls
+ to pow(2.0, x)</LI>
+ 
+ <LI>
+ m11</LI>
+ 
+ <UL>
+ <LI>
+ No speedups. Just cleaned up some bits of the code.</LI>
+ 
+ <LI>
+ Changed K&amp;R prototyping to 'normal' format. Thanks to <B>Steffan Haeuser</B>
+ for his help here.</LI>
+ 
+ <LI>
+ Changed some C++ style comments to normal C comments in huffman.c</LI>
+ 
+ <LI>
+ Removed the #warning from psy_data.h (it was getting annoying!)</LI>
+ 
+ <LI>
+ Removed reference in bitstream.c to malloc.h. Is there a system left where
+ malloc.h hasn't been superceded by stdlib.h?</LI>
+ </UL>
+ 
+ <LI>
+ In Progess:</LI>
+ 
+ <UL>
+ <LI>
+ my PSYD hack for the spreading functions is only valid for 44.1khz - Should
+ really put in a "if freq = 44.1khz" switch for it. Someone might want to
+ extend the speedup for 48 and 32khz.</LI>
+ 
+ <LI>
+ Putting in Jan Peman's quantanf_init speedup.</LI>
+ </UL>
+ </UL>
+ </UL>
+ </UL>
+ 
+ <HR><B><A HREF="mailto:mikecheng@cryogen.com">mike/cstar</A></B>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/index.html lame3.50/doc/html/index.html
*** encoder/doc/html/index.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/index.html	Tue Sep 21 14:38:26 1999
***************
*** 0 ****
--- 1,54 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>L.A.M.E. V3 Next Generation High-End MPEG Layer III Encoding</TITLE>
+ <META NAME="description" CONTENT="MP3EncV3.1 Next Generation High-End MPEG Layer-3 Encoding">
+ <META NAME="keywords" CONTENT="mp3enc">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node1.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <P> 
+ <H1 ALIGN="CENTER"><FONT SIZE="+4"><i>LAME</i> V3.28 <BR>
+   </FONT> 
+   <P><FONT SIZE="+4"> <BR>
+     </font> <BIG>Next Generation High-End MPEG&nbsp;Layer&nbsp;III Encoding <BR>
+     </BIG> 
+ </H1>
+ <P ALIGN="CENTER"><STRONG>Open Source Project <BR>
+   <A HREF="http://www.sulaco.org/mp3">http://www.sulaco.org/mp3</A> </STRONG></P>
+ <P ALIGN="LEFT"></P>
+ <P> 
+ <DIV ALIGN="LEFT"> 
+   <P> 
+ </DIV>
+ <BR>
+ <HR>
+ <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A HREF="node5.html#SECTION00300000000000000000"> For the impatient</A> 
+     <UL>
+       <LI><A HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+         <UL>
+           <LI><A HREF="node6.html#SECTION00311000000000000000"> The purpose of 
+             audio compression</A> 
+           <LI><A HREF="node6.html#SECTION00312000000000000000"> The two parts 
+             of audio compression</A> 
+           <LI><A HREF="node6.html#SECTION00313000000000000000"> Compression ratios, 
+             bitrate and quality</A> 
+         </UL>
+       <LI><A HREF="node7.html#SECTION00320000000000000000"> Some examples</A> 
+     </UL>
+   <LI><a href="switchs.html">Command line switch reference</a>
+   <LI><a href="history.html">History</a> 
+   <LI><a href="contributors.html">Contributors</a><BR>
+ </UL>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/lame.css lame3.50/doc/html/lame.css
*** encoder/doc/html/lame.css	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/lame.css	Tue Sep 21 14:38:27 1999
***************
*** 0 ****
--- 1,24 ----
+ BODY {
+         font-family: Arial, Helvetica, sans-serif;
+         position: absolute;
+         padding-left: 1cm;
+         margin-left: 1cm;
+      }
+ 
+ h1, h2, h3 {
+         margin-left: -1cm; text-align: left
+         }
+ 
+ TABLE { text-align: left; font-family: Arial, Helvetica, sans-serif;}
+ TH {background-color: #C0C0C0}
+ TD {font-family: Arial, Helvetica, sans-serif;}
+ 
+ SMALL.TINY		{ font-size : xx-small }
+ SMALL.SCRIPTSIZE	{ font-size : xx-small }
+ SMALL.FOOTNOTESIZE	{ font-size : x-small  }
+ SMALL.SMALL		{ font-size : small    }
+ BIG.LARGE		{ font-size : large    }
+ BIG.XLARGE		{ font-size : x-large  }
+ BIG.XXLARGE		{ font-size : xx-large }
+ BIG.HUGE		{ font-size : xx-large }
+ BIG.XHUGE		{ font-size : xx-large }
diff -r -c -N encoder/doc/html/node5.html lame3.50/doc/html/node5.html
*** encoder/doc/html/node5.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/node5.html	Tue Sep 21 14:38:27 1999
***************
*** 0 ****
--- 1,51 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>For the impatient</TITLE>
+ <META NAME="description" CONTENT="For the impatient">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node10.html">
+ <LINK REL="previous" HREF="node2.html">
+ <LINK REL="up" HREF="mp3enc.html">
+ <LINK REL="next" HREF="node6.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > 
+ <H1><A NAME="SECTION00300000000000000000"> For the impatient</A> </H1>
+ If you are new to audio compression, you should read section <A HREF="node6.html#chap-intro">1.1</A> 
+ for an introduction about audio compression and MPEG Layer-3. 
+ <P> If, however, you want to jump right into the business of sound compression, 
+   then Section <A HREF="node7.html#cmdl-examples">1.2</A> will show you some prefabricated 
+   command lines that will give you compressed audio streams right away. 
+ <P> If you are an expert in audio coding already, the command line switch reference 
+   page might come in handy. 
+ <P> <BR>
+ <HR>
+ <!--Table of Child-Links--> <A NAME="CHILD_LINKS">&#160;</A> 
+ <UL>
+   <LI><A NAME="tex2html127"
+  HREF="node6.html#SECTION00310000000000000000"> Introduction</A> 
+     <UL>
+       <LI><A NAME="tex2html128"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+       <LI><A NAME="tex2html129"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+       <LI><A NAME="tex2html130"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+         quality</A> 
+     </UL>
+   <LI><A NAME="tex2html131"
+  HREF="node7.html#SECTION00320000000000000000"> Some examples</A> 
+   <LI><A NAME="tex2html132"
+  HREF="switchs.html"> Command line switch reference</A> 
+ </UL>
+ <!--End of Table of Child-Links--> <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node6.html lame3.50/doc/html/node6.html
*** encoder/doc/html/node6.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/node6.html	Tue Sep 21 14:38:27 1999
***************
*** 0 ****
--- 1,133 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Introduction</TITLE>
+ <META NAME="description" CONTENT="Introduction">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node7.html">
+ <LINK REL="previous" HREF="node5.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node7.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <FONT FACE = Helvetica > <!--Table of Child-Links--> <A NAME="CHILD_LINKS"><strong>Subsections</strong></A> 
+ <UL>
+   <LI><A NAME="tex2html146"
+  HREF="node6.html#SECTION00311000000000000000"> The purpose of audio compression</A> 
+   <LI><A NAME="tex2html147"
+  HREF="node6.html#SECTION00312000000000000000"> The two parts of audio compression</A> 
+   <LI><A NAME="tex2html148"
+  HREF="node6.html#SECTION00313000000000000000"> Compression ratios, bitrate and 
+     quality</A> 
+ </UL>
+ <!--End of Table of Child-Links--> 
+ <HR>
+ <H1><A NAME="SECTION00310000000000000000"> Introduction</A> </H1>
+ <A NAME="chap-intro">&#160;</A> There is a lot of confusion surrounding the terms 
+ <A NAME="352">&#160;</A><I>audio compression</I>, <A NAME="354">&#160;</A><I>audio 
+ encoding</I>, and <A NAME="356">&#160;</A><I>audio decoding</I>. This section 
+ will give you an overview what audio coding (another one of these terms...) is 
+ all about. 
+ <P> 
+ <H2><A NAME="SECTION00311000000000000000"> The purpose of audio compression</A> 
+ </H2>
+ <P> Up to the advent of audio compression, high-quality digital audio data took 
+   a lot of hard disk space to store. Let us go through a short example. 
+ <P> You want to, say, sample your favorite 1-minute song and store it on your 
+   harddisk. Because you want CD quality, you sample at 44.1&nbsp;kHz, stereo, 
+   with 16 bits per sample. 
+ <P> 44100 Hz means that you have 44100 values per second coming in from your sound 
+   card (or input file). Multiply that by two because you have two channels. Multiply 
+   by another factor of two because you have two bytes per value (that's what 16 
+   bit means). The song will take up <NOBR>44100 samples/s &middot; 2 channels 
+   &middot; 2 bytes/sample &middot; 60 s/min ~ 10 MBytes</NOBR> of storage space 
+   on your harddisk. 
+ <P> If you wanted to download that over the internet, given an average 28.8&nbsp;modem, 
+   it would take you (at least) <NOBR>10000000 bytes &middot; 8 bits/byte / (28800 
+   bits/s) &middot; / (60 s/min) ~ 45 minutes</NOBR> 
+ <DIV ALIGN="CENTER"> <B>Just to download one minute of music!</B> </DIV>
+ <P> Digital audio coding, which - in this context - is synonymously called digital 
+   audio compression as well, is the art of minimizing storage space (or channel 
+   bandwidth) requirements for audio data. Modern perceptual audio coding techniques 
+   (like MPEG Layer-3) exploit the properties of the human ear (the perception 
+   of sound) to achieve a size reduction by a factor of 12 with little or no perceptible 
+   loss of quality. 
+ <P> Therefore, such schemes are the key technology for high quality low bit-rate 
+   applications, like soundtracks for CD-ROM games, solid-state sound memories, 
+   Internet audio, digital audio broadcasting systems, and the like. 
+ <P> 
+ <H2><A NAME="SECTION00312000000000000000"> The two parts of audio compression</A> 
+ </H2>
+ <P> Audio compression really consists of two parts. The first part, called <A NAME="358">&#160;</A><I>encoding</I>, 
+   transforms the digital audio data that resides, say, in a WAVE file, into a 
+   highly compressed form called <A NAME="360">&#160;</A><I>bitstream</I>. To play 
+   the bitstream on your soundcard, you need the second part, called <A NAME="362">&#160;</A><I>decoding</I>. 
+   Decoding takes the bitstream and re-expands it to a WAVE file. 
+ <P> The program that effects the first part is called an audio <I>encoder</I>. 
+   <i>LAME</i> is such an encoder . The program that does the second part is called 
+   an audio <I>decoder</I>. One well-known MPEG&nbsp;Layer-3 decoder is <tt>X11Amp</tt>, 
+   another <TT>mpg123</TT>. Both can be found on <A NAME="tex2html1"
+  HREF="http://www.mp3tech.org">http://www.mp3tech.org</A> . 
+ <H2><A NAME="SECTION00313000000000000000"> Compression ratios, bitrate and quality</A> 
+ </H2>
+ <P> It has not been explicitly mentioned up to now: What you end up with after 
+   encoding and decoding is not the same sound file anymore: All superflous information 
+   has been squeezed out, so to say. It is not the same <I>file</I>, but it will 
+   <I>sound</I> the same - more or less, depending on how much compression had 
+   been performed on it. 
+ <P> Generally speaking, the lower the compression ratio achieved, the better the 
+   sound quality will be in the end - and <I>vice versa</I>. Table <A HREF="node6.html#table-soundq">1.1</A> 
+   gives you an overview about quality achievable. 
+ <P> Because compression ratio is a somewhat unwieldy measure, experts use the 
+   term <A NAME="365">&#160;</A><I>bitrate</I> when speaking of the strength of 
+   compression. Bitrate denotes the average number of bits that one second of audio 
+   data will take up in your compressed bitstream. Usually the units used will 
+   be kbps, which is <SUP>kBits</SUP>/<SUB>s</SUB>, or 1000&nbsp;<SUP>bits</SUP>/<SUB>s</SUB>. 
+   To calculate the number of bytes per second of audio data, simply divide the 
+   number of bits per second by eight. 
+ <P> <BR>
+ <DIV ALIGN="CENTER"><A NAME="table-soundq">&#160;</A> <A NAME="95">&#160;</A> 
+   <TABLE CELLPADDING=3 BORDER="1">
+     <CAPTION><STRONG>Table 1.1:</STRONG> Bitrate versus sound quality</CAPTION>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>Bitrate</TD>
+       <TD ALIGN="RIGHT" nowrap>Bandwidth</TD>
+       <TD ALIGN="LEFT" nowrap>Quality comparable to or better than</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>8 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>2.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>POTS (telephone sound)</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>16 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>4.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>shortwave radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>32 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>7.5 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>AM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>64 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>11 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>FM radio</TD>
+     </TR>
+     <TR VALIGN="TOP"> 
+       <TD ALIGN="RIGHT" nowrap>128 kBps</TD>
+       <TD ALIGN="RIGHT" nowrap>16 kHz</TD>
+       <TD ALIGN="LEFT" nowrap>CD</TD>
+     </TR>
+   </TABLE>
+ </DIV>
+ <BR>
+ </font> 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/node7.html lame3.50/doc/html/node7.html
*** encoder/doc/html/node7.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/node7.html	Tue Sep 21 22:40:21 1999
***************
*** 0 ****
--- 1,36 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
+ <HTML>
+ <HEAD>
+    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
+    <META NAME="description" CONTENT="Some examples">
+    <META NAME="keywords" CONTENT="lame">
+    <META NAME="resource-type" CONTENT="document">
+    <META NAME="distribution" CONTENT="global">
+    <META NAME="GENERATOR" CONTENT="Mozilla/4.08 [en] (X11; I; Linux 2.0.36 i686) [Netscape]">
+    <TITLE>Some examples</TITLE>
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node8.html">
+ <LINK REL="previous" HREF="node6.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node8.html">
+ </HEAD>
+ <BODY TEXT="#000000" BGCOLOR="#F9FBFB" LINK="#006666" VLINK="#4C4C4C" ALINK="#995500">
+ 
+ <H1>
+ <A NAME="SECTION00320000000000000000"></A><FONT FACE="Helvetica">Some examples</FONT></H1>
+ <A NAME="cmdl-examples"></A>
+ <UL>
+ <LI>
+ <FONT FACE="Helvetica">Recommended usage: Encode a WAVE-file <TT>myfile.wav</TT>
+ to a bitrate of 128000 bits/s, writing to a plain bitstream <TT>myfile.mp3</TT>
+ and using high quality mode:</FONT></LI>
+ 
+ <BR><TT><FONT FACE="Helvetica">lame -h myfile.wav myfile.mp3</FONT></TT>
+ <LI>
+ <FONT FACE="Helvetica">Encode a plain PCM stream (2-channel, 44.1 kHz)
+ to a plain 56 kBit/s Layer-3 stream, using the encoder as filter</FONT></LI>
+ 
+ <BR><TT><FONT FACE="Helvetica">lame -r -s 44.1 -b 56 - -</FONT></TT></UL>
+ 
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/html/switchs.html lame3.50/doc/html/switchs.html
*** encoder/doc/html/switchs.html	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/html/switchs.html	Tue Sep 21 14:38:28 1999
***************
*** 0 ****
--- 1,280 ----
+ <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
+ <HTML>
+ <HEAD>
+ <TITLE>Command line switch reference</TITLE>
+ <META NAME="description" CONTENT="Command line switch reference">
+ <META NAME="keywords" CONTENT="lame">
+ <META NAME="resource-type" CONTENT="document">
+ <META NAME="distribution" CONTENT="global">
+ <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso_8859_1">
+ <LINK REL="STYLESHEET" HREF="lame.css">
+ <LINK REL="next" HREF="node9.html">
+ <LINK REL="previous" HREF="node7.html">
+ <LINK REL="up" HREF="node5.html">
+ <LINK REL="next" HREF="node9.html">
+ </HEAD>
+ <BODY TEXT=#000000
+         BGCOLOR=#F9FBFB LINK=#006666 VLINK=#4C4C4C
+         ALINK=#995500>
+ <H1>Command line switch reference</H1>
+ <P> 
+ <TABLE CELLPADDING=3 BORDER="1">
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap>switch</TD>
+     <TD ALIGN="LEFT" nowrap>parameter</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#a">-a</a></tt></td>
+     <td align="LEFT" nowrap>downmix stereo file to mono</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#b">-b</a></tt></td>
+     <td align="LEFT" nowrap>bitrate (32, 40, 48, 56, 64, 96, 112, <b>128</b>, 
+       160, 192, 224, 256, 320)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#c">-c</a></tt></td>
+     <td align="LEFT" nowrap>copyright</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#e">-e</a></tt></td>
+     <td align="LEFT" nowrap>de-emphasis (<b>n</b>, 5, c)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#f">-f</a></tt></td>
+     <td align="LEFT" nowrap> fast mode</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt>-g</tt></td>
+     <td align="LEFT" nowrap>turn on MP3x graphical frame analyser (might not be 
+       available on your release)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#h">-h</a></tt></td>
+     <td align="LEFT" nowrap>high quality</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#k">-k</a></tt></td>
+     <td align="LEFT" nowrap> full bandwidth</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#m">-m</a></tt></td>
+     <td align="LEFT" nowrap>stereo mode (s, <b>j</b>, f, m)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#-nohist">--nohist</a></tt></td>
+     <td align="LEFT" nowrap>disable histogram display</td>
+   </tr>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><tt><a href="#o">-o</a></tt></TD>
+     <TD ALIGN="LEFT" nowrap>non-original</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#p">-p</a></tt></td>
+     <td align="LEFT" nowrap>error protection</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#r">-r</a></tt></td>
+     <td align="LEFT" nowrap>input file is raw pcm</td>
+   </tr>
+   <TR VALIGN="TOP"> 
+     <TD ALIGN="LEFT" nowrap><TT><a href="#s">-s</a></TT></TD>
+     <TD ALIGN="LEFT" nowrap>sampling frequency</TD>
+   </TR>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#S">-S</a></tt></td>
+     <td align="LEFT" nowrap>silent operation</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#t">-t</a></tt></td>
+     <td align="LEFT" nowrap>disable VBR tag</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#V">-V</a></tt></td>
+     <td align="LEFT" nowrap>VBR quality setting (0...9)</td>
+   </tr>
+   <tr valign="TOP"> 
+     <td align="LEFT" nowrap><tt><a href="#x">-x</a></tt></td>
+     <td align="LEFT" nowrap>swapbytes</td>
+   </tr>
+ </TABLE>
+ <BR>
+ <dl> 
+   <dt><strong><tt>-a</tt><a name="a">&nbsp;&nbsp;&nbsp;&nbsp;downmix&#160;</a></strong> 
+   <dd>Mix the stereo input file to mono and encode as mono. This option is only 
+     needed in the case of raw PCM stereo input (because LAME cannot determine 
+     the number of channels in the input file).<br>
+     To encode a stereo PCM input file as mono, use "lame -m s -a".<br>
+     For WAV and AIFF input files, using "-m m" will always produce a mono .mp3 
+     file from both mono and stereo input.<br>
+     The downmix is calculated as the sum of the left and right channel, attenuated 
+     by 6 dB. 
+   <dt><br>
+     <br>
+     <strong><tt>-b</tt><a name="b">&nbsp;&nbsp;&nbsp;&nbsp;bitrate&nbsp;</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd>For MPEG1 (sampling frequencies of 32, 44.1 and 48kHz)<br>
+     n = 32,40,48,56,64,80,96,112,128,160,192,224,256,320<br>
+     <br>
+     For MPEG2 (sampling frequencies of 16, 22.05 and 24kHz)<br>
+     n = 8,16,24,32,40,48,56,64,80,96,112,128,144,160<br>
+     <br>
+     Default is 128kbs MPEG1, 80kbs MPEG2. When used with variable bitrate encodings 
+     (VBR), -b specifies the minimum bitrate to use. This is useful to prevent 
+     LAME VBR from using some very aggressive compression which can cause some 
+     distortion due to small flaws in the psycho-acoustic model. 
+   <dd> 
+   <dt><br>
+     <br>
+     <strong><tt>-c</tt><a name="c">&nbsp;&nbsp;&nbsp;&nbsp;copyright</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd>Mark the encoded file as being copyrighted. 
+   <dd> 
+   <dt><br>
+     <br>
+     <strong><tt>-e n/5/c</tt><a name="e">&nbsp;&nbsp;&nbsp;&nbsp;de-emphasis</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> <br>
+     default=n (none) 
+   <dd> 
+   <dt><br>
+     <br>
+     <strong><tt>-f</tt><a name="f">&nbsp;&nbsp;&nbsp;&nbsp;fast mode</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> This switch forces the encoder to use the fast encoding mode. It will reduce 
+     a lot the quality of the output. This might be useful for real-time processing 
+     or streaming on slowest computers. 
+   <dt><br>
+     <br>
+     <strong><tt>-h</tt><a name="h">&nbsp;&nbsp;&nbsp;&nbsp;high quality</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Enables specialized mid/side masking thresholds to be used in jstereo mode. 
+     Will sound better but is 20% slower. It is only effective on joint stereo 
+     encoding. 
+   <dt><br>
+     <br>
+     <strong><tt>-k</tt><a name="k">&nbsp;&nbsp;&nbsp;&nbsp;full bandwidth</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Tells the encoder to use full bandwidth. By default, the encoder uses a 
+     16kHz bandwidth up to 64kbps per channel, and full bandwidth at higher bitrates. 
+     Increasing the bandwidth from the default setting might produces ringing artefacts 
+     at low bitrates. Use with care! 
+   <dt><br>
+     <br>
+     <strong><tt>-m s/<b>j/</b>f/m</tt><a name="m">&nbsp;&nbsp;&nbsp;&nbsp;stereo 
+     mode</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> jstereo is the default mode for stereo files with VBR or fixed bitrates 
+     of 160kbs or less. At higher fixed bitrates, the default is stereo. <b><i><br>
+     <br>
+     stereo</i></b> <br>
+     In this mode, the encoder makes no use of potentially existing correlations 
+     between the two input channels. It can, however, negotiate the bit demand 
+     between both channel, i.e. give one channel more bits if the other contains 
+     silence.<br>
+     <br>
+     <i><b>joint stereo</b></i><br>
+     In this mode, the encoder will make use of a correlation between both channels. 
+     The signal will be matrixed into a sum ("mid") and difference ("side") signal. 
+     For quasi-mono signals, this will give a significant gain in encoding quality.<br>
+     This mode does not destroy phase information like IS stereo that may be used 
+     by other encoders and thus can be used to encode DOLBY ProLogic surround signals. 
+     <br>
+     <br>
+     <b><i>forced joint stereo </i></b><br>
+     This mode will force MS joint stereo on all frames. It's slightly faster then 
+     jstereo. But it should only be used if you are sure every frame of the input 
+     file has very little stereo seperation.<br>
+     <br>
+     <b><i>mono</i></b><br>
+     The input will be encoded as a mono signal. If it was a stereo signal, it 
+     will be downsampled to mono.
+   <dt><br>
+     <br>
+     <strong><tt>--nohist</tt><a name="-nohist">&nbsp;&nbsp;&nbsp;&nbsp;disable 
+     histogram display</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> By default, LAME will display a bitrate histogram while producing VBR mp3 
+     files. This will disable that feature.<br>
+     Histogram display might not be available on your release. 
+   <dt><br>
+     <br>
+     <strong><tt>-o</tt><a name="o">&nbsp;&nbsp;&nbsp;&nbsp;non-original</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Mark the encoded file as a copy.
+   <dt><br>
+     <br>
+     <strong><tt>-p</tt><a name="p">&nbsp;&nbsp;&nbsp;&nbsp;error protection</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Turn on CRC error protection.
+   <dt><br>
+     <br>
+     <strong><tt>-r</tt><a name="r">&nbsp;&nbsp;&nbsp;&nbsp;input file is raw pcm</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Assume the input file is raw pcm. Sampling rate and mono/stereo/jstereo 
+     must be specified on the command line. Without -r, LAME will perform several 
+     fseek()'s on the input file looking for WAV and AIFF headers.<br>
+     Might not be available on your release.
+   <dt><br>
+     <br>
+     <strong><tt>-s 16/22.05/24/32/44.1/48</tt><a name="s">&nbsp;&nbsp;&nbsp;&nbsp;sampling 
+     frequency</a></strong> </dt>
+ </dl>
+ <dl> 
+   <dd> Required only for raw PCM input files. Otherwise it will be determined 
+     from the header. 
+   <dt><br>
+     <br>
+     <strong><tt>-S</tt><a name="S">&nbsp;&nbsp;&nbsp;&nbsp;silent operation</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Don't print progress report.
+   <dt><br>
+     <br>
+     <strong><tt>-t</tt><a name="t">&nbsp;&nbsp;&nbsp;&nbsp;disable VBR tag</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Disable writing of the VBR Tag (only valid in VBR mode).<br>
+     This tag in embedded in frame 0 of the MP3 file. It lets VBR aware players 
+     correctly seek and compute playing times of VBR files.
+   <dt><br>
+     <br>
+     <strong><tt>-V 0...9</tt><a name="V">&nbsp;&nbsp;&nbsp;&nbsp;VBR quality setting</a></strong></dt>
+ </dl>
+ <dl> 
+   <dd> Enable VBR (Variable BitRate) and specifies the value of VBR quality.<br>
+     default=4<br>
+     0=highest quality.
+   <dt><br>
+     <br>
+     <strong><tt>-x</tt><a name="x">&nbsp;&nbsp;&nbsp;&nbsp;swapbytes</a></strong> 
+   </dt>
+ </dl>
+ <dl> 
+   <dd> Swap bytes in the input file. For sorting out little endian/big endian 
+     type problems. If your encodings sounds like static, try this first. 
+ </dl>
+ <dl> 
+   <dd>&nbsp; 
+ </dl>
+ </BODY>
+ </HTML>
diff -r -c -N encoder/doc/man/lame.1 lame3.50/doc/man/lame.1
*** encoder/doc/man/lame.1	Wed Dec 31 17:00:00 1969
--- lame3.50/doc/man/lame.1	Fri Sep 10 09:52:02 1999
***************
*** 0 ****
--- 1,138 ----
+ .TH lame 1 "August 16, 1999" " " "LAME audio compressorMP3 "
+ .SH NAME
+ lame \- create mp3 audio files
+ .SH SYNOPSIS
+ .nf
+ lame [options] <infile> <outfile>
+ .fi
+ .SH DESCRIPTION
+ .PP
+ Lame is a program which can be used to create compressed audio files.
+ (Lame aint MP3 encoder).   These audio files can be played back by popular 
+ mp3 players such as mpg123.  To read from stdin, use "-" for <infile>.
+ To write to stdout, use a "-" for <outfile>.
+ 
+ .SH OPTIONS
+ .TP
+ .BI -m  " mode"
+  (s)tereo, (j)oint, (f)orce or (m)ono  (default j)
+ force = force mid/side stereo on all frames.  Faster if you know mid/side
+ stereo is appropriate for the input file.
+ .TP
+ .BI -s " sample" " freq"
+ frequency of input file (khz) - default 44.1
+ .TP
+ .BI -b  " bitrate"
+ set the bitrate, default 128kbps
+ (for VBR, this sets the allowed minimum bitrate)
+ 
+ .TP
+ .BI -v
+ use variable bitrate  (still undergoing development).  
+ .TP
+ .BI -V " n"
+ quality setting for VBR. Default n=4, 0=high quality,bigger files.
+ 9=smaller files
+ .TP
+ .BI -t
+ disable Xing VBR informational tag
+ .TP
+ .BI --nohist
+ disable VBR histogram display
+ 
+ .TP
+ .BI -h
+ slower, but higher quality
+ .TP
+ .BI -f
+ fast mode (low quality)
+ .TP
+ .BI -k
+ disable sfb=21 cutoff
+ .TP
+ .BI -d
+ allow channels to have different blocktypes
+ 
+ .TP
+ .BI -r
+ input is raw pcm
+ .TP
+ .BI -x
+ force byte-swapping of input
+ .TP
+ .BI -a
+ autoconvert from stereo to mono file for mono encoding
+ .TP
+ .BI -e " emp    "
+  de-emphasis n/5/c  (default    n)
+ .TP
+ .BI -p
+ add CRC error protection (this is working, but takes up 16bits)
+ .TP
+ .BI -c
+ mark as copyright
+ .TP
+ .BI -o
+ mark as non-original (i.e. do not set the original bit)
+ .TP
+ .BI -S
+ don't print progress report, VBR histograms
+ 
+ .TP
+ .BI -g
+ run graphical analysis on <infile>.  <infile> can also be a .mp3 file.
+ 
+ .SH EXAMPLES
+ .LP
+  Recommended way to create a fixed 128kbs mp3 file from a wav file
+ .IP
+ .B lame -h
+ .I foo.wav foo.mp3
+ .LP
+ Copy track 7 from a regular audio CD, using cdparanoia
+ 
+ .IP
+ .B cdparanoia 7 foo.wav  ;
+ .B  lame -h foo.wav foo.mp3
+ 
+ .LP
+ Copy track 7 from a regular audio CD with cdda2wav, where the cdrom device is
+ device /dev/cdrom to an mp3 file foo.mp3
+ 
+ .IP
+ .B cdda2wav \-O
+ .I wav
+ .B \-t 7 \-D
+ .I /dev/cdrom
+ .I \-
+ .B  | lame 
+ .I \- foo.mp3
+ 
+ .IP
+ 
+ .LP
+ Streaming from mono 22.05kHz raw pcm data and using sox to 
+ downsampling to 16kHz:
+ .IP
+ cat inputfile | sox -t raw -x -w -s -c 1 -r 22050 -  
+ -t raw -x -w -s -c 1 -r 16000 - | lame -r -m m -b 24 -s 16 - - > output
+ .IP
+ 
+ 
+ 
+ 
+ .SH BUGS
+ .PP
+ Quality is much better than encoders based on the ISO routines,
+ but still not as good as the FhG encoder.
+ .SH SEE ALSO
+ mpg123(1)
+ .SH AUTHORS
+ .nf
+ LAME originally developed by Mike Cheng
+ (www.uq.net.au/~zzmcheng)
+ GPSYCHO psycho-acoustic model by Mark Taylor 
+ (www.sulaco.org/mp3).
+ mpglib by Michael Hipp
+ Manual page by William Schelter
+ .f
diff -r -c -N encoder/encode.c lame3.50/encode.c
*** encoder/encode.c	Wed Jan 22 02:43:14 1997
--- lame3.50/encode.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1456 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: encode.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: encode.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
-  *          Davis Pan                                                 *
-  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
-  *                                      efilter to enfilter           *
-  *                                      ewindow to enwindow           *
-  *                              integrated "quantizer", "scalefactor",*
-  *                              and "transmission" files              *
-  *                              update routine "window_subband"       *
-  * 3/31/91  Bill Aspromonte     replaced read_filter by               *
-  *                              create_an_filter                      *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Incorporated Jean-Georges Fritsch's   *
-  *                              "bitstream.c" package.                *
-  *                              Incorporated Bill Aspromonte's        *
-  *                              filterbank coefficient matrix         *
-  *                              calculation routines and added        *
-  *                              roundoff to coincide with specs.      *
-  *                              Modified to strictly adhere to        *
-  *                              encoded bitstream specs, including    *
-  *                              "Berlin changes".                     *
-  *                              Modified PCM sound file handling to   *
-  *                              process all incoming samples and fill *
-  *                              out last encoded frame with zeros     *
-  *                              (silence) if needed.                  *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 19jun91  dpwe (Aware)        moved "alloc_*" reader to common.c    *
-  *                              Globals sblimit, alloc replaced by new*
-  *                              struct 'frame_params' passed as arg.  *
-  *                              Added JOINT STEREO coding, layers I,II*
-  *                              Affects: *_bit_allocation,            *
-  *                              subband_quantization, encode_bit_alloc*
-  *                              sample_encoding                       *
-  * 6/10/91  Earle Jennings      modified II_subband_quantization to   *
-  *                              resolve type cast problem for MS_DOS  *
-  * 6/11/91  Earle Jennings      modified to avoid overflow on MS_DOS  *
-  *                              in routine filter_subband             *
-  * 7/10/91  Earle Jennings      port to MsDos from MacIntosh version  *
-  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
-  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
-  *          Don H. Lee,                                               *
-  *          Peter W. Farrett                                          *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  *                              newly introduced function encode_CRC  *
-  *11/ 8/91  Kathy Wang          Documentation of code                 *
-  *                              All variablenames are referred to     *
-  *                              with surrounding pound (#) signs      *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 6/16/92  Shaun Astarabadi    Changed I_scale_factor_calc() and     *
-  *                              II_scale_factor_calc() to use scale   *
-  *                              factor 0 thru 62 only and not to      *
-  *                              encode index 63 into the bit stream.  *
-  * 7/27/92  Mike Li             (re-)Port to MS-DOS                   *
-  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() defs       *
-  * 3/31/93  Giogio Dimino       changed II_a_bit_allocation() from:   *
-  *                              if( ad > ...) to if(ad >= ...)        *
-  * 8/05/93  TEST                changed I_a_bit_allocation() from:    *
-  *                              if( ad > ...) to if(ad >= ...)        *
-  * 8/02/95  mc@fivebats.com     Changed audio file reading code to    *
-  *                              read samples big-endian               *
-  *10/15/95  mc@fivebats.com     Modified get_audio() for layer3-LSF   *
-  **********************************************************************/
-  
- #include "common.h"
- #include "encoder.h"
- 
- #ifdef MS_DOS
- extern unsigned _stklen = 16384;
- #endif
- 
- 
- /*=======================================================================\
- |                                                                       |
- | This segment contains all the core routines of the encoder,           |
- | except for the psychoacoustic models.                                 |
- |                                                                       |
- | The user can select either one of the two psychoacoustic              |
- | models. Model I is a simple tonal and noise masking threshold         |
- | generator, and Model II is a more sophisticated cochlear masking      |
- | threshold generator. Model I is recommended for lower complexity      |
- | applications whereas Model II gives better subjective quality at low  |
- | bit rates.                                                            |
- |                                                                       |
- | Layers I and II of mono, stereo, and joint stereo modes are supported.|
- | Routines associated with a given layer are prefixed by "I_" for layer |
- | 1 and "II_" for layer 2.                                              |
- \=======================================================================*/
-  
- /************************************************************************
- *
- * read_samples()
- *
- * PURPOSE:  reads the PCM samples from a file to the buffer
- *
- *  SEMANTICS:
- * Reads #samples_read# number of shorts from #musicin# filepointer
- * into #sample_buffer[]#.  Returns the number of samples read.
- *
- ************************************************************************/
- 
- unsigned long read_samples(musicin, sample_buffer, num_samples, frame_size)
- FILE *musicin;
- short sample_buffer[2304];
- unsigned long num_samples, frame_size;
- {
-     unsigned long samples_read;
-     static unsigned long samples_to_read;
-     static char init = TRUE;
- 
-     if (init) {
-         samples_to_read = num_samples;
-         init = FALSE;
-     }
-     if (samples_to_read >= frame_size)
-         samples_read = frame_size;
-     else
-         samples_read = samples_to_read;
-     if ((samples_read =
-          fread(sample_buffer, sizeof(short), (int)samples_read, musicin)) == 0)
-         printf("Hit end of audio data\n");
-     /*
-        Samples are big-endian. If this is a little-endian machine
-        we must swap
-      */
-     if ( NativeByteOrder == order_unknown )
-       {
- 	NativeByteOrder = DetermineByteOrder();
- 	if ( NativeByteOrder == order_unknown )
- 	  {
- 	    fprintf( stderr, "byte order not determined\n" );
- 	    exit( 1 );
- 	  }
-       }
-     if ( NativeByteOrder == order_littleEndian )
-       SwapBytesInWords( sample_buffer, samples_read );
- 
-     samples_to_read -= samples_read;
-     if (samples_read < frame_size && samples_read > 0) {
-         printf("Insufficient PCM input for one frame - fillout with zeros\n");
-         for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
-         samples_to_read = 0;
-     }
-     return(samples_read);
- }
- 
- /************************************************************************
- *
- * get_audio()
- *
- * PURPOSE:  reads a frame of audio data from a file to the buffer,
- *   aligns the data for future processing, and separates the
- *   left and right channels
- *
- *
- ************************************************************************/
-  
- unsigned long get_audio( musicin, buffer, num_samples, stereo, info )
- FILE *musicin;
- short FAR buffer[2][1152];
- unsigned long num_samples;
- int stereo;
- layer *info;
- {
-     int j;
-     short insamp[2304];
-     unsigned long samples_read;
-     int lay;
-     lay = info->lay;
- 
-     if ( (lay == 3) && (info->version == 0) )
-     {
- 	if ( stereo == 2 )
- 	{
- 	    samples_read = read_samples( musicin, insamp, num_samples,
- 					 (unsigned long) 1152 );
- 	    for ( j = 0; j < 576; j++ )
- 	    {
- 		buffer[0][j] = insamp[2 * j];
- 		buffer[1][j] = insamp[2 * j + 1];
- 	    }
- 	}
- 	else
- 	{
- 	    samples_read = read_samples( musicin, insamp, num_samples,
- 					 (unsigned long) 576 );
- 	    for ( j = 0; j < 576; j++ )
- 	    {
- 		buffer[0][j] = insamp[j];
- 		buffer[1][j] = 0;
- 	    }
- 	}
-     }
-     else
-     {
- 	if (lay == 1){
- 	    if(stereo == 2){ /* layer 1, stereo */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 768);
- 		for(j=0;j<448;j++) {
- 		    if(j<64) {
- 			buffer[0][j] = buffer[0][j+384];
- 			buffer[1][j] = buffer[1][j+384];
- 		    }
- 		    else {
- 			buffer[0][j] = insamp[2*j-128];
- 			buffer[1][j] = insamp[2*j-127];
- 		    }
- 		}
- 	    }
- 	    else { /* layer 1, mono */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 384);
- 		for(j=0;j<448;j++){
- 		    if(j<64) {
- 			buffer[0][j] = buffer[0][j+384];
- 			buffer[1][j] = 0;
- 		    }
- 		    else {
- 			buffer[0][j] = insamp[j-64];
- 			buffer[1][j] = 0;
- 		    }
- 		}
- 	    }
- 	}
- 	else {
- 	    if(stereo == 2){ /* layer 2 (or 3), stereo */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 2304);
- 		for(j=0;j<1152;j++) {
- 		    buffer[0][j] = insamp[2*j];
- 		    buffer[1][j] = insamp[2*j+1];
- 		}
- 	    }
- 	    else { /* layer 2 (or 3), mono */
- 		samples_read = read_samples(musicin, insamp, num_samples,
- 					    (unsigned long) 1152);
- 		for(j=0;j<1152;j++){
- 		    buffer[0][j] = insamp[j];
- 		    buffer[1][j] = 0;
- 		}
- 	    }
- 	}
-     }
-     return(samples_read);
- }
-  
- /************************************************************************
- *
- * read_ana_window()
- *
- * PURPOSE:  Reads encoder window file "enwindow" into array #ana_win#
- *
- ************************************************************************/
-  
- void read_ana_window(ana_win)
- double FAR ana_win[HAN_SIZE];
- {
-     int i,j[4];
-     FILE *fp;
-     double f[4];
-     char t[150];
-  
-     if (!(fp = OpenTableFile("enwindow") ) ) {
-        printf("Please check analysis window table 'enwindow'\n");
-        exit(1);
-     }
-     for (i=0;i<512;i+=4) {
-        fgets(t, 150, fp);
-        sscanf(t,"C[%d] = %lf C[%d] = %lf C[%d] = %lf C[%d] = %lf\n",
-               j, f,j+1,f+1,j+2,f+2,j+3,f+3);
-        if (i==j[0]) {
-           ana_win[i] = f[0];
-           ana_win[i+1] = f[1];
-           ana_win[i+2] = f[2];
-           ana_win[i+3] = f[3];
-        }
-        else {
-           printf("Check index in analysis window table\n");
-           exit(1);
-        }
-        fgets(t,150,fp);
-     }
-     fclose(fp);
- }
- 
- /************************************************************************
- *
- * window_subband()
- *
- * PURPOSE:  Overlapping window on PCM samples
- *
- * SEMANTICS:
- * 32 16-bit pcm samples are scaled to fractional 2's complement and
- * concatenated to the end of the window buffer #x#. The updated window
- * buffer #x# is then windowed by the analysis window #c# to produce the
- * windowed sample #z#
- *
- ************************************************************************/
-  
- void window_subband(buffer, z, k)
- short FAR **buffer;
- double FAR z[HAN_SIZE];
- int k;
- {
-     typedef double FAR XX[2][HAN_SIZE];
-     static XX FAR *x;
-     int i, j;
-     static off[2] = {0,0};
-     static char init = 0;
-     static double FAR *c;
-     if (!init) {
-         c = (double FAR *) mem_alloc(sizeof(double) * HAN_SIZE, "window");
-         read_ana_window(c);
-         x = (XX FAR *) mem_alloc(sizeof(XX),"x");
-         for (i=0;i<2;i++)
-             for (j=0;j<HAN_SIZE;j++)
-                 (*x)[i][j] = 0;
-         init = 1;
-     }
- 
-     /* replace 32 oldest samples with 32 new samples */
-     for (i=0;i<32;i++) (*x)[k][31-i+off[k]] = (double) *(*buffer)++/SCALE;
-     /* shift samples into proper window positions */
-     for (i=0;i<HAN_SIZE;i++) z[i] = (*x)[k][(i+off[k])&HAN_SIZE-1] * c[i];
-     off[k] += 480;              /*offset is modulo (HAN_SIZE-1)*/
-     off[k] &= HAN_SIZE-1;
- 
- }
-  
- /************************************************************************
- *
- * create_ana_filter()
- *
- * PURPOSE:  Calculates the analysis filter bank coefficients
- *
- * SEMANTICS:
- * Calculates the analysis filterbank coefficients and rounds to the
- * 9th decimal place accuracy of the filterbank tables in the ISO
- * document.  The coefficients are stored in #filter#
- 
- ************************************************************************/
-  
- void create_ana_filter(filter)
- double FAR filter[SBLIMIT][64];
- {
-    register int i,k;
-  
-    for (i=0; i<32; i++)
-       for (k=0; k<64; k++) {
-           if ((filter[i][k] = 1e9*cos((double)((2*i+1)*(16-k)*PI64))) >= 0)
-              modf(filter[i][k]+0.5, &filter[i][k]);
-           else
-              modf(filter[i][k]-0.5, &filter[i][k]);
-           filter[i][k] *= 1e-9;
-    }
- }
- 
- /************************************************************************
- *
- * filter_subband()
- *
- * PURPOSE:  Calculates the analysis filter bank coefficients
- *
- * SEMANTICS:
- *      The windowed samples #z# is filtered by the digital filter matrix #m#
- * to produce the subband samples #s#. This done by first selectively
- * picking out values from the windowed samples, and then multiplying
- * them by the filter matrix, producing 32 subband samples.
- *
- ************************************************************************/
-  
- void filter_subband(z,s)
- double FAR z[HAN_SIZE], s[SBLIMIT];
- {
-    double y[64];
-    int i,j;
- static char init = 0;
-    typedef double MM[SBLIMIT][64];
- static MM FAR *m;
- #ifdef MS_DOS
-    long    SIZE_OF_MM;
-    SIZE_OF_MM      = SBLIMIT*64;
-    SIZE_OF_MM      *= 8;
-    if (!init) {
-        m = (MM FAR *) mem_alloc(SIZE_OF_MM, "filter");
-        create_ana_filter(*m);
-        init = 1;
-    }
- #else
-    if (!init) {
-        m = (MM FAR *) mem_alloc(sizeof(MM), "filter");
-        create_ana_filter(*m);
-        init = 1;
-    }
- #endif
-    for (i=0;i<64;i++) for (j=0, y[i] = 0;j<8;j++) y[i] += z[i+64*j];
-    for (i=0;i<SBLIMIT;i++)
-        for (j=0, s[i]= 0;j<64;j++) s[i] += (*m)[i][j] * y[j];
- }
- 
- /************************************************************************
- * encode_info()
- *
- * PURPOSE:  Puts the syncword and header information on the output
- * bitstream.
- *
- ************************************************************************/
-  
- void encode_info(fr_ps,bs)
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-         layer *info = fr_ps->header;
-  
-         putbits(bs,0xfff,12);                    /* syncword 12 bits */
-         put1bit(bs,info->version);               /* ID        1 bit  */
-         putbits(bs,4-info->lay,2);               /* layer     2 bits */
-         put1bit(bs,!info->error_protection);     /* bit set => no err prot */
-         putbits(bs,info->bitrate_index,4);
-         putbits(bs,info->sampling_frequency,2);
-         put1bit(bs,info->padding);
-         put1bit(bs,info->extension);             /* private_bit */
-         putbits(bs,info->mode,2);
-         putbits(bs,info->mode_ext,2);
-         put1bit(bs,info->copyright);
-         put1bit(bs,info->original);
-         putbits(bs,info->emphasis,2);
- }
-  
- /************************************************************************
- *
- * mod()
- *
- * PURPOSE:  Returns the absolute value of its argument
- *
- ************************************************************************/
-  
- double mod(a)
- double a;
- {
-     return (a > 0) ? a : -a;
- }
-  
- /************************************************************************
- *
- * I_combine_LR    (Layer I)
- * II_combine_LR   (Layer II)
- *
- * PURPOSE:Combines left and right channels into a mono channel
- *
- * SEMANTICS:  The average of left and right subband samples is put into
- * #joint_sample#
- *
- * Layer I and II differ in frame length and # subbands used
- *
- ************************************************************************/
-  
- void I_combine_LR(sb_sample, joint_sample)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- {   /* make a filtered mono for joint stereo */
-     int sb, smp;
-  
-    for(sb = 0; sb<SBLIMIT; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-         joint_sample[0][smp][sb] = .5 *
-                     (sb_sample[0][0][smp][sb] + sb_sample[1][0][smp][sb]);
- }
-  
- void II_combine_LR(sb_sample, joint_sample, sblimit)
- double FAR sb_sample[2][3][SCALE_BLOCK][SBLIMIT];
- double FAR joint_sample[3][SCALE_BLOCK][SBLIMIT];
- int sblimit;
- {  /* make a filtered mono for joint stereo */
-    int sb, smp, sufr;
-  
-    for(sb = 0; sb<sblimit; ++sb)
-       for(smp = 0; smp<SCALE_BLOCK; ++smp)
-          for(sufr = 0; sufr<3; ++sufr)
-             joint_sample[sufr][smp][sb] = .5 * (sb_sample[0][sufr][smp][sb]
-                                            + sb_sample[1][sufr][smp][sb]);
- }
-  
- /************************************************************************
- *
- * I_scale_factor_calc     (Layer I)
- * II_scale_factor_calc    (Layer II)
- *
- * PURPOSE:For each subband, calculate the scale factor for each set
- * of the 12 subband samples
- *
- * SEMANTICS:  Pick the scalefactor #multiple[]# just larger than the
- * absolute value of the peak subband sample of 12 samples,
- * and store the corresponding scalefactor index in #scalar#.
- *
- * Layer II has three sets of 12-subband samples for a given
- * subband.
- *
- ************************************************************************/
-  
- void I_scale_factor_calc(sb_sample,scalar,stereo)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo;
- {
-    int i,j, k;
-    double s[SBLIMIT];
-  
-    for (k=0;k<stereo;k++) {
-      for (i=0;i<SBLIMIT;i++)
-        for (j=1, s[i] = mod(sb_sample[k][0][0][i]);j<SCALE_BLOCK;j++)
-          if (mod(sb_sample[k][0][j][i]) > s[i])
-             s[i] = mod(sb_sample[k][0][j][i]);
-  
-      for (i=0;i<SBLIMIT;i++)
-        for (j=SCALE_RANGE-2,scalar[k][0][i]=0;j>=0;j--) /* $A 6/16/92 */
-          if (s[i] <= multiple[j]) {
-             scalar[k][0][i] = j;
-             break;
-          }
-    }
- }
- 
- /******************************** Layer II ******************************/
-  
- void II_scale_factor_calc(sb_sample,scalar,stereo,sblimit)
- double FAR sb_sample[][3][SCALE_BLOCK][SBLIMIT];
- unsigned int scalar[][3][SBLIMIT];
- int stereo,sblimit;
- {
-   int i,j, k,t;
-   double s[SBLIMIT];
-  
-   for (k=0;k<stereo;k++) for (t=0;t<3;t++) {
-     for (i=0;i<sblimit;i++)
-       for (j=1, s[i] = mod(sb_sample[k][t][0][i]);j<SCALE_BLOCK;j++)
-         if (mod(sb_sample[k][t][j][i]) > s[i])
-              s[i] = mod(sb_sample[k][t][j][i]);
-  
-   for (i=0;i<sblimit;i++)
-     for (j=SCALE_RANGE-2,scalar[k][t][i]=0;j>=0;j--)    /* $A 6/16/92 */
-       if (s[i] <= multiple[j]) {
-          scalar[k][t][i] = j;
-          break;
-       }
-       for (i=sblimit;i<SBLIMIT;i++) scalar[k][t][i] = SCALE_RANGE-1;
-     }
- }
- 
- /************************************************************************
- *
- * pick_scale  (Layer II)
- *
- * PURPOSE:For each subband, puts the smallest scalefactor of the 3
- * associated with a frame into #max_sc#.  This is used
- * used by Psychoacoustic Model I.
- * (I would recommend changin max_sc to min_sc)
- *
- ************************************************************************/
-  
- void pick_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-   int i,j,k,max;
-   int stereo  = fr_ps->stereo;
-   int sblimit = fr_ps->sblimit;
-  
-   for (k=0;k<stereo;k++)
-     for (i=0;i<sblimit;max_sc[k][i] = multiple[max],i++)
-       for (j=1, max = scalar[k][0][i];j<3;j++)
-          if (max > scalar[k][j][i]) max = scalar[k][j][i];
-   for (i=sblimit;i<SBLIMIT;i++) max_sc[0][i] = max_sc[1][i] = 1E-20;
- }
- 
- /************************************************************************
- *
- * put_scale   (Layer I)
- *
- * PURPOSE:Sets #max_sc# to the scalefactor index in #scalar.
- * This is used by Psychoacoustic Model I
- *
- ************************************************************************/
-  
- void put_scale(scalar, fr_ps, max_sc)
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- double FAR max_sc[2][SBLIMIT];
- {
-    int i,j,k, max;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-  
-    for (k=0;k<stereo;k++) for (i=0;i<SBLIMIT;i++)
-         max_sc[k][i] = multiple[scalar[k][0][i]];
- }
-  
- /************************************************************************
- *
- * II_transmission_pattern (Layer II only)
- *
- * PURPOSE:For a given subband, determines whether to send 1, 2, or
- * all 3 of the scalefactors, and fills in the scalefactor
- * select information accordingly
- *
- * SEMANTICS:  The subbands and channels are classified based on how much
- * the scalefactors changes over its three values (corresponding
- * to the 3 sets of 12 samples per subband).  The classification
- * will send 1 or 2 scalefactors instead of three if the scalefactors
- * do not change much.  The scalefactor select information,
- * #scfsi#, is filled in accordingly.
- *
- ************************************************************************/
-  
- void II_transmission_pattern(scalar, scfsi, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int dscf[2];
-    int class[2],i,j,k;
- static int pattern[5][5] = {0x123, 0x122, 0x122, 0x133, 0x123,
-                             0x113, 0x111, 0x111, 0x444, 0x113,
-                             0x111, 0x111, 0x111, 0x333, 0x113,
-                             0x222, 0x222, 0x222, 0x333, 0x123,
-                             0x123, 0x122, 0x122, 0x133, 0x123};
-  
-    for (k=0;k<stereo;k++)
-      for (i=0;i<sblimit;i++) {
-        dscf[0] =  (scalar[k][0][i]-scalar[k][1][i]);
-        dscf[1] =  (scalar[k][1][i]-scalar[k][2][i]);
-        for (j=0;j<2;j++) {
-          if (dscf[j]<=-3) class[j] = 0;
-          else if (dscf[j] > -3 && dscf[j] <0) class[j] = 1;
-               else if (dscf[j] == 0) class[j] = 2;
-                    else if (dscf[j] > 0 && dscf[j] < 3) class[j] = 3;
-                         else class[j] = 4;
-        }
-        switch (pattern[class[0]][class[1]]) {
-          case 0x123 :    scfsi[k][i] = 0;
-                          break;
-          case 0x122 :    scfsi[k][i] = 3;
-                          scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x133 :    scfsi[k][i] = 3;
-                          scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x113 :    scfsi[k][i] = 1;
-                          scalar[k][1][i] = scalar[k][0][i];
-                          break;
-          case 0x111 :    scfsi[k][i] = 2;
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-                          break;
-          case 0x222 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][2][i] = scalar[k][1][i];
-                          break;
-          case 0x333 :    scfsi[k][i] = 2;
-                          scalar[k][0][i] = scalar[k][1][i] = scalar[k][2][i];
-                          break;
-          case 0x444 :    scfsi[k][i] = 2;
-                          if (scalar[k][0][i] > scalar[k][2][i])
-                               scalar[k][0][i] = scalar[k][2][i];
-                          scalar[k][1][i] = scalar[k][2][i] = scalar[k][0][i];
-       }
-    }
- }
-  
- /************************************************************************
- *
- * I_encode_scale  (Layer I)
- * II_encode_scale (Layer II)
- *
- * PURPOSE:The encoded scalar factor information is arranged and
- * queued into the output fifo to be transmitted.
- *
- * For Layer II, the three scale factors associated with
- * a given subband and channel are transmitted in accordance
- * with the scfsi, which is transmitted first.
- *
- ************************************************************************/
-  
- void I_encode_scale(scalar, bit_alloc, fr_ps, bs)
- unsigned int scalar[2][3][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int i,j;
-  
-    for (i=0;i<SBLIMIT;i++) for (j=0;j<stereo;j++)
-       if (bit_alloc[j][i]) putbits(bs,scalar[j][0][i],6);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_scale(bit_alloc, scfsi, scalar, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
- unsigned int scalar[2][3][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int i,j,k;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  putbits(bs,scfsi[k][i],2);
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++)
-      if (bit_alloc[k][i])  /* above jsbound, bit_alloc[0][i] == ba[1][i] */
-         switch (scfsi[k][i]) {
-            case 0: for (j=0;j<3;j++)
-                      putbits(bs,scalar[k][j][i],6);
-                    break;
-            case 1:
-            case 3: putbits(bs,scalar[k][0][i],6);
-                    putbits(bs,scalar[k][2][i],6);
-                    break;
-            case 2: putbits(bs,scalar[k][0][i],6);
-         }
- }
-  
- /*=======================================================================\
- |                                                                        |
- |      The following routines are done after the masking threshold       |
- | has been calculated by the fft analysis routines in the Psychoacoustic |
- | model. Using the MNR calculated, the actual number of bits allocated   |
- | to each subband is found iteratively.                                  |
- |                                                                        |
- \=======================================================================*/
-  
- /************************************************************************
- *
- * I_bits_for_nonoise  (Layer I)
- * II_bits_for_nonoise (Layer II)
- *
- * PURPOSE:Returns the number of bits required to produce a
- * mask-to-noise ratio better or equal to the noise/no_noise threshold.
- *
- * SEMANTICS:
- * bbal = # bits needed for encoding bit allocation
- * bsel = # bits needed for encoding scalefactor select information
- * banc = # bits needed for ancillary data (header info included)
- *
- * For each subband and channel, will add bits until one of the
- * following occurs:
- * - Hit maximum number of bits we can allocate for that subband
- * - MNR is better than or equal to the minimum masking level
- *   (NOISY_MIN_MNR)
- * Then the bits required for scalefactors, scfsi, bit allocation,
- * and the subband samples are tallied (#req_bits#) and returned.
- *
- * (NOISY_MIN_MNR) is the smallest MNR a subband can have before it is
- * counted as 'noisy' by the logic which chooses the number of JS
- * subbands.
- *
- * Joint stereo is supported.
- *
- ************************************************************************/
- 
- static double snr[18] = {0.00, 7.00, 11.00, 16.00, 20.84,
-                          25.28, 31.59, 37.75, 43.84,
-                          49.89, 55.93, 61.96, 67.98, 74.01,
-                          80.03, 86.05, 92.01, 98.01};
- 
- int I_bits_for_nonoise(perm_smr, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    int req_bits = 0;
-  
-    /* initial b_anc (header) allocation bits */
-    req_bits = 32 + 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-  
-    for(i=0; i<SBLIMIT; ++i)
-      for(j=0; j<((i<jsbound)?stereo:1); ++j) {
-        for(k=0;k<14; ++k)
-          if( (-perm_smr[j][i] + snr[k]) >= NOISY_MIN_MNR)
-            break; /* we found enough bits */
-          if(stereo == 2 && i >= jsbound)     /* check other JS channel */
-            for(;k<14; ++k)
-              if( (-perm_smr[1-j][i] + snr[k]) >= NOISY_MIN_MNR) break;
-          if(k>0) req_bits += (k+1)*SCALE_BLOCK + 6*((i>=jsbound)?stereo:1);
-    }
-    return req_bits;
- }
-  
- /***************************** Layer II  ********************************/
-  
- int II_bits_for_nonoise(perm_smr, scfsi, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- frame_params *fr_ps;
- {
-    int sb,ch,ba;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-    int req_bits = 0, bbal = 0, berr = 0, banc = 32;
-    int maxAlloc, sel_bits, sc_bits, smp_bits;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
- 
-    /* added 92-08-11 shn */
-    if (fr_ps->header->error_protection) berr=16; else berr=0; 
-  
-    for (sb=0; sb<jsbound; ++sb)
-      bbal += stereo * (*alloc)[sb][0].bits;
-    for (sb=jsbound; sb<sblimit; ++sb)
-      bbal += (*alloc)[sb][0].bits;
-    req_bits = banc + bbal + berr;
-  
-    for(sb=0; sb<sblimit; ++sb)
-      for(ch=0; ch<((sb<jsbound)?stereo:1); ++ch) {
-        maxAlloc = (1<<(*alloc)[sb][0].bits)-1;
-        sel_bits = sc_bits = smp_bits = 0;
-        for(ba=0;ba<maxAlloc-1; ++ba)
-          if( (-perm_smr[ch][sb] + snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-              >= NOISY_MIN_MNR)
-             break;      /* we found enough bits */
-        if(stereo == 2 && sb >= jsbound) /* check other JS channel */
-          for(;ba<maxAlloc-1; ++ba)
-            if( (-perm_smr[1-ch][sb]+ snr[(*alloc)[sb][ba].quant+((ba>0)?1:0)])
-                >= NOISY_MIN_MNR)
-              break;
-        if(ba>0) {
-          smp_bits = SCALE_BLOCK * ((*alloc)[sb][ba].group * (*alloc)[sb][ba].bits);
-          /* scale factor bits required for subband */
-          sel_bits = 2;
-          sc_bits  = 6 * sfsPerScfsi[scfsi[ch][sb]];
-          if(stereo == 2 && sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            sel_bits += 2;
-            sc_bits  += 6 * sfsPerScfsi[scfsi[1-ch][sb]];
-          }
-          req_bits += smp_bits+sel_bits+sc_bits;
-        }
-    }
-    return req_bits;
- }
-  
- /************************************************************************
- *
- * I_main_bit_allocation   (Layer I)
- * II_main_bit_allocation  (Layer II)
- *
- * PURPOSE:For joint stereo mode, determines which of the 4 joint
- * stereo modes is needed.  Then calls *_a_bit_allocation(), which
- * allocates bits for each of the subbands until there are no more bits
- * left, or the MNR is at the noise/no_noise threshold.
- *
- * SEMANTICS:
- *
- * For joint stereo mode, joint stereo is changed to stereo if
- * there are enough bits to encode stereo at or better than the
- * no-noise threshold (NOISY_MIN_MNR).  Otherwise, the system
- * iteratively allocates less bits by using joint stereo until one
- * of the following occurs:
- * - there are no more noisy subbands (MNR >= NOISY_MIN_MNR)
- * - mode_ext has been reduced to 0, which means that all but the
- *   lowest 4 subbands have been converted from stereo to joint
- *   stereo, and no more subbands may be converted
- *
- *     This function calls *_bits_for_nonoise() and *_a_bit_allocation().
- *
- ************************************************************************/
-  
- void I_main_bit_allocation(perm_smr, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs;
-    int  mode, mode_ext, lay, i;
-    int  rq_db, av_db = *adb;
- static  int init = 0;
-  
-    if(init == 0) {
-      /* rearrange snr for layer I */
-      snr[2] = snr[3];
-      for (i=3;i<16;i++) snr[i] = snr[i+2];
-      init = 1;
-    }
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if(rq_db = I_bits_for_nonoise(perm_smr, fr_ps) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-           --mode_ext;
-           fr_ps->jsbound = js_bound(lay, mode_ext);
-           rq_db = I_bits_for_nonoise(perm_smr, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_main_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int  noisy_sbs, nn;
-    int  mode, mode_ext, lay;
-    int  rq_db, av_db = *adb;
-  
-    if((mode = fr_ps->actual_mode) == MPG_MD_JOINT_STEREO) {
-      fr_ps->header->mode = MPG_MD_STEREO;
-      fr_ps->header->mode_ext = 0;
-      fr_ps->jsbound = fr_ps->sblimit;
-      if((rq_db=II_bits_for_nonoise(perm_smr, scfsi, fr_ps)) > *adb) {
-        fr_ps->header->mode = MPG_MD_JOINT_STEREO;
-        mode_ext = 4;           /* 3 is least severe reduction */
-        lay = fr_ps->header->lay;
-        do {
-          --mode_ext;
-          fr_ps->jsbound = js_bound(lay, mode_ext);
-          rq_db = II_bits_for_nonoise(perm_smr, scfsi, fr_ps);
-        } while( (rq_db > *adb) && (mode_ext > 0));
-        fr_ps->header->mode_ext = mode_ext;
-      }    /* well we either eliminated noisy sbs or mode_ext == 0 */
-    }
-    noisy_sbs = II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps);
- }
-  
- /************************************************************************
- *
- * I_a_bit_allocation  (Layer I)
- * II_a_bit_allocation (Layer II)
- *
- * PURPOSE:Adds bits to the subbands with the lowest mask-to-noise
- * ratios, until the maximum number of bits for the subband has
- * been allocated.
- *
- * SEMANTICS:
- * 1. Find the subband and channel with the smallest MNR (#min_sb#,
- *    and #min_ch#)
- * 2. Calculate the increase in bits needed if we increase the bit
- *    allocation to the next higher level
- * 3. If there are enough bits available for increasing the resolution
- *    in #min_sb#, #min_ch#, and the subband has not yet reached its
- *    maximum allocation, update the bit allocation, MNR, and bits
-     available accordingly
- * 4. Repeat until there are no more bits left, or no more available
- *    subbands. (A subband is still available until the maximum
- *    number of bits for the subband has been allocated, or there
- *    aren't enough bits to go to the next higher resolution in the
-     subband.)
- *
- ************************************************************************/
-  
- int I_a_bit_allocation(perm_smr, bit_alloc, adb, fr_ps) /* return noisy sbs */
- double FAR perm_smr[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, k, smpl_bits, scale_bits, min_sb, min_ch, oth_ch;
-    int bspl, bscf, ad, noisy_sbs, done = 0, bbal ;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
-  
-    if (!init) {
-       init = 1;
-       if (fr_ps->header->error_protection) berr = 16;  /* added 92-08-11 shn */
-    }
-    bbal = 4 * ( (jsbound * stereo) + (SBLIMIT-jsbound) );
-    *adb -= bbal + berr + banc;
-    ad= *adb;
-  
-    for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = mnr[0][0]+1;    min_sb = -1; min_ch = -1;
-      for (i=0;i<SBLIMIT;i++) for (k=0;k<stereo;k++)
-        /* go on only if there are bits left */
-        if (used[k][i] != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-        }
-      if(min_sb > -1) {   /* there was something to find */
-        /* first step of bit allocation is biggest */
-        if (used[min_ch][min_sb])  { smpl_bits = SCALE_BLOCK; scale_bits = 0; }
-        else                       { smpl_bits = 24; scale_bits = 6; }
-        if(min_sb >= jsbound)        scale_bits *= stereo;
-  
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-  
-        if (ad >= bspl + bscf + scale_bits + smpl_bits) {
-          bspl += smpl_bits; /* bit for subband sample */
-          bscf += scale_bits; /* bit for scale factor */
-          bit_alloc[min_ch][min_sb]++;
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb]
-                                + snr[bit_alloc[min_ch][min_sb]];
-          /* Check if subband has been fully allocated max bits */
-          if (bit_alloc[min_ch][min_sb] ==  14 ) used[min_ch][min_sb] = 2;
-        }
-        else            /* no room to improve this band */
-          used[min_ch][min_sb] = 2; /*   for allocation anymore */
-        if(stereo == 2 && min_sb >= jsbound) {
-          oth_ch = 1-min_ch;  /* joint-st : fix other ch */
-          bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb]
-                                + snr[bit_alloc[oth_ch][min_sb]];
-        }
-      }
-    } while(min_sb>-1);     /* i.e. still some sub-bands to find */
- 
-    /* Calculate the number of bits left, add on to pointed var */
-    ad -= bspl+bscf;
-    *adb = ad;
- 
-    /* see how many channels are noisy */
-    noisy_sbs = 0; small = mnr[0][0];
-    for(k=0; k<stereo; ++k) {
-      for(i = 0; i< SBLIMIT; ++i) {
-        if(mnr[k][i] < NOISY_MIN_MNR)   ++noisy_sbs;
-        if(small > mnr[k][i])           small = mnr[k][i];
-      }
-    }
-    return noisy_sbs;
- }
- 
- /***************************** Layer II  ********************************/
-  
- int II_a_bit_allocation(perm_smr, scfsi, bit_alloc, adb, fr_ps)
- double FAR perm_smr[2][SBLIMIT];
- unsigned int scfsi[2][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- int *adb;
- frame_params *fr_ps;
- {
-    int i, min_ch, min_sb, oth_ch, k, increment, scale, seli, ba;
-    int bspl, bscf, bsel, ad, noisy_sbs, bbal=0;
-    double mnr[2][SBLIMIT], small;
-    char used[2][SBLIMIT];
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
- static char init= 0;
- static int banc=32, berr=0;
- static int sfsPerScfsi[] = { 3,2,1,2 };    /* lookup # sfs per scfsi */
-  
-    if (!init) { 
-        init = 1;  
-        if (fr_ps->header->error_protection) berr=16; /* added 92-08-11 shn */
-    }
-    for (i=0; i<jsbound; ++i)
-      bbal += stereo * (*alloc)[i][0].bits;
-    for (i=jsbound; i<sblimit; ++i)
-      bbal += (*alloc)[i][0].bits;
-    *adb -= bbal + berr + banc;
-    ad = *adb;
-  
-    for (i=0;i<sblimit;i++) for (k=0;k<stereo;k++) {
-      mnr[k][i]=snr[0]-perm_smr[k][i];
-      bit_alloc[k][i] = 0;
-      used[k][i] = 0;
-    }
-    bspl = bscf = bsel = 0;
-  
-    do  {
-      /* locate the subband with minimum SMR */
-      small = 999999.0; min_sb = -1; min_ch = -1;
-      for (i=0;i<sblimit;i++) for(k=0;k<stereo;++k)
-        if (used[k][i]  != 2 && small > mnr[k][i]) {
-          small = mnr[k][i];
-          min_sb = i;  min_ch = k;
-      }
-      if(min_sb > -1) {   /* there was something to find */
-        /* find increase in bit allocation in subband [min] */
-        increment = SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].group *
-                         (*alloc)[min_sb][bit_alloc[min_ch][min_sb]+1].bits);
-        if (used[min_ch][min_sb])
-          increment -= SCALE_BLOCK * ((*alloc)[min_sb][bit_alloc[min_ch][min_sb]].group*
-                            (*alloc)[min_sb][bit_alloc[min_ch][min_sb]].bits);
-  
-        /* scale factor bits required for subband [min] */
-        oth_ch = 1 - min_ch;    /* above js bound, need both chans */
-        if (used[min_ch][min_sb]) scale = seli = 0;
-        else {          /* this channel had no bits or scfs before */
-          seli = 2;
-          scale = 6 * sfsPerScfsi[scfsi[min_ch][min_sb]];
-          if(stereo == 2 && min_sb >= jsbound) {
-            /* each new js sb has L+R scfsis */
-            seli += 2;
-            scale += 6 * sfsPerScfsi[scfsi[oth_ch][min_sb]];
-          }
-        }
-        /* check to see enough bits were available for */
-        /* increasing resolution in the minimum band */
-        if (ad >= bspl + bscf + bsel + seli + scale + increment) {
-          ba = ++bit_alloc[min_ch][min_sb]; /* next up alloc */
-          bspl += increment;  /* bits for subband sample */
-          bscf += scale;      /* bits for scale factor */
-          bsel += seli;       /* bits for scfsi code */
-          used[min_ch][min_sb] = 1; /* subband has bits */
-          mnr[min_ch][min_sb] = -perm_smr[min_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-          /* Check if subband has been fully allocated max bits */
-          if (ba >= (1<<(*alloc)[min_sb][0].bits)-1) used[min_ch][min_sb] = 2;
-        }
-        else used[min_ch][min_sb] = 2; /* can't increase this alloc */
-        if(min_sb >= jsbound && stereo == 2) {
-          /* above jsbound, alloc applies L+R */
-          ba = bit_alloc[oth_ch][min_sb] = bit_alloc[min_ch][min_sb];
-          used[oth_ch][min_sb] = used[min_ch][min_sb];
-          mnr[oth_ch][min_sb] = -perm_smr[oth_ch][min_sb] +
-                                snr[(*alloc)[min_sb][ba].quant+1];
-        }
-      }
-    } while(min_sb > -1);   /* until could find no channel */
-    /* Calculate the number of bits left */
-    ad -= bspl+bscf+bsel;   *adb = ad;
-    for (i=sblimit;i<SBLIMIT;i++) for (k=0;k<stereo;k++) bit_alloc[k][i]=0;
-  
-    noisy_sbs = 0;  small = mnr[0][0];      /* calc worst noise in case */
-    for(k=0;k<stereo;++k) {
-      for (i=0;i<sblimit;i++) {
-        if (small > mnr[k][i]) small = mnr[k][i];
-        if(mnr[k][i] < NOISY_MIN_MNR) ++noisy_sbs; /* noise is not masked */
- 
-      }
-    }
-    return noisy_sbs;
- }
-  
- /************************************************************************
- *
- * I_subband_quantization  (Layer I)
- * II_subband_quantization (Layer II)
- *
- * PURPOSE:Quantizes subband samples to appropriate number of bits
- *
- * SEMANTICS:  Subband samples are divided by their scalefactors, which
-  makes the quantization more efficient. The scaled samples are
- * quantized by the function a*x+b, where a and b are functions of
- * the number of quantization levels. The result is then truncated
- * to the appropriate number of bits and the MSB is inverted.
- *
- * Note that for fractional 2's complement, inverting the MSB for a
-  negative number x is equivalent to adding 1 to it.
- *
- ************************************************************************/
-  
- static double a[17] = {
-   0.750000000, 0.625000000, 0.875000000, 0.562500000, 0.937500000,
-   0.968750000, 0.984375000, 0.992187500, 0.996093750, 0.998046875,
-   0.999023438, 0.999511719, 0.999755859, 0.999877930, 0.999938965,
-   0.999969482, 0.999984741 };
-  
- static double b[17] = {
-   -0.250000000, -0.375000000, -0.125000000, -0.437500000, -0.062500000,
-   -0.031250000, -0.015625000, -0.007812500, -0.003906250, -0.001953125,
-   -0.000976563, -0.000488281, -0.000244141, -0.000122070, -0.000061035,
-   -0.000030518, -0.000015259 };
-  
- void I_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                             bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT]; /* L+R for j-stereo if necess */
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, n, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    double d;
- static char init = 0;
- 
-    if (!init) {
-      init = 1;
-      /* rearrange quantization coef to correspond to layer I table */
-      a[1] = a[2]; b[1] = b[2];
-      for (i=2;i<15;i++) { a[i] = a[i+2]; b[i] = b[i+2]; }
-    }
-    for (j=0;j<SCALE_BLOCK;j++) for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        if (bit_alloc[k][i]) {
-          /* for joint stereo mode, have to construct a single subband stream
-             for the js channels.  At present, we calculate a set of mono
-             subband samples and pass them through the scaling system to
-             generate an alternate normalised sample stream.
-  
-             Could normalise both streams (divide by their scfs), then average
-             them.  In bad conditions, this could give rise to spurious
-             cancellations.  Instead, we could just select the sb stream from
-             the larger channel (higher scf), in which case _that_ channel
-             would be 'properly' reconstructed, and the mate would just be a
-             scaled version.  Spec recommends averaging the two (unnormalised)
-             subband channels, then normalising this new signal without
-             actually sending this scale factor... This means looking ahead.
-          */
-          if(stereo == 2 && i>=jsbound)
-            /* use the joint data passed in */
-            d = j_samps[0][j][i] / multiple[j_scale[0][i]];
-          else
-            d = sb_samples[k][0][j][i] / multiple[scalar[k][0][i]];
-          /* scale and quantize floating point sample */
-          n = bit_alloc[k][i];
-          d = d * a[n-1] + b[n-1];
-          /* extract MSB N-1 bits from the floating point sample */
-          if (d >= 0) sig = 1;
-          else { sig = 0; d += 1.0; }
-          sbband[k][0][j][i] = (unsigned int) (d * (double) (1L<<n));
-          /* tag the inverted sign bit to sbband at position N */
-          if (sig) sbband[k][0][j][i] |= 1<<n;
-        }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_subband_quantization(scalar, sb_samples, j_scale, j_samps,
-                              bit_alloc, sbband, fr_ps)
- unsigned int scalar[2][3][SBLIMIT];
- double FAR sb_samples[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int j_scale[3][SBLIMIT];
- double FAR j_samps[3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- frame_params *fr_ps;
- {
-    int i, j, k, s, n, qnt, sig;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    unsigned int stps;
-    double d;
-    al_table *alloc = fr_ps->alloc;
- 
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j++)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              /* scale and quantize floating point sample */
-              if(stereo == 2 && i>=jsbound)       /* use j-stereo samples */
-                d = j_samps[s][j][i] / multiple[j_scale[s][i]];
-              else
-                d = sb_samples[k][s][j][i] / multiple[scalar[k][s][i]];
-              if (mod(d) > 1.0)
-                printf("Not scaled properly %d %d %d %d\n",k,s,j,i);
-              qnt = (*alloc)[i][bit_alloc[k][i]].quant;
-              d = d * a[qnt] + b[qnt];
-              /* extract MSB N-1 bits from the floating point sample */
-              if (d >= 0) sig = 1;
-              else { sig = 0; d += 1.0; }
-              n = 0;
- #ifndef MS_DOS
-              stps = (*alloc)[i][bit_alloc[k][i]].steps;
-              while ((1L<<n) < stps) n++;
- #else
-              while  ( ( (unsigned long)(1L<<(long)n) <
-                        ((unsigned long) ((*alloc)[i][bit_alloc[k][i]].steps)
-                         & 0xffff
-                         )
-                        ) && ( n <16)
-                      ) n++;
- #endif
-              n--;
-              sbband[k][s][j][i] = (unsigned int) (d * (double) (1L<<n));
-              /* tag the inverted sign bit to sbband at position N */
-              /* The bit inversion is a must for grouping with 3,5,9 steps
-                 so it is done for all subbands */
-              if (sig) sbband[k][s][j][i] |= 1<<n;
-            }
-            for (s=0;s<3;s++)
-              for (j=sblimit;j<SBLIMIT;j++)
-                for (i=0;i<SCALE_BLOCK;i++) for (k=0;k<stereo;k++) sbband[k][s][i][j] = 0;
- }
-  
- /*************************************************************************
- * I_encode_bit_alloc  (Layer I)
- * II_encode_bit_alloc (Layer II)
- *
- * PURPOSE:Writes bit allocation information onto bitstream
- *
- * Layer I uses 4 bits/subband for bit allocation information,
- * and Layer II uses 4,3,2, or 0 bits depending on the
- * quantization table used.
- *
- ************************************************************************/
-  
- void I_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for (i=0;i<SBLIMIT;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++) putbits(bs,bit_alloc[k][i],4);
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_encode_bit_alloc(bit_alloc, fr_ps, bs)
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (i=0;i<sblimit;i++)
-      for (k=0;k<((i<jsbound)?stereo:1);k++)
-        putbits(bs,bit_alloc[k][i],(*alloc)[i][0].bits);
- }
-  
- /************************************************************************
- *
- * I_sample_encoding   (Layer I)
- * II_sample_encoding  (Layer II)
- *
- * PURPOSE:Put one frame of subband samples on to the bitstream
- *
- * SEMANTICS:  The number of bits allocated per sample is read from
- * the bit allocation information #bit_alloc#.  Layer 2
- * supports writing grouped samples for quantization steps
- * that are not a power of 2.
- *
- ************************************************************************/
-  
- void I_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    int i,j,k;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-  
-    for(j=0;j<SCALE_BLOCK;j++) {
-      for(i=0;i<SBLIMIT;i++)
-        for(k=0;k<((i<jsbound)?stereo:1);k++)
-          if(bit_alloc[k][i]) putbits(bs,sbband[k][0][j][i],bit_alloc[k][i]+1);
-    }
- }
-  
- /***************************** Layer II  ********************************/
-  
- void II_sample_encoding(sbband, bit_alloc, fr_ps, bs)
- unsigned int FAR sbband[2][3][SCALE_BLOCK][SBLIMIT];
- unsigned int bit_alloc[2][SBLIMIT];
- frame_params *fr_ps;
- Bit_stream_struc *bs;
- {
-    unsigned int temp;
-    unsigned int i,j,k,s,x,y;
-    int stereo  = fr_ps->stereo;
-    int sblimit = fr_ps->sblimit;
-    int jsbound = fr_ps->jsbound;
-    al_table *alloc = fr_ps->alloc;
-  
-    for (s=0;s<3;s++)
-      for (j=0;j<SCALE_BLOCK;j+=3)
-        for (i=0;i<sblimit;i++)
-          for (k=0;k<((i<jsbound)?stereo:1);k++)
-            if (bit_alloc[k][i]) {
-              if ((*alloc)[i][bit_alloc[k][i]].group == 3) {
-                for (x=0;x<3;x++) putbits(bs,sbband[k][s][j+x][i],
-                                          (*alloc)[i][bit_alloc[k][i]].bits);
-              }
-              else {
-                y =(*alloc)[i][bit_alloc[k][i]].steps;
-                temp = sbband[k][s][j][i] +
-                       sbband[k][s][j+1][i] * y +
-                       sbband[k][s][j+2][i] * y * y;
-                putbits(bs,temp,(*alloc)[i][bit_alloc[k][i]].bits);
-              }
-            }
- }
-  
- /************************************************************************
- *
- * encode_CRC
- *
- ************************************************************************/
-  
- void encode_CRC(crc, bs)
- unsigned int crc;
- Bit_stream_struc *bs;
- {
-    putbits(bs, crc, 16);
- }
--- 0 ----
diff -r -c -N encoder/encoder.h lame3.50/encoder.h
*** encoder/encoder.h	Wed Jan 22 02:43:14 1997
--- lame3.50/encoder.h	Fri Sep 10 09:51:59 1999
***************
*** 10,47 ****
   *
   * Received from Mike Coleman
   **********************************************************************/
! /**********************************************************************
!  *   date   programmers         comment                               *
!  * 2/25/91  Doulas Wong,        start of version 1.0 records          *
!  *          Davis Pan                                                 *
!  * 5/10/91  W. Joseph Carter    Reorganized & renamed all ".h" files  *
!  *                              into "common.h" and "encoder.h".      *
!  *                              Ported to Macintosh and Unix.         *
!  *                              Added function prototypes for more    *
!  *                              rigorous type checking.               *
!  * 27jun91  dpwe (Aware)        moved "alloc_*" types, pros to common *
!  *                              Use ifdef PROTO_ARGS for prototypes   *
!  *                              prototypes reflect frame_params struct*
!  * 7/10/91  Earle Jennings      Conversion of all floats to FLOAT     *
!  * 10/3/91  Don H. Lee          implemented CRC-16 error protection   *
!  *                              Additions and revisions are marked    *
!  *                              with "dhl" for clarity                *
!  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
!  *                              important fixes involved changing     *
!  *                              16-bit ints to long or unsigned in    *
!  *                              bit alloc routines for quant of 65535 *
!  *                              and passing proper function args.     *
!  *                              Removed "Other Joint Stereo" option   *
!  *                              and made bitrate be total channel     *
!  *                              bitrate, irrespective of the mode.    *
!  *                              Fixed many small bugs & reorganized.  *
!  *                              Modified some function prototypes.    *
!  * 7/27/92  Masahiro Iwadare    FFT modifications for Layer 3         *
!  * 8/3/92   Mike Li             removed declaration _stklen for DOS.  *
!  * 9/22/92  jddevine@aware.com  Fix protos for _scale_factor_calc()   *
!  * 11/04/94 Jon Rowlands        Fix protos for usage()                *
!  * 07/11/95 Soeren H. Nielsen   Changed defs. and protos for LSF      *
!  **********************************************************************/
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
--- 10,16 ----
   *
   * Received from Mike Coleman
   **********************************************************************/
! 
  #ifndef ENCODER_DOT_H
  #define ENCODER_DOT_H
  /***********************************************************************
***************
*** 60,71 ****
  
  /* Default Input Arguments (for command line control) */
  
! #define DFLT_LAY        2      /* default encoding layer is II */
! #define DFLT_MOD        's'    /* default mode is stereo */
! #define DFLT_PSY        1      /* default psych model is 1 */
  #define DFLT_SFQ        44.1   /* default input sampling rate is 44.1 kHz */
  #define DFLT_EMP        'n'    /* default de-emphasis is none */
! #define DFLT_EXT        ".mpg" /* default output file extension */
  
  #define FILETYPE_ENCODE 'TEXT'
  #define CREATOR_ENCODE  'MpgD'
--- 29,40 ----
  
  /* Default Input Arguments (for command line control) */
  
! #define DFLT_LAY        3      /* default encoding layer is III */
! #define DFLT_MOD        'j'    /* default mode is stereo */
! #define DFLT_PSY        2      /* default psych model is 2 */
  #define DFLT_SFQ        44.1   /* default input sampling rate is 44.1 kHz */
  #define DFLT_EMP        'n'    /* default de-emphasis is none */
! #define DFLT_EXT        ".mp3" /* default output file extension */
  
  #define FILETYPE_ENCODE 'TEXT'
  #define CREATOR_ENCODE  'MpgD'
***************
*** 75,92 ****
  
  #define NOISY_MIN_MNR   0.0
  
- /* Psychacoustic Model 1 Definitions */
- 
- #define CB_FRACTION     0.33
- #define MAX_SNR         1000
- #define NOISE           10
- #define TONE            20
- #define DBMIN           -200.0
- #define LAST            -1
- #define STOP            -100
- #define POWERNORM       90.3090 /* = 20 * log10(32768) to normalize */
-                                 /* max output power to 96 dB per spec */
- 
  /* Psychoacoustic Model 2 Definitions */
  
  #define LOGBLKSIZE      10
--- 44,49 ----
***************
*** 95,337 ****
  #define CBANDS          63
  #define LXMIN           32.0
  
- /***********************************************************************
- *
- *  Encoder Type Definitions
- *
- ***********************************************************************/
- 
- /* Psychoacoustic Model 1 Type Definitions */
- 
- typedef int        IFFT2[FFT_SIZE/2];
- typedef int        IFFT[FFT_SIZE];
- typedef double     D9[9];
- typedef double     D10[10];
- typedef double     D640[640];
- typedef double     D1408[1408];
- typedef double     DFFT2[FFT_SIZE/2];
- typedef double     DFFT[FFT_SIZE];
- typedef double     DSBL[SBLIMIT];
- typedef double     D2SBL[2][SBLIMIT];
- 
- typedef struct {
-         int        line;
-         double     bark, hear, x;
- } g_thres, *g_ptr;
- 
- typedef struct {
-         double     x;
-         int        type, next, map;
- } mask, *mask_ptr;
- 
- /* Psychoacoustic Model 2 Type Definitions */
- 
- typedef int        ICB[CBANDS];
- typedef int        IHBLK[HBLKSIZE];
- typedef FLOAT      F32[32];
- typedef FLOAT      F2_32[2][32];
- typedef FLOAT      FCB[CBANDS];
- typedef FLOAT      FCBCB[CBANDS][CBANDS];
- typedef FLOAT      FBLK[BLKSIZE];
- typedef FLOAT      FHBLK[HBLKSIZE];
- typedef FLOAT      F2HBLK[2][HBLKSIZE];
- typedef FLOAT      F22HBLK[2][2][HBLKSIZE];
- typedef double     DCB[CBANDS];
- 
- /***********************************************************************
- *
- *  Encoder Function Prototype Declarations
- *
- ***********************************************************************/
  
  /* The following functions are in the file "musicin.c" */
- 
- #ifdef        PROTO_ARGS
- extern void   obtain_parameters(frame_params*, int*, unsigned long*,
-                            char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   parse_args(int, char**, frame_params*, int*, unsigned long*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   print_config(frame_params*, int*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
- void   usage(void);
- extern void   aiff_check(char*, IFF_AIFF*, int*);
- #else
- extern void   obtain_parameters();
- extern void   parse_args();
- extern void   print_config();
- static void   usage();
- extern void   aiff_check();
- #endif
  
  /* The following functions are in the file "encode.c" */
- 
- #ifdef        PROTO_ARGS
- extern unsigned long    read_samples(FILE*, short[2304], unsigned long,
-                            unsigned long);
- #if 0
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, int);
- #else
- extern unsigned long    get_audio(FILE*, short[2][1152], unsigned long,
-                            int, layer* info);
- #endif
- extern void   read_ana_window(double[HAN_SIZE]);
  extern void   window_subband(short**, double[HAN_SIZE], int);
- extern void   create_ana_filter(double[SBLIMIT][64]);
  extern void   filter_subband(double[HAN_SIZE], double[SBLIMIT]);
- extern void   encode_info(frame_params*, Bit_stream_struc*);
- extern double mod(double);
- extern void   I_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT]);
- extern void   II_combine_LR(double[2][3][SCALE_BLOCK][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], int);
- extern void   I_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int);
- extern void   II_scale_factor_calc(double[][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[][3][SBLIMIT], int, int);
- extern void   pick_scale(unsigned int[2][3][SBLIMIT], frame_params*,
-                            double[2][SBLIMIT]);
- extern void   put_scale(unsigned int[2][3][SBLIMIT], frame_params*,
-                            double[2][SBLIMIT]);
- extern void   II_transmission_pattern(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*);
- extern void   II_encode_scale(unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_scale(unsigned int[2][3][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern int    II_bits_for_nonoise(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            frame_params*);
- extern void   II_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern int    II_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_bits_for_nonoise(double[2][SBLIMIT], frame_params*);
- extern void   I_main_bit_allocation(double[2][SBLIMIT],
-                            unsigned int[2][SBLIMIT], int*, frame_params*);
- extern int    I_a_bit_allocation(double[2][SBLIMIT], unsigned int[2][SBLIMIT],
-                            int*, frame_params*);
- extern void   I_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_subband_quantization(unsigned int[2][3][SBLIMIT],
-                            double[2][3][SCALE_BLOCK][SBLIMIT], unsigned int[3][SBLIMIT],
-                            double[3][SCALE_BLOCK][SBLIMIT], unsigned int[2][SBLIMIT],
-                            unsigned int[2][3][SCALE_BLOCK][SBLIMIT], frame_params*);
- extern void   II_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_encode_bit_alloc(unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   I_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   II_sample_encoding(unsigned int[2][3][SCALE_BLOCK][SBLIMIT],
-                            unsigned int[2][SBLIMIT], frame_params*,
-                            Bit_stream_struc*);
- extern void   encode_CRC(unsigned int, Bit_stream_struc*);
- #else
- extern unsigned long  read_samples();
- extern unsigned long  get_audio();
- extern void        read_ana_window();
- extern void        window_subband();
- extern void        create_ana_filter();
- extern void        filter_subband();
- extern void        encode_info();
- extern double      mod();
- extern void        I_combine_LR();
- extern void        II_combine_LR();
- extern void        I_scale_factor_calc();
- extern void        II_scale_factor_calc();
- extern void        pick_scale();
- extern void        put_scale();
- extern void        II_transmission_pattern();
- extern void        II_encode_scale();
- extern void        I_encode_scale();
- extern int         II_bits_for_nonoise();
- extern void        II_main_bit_allocation();
- extern int         II_a_bit_allocation();
- extern int         I_bits_for_nonoise();
- extern void        I_main_bit_allocation();
- extern int         I_a_bit_allocation();
- extern void        I_subband_quantization();
- extern void        II_subband_quantization();
- extern void        II_encode_bit_alloc();
- extern void        I_encode_bit_alloc();
- extern void        I_sample_encoding();
- extern void        II_sample_encoding();
- extern void        encode_CRC();
- #endif
- 
- /* The following functions are in the file "tonal.c" */
- 
- #ifdef     PROTO_ARGS
- extern void        read_cbound(int, int);
- extern void        read_freq_band(g_ptr*, int, int);
- extern void        make_map(mask[HAN_SIZE], g_thres*);
- extern double      add_db(double, double);
- extern void        II_f_f_t(double[FFT_SIZE], mask[HAN_SIZE]);
- extern void        II_hann_win(double[FFT_SIZE]);
- extern void        II_pick_max(mask[HAN_SIZE], double[SBLIMIT]);
- extern void        II_tonal_label(mask[HAN_SIZE], int*);
- extern void        noise_label(mask*, int*, g_thres*);
- extern void        subsampling(mask[HAN_SIZE], g_thres*, int*, int*);
- extern void        threshold(mask[HAN_SIZE], g_thres*, int*, int*, int);
- extern void        II_minimum_mask(g_thres*, double[SBLIMIT], int);
- extern void        II_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT],
-                            int);
- extern void        II_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
- extern void        I_f_f_t(double[FFT_SIZE/2], mask[HAN_SIZE/2]);
- extern void        I_hann_win(double[FFT_SIZE/2]);
- extern void        I_pick_max(mask[HAN_SIZE/2], double[SBLIMIT]);
- extern void        I_tonal_label(mask[HAN_SIZE/2], int*);
- extern void        I_minimum_mask(g_thres*, double[SBLIMIT]);
- extern void        I_smr(double[SBLIMIT], double[SBLIMIT], double[SBLIMIT]);
- extern void        I_Psycho_One(short[2][1152], double[2][SBLIMIT],
-                            double[2][SBLIMIT], frame_params*);
- #else
- extern void        read_cbound();
- extern void        read_freq_band();
- extern void        make_map();
- extern double      add_db();
- extern void        II_f_f_t();
- extern void        II_hann_win();
- extern void        II_pick_max();
- extern void        II_tonal_label();
- extern void        noise_label();
- extern void        subsampling();
- extern void        threshold();
- extern void        II_minimum_mask();
- extern void        II_smr();
- extern void        II_Psycho_One();
- extern void        I_f_f_t();
- extern void        I_hann_win();
- extern void        I_pick_max();
- extern void        I_tonal_label();
- extern void        I_minimum_mask();
- extern void        I_smr();
- extern void        I_Psycho_One();
- #endif
  
- /* The following functions are in the file "psy.c" */
  
! #ifdef     PROTO_ARGS
  extern void        psycho_anal(short int*, short int[1056], int, int,
                             FLOAT[32], double);
! #else
! extern void        psycho_anal();
! #endif
! 
! /* The following functions are in the file "subs.c" */
! 
! #ifdef     PROTO_ARGS
! extern void        fft(FLOAT[BLKSIZE], FLOAT[BLKSIZE], FLOAT[BLKSIZE],
!                            FLOAT[BLKSIZE], int );
! #else
! extern void        fft();
! #endif
  #endif
--- 52,73 ----
  #define CBANDS          63
  #define LXMIN           32.0
  
  
  /* The following functions are in the file "musicin.c" */
  extern void   parse_args(int, char**, frame_params*, int*, unsigned long*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  extern void   print_config(frame_params*, int*,
                             char[MAX_NAME_SIZE], char[MAX_NAME_SIZE]);
  
  /* The following functions are in the file "encode.c" */
  extern void   window_subband(short**, double[HAN_SIZE], int);
  extern void   filter_subband(double[HAN_SIZE], double[SBLIMIT]);
  
  
! /* The following functions are in the file "psy.c" */
  extern void        psycho_anal(short int*, short int[1056], int, int,
                             FLOAT[32], double);
! 
! 
! 
  #endif
diff -r -c -N encoder/fastmdct.c lame3.50/fastmdct.c
*** encoder/fastmdct.c	Wed Dec 31 17:00:00 1969
--- lame3.50/fastmdct.c	Mon Oct 25 11:59:52 1999
***************
*** 0 ****
--- 1,265 ----
+ #include "util.h"
+ #include "l3side.h"
+ #include "fastmdct.h"
+ 
+ static double win[4][36];
+ static double cos_s[6][12], cos_l[18][18];
+ void mdct_short(double *, double *, int);
+ void mdct_long(double *, double *, int);
+ void mdct_init(void);
+ 
+ double ca[8], cs[8];
+ 
+ /*
+   This is table B.9: coefficients for aliasing reduction
+ */
+ static double c[8] = { -0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142, -0.0037 };
+ 
+ void mdct_sub( L3SBS sb_sample, double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr )
+ {
+     gr_info *cod_info;
+     double mdct_in[36];
+     int ch,gr,band,k,j;
+     double bu,bd;
+     static int init = 0;
+     int	block_type;
+     double (*mdct_enc)[2][32][18] = (double (*)[2][32][18]) mdct_freq;
+     
+     if ( init == 0 )
+     {
+       mdct_init();
+ 	/* prepare the aliasing reduction butterflies */
+ 	for ( k = 0; k < 8; k++ )
+ 	{
+ 	    double sq;
+ 	    sq = sqrt( 1.0 + c[k] * c[k] );
+ 	    ca[k] = c[k] / sq;
+ 	    cs[k] = 1.0 / sq;
+ 	}
+ 	init++;
+     }
+     
+     for ( gr = 0; gr < mode_gr; gr++ )
+ 	for ( ch = 0; ch < stereo; ch++ )
+ 	{
+ 	    cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]) ;
+ 	    block_type = cod_info->block_type;
+ 	    
+ 	    /*
+ 	      Compensate for inversion in the analysis filter
+ 	    */
+ 	    for ( band = 1; band < 32; band+=2 )
+ 		for ( k = 1; k < 18; k+=2 )
+ 			sb_sample[ch][gr+1][k][band] *= -1.0;
+ 	    
+ 	    /*
+ 	      Perform imdct of 18 previous subband samples
+ 	      + 18 current subband samples
+ 	    */
+ 	    for ( band = 0; band < 32; band++ )
+ 	    {
+ 		for ( k = 0; k < 18; k++ )
+ 		{
+ 		    mdct_in[k]    = sb_sample[ch][ gr ][k][band];
+ 		    mdct_in[k+18] = sb_sample[ch][gr+1][k][band];
+ 		}
+ #ifdef ALLOW_MIXED
+ 		if ( cod_info->mixed_block_flag && (band < 2) )
+ 		    block_type = 0;
+ #endif
+ 		if (block_type==2)
+ 		  mdct_short(mdct_in, &mdct_enc[gr][ch][band][0], block_type );
+ 		else 
+ 		  mdct_long( mdct_in, &mdct_enc[gr][ch][band][0], block_type );
+ 	    }
+ 	    
+ 	    /*
+ 	      Perform aliasing reduction butterfly
+ 	      on long blocks
+ 	    */
+ 	    if ( block_type != 2 )
+ 		for ( band = 0; band < 31; band++ )
+ 		    for ( k = 0; k < 8; k++ )
+ 		    {
+ 			bu = mdct_enc[gr][ch][band][17-k] * cs[k] + mdct_enc[gr][ch][band+1][k] * ca[k];
+ 			bd = mdct_enc[gr][ch][band+1][k] * cs[k] - mdct_enc[gr][ch][band][17-k] * ca[k];
+ 			mdct_enc[gr][ch][band][17-k] = bu;
+ 			mdct_enc[gr][ch][band+1][k]  = bd;
+ 		    }
+ 	    
+ 	}
+     
+     /*
+       Save latest granule's subband samples to be used in
+       the next mdct call
+     */
+     for ( ch = 0; ch < stereo; ch++ )
+ 	for ( j = 0; j < 18; j++ )
+ 	    for ( band = 0; band < 32; band++ )
+ 		sb_sample[ch][0][j][band] = sb_sample[ch][mode_gr][j][band];
+ }
+ 
+ void mdct_init(void)
+ {
+   int k,i,m,N;
+ 
+     /* type 0 */
+     for ( i = 0; i < 36; i++ )
+       win[0][i] = sin( PI/36 * (i + 0.5) );
+     /* type 1*/
+     for ( i = 0; i < 18; i++ ) 
+       win[1][i] = sin( PI/36 * (i + 0.5) );
+     for ( i = 18; i < 24; i++ )
+       win[1][i] = 1.0;
+     for ( i = 24; i < 30; i++ )
+       win[1][i] = sin( PI/12 * ( i + 0.5 - 18) );
+     for ( i = 30; i < 36; i++ )
+       win[1][i] = 0.0;
+     /* type 3*/
+     for ( i = 0; i < 6; i++ )
+       win[3][i] = 0.0;
+     for ( i = 6; i < 12; i++ ) 
+       win[3][i] = sin( PI/12 * (i + 0.5 - 6) );
+     for ( i = 12; i < 18; i++ )
+       win[3][i] = 1.0;
+     for ( i = 18; i < 36; i++ )
+       win[3][i] = sin( PI/36 * (i + 0.5) );
+ 
+     N = 12;
+     for ( m = 0; m < N / 2; m++ )
+       for ( k = 0; k < N; k++ )
+         cos_s[m][k] = cos( (PI /(2 * N)) * (2 * k + 1 + N / 2) *
+                      (2 * m + 1) ) / (N / 4) * sin( PI/12 * (k + 0.5) );
+ 
+     N = 36;
+     for ( m = 0; m < N / 2; m++ )
+     {
+       for ( k = 0; k < 9; k++ )
+       {
+         cos_l[m][k] = cos( (PI / (2 * N)) * (2 * k + 1 + N / 2) *
+                      (2 * m + 1) ) / (N / 4);
+         cos_l[m][9+k] = cos( (PI / (2 * N)) * (2 * (18 + k) + 1 + N / 2) *
+                      (2 * m + 1) ) / (N / 4);
+       }
+     }
+ }
+ 
+ void mdct_short( double *in, double *out, int block_type)
+ {
+   int l,m,k,N;
+   double sum;
+   N = 12;
+   for ( l = 0; l < 3; l++ )
+     {
+       for ( m = 0; m < N / 2; m++ )
+ 	{
+ 	  for ( sum = 0.0, k = 0; k < N; k++ )
+ 	    sum += in[k + 6 * l + 6] * cos_s[m][k];
+ 	  out[ 3 * m + l] = sum;
+ 	}
+     }
+ }
+ 
+ void mdct_long (double *in, double *out, int block_type) {
+   int k;
+   double sum;
+   static double fin[18];
+   static double *cos_l0;
+   double s0, s1, s2, s3, s4, s5;
+   double *finp;
+ 
+   int all[] = {0,2,3,5,6,8,9,11,12,14,15,17,-1};
+   int i,j=0;
+       for (k=0;k<9;k++)
+       {
+ 	 fin[k] = win[block_type][k] * in[k] - win[block_type][17-k] * in[17-k];
+ 	 fin[9+k] = win[block_type][18+k] * in[18+k] + win[block_type][35-k] * in[35-k];
+       }
+ 
+       /* 0, 2, 3, 5, 6, 8, 9, 11, 12, 14, 15, 17 */  
+       while ((i = all[j++])>=0) {
+ 	cos_l0= &cos_l[i][0];
+ 	finp = &fin[0];
+ 	sum =  ( *finp++ ) * *cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0;
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	sum += ( *finp++ ) * *++cos_l0; 
+ 	out[i]=sum; 
+       }
+ 
+ 
+     s0 = fin[0] + fin[ 5] + fin[15];
+     s1 = fin[1] + fin[ 4] + fin[16];
+     s2 = fin[2] + fin[ 3] + fin[17];
+     s3 = fin[6] - fin[ 9] + fin[14];
+     s4 = fin[7] - fin[10] + fin[13];
+     s5 = fin[8] - fin[11] + fin[12];
+ 
+       /* 1 */
+       cos_l0 = & cos_l[1][0];
+       sum =  s0 * *cos_l0;  /* mfc=3 2*/
+       sum += s1 * *++cos_l0;  /* mfc=9 1*/
+       sum += s2 * *++cos_l0;  /* mfc=15 0*/
+       sum += s3 * *(cos_l0+=4); /* mfc=21 6*/
+       sum += s4 * *++cos_l0; /* mfc=27 7*/
+       sum += s5 * *++cos_l0;; /* mfc = 28 8*/
+       out[1]=sum;
+ 
+       /* 7 */
+       cos_l0 = &cos_l[7][0];
+       sum =  s0 * *cos_l0; 
+       sum += s1 * *++cos_l0; 
+       sum += s2 * *++cos_l0; 
+       sum += s3 * *(cos_l0+=4); 
+       sum += s4 * *++cos_l0; 
+       sum += s5 * *++cos_l0; 
+       out[7]=sum;
+ 
+       /* 10 */
+       cos_l0= &cos_l[10][0];
+       sum =  s0 * *cos_l0; /* 33 */
+       sum += s1 * *++cos_l0; /* 9 */
+       sum += s2 * *++cos_l0; /* 21 */
+       sum += s3 * *(cos_l0+=4); /* 3 */
+       sum += s4 * *++cos_l0; /* 27 */
+       sum += s5 * *++cos_l0; /* 15 */
+       out[10]=sum;
+ 
+       /* 16 */
+       cos_l0 = &cos_l[16][0];
+       sum =  s0 * *cos_l0; /* 21 */
+       sum += s1 * *++cos_l0;  /* 27 */
+       sum += s2 * *++cos_l0; /* 33 */
+       sum += s3 * *(cos_l0+=4); /* 15 */
+       sum += s4 * *++cos_l0; /* 9 */
+       sum += s5 * *++cos_l0; /* 3 */
+       out[16]=sum;
+ 
+       s0 = s0 - s1 + s5;
+       s2 = s2 - s3 - s4;
+ 
+       /* 4 */
+       sum = s0 * cos_l[4][0];
+       sum += s2* cos_l[4][2];
+       out[4]=sum;
+ 
+       /* 13 */
+       sum = s0 * cos_l[13][0];
+       sum += s2 * cos_l[13][2]; 
+       out[13]=sum;
+ 
+ }
diff -r -c -N encoder/fastmdct.h lame3.50/fastmdct.h
*** encoder/fastmdct.h	Wed Dec 31 17:00:00 1969
--- lame3.50/fastmdct.h	Mon Oct 25 12:00:08 1999
***************
*** 0 ****
--- 1,25 ----
+ /**********************************************************************
+  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
+  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
+  *
+  * $Id: mdct.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
+  *
+  * $Log: mdct.h,v $
+  * Revision 1.1  1996/02/14 04:04:23  rowlands
+  * Initial revision
+  *
+  * Received from Mike Coleman
+  **********************************************************************/
+ 
+ #ifndef MDCT_DOT_H
+ #define MDCT_DOT_H
+ void mdct(double *in, double *out, int block_type);
+ void inv_mdct(double *in, double *out, int block_type);
+ 
+ typedef double D32_18[SBLIMIT][18];
+ typedef double L3SBS[2][3][18][SBLIMIT]; /* [gr][ch] */
+ 
+ void mdct_sub(L3SBS sb_sample, double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr );
+ void mdct_sub_dec(double (*mdct_freq)[2][576], double inv_mdct_dec[3][2][18][32], int stereo, III_side_info_t *l3_side);
+ void delay(double (*xr)[2][576], int stereo);
+ #endif
diff -r -c -N encoder/fft.c lame3.50/fft.c
*** encoder/fft.c	Wed Dec 31 17:00:00 1969
--- lame3.50/fft.c	Mon Nov  1 17:45:44 1999
***************
*** 0 ****
--- 1,259 ----
+ /*
+ ** FFT and FHT routines
+ **  Copyright 1988, 1993; Ron Mayer
+ **  
+ **  fht(fz,n);
+ **      Does a hartley transform of "n" points in the array "fz".
+ **      
+ ** NOTE: This routine uses at least 2 patented algorithms, and may be
+ **       under the restrictions of a bunch of different organizations.
+ **       Although I wrote it completely myself; it is kind of a derivative
+ **       of a routine I once authored and released under the GPL, so it
+ **       may fall under the free software foundation's restrictions;
+ **       it was worked on as a Stanford Univ project, so they claim
+ **       some rights to it; it was further optimized at work here, so
+ **       I think this company claims parts of it.  The patents are
+ **       held by R. Bracewell (the FHT algorithm) and O. Buneman (the
+ **       trig generator), both at Stanford Univ.
+ **       If it were up to me, I'd say go do whatever you want with it;
+ **       but it would be polite to give credit to the following people
+ **       if you use this anywhere:
+ **           Euler     - probable inventor of the fourier transform.
+ **           Gauss     - probable inventor of the FFT.
+ **           Hartley   - probable inventor of the hartley transform.
+ **           Buneman   - for a really cool trig generator
+ **           Mayer(me) - for authoring this particular version and
+ **                       including all the optimizations in one package.
+ **       Thanks,
+ **       Ron Mayer; mayer@acuson.com
+ **
+ */
+ 
+ #include <math.h>
+ #include "util.h"
+ 
+ static FLOAT costab[20]=
+     {
+      .00000000000000000000000000000000000000000000000000,
+      .70710678118654752440084436210484903928483593768847,
+      .92387953251128675612818318939678828682241662586364,
+      .98078528040323044912618223613423903697393373089333,
+      .99518472667219688624483695310947992157547486872985,
+      .99879545620517239271477160475910069444320361470461,
+      .99969881869620422011576564966617219685006108125772,
+      .99992470183914454092164649119638322435060646880221,
+      .99998117528260114265699043772856771617391725094433,
+      .99999529380957617151158012570011989955298763362218,
+      .99999882345170190992902571017152601904826792288976,
+      .99999970586288221916022821773876567711626389934930,
+      .99999992646571785114473148070738785694820115568892,
+      .99999998161642929380834691540290971450507605124278,
+      .99999999540410731289097193313960614895889430318945,
+      .99999999885102682756267330779455410840053741619428
+     };
+ static FLOAT sintab[20]=
+     {
+      1.0000000000000000000000000000000000000000000000000,
+      .70710678118654752440084436210484903928483593768846,
+      .38268343236508977172845998403039886676134456248561,
+      .19509032201612826784828486847702224092769161775195,
+      .09801714032956060199419556388864184586113667316749,
+      .04906767432741801425495497694268265831474536302574,
+      .02454122852291228803173452945928292506546611923944,
+      .01227153828571992607940826195100321214037231959176,
+      .00613588464915447535964023459037258091705788631738,
+      .00306795676296597627014536549091984251894461021344,
+      .00153398018628476561230369715026407907995486457522,
+      .00076699031874270452693856835794857664314091945205,
+      .00038349518757139558907246168118138126339502603495,
+      .00019174759731070330743990956198900093346887403385,
+      .00009587379909597734587051721097647635118706561284,
+      .00004793689960306688454900399049465887274686668768
+     };
+ 
+ /* This is a simplified version for n an even power of 2 */
+ 
+ static void fht(FLOAT *fz, int n)
+ {
+  int i,k,k1,k2,k3,k4,kx;
+  FLOAT *fi,*fn,*gi;
+  FLOAT t_c,t_s;
+ 
+  for (k1=1,k2=0;k1<n;k1++)
+     {
+      FLOAT a;
+      for (k=n>>1; (!((k2^=k)&k)); k>>=1);
+      if (k1>k2)
+ 	{
+ 	     a=fz[k1];fz[k1]=fz[k2];fz[k2]=a;
+ 	}
+     }
+   for (fi=fz,fn=fz+n;fi<fn;fi+=4)
+      {
+       FLOAT f0,f1,f2,f3;
+       f1     = fi[0 ]-fi[1 ];
+       f0     = fi[0 ]+fi[1 ];
+       f3     = fi[2 ]-fi[3 ];
+       f2     = fi[2 ]+fi[3 ];
+       fi[2 ] = (f0-f2);	
+       fi[0 ] = (f0+f2);
+       fi[3 ] = (f1-f3);	
+       fi[1 ] = (f1+f3);
+      }
+ 
+  k=0;
+  do
+     {
+      FLOAT s1,c1;
+      k  += 2;
+      k1  = 1  << k;
+      k2  = k1 << 1;
+      k4  = k2 << 1;
+      k3  = k2 + k1;
+      kx  = k1 >> 1;
+ 	 fi  = fz;
+ 	 gi  = fi + kx;
+ 	 fn  = fz + n;
+ 	 do
+ 	    {
+ 	     FLOAT g0,f0,f1,g1,f2,g2,f3,g3;
+ 	     f1      = fi[0 ] - fi[k1];
+ 	     f0      = fi[0 ] + fi[k1];
+ 	     f3      = fi[k2] - fi[k3];
+ 	     f2      = fi[k2] + fi[k3];
+ 	     fi[k2]  = f0	  - f2;
+ 	     fi[0 ]  = f0	  + f2;
+ 	     fi[k3]  = f1	  - f3;
+ 	     fi[k1]  = f1	  + f3;
+ 	     g1      = gi[0 ] - gi[k1];
+ 	     g0      = gi[0 ] + gi[k1];
+ 	     g3      = SQRT2  * gi[k3];
+ 	     g2      = SQRT2  * gi[k2];
+ 	     gi[k2]  = g0	  - g2;
+ 	     gi[0 ]  = g0	  + g2;
+ 	     gi[k3]  = g1	  - g3;
+ 	     gi[k1]  = g1	  + g3;
+ 	     gi     += k4;
+ 	     fi     += k4;
+ 	    } while (fi<fn);
+      t_c = costab[k];
+      t_s = sintab[k];
+      c1 = 1;
+      s1 = 0;
+      for (i=1;i<kx;i++)
+         {
+ 	 FLOAT c2,s2;
+          FLOAT t = c1;
+          c1 = t*t_c - s1*t_s;
+          s1 = t*t_s + s1*t_c;
+          c2 = c1*c1 - s1*s1;
+          s2 = 2*(c1*s1);
+ 	     fn = fz + n;
+ 	     fi = fz +i;
+ 	     gi = fz +k1-i;
+ 	     do
+ 		{
+ 		 FLOAT a,b,g0,f0,f1,g1,f2,g2,f3,g3;
+ 		 b       = s2*fi[k1] - c2*gi[k1];
+ 		 a       = c2*fi[k1] + s2*gi[k1];
+ 		 f1      = fi[0 ]    - a;
+ 		 f0      = fi[0 ]    + a;
+ 		 g1      = gi[0 ]    - b;
+ 		 g0      = gi[0 ]    + b;
+ 		 b       = s2*fi[k3] - c2*gi[k3];
+ 		 a       = c2*fi[k3] + s2*gi[k3];
+ 		 f3      = fi[k2]    - a;
+ 		 f2      = fi[k2]    + a;
+ 		 g3      = gi[k2]    - b;
+ 		 g2      = gi[k2]    + b;
+ 		 b       = s1*f2     - c1*g3;
+ 		 a       = c1*f2     + s1*g3;
+ 		 fi[k2]  = f0        - a;
+ 		 fi[0 ]  = f0        + a;
+ 		 gi[k3]  = g1        - b;
+ 		 gi[k1]  = g1        + b;
+ 		 b       = c1*g2     - s1*f3;
+ 		 a       = s1*g2     + c1*f3;
+ 		 gi[k2]  = g0        - a;
+ 		 gi[0 ]  = g0        + a;
+ 		 fi[k3]  = f1        - b;
+ 		 fi[k1]  = f1        + b;
+ 		 gi     += k4;
+ 		 fi     += k4;
+ 		} while (fi<fn);
+         }
+     } while (k4<n);
+ }
+ 
+ void fft(FLOAT *x_real, FLOAT *energy, FLOAT *ax, FLOAT *bx, int N)
+ {
+  FLOAT a,b;
+  int i,j;
+ 
+  fht(x_real,N);
+ 
+ 
+  energy[0] = x_real[0] * x_real[0];
+  ax[0] = bx[0] = x_real[0];
+ 
+  for (i=1,j=N-1;i<N/2;i++,j--) {
+    a = ax[i] = x_real[i];
+    b = bx[i] = x_real[j];
+    energy[i]=(a*a + b*b)/2;
+    
+    if (energy[i] < 0.0005) {
+      energy[i] = 0.0005;
+      ax[i] = bx[i] =  0.0223606797749978970790696308768019662239; /* was sqrt(0.0005) */
+    }
+  }
+  energy[N/2] = x_real[N/2] * x_real[N/2];
+  ax[N/2] = bx[N/2] = x_real[N/2];
+ }
+ 
+ 
+ 
+ 
+ #if 0
+ /* mt 7/99
+    Note: fft_side() can be used to compute energy, ax & bx for the
+    mid and side channels (chn=2,3) without calling additional FFTs. 
+    But it requires wsamp_r to be saved from channels 0 and 1.  
+    My tests show that the FFT is so fast that this gives no savings.
+    Probably the extra memory hurts the cache performance.
+ */
+ 
+ void fft_side(FLOAT x_real0[],FLOAT x_real1[], FLOAT *energy, FLOAT *ax, FLOAT *bx, 
+ int N, int sign)
+ /*
+ x_real0 = x_real from channel 0
+ x_real1 = x_real from channel 1
+ sign = 1:    compute mid channel energy, ax, bx
+ sign =-1:    compute side channel energy, ax, bx
+ */
+ {
+  FLOAT a,b;
+  int i,j;
+ 
+ #define XREAL(j) ((x_real0[j]+sign*x_real1[j])/SQRT2)
+ 
+  energy[0] = XREAL(0) * XREAL(0);
+  ax[0] = bx[0] = XREAL(0);
+ 
+  for (i=1,j=N-1;i<N/2;i++,j--) {
+    a = ax[i] = XREAL(i);
+    b = bx[i] = XREAL(j);
+    energy[i]=(a*a + b*b)/2;
+    
+    if (energy[i] < 0.0005) {
+      energy[i] = 0.0005;
+      ax[i] = bx[i] =  0.0223606797749978970790696308768019662239; /* was sqrt(0.0005) */
+    }
+  }
+  energy[N/2] = XREAL(N/2) * XREAL(N/2);
+  ax[N/2] = bx[N/2] = XREAL(N/2);
+ 
+ 
+ }
+ #endif
+ 
+ 
diff -r -c -N encoder/fft.h lame3.50/fft.h
*** encoder/fft.h	Wed Dec 31 17:00:00 1969
--- lame3.50/fft.h	Fri Sep 10 09:52:06 1999
***************
*** 0 ****
--- 1,16 ----
+ #ifndef FFT_H
+ #define FFT_H
+ 
+ #include "encoder.h"
+ 
+ void fft(FLOAT x_real[BLKSIZE],
+          FLOAT energy[BLKSIZE],
+          FLOAT ax[BLKSIZE],FLOAT  bx[BLKSIZE],
+          int N);
+ 
+ void fft_side(FLOAT x_real0[BLKSIZE],FLOAT x_real1[BLKSIZE],
+          FLOAT energy[BLKSIZE],
+          FLOAT ax[BLKSIZE],FLOAT  bx[BLKSIZE],
+          int N,int sign);
+ 
+ #endif
diff -r -c -N encoder/filterbank.c lame3.50/filterbank.c
*** encoder/filterbank.c	Wed Dec 31 17:00:00 1969
--- lame3.50/filterbank.c	Wed Oct 27 01:23:41 1999
***************
*** 0 ****
--- 1,115 ----
+ #include "util.h"
+ #include "encoder.h"
+ #include "tables.h"
+ 
+ 
+ /************************************************************************
+ *
+ * window_subband()
+ *
+ * PURPOSE:  Overlapping window on PCM samples
+ *
+ * SEMANTICS:
+ * 32 16-bit pcm samples are scaled to fractional 2's complement and
+ * concatenated to the end of the window buffer #x#. The updated window
+ * buffer #x# is then windowed by the analysis window #c# to produce the
+ * windowed sample #z#
+ *
+ ************************************************************************/
+ 
+ void window_subband(short **buffer, double z[64], int k)
+ {
+     static double x[2][HAN_SIZE];
+     double *xk;
+     static int off[2] = {0,0};
+     double *ep0,*ep1, *ep2, *ep3, *ep4, *ep5, *ep6, *ep7;
+ 
+     int i,q;
+     double t;
+ 
+     xk=x[k];
+ 
+     /* replace 32 oldest samples with 32 new samples */
+     for (i=0;i<32;i++) 
+       xk[31-i+off[k]] = (double) *(*buffer)++/32768;
+ 
+     ep0 = &enwindow[0];
+     ep1 = &enwindow[64];
+     ep2 = &enwindow[128];
+     ep3 = &enwindow[192];
+     ep4 = &enwindow[256];
+     ep5 = &enwindow[320];
+     ep6 = &enwindow[384];
+     ep7 = &enwindow[448];
+  
+     q = off[k];
+ 
+     /* shift samples into proper window positions */
+     for( i = 0 ; i<64 ; i++, q++ ) {        
+         t =  xk[(q)&(512-1)] * *ep0++;
+         t += xk[(q+64)&(512-1)] * *ep1++;
+         t += xk[(q+128)&(512-1)] * *ep2++;
+         t += xk[(q+192)&(512-1)] * *ep3++;
+         t += xk[(q+256)&(512-1)] * *ep4++;
+         t += xk[(q+320)&(512-1)] * *ep5++;
+         t += xk[(q+384)&(512-1)] * *ep6++;
+         t += xk[(q+448)&(512-1)] * *ep7++;
+         z[i] = t;
+         }
+     
+     off[k] += 480;              /*offset is modulo (HAN_SIZE-1)*/
+     off[k] &= HAN_SIZE-1;
+ 
+ }
+  
+ /************************************************************************
+ *
+ * filter_subband()
+ *
+ * PURPOSE:  Calculates the analysis filter bank coefficients
+ *
+ * SEMANTICS:
+ *      The windowed samples #z# is filtered by the digital filter matrix #m#
+ * to produce the subband samples #s#. This done by first selectively
+ * picking out values from the windowed samples, and then multiplying
+ * them by the filter matrix, producing 32 subband samples.
+ *
+ ************************************************************************/
+ 
+ 
+ void filter_subband(double z[64], double s[SBLIMIT]) {
+ 
+    double yprime[32];
+    int i,j;
+    static int init = 0;
+    static double filter[16][32];
+    
+    double s0,s1;
+ 
+    if(!init) {
+       init=1;
+       for (i=0; i<16; i++)  for (j=0; j<32; j++)
+          filter[i][j] = cos((double)((2*i+1)*j*PI64));
+       }
+ 
+    yprime[0] = z[16];
+ 
+    for( i=1; i<=16; i++ ) yprime[i] = z[i+16]+z[16-i];
+    for( i=17; i<=31; i++ ) yprime[i] = z[i+16]-z[80-i];
+  
+    for( i=0; i<16; i++ ) {
+       s0 = s1 = 0.0;
+ 
+       for( j=0; j<32; j+=2 ) {
+          s0 += filter[i][j]*yprime[j];
+          s1 += filter[i][j+1]*yprime[j+1];
+          }
+ 
+      s[i] = s0+s1;
+      s[31-i] = s0-s1;
+ 
+      }
+ 
+    }
+ 
+ 
diff -r -c -N encoder/formatBitstream.c lame3.50/formatBitstream.c
*** encoder/formatBitstream.c	Wed Jan 22 02:43:14 1997
--- lame3.50/formatBitstream.c	Mon Oct 25 12:21:59 1999
***************
*** 27,37 ****
  static int BitsRemaining  = 0;
  static BitsFcnPtr PutBits = NULL;
  
  /* forward declarations */
  static int store_side_info( BF_FrameData *frameInfo );
  static int main_data( BF_FrameData *frameInfo, BF_FrameResults *results );
  static int side_queue_elements( int *forwardFrameLength, int *forwardSILength );
! static void free_side_queues();
  static void WriteMainDataBits( unsigned val,
                                 unsigned nbits,
  			       BF_FrameResults *results );
--- 27,45 ----
  static int BitsRemaining  = 0;
  static BitsFcnPtr PutBits = NULL;
  
+ void InitFormatBitStream(void)
+ {
+ 	BitCount		= 0;
+ 	ThisFrameSize	= 0;
+ 	BitsRemaining	= 0;
+ 	PutBits			= NULL;
+ }
+ 
  /* forward declarations */
  static int store_side_info( BF_FrameData *frameInfo );
  static int main_data( BF_FrameData *frameInfo, BF_FrameResults *results );
  static int side_queue_elements( int *forwardFrameLength, int *forwardSILength );
! static void free_side_queues(void);
  static void WriteMainDataBits( unsigned val,
                                 unsigned nbits,
  			       BF_FrameResults *results );
***************
*** 49,58 ****
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
--- 57,67 ----
    See formatBitstream.h for more information about the data
    structures and the bitstream syntax.
  */
+ static int elements, forwardFrameLength, forwardSILength; 
  void
  BF_BitstreamFrame( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      assert( frameInfo->nGranules <= MAX_GRANULES );
      assert( frameInfo->nChannels <= MAX_CHANNELS );
***************
*** 87,108 ****
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!     int elements, forwardFrameLength, forwardSILength;
  
      /* get ptr to bit writing function */
      PutBits = frameInfo->putbits;
      assert( PutBits );
  
-     elements = side_queue_elements( &forwardFrameLength, &forwardSILength );
- 
      if ( elements )
      {
! 	int bitsRemaining = forwardFrameLength - forwardSILength;
! 	int wordsRemaining = bitsRemaining / 32;
! 	while ( wordsRemaining-- )
! 	    WriteMainDataBits( 0, 32, results );
! 	WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
--- 96,117 ----
  void
  BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results )
  {
!   /*    int elements, forwardFrameLength, forwardSILength; */
  
      /* get ptr to bit writing function */
      PutBits = frameInfo->putbits;
      assert( PutBits );
  
      if ( elements )
      {
!       int bitsRemaining = forwardFrameLength - forwardSILength;
!       int wordsRemaining = bitsRemaining / 32;
!       while ( wordsRemaining-- ) {
! 	WriteMainDataBits( 0, 32, results );
!       }
!       WriteMainDataBits( 0, (bitsRemaining % 32), results );	
      }
+     
  
      results->mainDataLength = forwardFrameLength - forwardSILength;
      results->SILength       = forwardSILength;
***************
*** 131,137 ****
      return bits;
  }
  
! 
  /*
    The following is all private to this file
  */
--- 140,146 ----
      return bits;
  }
  
! 
  /*
    The following is all private to this file
  */
***************
*** 148,155 ****
      BF_PartHolder *spectrumSIPH[MAX_GRANULES][MAX_CHANNELS];
  } MYSideInfo;
  
! static MYSideInfo *get_side_info();
! static int write_side_info();
  typedef int (*PartWriteFcnPtr)( BF_BitstreamPart *part, BF_FrameResults *results );
  
  
--- 157,164 ----
      BF_PartHolder *spectrumSIPH[MAX_GRANULES][MAX_CHANNELS];
  } MYSideInfo;
  
! static MYSideInfo *get_side_info(void);
! static int write_side_info(void);
  typedef int (*PartWriteFcnPtr)( BF_BitstreamPart *part, BF_FrameResults *results );
  
  
***************
*** 246,254 ****
      assert( (BitCount + BitsRemaining) == ThisFrameSize );
  }
  
! 
  static int
! write_side_info()
  {
      MYSideInfo *si;
      int bits, ch, gr;
--- 255,263 ----
      assert( (BitCount + BitsRemaining) == ThisFrameSize );
  }
  
! 
  static int
! write_side_info(void)
  {
      MYSideInfo *si;
      int bits, ch, gr;
***************
*** 284,290 ****
  side_queue_elements( int *frameLength, int *SILength )
  {
      int elements = 0;
!     side_info_link *l = side_queue_head;
  
      *frameLength = 0;
      *SILength    = 0;
--- 293,299 ----
  side_queue_elements( int *frameLength, int *SILength )
  {
      int elements = 0;
!     side_info_link *l;
  
      *frameLength = 0;
      *SILength    = 0;
***************
*** 302,308 ****
  store_side_info( BF_FrameData *info )
  {
      int ch, gr;
!     side_info_link *l = NULL;
      /* obtain a side_info_link to store info */
      side_info_link *f = side_queue_free;
      int bits = 0;
--- 311,317 ----
  store_side_info( BF_FrameData *info )
  {
      int ch, gr;
!     side_info_link *l;
      /* obtain a side_info_link to store info */
      side_info_link *f = side_queue_free;
      int bits = 0;
***************
*** 377,383 ****
  }
  
  static MYSideInfo*
! get_side_info()
  {
      side_info_link *f = side_queue_free;
      side_info_link *l = side_queue_head;
--- 386,392 ----
  }
  
  static MYSideInfo*
! get_side_info(void)
  {
      side_info_link *f = side_queue_free;
      side_info_link *l = side_queue_head;
***************
*** 404,410 ****
  }
  
  static void
! free_side_queues()
  {
      side_info_link *l, *next;
      
--- 413,419 ----
  }
  
  static void
! free_side_queues(void)
  {
      side_info_link *l, *next;
      
***************
*** 445,456 ****
  */
  BF_PartHolder *BF_newPartHolder( int max_elements )
  {
!     BF_PartHolder *newPH    = calloc( 1, sizeof(BF_PartHolder) );
      assert( newPH );
      newPH->max_elements  = max_elements;
!     newPH->part          = calloc( 1, sizeof(BF_BitstreamPart) );
      assert( newPH->part );
!     newPH->part->element = calloc( max_elements, sizeof(BF_BitstreamElement) );
      assert( newPH->part->element );
      newPH->part->nrEntries = 0;
      return newPH;
--- 454,465 ----
  */
  BF_PartHolder *BF_newPartHolder( int max_elements )
  {
!     BF_PartHolder *newPH    = (BF_PartHolder*) calloc( 1, sizeof(BF_PartHolder) );
      assert( newPH );
      newPH->max_elements  = max_elements;
!     newPH->part          = (BF_BitstreamPart*) calloc( 1, sizeof(BF_BitstreamPart) );
      assert( newPH->part );
!     newPH->part->element = (BF_BitstreamElement*) calloc( max_elements, sizeof(BF_BitstreamElement) );
      assert( newPH->part->element );
      newPH->part->nrEntries = 0;
      return newPH;
diff -r -c -N encoder/formatBitstream.h lame3.50/formatBitstream.h
*** encoder/formatBitstream.h	Wed Jan 22 02:43:15 1997
--- lame3.50/formatBitstream.h	Tue Sep 28 19:37:14 1999
***************
*** 97,145 ****
      int nextBackPtr;
  } BF_FrameResults;
  
- /*
-   The following is a shorthand bitstream syntax for
-   the type of bitstream this package will create.
-   The bitstream has headers and side information that
-   are placed at appropriate sections to allow framing.
-   The main data is placed where it fits in a manner
-   similar to layer3, which means that main data for a
-   frame may be written to the bitstream before the
-   frame's header and side information is written.
- 
- BitstreamFrame()
- {
-     Header();
-     FrameSI();
- 
-     for ( ch )
- 	ChannelSI();
- 
-     for ( gr )
- 	for ( ch )
- 	    SpectrumSI();
- 
-     MainData();
- }
- 
- MainData()
- {
-     for ( gr )
- 	for ( ch )
- 	{
- 	    Scalefactors();
- 	    CodedData();
- 	    UserSpectrum();
- 	}
-     UserFrameData();
- }
- 
- */
  
  /*
    public functions in formatBitstream.c
  */
  
  /* count the bits in a BitstreamPart */
  int  BF_PartLength( BF_BitstreamPart *part );
  
--- 97,111 ----
      int nextBackPtr;
  } BF_FrameResults;
  
  
  /*
    public functions in formatBitstream.c
  */
  
+ 
+ /* Initialize the bitstream */
+ void InitFormatBitStream(void);
+ 
  /* count the bits in a BitstreamPart */
  int  BF_PartLength( BF_BitstreamPart *part );
  
***************
*** 149,154 ****
--- 115,122 ----
  /* write any remaining frames to the bitstream, padding with zeros */
  void BF_FlushBitstream( BF_FrameData *frameInfo, BF_FrameResults *results );
  
+ 
+ 
  typedef struct BF_PartHolder
  {
      int              max_elements;
***************
*** 162,165 ****
  BF_PartHolder *BF_NewHolderFromBitstreamPart( BF_BitstreamPart *thePart );
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart );
  BF_PartHolder *BF_freePartHolder( BF_PartHolder *thePH );
! #endif
--- 130,134 ----
  BF_PartHolder *BF_NewHolderFromBitstreamPart( BF_BitstreamPart *thePart );
  BF_PartHolder *BF_LoadHolderFromBitstreamPart( BF_PartHolder *theHolder, BF_BitstreamPart *thePart );
  BF_PartHolder *BF_freePartHolder( BF_PartHolder *thePH );
! 
! #endif  /* #ifndef _FORMAT_BITSTREAM_H */
diff -r -c -N encoder/get_audio.c lame3.50/get_audio.c
*** encoder/get_audio.c	Wed Dec 31 17:00:00 1969
--- lame3.50/get_audio.c	Thu Oct 28 21:45:33 1999
***************
*** 0 ****
--- 1,806 ----
+ #include "util.h"
+ #include "get_audio.h"
+ #include "globalflags.h"
+ #include "lame.h"
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ 
+ static FILE *musicin=NULL;  /* input file pointer */
+ static unsigned long num_samples;
+ static int samp_freq;
+ static int input_bitrate;
+ static int num_channels;
+ 
+ int read_samples_pcm( short sample_buffer[2304],int frame_size, int samples_to_read);
+ int read_samples_mp3(FILE *musicin,short int mpg123pcm[2][1152],int num_chan);
+ 
+ /************************************************************************
+ *
+ * get_audio()
+ *
+ * PURPOSE:  reads a frame of audio data from a file to the buffer,
+ *   aligns the data for future processing, and separates the
+ *   left and right channels
+ *
+ *
+ ************************************************************************/
+ int get_audio(short buffer[2][1152],int stereo, layer* info)
+ {
+ 
+   int		j;
+   short	insamp[2304];
+   int samples_read;
+   int framesize,samples_to_read;
+   static unsigned long num_samples_read;
+   unsigned long remaining;
+   if (frameNum==0) {
+     num_samples_read=0;
+     num_samples= GetSndSamples();
+   }
+ 
+   remaining=num_samples-num_samples_read;
+   framesize = (info->version ==0) ? 576 : 1152;
+   samples_to_read = remaining > framesize ? framesize : remaining;
+   if (samples_to_read<0) samples_to_read=0;
+ 
+   if (input_format==sf_mp3) {
+     if ((stereo==2) || (autoconvert) ) 
+       samples_read=read_samples_mp3(musicin,buffer,2);
+     else
+       samples_read=read_samples_mp3(musicin,buffer,1);
+   }else{
+     /* MPEG 1 */
+     if(stereo == 2)  {
+       samples_read = read_samples_pcm(insamp, 2*framesize,2*samples_to_read);
+       samples_read /=2;
+       for(j=0;j<framesize;j++)
+ 	{
+ 	  buffer[0][j] = insamp[2*j];
+ 	  buffer[1][j] = insamp[2*j+1];
+ 	}
+     }else{
+       if (autoconvert==TRUE) {
+ 	/* downconvert from a stereo file into a mono buffer */
+ 	samples_read = read_samples_pcm(insamp,2*framesize, 2*samples_to_read);
+ 	samples_read /=2;
+ 	for(j=0;j<framesize;j++)
+ 	  {
+ 	    /* dont overflow the short int */
+ 	    buffer[0][j] = ((int)insamp[2*j] + (int)insamp[2*j+1])/2;
+ 	    buffer[1][j] = 0;
+ 	  }	
+       } else {
+ 	samples_read = read_samples_pcm(insamp, framesize,samples_to_read);
+ 	for(j=0;j<framesize;j++)
+ 	  {
+ 	    buffer[0][j] = insamp[j];
+ 	    buffer[1][j] = 0;
+ 	  }
+       }
+     }
+   }
+ 
+   /* dont count things in this case to avoid overflows */
+   if (num_samples!=MAX_U_32_NUM) num_samples_read += samples_read;
+   //  printf("%i %i %i \n",samples_read,(int)num_samples_read,(int)num_samples);
+   return(samples_read);
+ }
+   
+   
+ int GetSndBitrate()
+ {
+ 	return input_bitrate;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ int read_samples_mp3(FILE *musicin,short int mpg123pcm[2][1152],int stereo)
+ {
+   int j,out=0;
+ #ifdef HAVEGTK
+   static int adj=0;
+   int ch;
+ #endif
+ 
+   out=lame_decode_fromfile(musicin,mpg123pcm);
+   if (out<=0) {
+     for ( j = 0; j < out; j++ ) {
+       mpg123pcm[0][j] = 0;
+       mpg123pcm[1][j] = 0;
+     }
+   }
+   if (autoconvert) {
+     for ( j = 0; j < out; j++ ) {
+       mpg123pcm[0][j] = ((int)mpg123pcm[0][j] + (int)mpg123pcm[1][j])/2;
+       mpg123pcm[1][j] = 0;
+     }
+   }
+ 
+ 
+ #ifdef HAVEGTK
+   if (gtkflag) {
+   if (out>0) {
+     /* set adj=0 for 1152 samples, adj=576 for 576 samples */
+     adj=0;
+     if (out==576) adj=576;
+ 
+     /* create a 1 frame lag so MP3 analysis syncs with WAV analysis */
+     /* Compensate for the decoder_delay.  add DECDELAY, where
+      * decoder_delay + DECDELAY = 1152 (or 576), so data is delayed
+      * by exactly one frame */
+     /* if out=0, last frame of data is in mpg123pcm */
+     for ( ch = 0; ch < stereo; ch++ ) {
+       for ( j = 0; j < DECDELAY-adj; j++ )
+ 	pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+1152-adj];
+       for ( j = 0; j < 1152-adj; j++ ) 
+ 	pinfo->pcmdata2[ch][j+DECDELAY-adj] = mpg123pcm[ch][j];
+     }
+     }
+ 
+     pinfo->frameNum123 = frameNum-1;
+     pinfo->frameNum = frameNum;
+   }
+ #endif
+   return out;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ #ifdef LIBSNDFILE 
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ ** 
+ ** This program is distributed in the hope that it will be useful,
+ ** but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ** GNU General Public License for more details.
+ ** 
+ ** You should have received a copy of the GNU General Public License
+ ** along with this program; if not, write to the Free Software 
+ ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+ #include <stdio.h>
+ 
+ /* External references */
+ 
+ static SNDFILE*	gs_pSndFileIn=NULL;
+ static SF_INFO	gs_wfInfo;
+ 
+ 
+ unsigned long GetSndSamples(void)
+ {
+        return gs_wfInfo.samples;
+ }
+ int GetSndSampleRate(void)
+ {
+ 	return gs_wfInfo.samplerate;
+ }
+ 
+ int GetSndChannels(void)
+ {
+ 	return gs_wfInfo.channels;
+ }
+ 
+ void CloseSndFile(void)
+ {
+   if (input_format==sf_mp3) {
+     if (fclose(musicin) != 0){
+       fprintf(stderr, "Could not close audio input file\n");
+       exit(2);
+     }
+   }else{
+ 	if (gs_pSndFileIn)
+ 	{
+ 		if (sf_close(gs_pSndFileIn) !=0)
+ 		{
+ 			fprintf(stderr, "Could not close sound file \n");
+ 			exit(2);
+ 		}
+ 	}
+   }
+ }
+ 
+ 
+ void InitSndFile()
+ {
+    gs_wfInfo.samples=MAX_U_32_NUM;
+    gs_wfInfo.channels=0;
+    gs_wfInfo.samplerate=0;
+    input_bitrate=0;
+ }
+ 
+ 
+ void OpenSndFile(const char* lpszFileName, layer *info,int default_samp,
+ int default_channels)
+ {
+   input_bitrate=0;
+   if (input_format==sf_mp3) {
+     if ((musicin = fopen(lpszFileName, "rb")) == NULL) {
+       fprintf(stderr, "Could not find \"%s\".\n", lpszFileName);
+       exit(1);
+     }
+     if (-1==lame_decode_initfile(musicin,&num_channels,&samp_freq,&input_bitrate)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", lpszFileName);
+       exit(1);
+     }
+     gs_wfInfo.samples=MAX_U_32_NUM;
+     gs_wfInfo.channels=num_channels;
+     gs_wfInfo.samplerate=samp_freq;
+ 
+   } else {
+ 
+     // Try to open the sound file
+     /* set some defaults incase input is raw PCM */
+     gs_wfInfo.seekable=(input_format!=sf_raw);  /* if user specified -r, set to not seekable */
+     gs_wfInfo.samplerate=default_samp;
+     gs_wfInfo.pcmbitwidth=16;
+     gs_wfInfo.channels=default_channels;
+     if (DetermineByteOrder()==order_littleEndian)
+       gs_wfInfo.format=SF_FORMAT_RAW_LE;
+     else
+       gs_wfInfo.format=SF_FORMAT_RAW_BE;
+ 
+     gs_pSndFileIn=sf_open_read(lpszFileName,&gs_wfInfo);
+ 
+ 	// Check result
+ 	if (gs_pSndFileIn==NULL)
+ 	{
+ 	        sf_perror(gs_pSndFileIn);
+ 		fprintf(stderr, "Could not open sound file \"%s\".\n", lpszFileName);
+ 		exit(1);
+ 	}
+ 
+     if ((gs_wfInfo.format==SF_FORMAT_RAW_LE) || 
+ 	(gs_wfInfo.format==SF_FORMAT_RAW_BE)) 
+       input_format=sf_raw;
+ 
+ #ifdef _DEBUG_SND_FILE
+ 	printf("\n\nSF_INFO structure\n");
+ 	printf("samplerate        :%d\n",gs_wfInfo.samplerate);
+ 	printf("samples           :%d\n",gs_wfInfo.samples);
+ 	printf("channels          :%d\n",gs_wfInfo.channels);
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("format            :");
+ 
+ 	if (gs_wfInfo.format&SF_FORMAT_WAV) printf("Microsoft WAV format (big endian)");
+ 	if (gs_wfInfo.format&SF_FORMAT_AIFF) printf("Apple/SGI AIFF format (little endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_AU) printf("Sun/NeXT AU format (big endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_AULE) printf("DEC AU format (little endian).");
+ 	if (gs_wfInfo.format&SF_FORMAT_PCM) printf("PCM data in 8, 16, 24 or 32 bits.");
+ 	if (gs_wfInfo.format&SF_FORMAT_FLOAT) printf("32 bit Intel x86 floats.");
+ 	if (gs_wfInfo.format&SF_FORMAT_ULAW) printf("U-Law encoded.");
+ 	if (gs_wfInfo.format&SF_FORMAT_ALAW) printf("A-Law encoded.");
+ 	if (gs_wfInfo.format&SF_FORMAT_MS_ADPCM) printf("Microsoft ADPCM.");
+ 	if (gs_wfInfo.format&SF_FORMAT_IMA_ADPCM) printf("IMA ADPCM.");
+ 
+ 	printf("\n");
+ 	printf("pcmbitwidth       :%d\n",gs_wfInfo.pcmbitwidth);
+ 	printf("sections          :%d\n",gs_wfInfo.sections);
+ 	printf("seekable          :\n",gs_wfInfo.seekable);
+ #endif
+   }
+ }
+ 
+ 
+ /************************************************************************
+ *
+ * read_samples()
+ *
+ * PURPOSE:  reads the PCM samples from a file to the buffer
+ *
+ *  SEMANTICS:
+ * Reads #samples_read# number of shorts from #musicin# filepointer
+ * into #sample_buffer[]#.  Returns the number of samples read.
+ *
+ ************************************************************************/
+ 
+ int read_samples_pcm(short sample_buffer[2304],int frame_size,int samples_to_read)
+ {
+     int 		samples_read;
+     int			rcode;
+ 
+     samples_read=sf_read_short(gs_pSndFileIn,sample_buffer,samples_to_read);
+     
+     rcode = samples_read;
+     if (samples_read < frame_size)
+       {
+ 	/* printf("Insufficient PCM input for one frame - fillout with zeros\n"); */
+ 	if (samples_read<0) samples_read=0;
+ 	for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
+       }
+     return(rcode);
+ }
+ 
+ 
+ #else /* ifdef LIBSNDFILE */
+ 
+ /************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  *
+  * OLD ISO/LAME routines follow.  Used if you dont have LIBSNDFILE
+  * or for stdin/stdout support
+  *
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************
+  ************************************************************************/
+ 
+ /* Replacement for forward fseek(,,SEEK_CUR), because fseek() fails on pipes */
+ int fskip(FILE *sf,long num_bytes,int dummy)
+ {
+   char data[1024];
+   int nskip = 0;
+   while (num_bytes > 0) {
+     nskip = (num_bytes>1024) ? 1024 : num_bytes;
+     num_bytes -= fread(data,(size_t)1,(size_t)nskip,sf);
+   }
+   /* return 0 if last read was successful */
+   return num_bytes;
+ }
+ 
+ 
+ 
+ void CloseSndFile(void)
+ {
+   if (fclose(musicin) != 0){
+     fprintf(stderr, "Could not close audio input file\n");
+     exit(2);
+   }
+ }
+ 
+ 
+ unsigned long GetSndSamples(void)
+ {
+        return num_samples;
+ }
+ int GetSndSampleRate(void)
+ {
+ 	return samp_freq;
+ }
+ 
+ int GetSndChannels(void)
+ {
+ 	return num_channels;
+ }
+ 
+ void InitSndFile()
+ {
+   num_samples=MAX_U_32_NUM;
+   samp_freq=0;
+   num_channels = 0;
+   input_bitrate=0;
+ }
+ 
+ 
+ 
+ void OpenSndFile(const char* inPath, layer *info,int default_samp,
+ int default_channels)
+ {
+   void parse_file_header(FILE *sf);
+   /* set the defaults from info incase we cannot determine them from file */
+   num_samples=MAX_U_32_NUM;
+   samp_freq=default_samp;
+   num_channels = default_channels;
+ 
+   if (!strcmp(inPath, "-")) {
+     /* Read from standard input. */
+ #ifdef __EMX__
+     _fsetmode(stdin,"b");
+ #elif (defined  __BORLANDC__)
+     setmode(_fileno(stdin), O_BINARY);
+ #elif (defined  __CYGWIN__)
+       setmode(fileno(stdin), _O_BINARY);
+ #elif (defined _WIN32)
+     _setmode(_fileno(stdin), _O_BINARY);
+ #endif
+     musicin = stdin;
+   } else {
+     if ((musicin = fopen(inPath, "rb")) == NULL) {
+       fprintf(stderr, "Could not find \"%s\".\n", inPath);
+       exit(1);
+     }
+   }
+ 
+   input_bitrate=0;
+   if (input_format==sf_mp3) {
+     if (-1==lame_decode_initfile(musicin,&num_channels,&samp_freq,&input_bitrate)) {
+       fprintf(stderr,"Error reading headers in mp3 input file %s.\n", inPath);
+       exit(1);
+     }
+   }else{
+     if (input_format != sf_raw) {
+       parse_file_header(musicin);
+     }
+ 
+     
+     if (input_format==sf_raw) {
+       /* assume raw PCM */
+       fprintf(stderr, "Assuming raw pcm input file");
+       if (swapbytes==TRUE)
+ 	fprintf(stderr, " : Forcing byte-swapping\n");
+       else
+ 	fprintf(stderr, "\n");
+     }
+   }
+ }
+ 
+ 
+ /************************************************************************
+ *
+ * read_samples()
+ *
+ * PURPOSE:  reads the PCM samples from a file to the buffer
+ *
+ *  SEMANTICS:
+ * Reads #samples_read# number of shorts from #musicin# filepointer
+ * into #sample_buffer[]#.  Returns the number of samples read.
+ *
+ ************************************************************************/
+ 
+ int read_samples_pcm(short sample_buffer[2304], int frame_size,int samples_to_read)
+ {
+     int samples_read;
+     int rcode;
+     int iswav=(input_format==sf_wave);
+ 
+     if ((samples_read =
+          fread(sample_buffer, sizeof(short), samples_to_read, musicin)) == 0)
+       { /* printf("Hit end of audio data\n");*/   }
+     /*
+        Samples are big-endian. If this is a little-endian machine
+        we must swap
+      */
+     if ( NativeByteOrder == order_unknown )
+       {
+ 	NativeByteOrder = DetermineByteOrder();
+ 	if ( NativeByteOrder == order_unknown )
+ 	  {
+ 	    fprintf( stderr, "byte order not determined\n" );
+ 	    exit( 1 );
+ 	  }
+       }
+     if (!iswav && ( NativeByteOrder == order_littleEndian ))
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+     if (iswav && ( NativeByteOrder == order_bigEndian ))
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+     if (swapbytes==TRUE)
+       SwapBytesInWords( sample_buffer, samples_read );
+ 
+ 
+     rcode=samples_read;
+     if (samples_read < frame_size) {
+       if (samples_read<0) samples_read=0;
+       /* printf("Insufficient PCM input for one frame - fillout with zeros\n"); */
+       for (; samples_read < frame_size; sample_buffer[samples_read++] = 0);
+     }
+     return(rcode);
+ }
+ 
+ 
+ 
+ #define WAV_ID_RIFF 0x52494646 /* "RIFF" */
+ #define WAV_ID_WAVE 0x57415645 /* "WAVE" */
+ #define WAV_ID_FMT  0x666d7420 /* "fmt " */
+ #define WAV_ID_DATA 0x64617461 /* "data" */
+ 
+ typedef struct fmt_chunk_data_struct {
+ 	short	format_tag;			 /* Format category */
+ 	u_short channels;			 /* Number of channels */
+ 	u_long	samples_per_sec;	 /* Sampling rate */
+ 	u_long	avg_bytes_per_sec;	 /* For buffer estimation */
+ 	u_short block_align;		 /* Data block size */
+ 	u_short bits_per_sample;	 /* for PCM data, anyway... */
+ } fmt_chunk_data;
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * wave_check
+ *
+ * PURPOSE:	Checks Wave header information to make sure it is valid.
+ *			Exits if not.
+ *
+ ************************************************************************/
+ 
+ static void
+ wave_check(char *file_name, fmt_chunk_data *wave_info)
+ {
+ 	if (wave_info->bits_per_sample != 16) {
+ 		fprintf(stderr, "%d-bit sample-size is not supported!\n",
+ 			wave_info->bits_per_sample);
+ 		exit(1);
+ 	}
+ }
+ 
+ 
+ /*****************************************************************************
+  *
+  *	Read Microsoft Wave headers
+  *
+  *	By the time we get here the first 32-bits of the file have already been
+  *	read, and we're pretty sure that we're looking at a WAV file.
+  *
+  *****************************************************************************/
+ 
+ static int
+ parse_wave_header(FILE *sf)
+ {
+ 	fmt_chunk_data wave_info;
+ 	int is_wav = 0;
+ 	long data_length = 0, file_length = 0, subSize = 0;
+ 	int loop_sanity = 0;
+ 
+ 	memset(&wave_info, 0, sizeof(wave_info));
+ 
+ 	file_length = Read32BitsHighLow(sf);
+ 
+ 	if (Read32BitsHighLow(sf) != WAV_ID_WAVE)
+ 		return 0;
+ 
+ 	for (loop_sanity = 0; loop_sanity < 20; ++loop_sanity) {
+ 		u_int type = Read32BitsHighLow(sf);
+ 
+ 		if (type == WAV_ID_FMT) {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			if (subSize < 16) {
+ 			  /*fprintf(stderr,
+ 			    "'fmt' chunk too short (only %ld bytes)!", subSize);  */
+ 				return 0;
+ 			}
+ 
+ 			wave_info.format_tag		= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.channels			= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.samples_per_sec	= Read32BitsLowHigh(sf);
+ 			subSize -= 4;
+ 			wave_info.avg_bytes_per_sec = Read32BitsLowHigh(sf);
+ 			subSize -= 4;
+ 			wave_info.block_align		= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 			wave_info.bits_per_sample	= Read16BitsLowHigh(sf);
+ 			subSize -= 2;
+ 
+ 			/* fprintf(stderr, "   skipping %d bytes\n", subSize); */
+ 
+ 			if (subSize > 0) {
+ 				if (fskip(sf, (long)subSize, SEEK_CUR) != 0 )
+ 					return 0;
+ 			};
+ 
+ 		} else if (type == WAV_ID_DATA) {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			data_length = subSize;
+ 			is_wav = 1;
+ 			/* We've found the audio data.	Read no further! */
+ 			break;
+ 
+ 		} else {
+ 			subSize = Read32BitsLowHigh(sf);
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 ) return 0;
+ 		}
+ 	}
+ 
+ 	if (is_wav) {
+ 		/* make sure the header is sane */
+ 		wave_check("name", &wave_info);
+ 
+ 		num_channels  = wave_info.channels;
+ 		samp_freq     = wave_info.samples_per_sec;
+ 		num_samples   = data_length / (wave_info.channels * wave_info.bits_per_sample / 8);
+ 	}
+ 	return is_wav;
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * aiff_check
+ *
+ * PURPOSE:	Checks AIFF header information to make sure it is valid.
+ *			Exits if not.
+ *
+ ************************************************************************/
+ 
+ static void
+ aiff_check2(const char *file_name, IFF_AIFF *pcm_aiff_data)
+ {
+ 	if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
+ 	   fprintf(stderr, "Sound data is not PCM in \"%s\".\n", file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
+ 		fprintf(stderr, "Sound data is not %d bits in \"%s\".\n",
+ 				(unsigned int) sizeof(short) * BITS_IN_A_BYTE, file_name);
+ 		exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->numChannels != 1 &&
+ 		pcm_aiff_data->numChannels != 2) {
+ 	   fprintf(stderr, "Sound data is not mono or stereo in \"%s\".\n",
+ 			   file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->blkAlgn.blockSize != 0) {
+ 	   fprintf(stderr, "Block size is not %d bytes in \"%s\".\n",
+ 			   0, file_name);
+ 	   exit(1);
+ 	}
+ 
+ 	if (pcm_aiff_data->blkAlgn.offset != 0) {
+ 	   fprintf(stderr, "Block offset is not %d bytes in \"%s\".\n",
+ 			   0, file_name);
+ 	   exit(1);
+ 	}
+ }
+ 
+ /*****************************************************************************
+  *
+  *	Read Audio Interchange File Format (AIFF) headers.
+  *
+  *	By the time we get here the first 32-bits of the file have already been
+  *	read, and we're pretty sure that we're looking at an AIFF file.
+  *
+  *****************************************************************************/
+ 
+ static int
+ parse_aiff_header(FILE *sf)
+ {
+ 	int is_aiff = 0;
+ 	long chunkSize = 0, subSize = 0;
+ 	IFF_AIFF aiff_info;
+ 
+ 	memset(&aiff_info, 0, sizeof(aiff_info));
+ 	chunkSize = Read32BitsHighLow(sf);
+ 	
+ 	if ( Read32BitsHighLow(sf) != IFF_ID_AIFF )
+ 		return 0;
+ 	
+ 	while ( chunkSize > 0 )
+ 	{
+ 		u_int type = 0;
+ 		chunkSize -= 4;
+ 
+ 		type = Read32BitsHighLow(sf);
+ 
+ 		/* fprintf(stderr,
+ 			"found chunk type %08x '%4.4s'\n", type, (char*)&type); */
+ 
+ 		/* don't use a switch here to make it easier to use 'break' for SSND */
+ 		if (type == IFF_ID_COMM) {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			aiff_info.numChannels	  = Read16BitsHighLow(sf);
+ 			subSize -= 2;
+ 			aiff_info.numSampleFrames = Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 			aiff_info.sampleSize	  = Read16BitsHighLow(sf);
+ 			subSize -= 2;
+ 			aiff_info.sampleRate	  = ReadIeeeExtendedHighLow(sf);
+ 			subSize -= 10;
+ 
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 )
+ 				return 0;
+ 
+ 		} else if (type == IFF_ID_SSND) {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			aiff_info.blkAlgn.offset	= Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 			aiff_info.blkAlgn.blockSize = Read32BitsHighLow(sf);
+ 			subSize -= 4;
+ 
+ 			if (fskip(sf, aiff_info.blkAlgn.offset, SEEK_CUR) != 0 )
+ 				return 0;
+ 
+ 			aiff_info.sampleType = IFF_ID_SSND;
+ 			is_aiff = 1;
+ 
+ 			/* We've found the audio data.	Read no further! */
+ 			break;
+ 			
+ 		} else {
+ 			subSize = Read32BitsHighLow(sf);
+ 			chunkSize -= subSize;
+ 
+ 			if (fskip(sf, (long) subSize, SEEK_CUR) != 0 )
+ 				return 0;
+ 		}
+ 	}
+ 
+ 	/* fprintf(stderr, "Parsed AIFF %d\n", is_aiff); */
+ 	if (is_aiff) {
+ 		/* make sure the header is sane */
+ 		aiff_check2("name", &aiff_info);
+ 		num_channels  = aiff_info.numChannels;
+ 		samp_freq     = aiff_info.sampleRate;
+ 		num_samples   = aiff_info.numSampleFrames;
+ 	}
+ 	return is_aiff;
+ }
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * parse_file_header
+ *
+ * PURPOSE: Read the header from a bytestream.  Try to determine whether
+ *		   it's a WAV file or AIFF without rewinding, since rewind
+ *		   doesn't work on pipes and there's a good chance we're reading
+ *		   from stdin (otherwise we'd probably be using libsndfile).
+ *
+ * When this function returns, the file offset will be positioned at the
+ * beginning of the sound data.
+ *
+ ************************************************************************/
+ 
+ void parse_file_header(FILE *sf)
+ {
+ 	u_int type = 0;
+ 	type = Read32BitsHighLow(sf);
+ 
+ 	/* fprintf(stderr,
+ 		"First word of input stream: %08x '%4.4s'\n", type, (char*) &type); */
+ 
+ 	input_format = sf_raw;
+ 
+ 	if (type == WAV_ID_RIFF) {
+ 		/* It's probably a WAV file */
+ 		if (parse_wave_header(sf)) {
+ 			input_format = sf_wave;
+ 		}
+ 
+ 	} else if (type == IFF_ID_FORM) {
+ 		/* It's probably an AIFF file */
+ 		if (parse_aiff_header(sf)) {
+ 			input_format = sf_aiff;
+ 		}
+ 	}
+ 	if (input_format==sf_raw) {
+ 	  /*
+ 	  ** Assume it's raw PCM.	 Since the audio data is assumed to begin
+ 	  ** at byte zero, this will unfortunately require seeking.
+ 	  */
+ 	  if (fseek(sf, 0L, SEEK_SET) != 0) {
+ 	    /* ignore errors */
+ 	    //	fprintf(stderr, "can't seek to beginning of file\n");
+ 	    //exit(1);
+ 	  }
+ 	  input_format = sf_raw;
+ 	}
+ }
+ #endif  /* LIBSNDFILE */
+ 
+ 
diff -r -c -N encoder/get_audio.h lame3.50/get_audio.h
*** encoder/get_audio.h	Wed Dec 31 17:00:00 1969
--- lame3.50/get_audio.h	Wed Oct 20 22:01:38 1999
***************
*** 0 ****
--- 1,94 ----
+ /*
+ ** Copyright (C) 1999 Albert Faber
+ **  
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ ** 
+ ** This program is distributed in the hope that it will be useful,
+ ** but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ** GNU General Public License for more details.
+ ** 
+ ** You should have received a copy of the GNU General Public License
+ ** along with this program; if not, write to the Free Software 
+ ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+ #ifndef GET_AUDIO_H_INCLUDED
+ #define GET_AUDIO_H_INCLUDED
+ 
+ 
+ #ifndef _BLADEDLL
+ 
+ /* AIFF Definitions */
+ 
+ #define IFF_ID_FORM 0x464f524d /* "FORM" */
+ #define IFF_ID_AIFF 0x41494646 /* "AIFF" */
+ #define IFF_ID_COMM 0x434f4d4d /* "COMM" */
+ #define IFF_ID_SSND 0x53534e44 /* "SSND" */
+ #define IFF_ID_MPEG 0x4d504547 /* "MPEG" */
+ 
+ 
+ 
+ 
+ void InitSndFile(void);
+ void CloseSndFile(void);
+ void OpenSndFile(const char* lpszFileName,layer *info,int default_samp, int 
+    default_chan);
+ unsigned long GetSndSamples(void);
+ int		GetSndSampleRate(void);
+ int		GetSndChannels(void);
+ int		GetSndBitrate(void);
+ 
+ 
+ int get_audio(short buffer[2][1152],int stereo,layer* info);
+ 
+ 
+ 
+ #ifdef LIBSNDFILE
+ /* INCLUDE the sound library header file */
+ #ifdef _MSC_VER
+ 	/* one byte alignment for WIN32 platforms */
+ 	#pragma pack(push,1)
+ 	#include "./libsndfile/src/sndfile.h"
+ 	#pragma pack(pop,1)
+ #else
+ 	#include "sndfile.h"
+ #endif
+ 
+ 
+ #else
+ /*****************************************************************
+  * LAME/ISO built in audio file I/O routines 
+  *******************************************************************/
+ #include "portableio.h"
+ #include "ieeefloat.h"
+ 
+ 
+ typedef struct  blockAlign_struct {
+     unsigned long   offset;
+     unsigned long   blockSize;
+ } blockAlign;
+ 
+ typedef struct  IFF_AIFF_struct {
+     short           numChannels;
+     unsigned long   numSampleFrames;
+     short           sampleSize;
+     double          sampleRate;
+     unsigned long   sampleType;
+     blockAlign      blkAlgn;
+ } IFF_AIFF;
+ 
+ extern int            aiff_read_headers(FILE*, IFF_AIFF*);
+ extern int            aiff_seek_to_sound_data(FILE*);
+ extern int            aiff_write_headers(FILE*, IFF_AIFF*);
+ extern int parse_wavheader(void);
+ extern int parse_aiff(const char fn[],layer *info);
+ extern void   aiff_check(const char*, IFF_AIFF*, int*);
+ 
+ 
+ #endif	// ifndef _LIBSNDDLL
+ #endif	// ifndef _BLADEDLL
+ #endif	// ifndef GET_AUDIO_H_INCLUDED
diff -r -c -N encoder/globalflags.h lame3.50/globalflags.h
*** encoder/globalflags.h	Wed Dec 31 17:00:00 1969
--- lame3.50/globalflags.h	Tue Oct 12 15:15:42 1999
***************
*** 0 ****
--- 1,39 ----
+ #ifndef GLOBAL_FLAGS_H_INCLUDED
+ #define GLOBAL_FLAGS_H_INCLUDED
+ 
+ typedef enum sound_file_format_e {
+ 	sf_unknown, sf_wave, sf_aiff, sf_mp3, sf_raw
+ } sound_file_format;
+ 
+ /***********************************************************************
+ *
+ *  Global Variable External Declarations
+ *
+ ***********************************************************************/
+ 
+ extern int allow_diff_short;
+ extern int ATHonly;
+ extern int autoconvert;
+ extern int experimentalX;
+ extern int experimentalY;
+ extern int experimentalZ;
+ extern int force_ms;
+ extern int fast_mode; 
+ extern long int frameNum;
+ extern int gtkflag;
+ extern int g_bWriteVbrTag;
+ extern int gpsycho;
+ extern int highq;
+ extern sound_file_format input_format;
+ extern int lame_nowrite;
+ extern double resample_ratio;     /* if > 0, = input_samp/output_samp */
+ extern int sfb21;
+ extern int silent;
+ extern int swapbytes;
+ extern long totalframes;       /* frames: 0..totalframes-1 */
+ extern int VBR;
+ extern int VBR_q;
+ extern int VBR_min_bitrate;
+ extern int VBR_max_bitrate;
+ extern int voice_mode;
+ #endif
diff -r -c -N encoder/gpkplotting.c lame3.50/gpkplotting.c
*** encoder/gpkplotting.c	Wed Dec 31 17:00:00 1969
--- lame3.50/gpkplotting.c	Sun Oct 24 21:49:24 1999
***************
*** 0 ****
--- 1,282 ----
+ #ifdef HAVEGTK
+ #include "gpkplotting.h"
+ #include "string.h"
+ 
+ static gint num_plotwindows = 0;
+ static gint max_plotwindows = 10;
+ static GdkPixmap *pixmaps[10];
+ static GtkWidget *pixmapboxes[10];
+ 
+ 
+ 
+ 
+ /* compute a gdkcolor */
+ void setcolor(GtkWidget *widget, GdkColor *color, gint red,gint green,gint blue)
+ {
+ 
+   /* colors in GdkColor are taken from 0 to 65535, not 0 to 255.    */
+   color->red = red * (65535/255);
+   color->green = green * (65535/255);
+   color->blue = blue * (65535/255);
+   color->pixel = (gulong)(color->red*65536 + color->green*256 + color->blue);
+   /* find closest in colormap, if needed */
+   gdk_color_alloc(gtk_widget_get_colormap(widget),color);
+ }
+ 
+ 
+ void gpk_redraw(GdkPixmap *pixmap, GtkWidget *pixmapbox)
+ {
+   /* redraw the entire pixmap */
+   gdk_draw_pixmap(pixmapbox->window,
+ 		  pixmapbox->style->fg_gc[GTK_WIDGET_STATE (pixmapbox)],
+ 		  pixmap,0,0,0,0,
+ 		  pixmapbox->allocation.width,
+ 		  pixmapbox->allocation.height);
+ }
+ 
+ 
+ static GdkPixmap **findpixmap(GtkWidget *widget)
+ {
+   int i;
+   for (i=0; i<num_plotwindows  && widget != pixmapboxes[i] ; i++);
+   if (i>=num_plotwindows) {
+     g_print("findpixmap(): bad argument widget \n");
+     return NULL;
+   }
+   return &pixmaps[i];
+ }
+ 
+ void gpk_graph_draw(GtkWidget *widget,               /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint *points;
+   int i;
+   gint16 width,height;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+ #ifndef _WIN32
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+ #else
+       fixed_font = gdk_font_load ("-misc-fixed-large-r-*-*-*-100-*-*-*-*-*-*");
+ #endif
+ 
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     points = g_malloc(n*sizeof(GdkPoint));
+     for (i=0; i<n ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     gdk_draw_lines(*ppixmap,gc,points,n);
+     g_free(points);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_rectangle_draw(GtkWidget *widget,              /* plot on this widged */
+ 			gdouble *xcord, gdouble *ycord, /* corners */
+ 			gdouble xmn,gdouble ymn,        /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color)
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     for (i=0; i<2 ; i++) {
+       points[i].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[i].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+     }
+     width=points[1].x-points[0].x + 1;
+     height=points[1].y-points[0].y + 1;
+     gdk_draw_rectangle(*ppixmap,gc,TRUE,
+ 		       points[0].x,points[0].y,width,height);
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ void gpk_bargraph_draw(GtkWidget *widget,           /* plot on this widged */
+ 		   int n,                           /* number of data points */
+ 		   gdouble *xcord, gdouble *ycord,  /* data */
+ 		   gdouble xmn,gdouble ymn,         /* coordinates of corners */
+ 		   gdouble xmx,gdouble ymx,
+                    int clear,                       /* clear old plot first */
+ 		   char *title,                     /* add a title (only if clear=1) */
+                    int barwidth,                    /* bar width. 0=compute based on window size */    
+                    GdkColor *color)		    
+ {
+   GdkPixmap **ppixmap;
+   GdkPoint points[2];
+   int i;
+   gint16 width,height,x,y,barheight;
+   GdkFont *fixed_font;
+   GdkGC *gc;
+ 
+ 
+   gc = gdk_gc_new(widget->window);
+   gdk_gc_set_foreground(gc, color);
+ 
+ 
+   if ((ppixmap=findpixmap(widget))) {
+     width = widget->allocation.width;
+     height = widget->allocation.height;
+ 
+ 
+     if (clear) {
+       /* white background */
+       gdk_draw_rectangle (*ppixmap,
+ 			  widget->style->white_gc,
+ 			  TRUE,0, 0,width,height);
+       /* title */
+ #ifndef _WIN32
+       fixed_font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");
+ #else
+       fixed_font = gdk_font_load ("-misc-fixed-large-r-*-*-*-100-*-*-*-*-*-*");
+ #endif
+ 
+       gdk_draw_text (*ppixmap,fixed_font,
+ 		     widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		     0,10,title,strlen(title));
+     }
+       
+ 
+     for (i=0; i<n ; i++) {
+       points[1].x =.5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       points[1].y =.5+  ((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       points[0].x = points[1].x;
+       points[0].y = height-1;
+ 
+       x = .5+  ((xcord[i]-xmn)*(width-1)/(xmx-xmn));
+       y = .5+((ycord[i]-ymx)*(height-1)/(ymn-ymx));
+       if (!barwidth) barwidth  = (width/(n+1))-1;
+       barwidth = barwidth > 5 ? 5 : barwidth;
+       barwidth = barwidth < 1 ? 1 : barwidth;
+       barheight = height-1 - y;
+       /* gdk_draw_lines(*ppixmap,gc,points,2); */
+       gdk_draw_rectangle(*ppixmap,gc,TRUE,x,y,barwidth,barheight);
+ 
+     }
+     gpk_redraw(*ppixmap,widget);
+   }
+   gdk_gc_destroy(gc);
+ }
+ 
+ 
+ 
+ 
+ 
+ /* Create a new backing pixmap of the appropriate size */
+ static gint
+ configure_event (GtkWidget *widget, GdkEventConfigure *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     if (*ppixmap) gdk_pixmap_unref(*ppixmap);
+     *ppixmap = gdk_pixmap_new(widget->window,
+ 			    widget->allocation.width,
+ 			    widget->allocation.height,
+ 			    -1);
+     gdk_draw_rectangle (*ppixmap,
+ 			widget->style->white_gc,
+ 			TRUE,
+ 			0, 0,
+ 			widget->allocation.width,
+ 			widget->allocation.height);
+   }
+   return TRUE;
+ }
+ 
+ 
+ 
+ /* Redraw the screen from the backing pixmap */
+ static gint
+ expose_event (GtkWidget *widget, GdkEventExpose *event, gpointer data)
+ {
+   GdkPixmap **ppixmap;
+   if ((ppixmap=findpixmap(widget))){
+     gdk_draw_pixmap(widget->window,
+ 		    widget->style->fg_gc[GTK_WIDGET_STATE (widget)],
+ 		    *ppixmap,
+ 		    event->area.x, event->area.y,
+ 		    event->area.x, event->area.y,
+ 		    event->area.width, event->area.height);
+   }
+ 
+   return FALSE;
+ }
+ 
+ 
+ 
+ 
+ 
+ GtkWidget *gpk_plot_new(int width, int height)
+ {
+   GtkWidget *pixmapbox;
+    
+   pixmapbox = gtk_drawing_area_new();
+   gtk_drawing_area_size(GTK_DRAWING_AREA(pixmapbox),width,height);
+   gtk_signal_connect (GTK_OBJECT (pixmapbox), "expose_event",
+ 		      (GtkSignalFunc) expose_event, NULL);
+   gtk_signal_connect (GTK_OBJECT(pixmapbox),"configure_event",
+ 		      (GtkSignalFunc) configure_event, NULL);
+   gtk_widget_set_events (pixmapbox, GDK_EXPOSURE_MASK);
+ 
+   if (num_plotwindows < max_plotwindows) {
+     pixmapboxes[num_plotwindows] = pixmapbox;
+     pixmaps[num_plotwindows] = NULL;
+     num_plotwindows ++;
+   } else {
+     g_print("gtk_plotarea_new(): exceeded maximum of 10 plotarea windows\n");
+   }
+ 
+   return pixmapbox;
+ }
+ 
+ 
+ #endif
diff -r -c -N encoder/gpkplotting.h lame3.50/gpkplotting.h
*** encoder/gpkplotting.h	Wed Dec 31 17:00:00 1969
--- lame3.50/gpkplotting.h	Fri Sep 10 09:52:00 1999
***************
*** 0 ****
--- 1,27 ----
+ #include <gtk/gtk.h>
+ 
+ /* allocate a graphing widget */
+ GtkWidget *gpk_plot_new(int width,int height);
+ 
+ /* graph a function in the graphing widged */
+ void gpk_graph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title,GdkColor *color);
+ 
+ /* draw a rectangle in the graphing widget */
+ void gpk_rectangle_draw(GtkWidget *widget,                  /* plot on this widged */
+ 			gdouble xcord[2], gdouble ycord[2], /* corners */
+ 			gdouble xmn,gdouble ymn,            /* coordinates of corners */
+ 			gdouble xmx,gdouble ymx,
+ 			GdkColor *color);                         /* color to use */
+ 
+ /* make a bar graph in the graphing widged */
+ void gpk_bargraph_draw(GtkWidget *widget,
+ 		   int n, gdouble *xcord, gdouble *ycord,
+ 		   gdouble xmn, gdouble ymn,gdouble xmx,gdouble ymx,
+ 		   int clear, char * title, int bwidth,GdkColor *color);
+ 
+ /* set forground color  */
+ void setcolor(GtkWidget *widget, GdkColor *color,int red,int green,int blue);
+ 
diff -r -c -N encoder/gtkanal.c lame3.50/gtkanal.c
*** encoder/gtkanal.c	Wed Dec 31 17:00:00 1969
--- lame3.50/gtkanal.c	Wed Oct 20 21:29:46 1999
***************
*** 0 ****
--- 1,1213 ----
+ #ifdef HAVEGTK
+ #include <math.h>
+ #include <gtk/gtk.h>
+ #include "gpkplotting.h"
+ #include "globalflags.h"
+ #include "util.h"
+ #include "encoder.h"
+ #include "psymodel.h"
+ #include "gtkanal.h"
+ #include "version.h"
+ #include "lame.h"
+ 
+ 
+ extern char inPath[MAX_NAME_SIZE];
+ extern int makeframe(void);
+ 
+ /* global variables for the state of the system */
+ static gint idle_keepgoing;        /* processing of frames is ON */
+ static gint idle_count_max;   /* number of frames to process before plotting */
+ static gint idle_count;       /* pause & plot when idle_count=idel_count_max */
+ static gint idle_finish=0;      /* process all frames, finish mp3 file and exit */
+ static gint idle_back = 0;     /* set when we are displaying the old data */
+ static int mp3done = 0;         /* last frame has been read */
+ static GtkWidget *frameprogress; /* progress bar */ 
+ static GtkWidget *framecounter;  /* progress counter */ 
+ 
+ /* main window */
+ GtkWidget *window;
+ /* Backing pixmap for drawing areas */
+ GtkWidget *pcmbox;       /* PCM data plotted here */
+ GtkWidget *winbox;       /* mpg123 synthesis data plotted here */
+ GtkWidget *enerbox[2];   /* spectrum, gr=0,1 plotted here */
+ GtkWidget *mdctbox[2];   /* mdct coefficients gr=0,1 plotted here */
+ GtkWidget *headerbox;    /* mpg123 header info shown here */
+ 
+ plotting_data *pinfo,*pplot;
+ plotting_data Pinfo[NUMPINFO];
+ 
+ struct gtkinfostruct {
+   int filetype;           /* input file type 0=WAV, 1=MP3 */
+   int msflag;             /* toggle between L&R vs M&S PCM data display */
+   int chflag;             /* toggle between L & R channels */
+   int kbflag;             /* toggle between wave # and barks */
+   int flag123;            /* show mpg123 frame info, OR ISO encoder frame info */
+   double avebits;         /* running average bits per frame */
+   int approxbits;         /* (approx) bits per frame */
+   int maxbits;            /* max bits per frame used so far*/
+   int totemph;            /* total of frames with de-emphasis */
+   int totms;              /* total frames with ms_stereo */
+   int totis;              /* total frames with i_stereo */
+   int totshort;           /* total granules with short blocks */
+   int totmix;             /* total granules with mixed blocks */
+   int pupdate;            /* plot while processing, or only when needed */
+ } gtkinfo;
+ 
+ 
+ 
+ /**********************************************************************
+  * read one frame and encode it 
+  **********************************************************************/
+ int gtkmakeframe()
+ {
+   int iread;
+   static int mpglag;
+   static short int Buffer[2][1152];
+   int ch,j,adj;
+   int mp3count,mp3out;
+   short mpg123pcm[2][1152];
+   char mp3buffer[LAME_MAXMP3BUFFER];
+   
+   iread=lame_readframe(Buffer);
+   /* even if iread=0, get_audio hit EOF and returned Buffer=all 0's.  call
+    * makeframe() one last time to flush all buffers */
+   if (input_format == sf_mp3) frameNum++;
+   else {
+     if (frameNum==0) {
+       mpglag=1;
+       lame_decode_init();
+     }
+     mp3count=lame_encode(Buffer,mp3buffer); /* encode frame */
+     mp3out=lame_decode(mp3buffer,mp3count,mpg123pcm); /* re-synthesis to pcm */
+     if (mp3out>0) {
+       /* decoded output is for frame pinfo->frameNum123 */
+       pinfo->frameNum123=pinfo->frameNum-mpglag;
+       adj = 1152-pinfo->framesize;
+       for ( ch = 0; ch < pinfo->stereo; ch++ ) {
+ 	for ( j = 0; j < DECDELAY-adj; j++ )
+ 	  pinfo->pcmdata2[ch][j] = pinfo->pcmdata2[ch][j+1152-adj];
+ 	for ( j = 0; j < 1152-adj; j++ ) {
+ 	  pinfo->pcmdata2[ch][j+DECDELAY-adj] = mpg123pcm[ch][j];
+ 	}
+       }
+     }else{
+       if (mpglag == MAXMPGLAG) {
+ 	fprintf(stderr,"READ_AHEAD set too low - not enough frame buffering.\n");
+ 	fprintf(stderr,"MP3x display of input and output PCM data out of sync.\n");
+       }
+       else mpglag++; 
+       pinfo->frameNum123=-1;  /* no frame output */
+     }
+   }
+   return iread;
+ }
+ 
+ 
+ void plot_frame(void)
+ {
+   int i,j,n,ch,gr;
+   gdouble *xcord,*ycord;
+   gdouble xmx,xmn,ymx,ymn;
+   double *data,*data2,*data3;
+   char title2[80];
+   char *title;
+   plotting_data *pplot1;
+   plotting_data *pplot2;
+ 
+   double en,samp;
+   static int firstcall=1;
+   static GdkColor *barcolor,*color,*grcolor[2];
+   static GdkColor yellow,gray,cyan,magenta,orange,pink,red,green,blue,black,oncolor,offcolor;
+   int blocktype[2][2];
+   int headbits;
+   int mode_gr = 2;
+ 
+   /* find the frame where mpg123 produced output coming from input frame
+    * pinfo.  i.e.:   out_frame + out_frame_lag = input_frame  */
+   for (i=1; i<=MAXMPGLAG; i++ ) {
+     if ((pplot-i)->frameNum123 == pplot->frameNum ) {
+       pplot2 = pplot-i;
+       break;
+     }
+   }
+   if (i > MAXMPGLAG) {
+     fprintf(stderr,"input/output pcm syncing problem.  should not happen!\n");
+     pplot2=pplot-1;
+   }
+ 
+ 
+   /* however, the PCM data is delayed by 528 samples in the encoder filterbanks.
+    * We added another 1152-528 delay to this so the PCM data is *exactly* one 
+    * frame behind the header & MDCT information */
+   pplot1 =pplot2 +1;                   /* back one frame for header info, MDCT */
+ 
+   /* allocate these GC's only once */
+   if (firstcall) {
+     firstcall=0;
+     /*    grcolor[0] = &magenta; */
+     grcolor[0] = &blue;
+     grcolor[1] = &green;
+     barcolor = &gray;
+ 
+     setcolor(headerbox,&oncolor,255,0,0);
+     setcolor(headerbox,&offcolor,175,175,175);
+     setcolor(pcmbox,&red,255,0,0);
+     setcolor(pcmbox,&pink,255,0,255);
+     setcolor(pcmbox,&magenta,255,0,100);
+     setcolor(pcmbox,&orange,255,127,0);
+     setcolor(pcmbox,&cyan,0,255,255);
+     setcolor(pcmbox,&green,0,255,0);
+     setcolor(pcmbox,&blue,0,0,255);
+     setcolor(pcmbox,&black,0,0,0);
+     setcolor(pcmbox,&gray,100,100,100);
+     setcolor(pcmbox,&yellow,255,255,0);
+ 
+   }
+ 
+   /*******************************************************************
+    * frame header info
+    *******************************************************************/
+   if (pplot1->sampfreq)
+     samp=pplot1->sampfreq;
+   else samp=1;
+   
+   headbits = 32 + ((pplot1->stereo==2) ? 256 : 136);
+   gtkinfo.approxbits = (pplot1->bitrate*1000*1152.0/samp) - headbits;
+   /*font = gdk_font_load ("-misc-fixed-medium-r-*-*-*-100-*-*-*-*-*-*");*/
+   sprintf(title2,"%3.1fkHz %ikbs ",samp/1000,pplot1->bitrate);
+   gtk_text_freeze (GTK_TEXT(headerbox));
+   gtk_text_backward_delete(GTK_TEXT(headerbox),
+ 			    gtk_text_get_length(GTK_TEXT(headerbox)));
+   gtk_text_set_point(GTK_TEXT(headerbox),0);
+   gtk_text_insert(GTK_TEXT(headerbox),NULL,&oncolor,NULL,title2, -1);
+   title = " mono ";
+   if (2==pplot1->stereo) title = pplot1->js ? " jstereo " : " stereo ";
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title, -1);
+   color = pplot1->ms_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"ms_stereo ", -1);
+   color = pplot1->i_stereo ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"i_stereo ", -1);
+   color = pplot1->emph ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"emph ", -1);
+   color = pplot1->scfsi ? &oncolor : &offcolor ; 
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, color, NULL,"scfsi ", -1);
+   if (gtkinfo.filetype) 
+     sprintf(title2," mdb=%i %i/NA",pplot1->maindata,pplot1->totbits);
+   else
+     sprintf(title2," mdb=%i   %i/%i",
+ 	  pplot1->maindata,pplot1->totbits,pplot->resvsize);
+   gtk_text_insert (GTK_TEXT(headerbox), NULL, &oncolor, NULL,title2, -1);
+   gtk_text_thaw (GTK_TEXT(headerbox));
+ 
+ 
+   ch = gtkinfo.chflag;
+   /*******************************************************************
+    * block type
+    *******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) 
+     if (gtkinfo.flag123) 
+       blocktype[gr][ch]=pplot1->mpg123blocktype[gr][ch];
+     else blocktype[gr][ch]=pplot->blocktype[gr][ch]; 
+ 
+   
+   /*******************************************************************
+    * draw the PCM data *
+    *******************************************************************/
+   n = 1600;  /* PCM frame + FFT window:   224 + 1152 + 224  */
+   xcord = g_malloc(n*sizeof(gdouble));
+   ycord = g_malloc(n*sizeof(gdouble));
+ 
+ 
+   if (gtkinfo.msflag) 
+     title=ch ? "Side Channel" :  "Mid Channel";
+   else 
+     title=ch ? "Right Channel" : "Left Channel";
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1;
+ 
+   /*  0  ... 224      draw in black, connecting to 224 pixel
+    * 1375 .. 1599     draw in black  connecting to 1375 pixel
+    * 224 ... 1375     MP3 frame.  draw in blue
+    */
+ 
+   /* draw the title */
+   gpk_graph_draw(pcmbox,0,xcord,ycord,xmn,ymn,xmx,ymx,1,title,
+ 		 &black);
+ 
+ 
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < mode_gr ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+   /* bars representing FFT windows */
+   xcord[0] = 0;       ycord[0] = ymn+3000;
+   xcord[1] = 1024-1;  ycord[1] = ymn+1000;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[0]);
+   xcord[0] = 576;          ycord[0] = ymn+2000;
+   xcord[1] = 576+1024-1;   ycord[1] = ymn;
+   gpk_rectangle_draw(pcmbox,xcord,ycord,xmn,ymn,xmx,ymx,grcolor[1]);
+ 
+ 
+   /* plot PCM data */
+   for (i=0; i<n; i++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot->pcmdata[0][i]-pplot->pcmdata[1][i]) : 
+       .5*(pplot->pcmdata[0][i]+pplot->pcmdata[1][i]);
+     else 
+       ycord[i]=pplot->pcmdata[ch][i];
+   }
+ 
+   /* skip plot if we are doing an mp3 file */
+   if (!gtkinfo.filetype) {
+     n = 224;    /* number of points on end of blue part */
+     /* data left of frame */
+     gpk_graph_draw(pcmbox,n+1,xcord,ycord,xmn,ymn,xmx,ymx,0,title,&black);
+     /* data right of frame */
+     gpk_graph_draw(pcmbox,n+1,&xcord[1152+n-1],&ycord[1152+n-1],
+ 		   xmn,ymn,xmx,ymx,0,title,&black);
+     /* the actual frame */
+     gpk_graph_draw(pcmbox,1152,&xcord[n],&ycord[n],xmn,ymn,xmx,ymx,0,title,&black);
+   }
+ 
+ 
+   /*******************************************************************/
+   /* draw the PCM re-synthesis data */
+   /*******************************************************************/
+   n = 1152;
+ 
+   sprintf(title2,"Re-synthesis  ms_ratio=%3.2f  %3.2f",
+ 	  pplot->ms_ratio[0],pplot->ms_ratio[1]);
+   title=title2;
+ 
+ 
+   ymn = -32767 ; 
+   ymx =  32767;
+   xmn = 0;
+   xmx = 1600-1; 
+   gpk_graph_draw(winbox,0,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,1,title,&black);
+   /* draw some hash marks dividing the frames */
+   ycord[0] = ymx*.8;  ycord[1] = ymn*.8;
+   for (gr=0 ; gr<=2; gr++) {
+     xcord[0] = 223.5 + gr*576;   xcord[1] = 223.5 +gr*576;  
+     gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+   }
+   for (gr = 0 ; gr < 2 ; gr++) {
+     if (blocktype[gr][ch]==2) 
+       for (i=1 ; i<=2; i++) {
+ 	xcord[0] = 223.5+gr*576 + i*192; 
+ 	xcord[1] = 223.5+gr*576 + i*192; 
+ 	gpk_rectangle_draw(winbox,xcord,ycord,xmn,ymn,xmx,ymx,&yellow);
+       }
+   }
+ 
+ 
+ 
+   n = 224;
+   for (j=1152-n,i=0; i<=n; i++,j++) {
+     xcord[i] = i;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot1->pcmdata2[0][j]-
+                           pplot1->pcmdata2[1][j]) : 
+       .5*(pplot1->pcmdata2[0][j]+pplot1->pcmdata2[1][j]);
+     else 
+       ycord[i]=pplot1->pcmdata2[ch][j];
+   }
+   gpk_graph_draw(winbox,n+1,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+   n = 1152;
+   for (i=0; i<n; i++) {
+     xcord[i] = i+224;
+     if (gtkinfo.msflag) 
+       ycord[i] = ch ? .5*(pplot2->pcmdata2[0][i]-pplot2->pcmdata2[1][i]) : 
+       .5*(pplot2->pcmdata2[0][i]+pplot2->pcmdata2[1][i]);
+     else 
+       ycord[i]=pplot2->pcmdata2[ch][i];
+   }
+   gpk_graph_draw(winbox,n,xcord,ycord,
+ 		 xmn,ymn,xmx,ymx,0,title,&black);
+ 
+ 
+ 
+ 
+ 
+   /*******************************************************************/
+   /* draw the MDCT energy spectrum */
+   /*******************************************************************/
+   for (gr = 0 ; gr < mode_gr ; gr ++) {
+     int bits;
+     char *blockname="";
+     char label[80],label2[80];
+     switch (blocktype[gr][ch]) {
+     case 0: blockname = "normal"; 	break;
+     case 1:  	blockname = "start";	break;
+     case 2: 	blockname = "short"; 	break;
+     case 3: 	blockname = "end"; 	break;
+     }
+     strcpy(label,blockname);
+     if (pplot1->mixed[gr][ch]) strcat(label,"(mixed)");
+     if (blocktype[gr][ch]==2) {
+       sprintf(label2,
+ 	      "%i %i%i%i",
+ 	      pplot1->scalefac_scale[gr][ch],
+               pplot1->sub_gain[gr][ch][0],
+ 	      pplot1->sub_gain[gr][ch][1],
+ 	      pplot1->sub_gain[gr][ch][2]);
+       strcat(label,label2);
+     }else{
+       sprintf(label2,"%i",pplot1->scalefac_scale[gr][ch]);
+       strcat(label,label2);
+     }
+ 
+     
+     
+     
+     n = 576;
+     if (gtkinfo.flag123) {
+       data = pplot1->mpg123xr[gr][0];
+       data2 = pplot1->mpg123xr[gr][1];
+     }else{
+       data = pplot->xr[gr][0];
+       data2 = pplot->xr[gr][1];
+     }
+     
+ 
+ 
+     ymn=9e20;
+     ymx=-9e20;
+     for (i=0; i<n; i++) {
+       double coeff;
+       xcord[i] = i+1;
+       if (gtkinfo.msflag){
+ 	coeff = ch ?  .5*(data[i]-data2[i]) : .5*(data[i]+data2[i]) ;
+       }else{
+ 	coeff = ch ? data2[i] : data[i];
+       }
+       ycord[i]=coeff*coeff*1e10;
+       ycord[i] = log10( MAX( ycord[i],(double) 1)); 
+       ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+       ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+     }
+     /*  print the min/max
+ 	sprintf(title2,"MDCT%1i %5.2f %5.2f  bits=%i",gr,ymn,ymx,
+ 	pplot1->mainbits[gr][ch]);
+     */
+     if (gtkinfo.flag123) bits=pplot1->mainbits[gr][ch];
+     else bits=pplot->LAMEmainbits[gr][ch];
+     
+     
+     sprintf(title2,"MDCT%1i(%s) bits=%i q=%i ",gr,label,bits,
+ 	      pplot1->qss[gr][ch]-210);
+     
+     xmn = 1;
+     xmx = n;
+     ymn=0;
+     ymx=11;
+     gpk_bargraph_draw(mdctbox[gr],n,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+   }
+   
+ 
+ 
+   
+   /*******************************************************************
+    * draw the psy model energy spectrum (k space) 
+    * l3psy.c computes pe, en, thm for THIS granule.  
+    * To encode, ISO uses (bug): en,thm from last granule.  
+    *                            pe from this granule
+    * gpsycho model corrects this
+    *******************************************************************/
+   if (gtkinfo.msflag || gtkinfo.filetype) {
+     /* erase everything */
+     gpk_bargraph_draw(enerbox[0],0,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1," ",0,barcolor);
+     gpk_bargraph_draw(enerbox[1],0,xcord,ycord,
+ 		      xmn,ymn,xmx,ymx,1," ",0,barcolor);
+   }
+   else if (gtkinfo.kbflag){
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+       n = HBLKSIZE; /* only show half the spectrum */
+ 
+       data = &pplot->energy[gr][ch][0];
+       
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       for (en=0 , j=0; j<BLKSIZE ; j++) 
+ 	en += pplot->energy[gr][ch][j];
+ 
+       sprintf(title2,"FFT%1i  pe=%4.1fK  en=%5.2e ",gr,
+ 	      pplot->pe[gr][ch]/1000,en);
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n;
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+       
+     }
+   }else{
+     /*******************************************************************
+      * draw the psy model energy spectrum (scalefactor bands)
+      * ISO model (because of bugs) uses:  
+      *        pe,en,thm,energy delayed 1 granule
+      *******************************************************************/
+     for (gr = 0 ; gr < mode_gr ; gr ++) {
+ 
+       if (blocktype[gr][ch]==2) {
+ 	n = 3*SBMAX_s; 
+ 	data = &pplot->en_s[gr][ch][0];
+ 	data2 = &pplot->thr_s[gr][ch][0];
+ 	data3 = &pplot->xfsf_s[gr][ch][0];
+       } else {
+ 	n = SBMAX_l; 
+ 	data = &pplot->en[gr][ch][0];
+ 	data2 = &pplot->thr[gr][ch][0];
+ 	data3 = &pplot->xfsf[gr][ch][0];
+       }
+       ymn=9e20;
+       ymx=-9e20;
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data[i],(double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+ 
+ 
+ 
+       /* en = max energy difference amoung the 3 short FFTs for this granule */
+       en = pplot->ers[gr][ch];
+       sprintf(title2,"FFT%1i pe=%4.1fK/%3.1f n=%i/%3.1f/%3.1f/%3.1f",gr,
+ 	      pplot->pe[gr][ch]/1000,en,pplot->over[gr][ch],
+ 	      pplot->max_noise[gr][ch],
+ 	      pplot->over_noise[gr][ch],
+ 	      pplot->tot_noise[gr][ch]);
+ 
+ 
+       ymn = 3;
+       ymx = 15;
+       xmn = 1;
+       xmx = n+1; /* a little extra because of the bar thickness */
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,1,title2,0,barcolor);
+ 
+ 
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1;
+ 	ycord[i] = log10( MAX( data3[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,&red);  
+ 
+       
+       for (i=0; i<n; i++) {
+ 	xcord[i] = i+1 + (.25*n)/SBMAX_l;
+ 	ycord[i] = log10( MAX( data2[i], (double) 1));
+ 	ymx=(ycord[i] > ymx) ? ycord[i] : ymx;
+ 	ymn=(ycord[i] < ymn) ? ycord[i] : ymn;
+       }
+       gpk_bargraph_draw(enerbox[gr],n,xcord,ycord,
+ 			xmn,ymn,xmx,ymx,0,title2,3,grcolor[gr]);
+     }
+   }
+ }
+ 
+ 
+ 
+ static void update_progress(void)
+ {    
+   char label[80];
+   sprintf(label,"Frame:%4i/%4i  %6.2fs",
+ 	 pplot->frameNum,(int)totalframes-1, pplot->frametime);
+   gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) pplot->frameNum);
+   gtk_label_set_text(GTK_LABEL(framecounter),label);
+ }
+ 
+ 
+ 
+ static void analyze(void)
+ {
+     if ( idle_keepgoing) {
+       idle_count = 0;
+       idle_count_max=0;
+       idle_keepgoing=0;
+       idle_finish=0;
+     }
+     plot_frame();   
+     update_progress(); 
+ }
+ 
+ static void plotclick( GtkWidget *widget, gpointer   data )
+ {   analyze(); }
+ 
+ 
+ 
+ 
+ static int frameadv1( GtkWidget *widget, gpointer   data )
+ {
+   int i;
+   if (idle_keepgoing ){
+     if (idle_back) {
+       /* frame displayed is the old frame.  to advance, just swap in new frame */
+       idle_back--;
+       pplot = &Pinfo[READ_AHEAD+idle_back];
+     }else{
+       /* advance the frame by reading in a new frame */
+       pplot = &Pinfo[READ_AHEAD];
+       if (mp3done) { 
+ 	/* dont try to read any more frames, and quit if "finish MP3" was selected */
+ 	if (idle_finish) gtk_main_quit();
+ 	idle_count_max=0; 
+       } else {
+ 	/* read in the next frame */
+ 	for (i=NUMPINFO-1 ; i>0 ; i--)
+ 	  memcpy(&Pinfo[i],&Pinfo[i-1],sizeof(plotting_data));
+ 	pinfo = &Pinfo[0];
+ 	pinfo->num_samples = gtkmakeframe();
+ 
+ 	if (pinfo->sampfreq) 
+ 	  pinfo->frametime = (pinfo->frameNum)*1152.0/pinfo->sampfreq;
+ 	else pinfo->frametime=0;
+ 
+         /* eof? */
+ 	if (!pinfo->num_samples) {
+ 	  if (idle_finish) gtk_main_quit();
+ 	}
+ 
+ 	pinfo->totbits = 0;
+ 	{ int gr,ch;
+ 	for (gr = 0 ; gr < 2 ; gr ++) 
+ 	  for (ch = 0 ; ch < 2 ; ch ++) {
+ 	    gtkinfo.totshort += (pinfo->mpg123blocktype[gr][ch]==2);
+ 	    gtkinfo.totmix  += !(pinfo->mixed[gr][ch]==0);
+ 	    pinfo->totbits += pinfo->mainbits[gr][ch];
+ 	  }
+ 	}
+ 	if (pinfo->frameNum > 0) /* start averaging at second frame */
+ 	  gtkinfo.avebits = (gtkinfo.avebits*((pinfo->frameNum)-1)
+ 	  + pinfo->totbits ) /(pinfo->frameNum);
+ 
+ 	gtkinfo.maxbits=MAX(gtkinfo.maxbits,pinfo->totbits);
+ 	gtkinfo.totemph += !(pinfo->emph==0);
+ 	gtkinfo.totms   += !(pinfo->ms_stereo==0);
+ 	gtkinfo.totis   += !(pinfo->i_stereo==0);
+ 
+ 	if (pplot->frameNum >= totalframes-1) mp3done=1;
+       }
+     }
+ 
+     idle_count++;
+     if (gtkinfo.pupdate) plot_frame();
+     update_progress();
+     if ((idle_count>=idle_count_max) && (! idle_finish)) analyze();
+   }
+   return 1;
+ }
+ 
+ 
+ static void frameadv( GtkWidget *widget, gpointer   data )
+ {
+     int adv;
+ 
+     if (!strcmp((char *) data,"-1")) {
+       /* ignore if we've already gone back as far as possible */
+       if (pplot->frameNum==0 || (idle_back==NUMBACK)) return;  
+       idle_back++;
+       pplot = &Pinfo[READ_AHEAD+idle_back];
+       analyze();
+       return;
+     }
+ 
+ 
+     adv = 1;
+     if (!strcmp((char *) data,"1")) adv = 1;
+     if (!strcmp((char *) data,"10")) adv = 10;
+     if (!strcmp((char *) data,"100")) adv = 100;
+     if (!strcmp((char *) data,"finish")) idle_finish = 1;
+ 
+ 
+     if (idle_keepgoing) {
+       /* already running - que up additional frame advance requests */
+       idle_count_max += adv; 
+     }
+     else {
+       /* turn on idleing */
+       idle_count_max = adv;
+       idle_count = 0;
+       idle_keepgoing = 1;
+     }
+ }
+ 
+ 
+ 
+ 
+ /* another callback */
+ static void delete_event( GtkWidget *widget,
+                    GdkEvent  *event,
+ 		   gpointer   data )
+ {
+     gtk_main_quit ();
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ static void channel_option (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   option = (int) data;
+   switch (option) {
+   case 1:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0; 
+     break;
+   case 2:
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=1; 
+     break;
+   case 3:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=0; 
+     break;
+   case 4:
+     gtkinfo.msflag=1;
+     gtkinfo.chflag=1; 
+   }
+   analyze();
+ }
+ static void spec_option (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   option = (int) data;
+   switch (option) {
+   case 1:
+     gtkinfo.kbflag=0;
+     break;
+   case 2:
+     gtkinfo.kbflag=1;
+     break;
+   case 3:
+     gtkinfo.flag123=0;
+     break;
+   case 4:
+     gtkinfo.flag123=1;
+     break;
+   case 5:
+     gtkinfo.pupdate=1;
+     break;
+   case 6:
+     gtkinfo.pupdate=0;
+     break;
+   }
+   analyze();
+ }
+ 
+ 
+ 
+ static void text_window (GtkWidget *widget, gpointer data)
+ {
+   int option;
+   GtkWidget *hbox,*vbox,*button,*box;
+   GtkWidget *textwindow,*vscrollbar;
+   char text[80];
+ 
+   option = (int) data;
+   
+   textwindow = gtk_window_new(GTK_WINDOW_DIALOG);
+   gtk_signal_connect_object (GTK_OBJECT (window), "delete_event",
+ 		      GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 		      GTK_OBJECT (textwindow));
+ 
+   gtk_container_set_border_width (GTK_CONTAINER (textwindow), 0);
+   vbox = gtk_vbox_new(FALSE,0);
+   hbox = gtk_hbox_new(FALSE,0);
+ 
+   button = gtk_button_new_with_label ("close");
+   gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
+ 			     GTK_SIGNAL_FUNC(gtk_widget_destroy),
+ 			     GTK_OBJECT (textwindow));
+ 
+   box = gtk_text_new (NULL, NULL);
+   gtk_text_set_editable (GTK_TEXT (box), FALSE);
+   vscrollbar = gtk_vscrollbar_new (GTK_TEXT(box)->vadj);
+ 
+ 
+   switch (option) {
+   case 0: 
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Documentation");
+     gtk_widget_set_usize(box,450,500); 
+     gtk_text_set_word_wrap(GTK_TEXT(box),TRUE);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"Frame header information: "\
+ 		"First the bitrate, sampling frequency and mono, stereo or jstereo "\
+ 		"indicators are displayed .  If the bitstream is jstereo, then mid/side "\
+ 		"stereo or intensity stereo may be on (indicated in red).  If "\
+ 		"de-emphasis is used, this is also indicated in red.  The mdb value is "\
+ 		"main_data_begin.  The encoded data starts this many bytes *before* the "\
+ 		"frame header.  A large value of mdb means the bitstream has saved some "\
+ 		"bits into the reservoir, which it may allocate for some future frame. "\
+ 		"The two numbers after mdb are the size (in bits) used to encode the "\
+ 		"MDCT coefficients for this frame, followed byt the size of the bit "\
+ 		"resevoir before encoding this frame.  The maximum frame size and a "\
+ 		"running average are given in the Stats pull down menu.  A large "\
+ 		"maximum frame size indicates the bitstream has made use of the bit "\
+ 		"reservoir. \n\n",-1);
+ 
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM data (top graph): "\
+ 		"The PCM data is plotted in black.  The layer3 frame is divided into 2 "\
+ 		"granules of 576 samples (marked with yellow vertical lines).  In the "\
+ 		"case of normal, start and stop blocks, the MDCT coefficients for each "\
+ 		"granule are computed using a 1152 sample window centered over the "\
+ 		"granule.  In the case of short blocks, the granule is further divided "\
+ 		"into 3 blocks of 192 samples (also marked with yellow vertical lines)."\
+ 		"The MDCT coefficients for these blocks are computed using 384 sample "\
+ 		"windows centered over the 192 sample window.  (This info not available "\
+ 		"when analyzing .mp3 files.)  For the psycho-acoustic model, a windowed "\
+ 		"FFT is computed for each granule.  The range of these windows "\
+ 		"is denoted by the blue and green bars.\n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"PCM re-synthesis data (second graph): "\
+ 		"Same as the PCM window described above.  The data displayed is the "\
+ 		"result of encoding and then decoding the original sample. \n\n",-1);
+ 
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"MDCT windows: "\
+ 		"Shows the energy in the MDCT spectrum for granule 0 (left window) "\
+ 		"and granule 1 (right window).  The text also shows the blocktype "\
+ 		"used, the number of bits used to encode the coefficients and the "\
+ 		"number of extra bits allocated from the reservoir.  The MDCT pull down "\
+ 		"window will toggle between the original unquantized MDCT coefficients "\
+ 		"and the compressed (quantized) coefficients.\n\n",-1); 
+  
+ 		gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		"FFT window: "\
+ 		"The gray bars show the energy in the FFT spectrum used by the "\
+ 		"psycho-acoustic model.  Granule 0 is in the left window, granule 1 in "\
+ 		"the right window.  The green and blue bars show how much distortion is "\
+ 		"allowable, as computed by the psycho-acoustic model. The red bars show "\
+ 		"the actual distortion after encoding.  There is one FFT for each "\
+ 		"granule, computed with a 1024 Hann window centered over the "\
+ 		"appropriate granule.  (the range of this 1024 sample window is shown "\
+ 		"by the blue and green bars in the PCM data window).  The Spectrum pull "\
+ 		"down window will toggle between showing the energy in equally spaced "\
+ 		"frequency domain and the scale factor bands used by layer3.  Finally, "\
+ 		"the perceptual entropy, total energy and number of scalefactor bands "\
+ 		"with audible distortion is shown.  (This info not available when "\
+ 		"analyzing .mp3 files.)",-1);
+ 
+     break;
+   case 1:
+ 	/* Set the about box information */
+     gtk_window_set_title (GTK_WINDOW (textwindow), "About");
+     gtk_widget_set_usize(box,350,260);
+ 
+     sprintf(text,"LAME version %s \nwww.sulaco.org/mp3\n\n",get_lame_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+ 
+     sprintf(text,"psycho-acoustic model:  GPSYCHO version %s\n",get_psy_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     sprintf(text,"frame analyzer: MP3x version %s\n\n",get_mp3x_version());
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+ 		    "decoder:  mpg123/mpglib  .59q  \nMichael Hipp (www.mpg123.de)\n\n",-1);
+     
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,
+     "Encoder, decoder & psy-models based on ISO\ndemonstration source. ",-1);
+     break;
+ 
+   case 2:
+     gtk_window_set_title (GTK_WINDOW (textwindow), "Statistics");
+     gtk_widget_set_usize(box,350,260);
+     sprintf(text,"frames processed so far: %i \n",Pinfo[0].frameNum+1);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"granules processed so far: %i \n\n",4*(Pinfo[0].frameNum+1));
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (approximate): %i\n",
+ 	    gtkinfo.approxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mean bits/frame (from LAME): %i\n",
+ 	    4*Pinfo[0].mean_bits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"bitsize of largest frame: %i \n",gtkinfo.maxbits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"average bits/frame: %3.1f \n\n",gtkinfo.avebits);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"ms_stereo frames: %i \n",gtkinfo.totms);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"i_stereo frames: %i \n",gtkinfo.totis);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"de-emphasis frames: %i \n",gtkinfo.totemph);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"short block granules: %i \n",gtkinfo.totshort);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     sprintf(text,"mixed block granules: %i \n",gtkinfo.totmix);
+     gtk_text_insert(GTK_TEXT(box),NULL,NULL,NULL,text,-1);
+     break;
+   }
+ 
+ 
+ 
+   gtk_widget_show (vscrollbar);
+   gtk_widget_show (box);
+   gtk_widget_show (vbox);
+   gtk_widget_show (hbox);
+   gtk_widget_show (button);
+ 
+   gtk_box_pack_start (GTK_BOX(hbox), box, FALSE, TRUE, 0);
+   gtk_box_pack_start(GTK_BOX(hbox), vscrollbar, FALSE, FALSE, 0);
+   gtk_box_pack_start (GTK_BOX (vbox), hbox, FALSE, TRUE, 0);
+   gtk_box_pack_end (GTK_BOX (vbox), button, FALSE, TRUE, 0);
+   gtk_container_add (GTK_CONTAINER (textwindow), vbox); 
+   gtk_widget_show(textwindow);
+ 
+ }
+ 
+ 
+ 
+ 
+ /* #include <strings.h>*/
+ 
+ 
+ /* This is the GtkItemFactoryEntry structure used to generate new menus.
+    Item 1: The menu path. The letter after the underscore indicates an
+            accelerator key once the menu is open.
+    Item 2: The accelerator key for the entry
+    Item 3: The callback function.
+    Item 4: The callback action.  This changes the parameters with
+            which the function is called.  The default is 0.
+    Item 5: The item type, used to define what kind of an item it is.
+            Here are the possible values:
+ 
+            NULL               -> "<Item>"
+            ""                 -> "<Item>"
+            "<Title>"          -> create a title item
+            "<Item>"           -> create a simple item
+            "<CheckItem>"      -> create a check item
+            "<ToggleItem>"     -> create a toggle item
+            "<RadioItem>"      -> create a radio item
+            <path>             -> path of a radio item to link against
+            "<Separator>"      -> create a separator
+            "<Branch>"         -> create an item to hold sub items
+            "<LastBranch>"     -> create a right justified branch 
+ */
+ 
+ static GtkItemFactoryEntry menu_items[] = {
+   {"/_File",         NULL,         NULL, 0, "<Branch>"},
+   /*
+   {"/File/_New",     "<control>N", print_hello, 0, NULL},
+   {"/File/_Open",    "<control>O", print_hello, 0, NULL},
+   {"/File/_Save",    "<control>S", print_hello, 0, NULL},
+   {"/File/Save _As", NULL,         NULL, 0, NULL},
+   {"/File/sep1",     NULL,         NULL, 0, "<Separator>"},
+   {"/File/Quit",     "<control>Q", gtk_main_quit, 0, NULL}, 
+   */
+   {"/File/_Quit",     "<control>Q", delete_event, 0, NULL}, 
+ 
+   {"/_Plotting",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Plotting/_While advancing" ,  NULL,  spec_option, 5, NULL},
+   {"/Plotting/_After advancing",  NULL,  spec_option, 6, NULL},
+ 
+   {"/_Channel",            NULL,         NULL,   0,    "<Branch>"},
+   {"/Channel/show _Left" ,  NULL,  channel_option, 1, NULL},
+   {"/Channel/show _Right",  NULL,  channel_option, 2, NULL},
+   {"/Channel/show _Mid" ,   NULL,  channel_option, 3, NULL},
+   {"/Channel/show _Side",   NULL,  channel_option, 4, NULL},
+ 
+   {"/_Spectrum",                   NULL,  NULL, 0, "<Branch>"},
+   {"/Spectrum/_Scalefactor bands",  NULL,  spec_option, 1, NULL},
+   {"/Spectrum/_Wave number",        NULL,  spec_option, 2, NULL},
+ 
+   {"/_MDCT",                         NULL,  NULL, 0, "<Branch>"},
+   {"/MDCT/_Original",               NULL,  spec_option, 3, NULL},
+   {"/MDCT/_Compressed",             NULL,  spec_option, 4, NULL},
+ 
+   {"/_Stats",                         NULL,  NULL, 0, "<Branch>"},
+   {"/Stats/_Show",               NULL,  text_window, 2, NULL},
+ 
+   {"/_Help",         NULL,         NULL, 0, "<LastBranch>"},
+   {"/_Help/_Documentation",   NULL,   text_window, 0, NULL},
+   {"/_Help/_About",           NULL,   text_window, 1, NULL},
+ };
+ 
+ 
+ static void get_main_menu(GtkWidget *window, GtkWidget ** menubar) {
+   int nmenu_items = sizeof(menu_items) / sizeof(menu_items[0]);
+   GtkItemFactory *item_factory;
+   GtkAccelGroup *accel_group;
+ 
+   accel_group = gtk_accel_group_new();
+ 
+   /* This function initializes the item factory.
+      Param 1: The type of menu - can be GTK_TYPE_MENU_BAR, GTK_TYPE_MENU,
+               or GTK_TYPE_OPTION_MENU.
+      Param 2: The path of the menu.
+      Param 3: A pointer to a gtk_accel_group.  The item factory sets up
+               the accelerator table while generating menus.
+   */
+ 
+   item_factory = gtk_item_factory_new(GTK_TYPE_MENU_BAR, "<main>", 
+ 				       accel_group);
+ 
+   /* This function generates the menu items. Pass the item factory,
+      the number of items in the array, the array itself, and any
+      callback data for the the menu items. */
+   gtk_item_factory_create_items(item_factory, nmenu_items, menu_items, NULL);
+ 
+   /* Attach the new accelerator group to the window. */
+   gtk_accel_group_attach (accel_group, GTK_OBJECT (window));
+ 
+   if (menubar)
+     /* Finally, return the actual menu bar created by the item factory. */ 
+     *menubar = gtk_item_factory_get_widget(item_factory, "<main>");
+ }
+ 
+ 
+ 
+ 
+ int gtkcontrol(void)
+ {
+     /* GtkWidget is the storage type for widgets */
+     GtkWidget *button;
+     GtkAdjustment *adj;
+     GtkWidget *mbox;        /* main box */
+     GtkWidget *box1;        /* frame control buttons go */
+     GtkWidget *box2;        /* frame counters */
+     GtkWidget *box3;        /* frame header info */
+     GtkWidget *table;       /* table for all the plotting areas */
+     GtkWidget *menubar;
+ 
+     gint tableops,graphx,graphy;
+     char frameinfo[80];
+ 
+     graphx = 500;  /* minimum allowed size of pixmap */
+     graphy = 100;
+ 
+ 
+     /* set some global defaults/variables */
+     gtkinfo.filetype = (input_format == sf_mp3);
+     gtkinfo.msflag=0;
+     gtkinfo.chflag=0;
+     gtkinfo.kbflag=0;
+     gtkinfo.flag123 = (input_format == sf_mp3); /* MP3 file=use mpg123 output */
+     gtkinfo.pupdate=0;
+     gtkinfo.avebits = 0;
+     gtkinfo.maxbits = 0;
+     gtkinfo.approxbits = 0;
+     gtkinfo.totemph = 0;
+     gtkinfo.totms = 0;
+     gtkinfo.totis = 0;
+     gtkinfo.totshort = 0;
+     gtkinfo.totmix = 0;
+ 
+     totalframes=Max(totalframes,READ_AHEAD+1);
+ 
+     memset((char *) Pinfo, 0, sizeof(Pinfo));
+     pplot = &Pinfo[READ_AHEAD];
+ 
+     strcpy(frameinfo,"MP3x: ");
+     strncat(frameinfo,inPath,70);
+ 
+     window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
+     gtk_window_set_title (GTK_WINDOW (window), frameinfo);
+     gtk_signal_connect (GTK_OBJECT (window), "delete_event",
+ 			GTK_SIGNAL_FUNC (delete_event), NULL);
+     gtk_container_set_border_width (GTK_CONTAINER (window), 0);
+ 
+ 
+     mbox = gtk_vbox_new(FALSE, 0);
+ 
+ 
+     /* layout of mbox */
+     box1 = gtk_hbox_new(FALSE, 0);
+     box2 = gtk_hbox_new(FALSE, 0);
+     box3 = gtk_hbox_new(FALSE, 0);
+     table = gtk_table_new (4, 2, FALSE);
+     tableops = GTK_FILL | GTK_EXPAND | GTK_SHRINK;
+     get_main_menu(window, &menubar);
+ 
+     gtk_box_pack_start(GTK_BOX(mbox), menubar, FALSE, TRUE, 0);
+     gtk_box_pack_end (GTK_BOX (mbox), box1, FALSE, TRUE, 0);
+     gtk_box_pack_end(GTK_BOX (mbox),box2, FALSE, TRUE, 0);
+     gtk_box_pack_start(GTK_BOX (mbox),box3, FALSE, TRUE, 0);
+     gtk_box_pack_start (GTK_BOX (mbox), table, TRUE, TRUE, 0);
+     gtk_container_add (GTK_CONTAINER (window), mbox); 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box3  frame header info */
+     /*********************************************************************/
+     /*
+     headerbox = gtk_label_new(" ");
+     gtk_label_set_justify(GTK_LABEL(headerbox),GTK_JUSTIFY_LEFT); 
+     */
+     headerbox = gtk_text_new (NULL, NULL);
+     gtk_text_set_editable (GTK_TEXT (headerbox), FALSE);
+     gtk_widget_set_usize(headerbox,200,20);
+     gtk_widget_show (headerbox);
+     gtk_box_pack_start(GTK_BOX (box3),headerbox, TRUE, TRUE, 0);
+     
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box2   frame counters  */
+     /*********************************************************************/
+     framecounter = gtk_label_new("");
+     gtk_widget_show(framecounter);
+     gtk_box_pack_start(GTK_BOX (box2),framecounter, FALSE, TRUE, 0);
+ 
+     adj = (GtkAdjustment *) gtk_adjustment_new (0, 0,(gint) totalframes-1, 0, 0, 0);
+     frameprogress = gtk_progress_bar_new_with_adjustment (adj);
+     /* Set the format of the string that can be displayed in the
+      * trough of the progress bar:
+      * %p - percentage
+      * %v - value
+      * %l - lower range value
+      * %u - upper range value */
+     gtk_progress_set_format_string (GTK_PROGRESS (frameprogress),
+ 	                            "%p%%");
+     gtk_progress_set_value (GTK_PROGRESS (frameprogress), (gdouble) 0);
+     gtk_progress_set_show_text (GTK_PROGRESS (frameprogress),TRUE);
+     gtk_widget_show (frameprogress);
+     gtk_box_pack_end (GTK_BOX (box2), frameprogress, FALSE, TRUE, 0);
+ 
+ 
+ 
+     /*********************************************************************/
+     /* stuff in box1  buttons along bottom */
+     /*********************************************************************/
+     button = gtk_button_new_with_label ("-1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "-1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+1");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "1");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+10");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "10");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("+100");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "100");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("finish mp3");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (frameadv), (gpointer) "finish");
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+     button = gtk_button_new_with_label ("stop/plot");
+     gtk_signal_connect (GTK_OBJECT (button), "clicked",
+ 			GTK_SIGNAL_FUNC (plotclick), NULL);
+     gtk_box_pack_start(GTK_BOX(box1), button, TRUE, TRUE, 0);
+     gtk_widget_show(button);
+ 
+ 
+     /*********************************************************************/
+     /* stuff in table.  all the plotting windows */
+     /*********************************************************************/
+     pcmbox = gpk_plot_new(graphx,graphy);
+     gtk_table_attach (GTK_TABLE(table),pcmbox,0,2,0,1,tableops,tableops,2,2 );
+     gtk_widget_show (pcmbox);
+ 
+     winbox = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),winbox,0,2,1,2,tableops,tableops,2,2);
+     gtk_widget_show (winbox);
+ 
+ 
+     mdctbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),mdctbox[0],0,1,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[0]);
+ 
+     mdctbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),mdctbox[1],1,2,2,3,tableops,tableops,2,2);
+     gtk_widget_show (mdctbox[1]);
+ 
+     enerbox[0] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach(GTK_TABLE(table),enerbox[0],0,1,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[0]);
+ 
+     enerbox[1] = gpk_plot_new(graphy,graphy);
+     gtk_table_attach (GTK_TABLE(table),enerbox[1],1,2,3,4,tableops,tableops,2,2);
+     gtk_widget_show (enerbox[1]);
+ 
+ 
+ 
+ 
+     gtk_idle_add((GtkFunction) frameadv1, NULL);
+     gtk_widget_show(menubar); 
+     gtk_widget_show(box2); 
+     gtk_widget_show(box3); 
+     gtk_widget_show(table);
+     gtk_widget_show(box1);
+     gtk_widget_show (mbox);
+     gtk_widget_show (window);     /* show smallest allowed window */
+ 
+     /* make window bigger.   */ 
+     /* now the user will be able to shrink it, if desired */
+     /* gtk_widget_set_usize(mbox,500,500);  */
+     /* gtk_widget_show (window); */     /* show smallest allowed window */
+ 
+ 
+     
+     idle_keepgoing=1;             /* processing of frames is ON */
+     idle_count_max=READ_AHEAD+1;  /* number of frames to process before plotting */
+     idle_count=0;                 /* pause & plot when idle_count=idle_count_max */
+ 
+ 
+     gtk_main ();
+     if (!mp3done) exit(2);
+     return(0);
+ }
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/gtkanal.h lame3.50/gtkanal.h
*** encoder/gtkanal.h	Wed Dec 31 17:00:00 1969
--- lame3.50/gtkanal.h	Thu Oct 14 22:38:16 1999
***************
*** 0 ****
--- 1,90 ----
+ /* 
+ layerIII enc->dec delay:  1056    (observed)
+ layerII  enc->dec dealy:   480    (observed)
+ 
+ 
+ polyphase 256-16             (dec or enc)
+ mdct      256+32  (9*32)     (dec or enc) 
+ total:    512+16
+ 
+ 
+ SYNC_FLUSH calculation:
+ layerIII enc delay:                     528
+ extra bits to display full fft window:  224
+ total:                                  752
+ 
+ layerII sync_flush:  should be 464
+ layerIII sync_flush: should be 752
+ 
+ 
+ Also we would like to remove mpg123 decoder delay with 
+ DECDELAY of -528 (not possible)
+ so delay by a enough to make the total delay 1 whole frame (1152-528)
+ */
+ 
+ 
+ 
+ #define ENCDELAY 528 
+ #define DECDELAY (1152-528)
+ /* include the 224 data from the FFT window */
+ #define WINDELAY (224 + ENCDELAY)
+ 
+ #ifdef HAVEGTK
+ 
+ #define READ_AHEAD 10             /* number of frames to read ahead */
+ #define MAXMPGLAG READ_AHEAD      /* if the mpg123 lag becomes bigger than this 				     we have to stop */
+ #define NUMBACK 6                 /* number of frames we can back up */
+ #define NUMPINFO (NUMBACK+READ_AHEAD+1)
+ 
+ #define BLKSIZE         1024
+ #define HBLKSIZE        513
+ #define SBMAX_l 21
+ #define SBMAX_s 12
+ 
+ 
+ 
+ typedef struct {
+   int frameNum;           /* current frame number */
+   int frameNum123;
+   int num_samples;        /* number of pcm samples read for this frame */
+   double frametime;       /* starting time of frame, in seconds */
+   double pcmdata[2][1152+WINDELAY];
+   double pcmdata2[2][1152+DECDELAY];
+   double energy[2][4][BLKSIZE];
+   double xr[2][2][576];
+   double mpg123xr[2][2][576];
+   double pe[2][4];
+   double ms_ratio[2];
+ 
+   double thr[2][4][SBMAX_l];
+   double en[2][4][SBMAX_l];
+   double thr_s[2][4][3*SBMAX_s];
+   double en_s[2][4][3*SBMAX_s];
+   double ers[2][4];
+ 
+   double xfsf[2][2][SBMAX_l];
+   double xfsf_s[2][2][3*SBMAX_s];
+ 
+   int qss[2][2];
+   int sub_gain[2][2][3];
+   int over[2][2];
+   double tot_noise[2][2];
+   double max_noise[2][2];
+   double over_noise[2][2];
+   int blocktype[2][2];
+   int scalefac_scale[2][2];
+   int mpg123blocktype[2][2];
+   int mixed[2][2];
+   int mainbits[2][2];
+   int LAMEmainbits[2][2];
+   int framesize,stereo,js,ms_stereo,i_stereo,emph,bitrate,sampfreq,maindata;
+   int scfsi,mean_bits,resvsize;
+   int totbits;
+ } plotting_data;
+  
+ 
+ int gtkcontrol(void);
+ extern plotting_data *pinfo;
+ extern int gtkflag;
+ #endif
+ 
diff -r -c -N encoder/huffman.c lame3.50/huffman.c
*** encoder/huffman.c	Wed Jan 22 02:43:15 1997
--- lame3.50/huffman.c	Wed Dec 31 17:00:00 1969
***************
*** 1,380 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: huffman.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: huffman.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   changes made since last update:                                  *
-  *   date   programmers                comment                        *
-  *27.2.92   F.O.Witte                  (ITT Intermetall)              *
-  *				       email: otto.witte@itt-sc.de    *
-  *				       tel:   ++49 (761)517-125	      *
-  *				       fax:   ++49 (761)517-880	      *
-  *12.6.92   J. Pineda                  Added sign bit to decoder.     *
-  * 08/24/93 M. Iwadare                 Changed for 1 pass decoding.   *
-  *--------------------------------------------------------------------*
-  *  7/14/94 Juergen Koller      Bug fixes in Layer III code           *
-  *********************************************************************/	
- #include <stdlib.h>
- #include "common.h"
- #include "huffman.h"
-      
- HUFFBITS dmask = 1 << (sizeof(HUFFBITS)*8-1);
- unsigned int hs = sizeof(HUFFBITS)*8;
- 
- struct huffcodetab ht[HTN];	/* array of all huffcodtable headers	*/
- 				/* 0..31 Huffman code table 0..31	*/
- 				/* 32,33 count1-tables			*/
- 
- /* read the huffman encode table */
- int read_huffcodetab(fi) 
- FILE *fi;
- {
- 
-   char line[100],command[40],huffdata[40];
-   unsigned int t,i,j,k,nn,x,y,n=0;
-   unsigned int xl, yl, len;
-   HUFFBITS h;
-   int	hsize;
-   
-   hsize = sizeof(HUFFBITS)*8; 
-   do {
-       fgets(line,99,fi);
-   } while ((line[0] == '#') || (line[0] < ' ') );
-   
-   do {    
-     while ((line[0]=='#') || (line[0] < ' ')) {
-       fgets(line,99,fi);
-     } 
- 
-     sscanf(line,"%s %s %u %u %u",command,ht[n].tablename,
- 			         &xl,&yl,&ht[n].linbits);
-     if (strcmp(command,".end")==0)
-       return n;
-     else if (strcmp(command,".table")!=0) {
-       fprintf(stderr,"huffman table %u data corrupted\n",n);
-       return -1;
-     }
-     ht[n].linmax = (1<<ht[n].linbits)-1;
-    
-     sscanf(ht[n].tablename,"%u",&nn);
-     if (nn != n) {
-       fprintf(stderr,"wrong table number %u\n",n);
-       return(-2);
-     } 
- 
-     ht[n].xlen = xl;
-     ht[n].ylen = yl;
- 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
- 
-     sscanf(line,"%s %u",command,&t);
-     if (strcmp(command,".reference")==0) {
-       ht[n].ref   = t;
-       ht[n].table = ht[t].table;
-       ht[n].hlen  = ht[t].hlen;
-       if ( (xl != ht[t].xlen) ||
-            (yl != ht[t].ylen)  ) {
-         fprintf(stderr,"wrong table %u reference\n",n);
-         return (-3);
-       };
-       do {
-         fgets(line,99,fi);
-       } while ((line[0] == '#') || (line[0] < ' ') );
-     } 
-     else {
- 	ht[n].ref  = -1;
-       ht[n].table=(HUFFBITS *) calloc(xl*yl,sizeof(HUFFBITS));
-       if (ht[n].table == NULL) {
-          fprintf(stderr,"unsufficient heap error\n");
-          return (-4);
-       }
-       ht[n].hlen=(unsigned char *) calloc(xl*yl,sizeof(unsigned char));
-       if (ht[n].hlen == NULL) {
-          fprintf(stderr,"unsufficient heap error\n");
-          return (-4);
-       }
-       for (i=0; i<xl; i++) {
-         for (j=0;j<yl; j++) {
- 	  if (xl>1) 
-             sscanf(line,"%u %u %u %s",&x, &y, &len,huffdata);
- 	  else 
-             sscanf(line,"%u %u %s",&x,&len,huffdata);
-           h=0;k=0;
- 	  while (huffdata[k]) {
-             h <<= 1;
-             if (huffdata[k] == '1')
-               h++;
-             else if (huffdata[k] != '0'){
-               fprintf(stderr,"huffman-table %u bit error\n",n);
-               return (-5);
-             };
-             k++;
-           };
-           if (k != len) {
-            fprintf(stderr,
-               "warning: wrong codelen in table %u, pos [%2u][%2u]\n",
- 	       n,i,j);
-           };
-           ht[n].table[i*xl+j] = h;
-           ht[n].hlen[i*xl+j] = (unsigned char) len;
- 	  do {
-             fgets(line,99,fi);
-           } while ((line[0] == '#') || (line[0] < ' '));
-         }
-       }
-     }
-     n++;
-   } while (1);
- }
- 
- /* read the huffman decoder table */
- int read_decoder_table(fi) 
- FILE *fi;
- {
-   int n,i,nn,t;
-   unsigned int v0,v1;
-   char command[100],line[100];
-   for (n=0;n<HTN;n++) {
-     /* .table number treelen xlen ylen linbits */ 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
-      
-     sscanf(line,"%s %s %u %u %u %u",command,ht[n].tablename,
-            &ht[n].treelen, &ht[n].xlen, &ht[n].ylen, &ht[n].linbits);
-     if (strcmp(command,".end")==0)
-       return n;
-     else if (strcmp(command,".table")!=0) {
-       fprintf(stderr,"huffman table %u data corrupted\n",n);
-       return -1;
-     }
-     ht[n].linmax = (1<<ht[n].linbits)-1;
-    
-     sscanf(ht[n].tablename,"%u",&nn);
-     if (nn != n) {
-       fprintf(stderr,"wrong table number %u\n",n);
-       return(-2);
-     } 
-     do {
-       fgets(line,99,fi);
-     } while ((line[0] == '#') || (line[0] < ' '));
- 
-     sscanf(line,"%s %u",command,&t);
-     if (strcmp(command,".reference")==0) {
-       ht[n].ref   = t;
-       ht[n].val   = ht[t].val;
-       ht[n].treelen  = ht[t].treelen;
-       if ( (ht[n].xlen != ht[t].xlen) ||
-            (ht[n].ylen != ht[t].ylen)  ) {
-         fprintf(stderr,"wrong table %u reference\n",n);
-         return (-3);
-       };
-       while ((line[0] == '#') || (line[0] < ' ') ) {
-         fgets(line,99,fi);
-       }
-     }    
-     else if (strcmp(command,".treedata")==0) {
-       ht[n].ref  = -1;
-       if ( ht[n].treelen )
-       {
- 	  ht[n].val = (unsigned char (*)[2]) 
- 	      calloc(2*(ht[n].treelen),sizeof(unsigned char));
- 	  if (ht[n].val == NULL) {
- 	      fprintf(stderr, "heaperror at table %d\n",n);
- 	      exit (-10);
- 	  }
-       }
-       else
- 	  ht[n].val = NULL;
-       for (i=0;i<ht[n].treelen; i++) {
-         fscanf(fi,"%x %x",&v0, &v1);
-         ht[n].val[i][0]=(unsigned char)v0;
-         ht[n].val[i][1]=(unsigned char)v1;
-       }
-       fgets(line,99,fi); /* read the rest of the line */
-     }
-     else {
-       fprintf(stderr,"huffman decodertable error at table %d\n",n);
-     }
-   }
-   return n;
- }
- 
- 
- /* do the huffman coding,  */
- /* note! for counta,countb - the 4 bit value is passed in y, set x to 0 */
- /* return value: 0-no error, 1 decode error				*/
- void huffman_coder( x, y, h, bs)
- unsigned int x; 	/* x-value */
- unsigned int y; 	/* y-value */
- struct huffcodetab *h; 	/* pointer to huffman code record 	*/
- Bit_stream_struc *bs;  	/* pointer to open write bitstream 	*/
- {
-   HUFFBITS huffbits; /* data left aligned */
-   HUFFBITS linbitsX; 
-   HUFFBITS linbitsY;
-   unsigned int len;
-   unsigned int xl1 = h->xlen-1;
-   unsigned int yl1 = h->ylen-1;
-   linbitsX = 0;
-   linbitsY = 0;
-   if (h->table == NULL) return;
-   if (((x < xl1) || (xl1==0)) && (y < yl1)) {
-     huffbits = h->table[x*(h->xlen)+y];
-     len = h->hlen[x*(h->xlen)+y];
-     putbits(bs,huffbits,len);
-     return;
-   }  
-   else if (x >= xl1) {
-     linbitsX = x-xl1;
-     if (linbitsX > h->linmax) {
-       fprintf(stderr,"warning: Huffman X table overflow\n");
-       linbitsX= h->linmax;
-     };
-     if (y >= yl1) {
-       huffbits = h->table[(h->ylen)*(h->xlen)-1];
-       len = h->hlen[(h->ylen)*(h->xlen)-1];
-       putbits(bs,huffbits,len);
-       linbitsY = y-yl1;
-       if (linbitsY > h->linmax) {
-         fprintf(stderr,"warning: Huffman Y table overflow\n");
-         linbitsY = h->linmax;
-       };
-       if (h->linbits) {
-         putbits(bs,linbitsX,h->linbits);
-         putbits(bs,linbitsY,h->linbits);
-       }
-     } 
-     else { /* x>= h->xlen, y<h->ylen */
-       huffbits = h->table[(h->ylen)*xl1+y];
-       len = h->hlen[(h->ylen)*xl1+y];
-       putbits(bs,huffbits,len);
-       if (h->linbits) {
-         putbits(bs,linbitsX,h->linbits);
-       }
-     }
-   }
-   else  { /* ((x < h->xlen) && (y>=h->ylen)) */
-     huffbits = h->table[(h->ylen)*x+yl1];
-     len = h->hlen[(h->ylen)*x+yl1];
-     putbits(bs,huffbits,len);
-     linbitsY = y-yl1;
-     if (linbitsY > h->linmax) {
-       fprintf(stderr,"warning: Huffman Y table overflow\n");
-       linbitsY = h->linmax;
-     };
-     if (h->linbits) {
-        putbits(bs,linbitsY,h->linbits);
-     }
-   }
- }
- 
- /* do the huffman-decoding 						*/
- /* note! for counta,countb -the 4 bit value is returned in y, discard x */
- int huffman_decoder(h, x, y, v, w)
- struct huffcodetab *h;	/* pointer to huffman code record	*/
- /* unsigned */ int *x; 	/* returns decoded x value 		*/
- /* unsigned */ int *y;	/* returns decoded y value		*/
- int *v;
- int *w;
- {  
-   HUFFBITS level;
-   int point = 0;
-   int error = 1;
-   level     = dmask;
-   if (h->val == NULL) return 2;
- 
-   /* table 0 needs no bits */
-   if ( h->treelen == 0)
-   {  *x = *y = 0;
-      return 0;
-   }
- 
- 
-   /* Lookup in Huffman table. */
- 
-   do {
-     if (h->val[point][0]==0) {   /*end of tree*/
-       *x = h->val[point][1] >> 4;
-       *y = h->val[point][1] & 0xf;
- 
-       error = 0;
-       break;
-     } 
-     if (hget1bit()) {
-       while (h->val[point][1] >= MXOFF) point += h->val[point][1]; 
-       point += h->val[point][1];
-     }
-     else {
-       while (h->val[point][0] >= MXOFF) point += h->val[point][0]; 
-       point += h->val[point][0];
-     }
-     level >>= 1;
-   } while (level  || (point < ht->treelen) );
-   
-   /* Check for error. */
-   
-   if (error) { /* set x and y to a medium value as a simple concealment */
-     printf("Illegal Huffman code in data.\n");
-     *x = (h->xlen-1 << 1);
-     *y = (h->ylen-1 << 1);
-   }
- 
-   /* Process sign encodings for quadruples tables. */
- 
-   if (h->tablename[0] == '3'
-       && (h->tablename[1] == '2' || h->tablename[1] == '3')) {
-      *v = (*y>>3) & 1;
-      *w = (*y>>2) & 1;
-      *x = (*y>>1) & 1;
-      *y = *y & 1;
- 
-      /* v, w, x and y are reversed in the bitstream. 
-         switch them around to make test bistream work. */
-      
- /*   {int i=*v; *v=*y; *y=i; i=*w; *w=*x; *x=i;}  MI */
- 
-      if (*v)
-         if (hget1bit() == 1) *v = -*v;
-      if (*w)
-         if (hget1bit() == 1) *w = -*w;
-      if (*x)
-         if (hget1bit() == 1) *x = -*x;
-      if (*y)
-         if (hget1bit() == 1) *y = -*y;
-      }
-      
-   /* Process sign and escape encodings for dual tables. */
-   
-   else {
-   
-       /* x and y are reversed in the test bitstream.
-          Reverse x and y here to make test bitstream work. */
- 	 
- /*    removed 11/11/92 -ag  
- 		{int i=*x; *x=*y; *y=i;} 
- */      
-      if (h->linbits)
-        if ((h->xlen-1) == *x) 
-          *x += hgetbits(h->linbits);
-      if (*x)
-         if (hget1bit() == 1) *x = -*x;
-      if (h->linbits)	  
-        if ((h->ylen-1) == *y)
-          *y += hgetbits(h->linbits);
-      if (*y)
-         if (hget1bit() == 1) *y = -*y;
-      }
- 	  
-   return error;  
- }
--- 0 ----
diff -r -c -N encoder/huffman.h lame3.50/huffman.h
*** encoder/huffman.h	Wed Jan 22 02:43:15 1997
--- lame3.50/huffman.h	Tue Oct  5 18:07:40 1999
***************
*** 1,60 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: huffman.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: huffman.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *  27.2.92 F.O.Witte (ITT Intermetall)				      *
-  *  8/24/93 M. Iwadare          Changed for 1 pass decoding.          *
-  *  7/14/94 J. Koller		useless 'typedef' before huffcodetab  *
-  *				removed				      *
-  *********************************************************************/	
-  
  #define HUFFBITS unsigned long int
  #define HTN	34
  #define MXOFF	250
   
  struct huffcodetab {
-   char tablename[3];	/*string, containing table_description	*/
    unsigned int xlen; 	/*max. x-index+			      	*/ 
    unsigned int ylen;	/*max. y-index+				*/
    unsigned int linbits; /*number of linbits			*/
    unsigned int linmax;	/*max number to be stored in linbits	*/
-   int ref;		/*a positive value indicates a reference*/
    HUFFBITS *table;	/*pointer to array[xlen][ylen]		*/
    unsigned char *hlen;	/*pointer to array[xlen][ylen]		*/
-   unsigned char(*val)[2];/*decoder tree				*/ 
-   unsigned int treelen;	/*length of decoder tree		*/
  };
  
  extern struct huffcodetab ht[HTN];/* global memory block		*/
  				/* array of all huffcodtable headers	*/
  				/* 0..31 Huffman code table 0..31	*/
  				/* 32,33 count1-tables			*/
- #ifdef PROTO_ARGS
- 
- extern int read_huffcodetab(FILE *); 
- extern int read_decoder_table(FILE *);
-  
- extern void huffman_coder(unsigned int, unsigned int,
- 			  struct huffcodetab *, Bit_stream_struc *);
- 			  
- extern int huffman_decoder(struct huffcodetab *,
- 			   /* unsigned */ int *, /* unsigned */ int*, int*, int*);
- 
- #else
- 
- extern int read_huffcodetab(); 
- extern int read_decoder_table(); 
- extern void huffman_coder();
- extern int huffman_decoder();
  
- #endif
--- 1,18 ----
diff -r -c -N encoder/id3tag.c lame3.50/id3tag.c
*** encoder/id3tag.c	Wed Dec 31 17:00:00 1969
--- lame3.50/id3tag.c	Tue Sep 21 21:25:57 1999
***************
*** 0 ****
--- 1,69 ----
+ /*
+  * functions for writing ID3 tags in LAME
+  *
+  * text functions stolen from mp3info by Ricardo Cerqueira <rmc@rccn.net>
+  * adapted for LAME by Conrad Sanderson <c.sanderson@me.gu.edu.au>
+  *
+  * 
+  */ 
+  
+ #include <stdio.h>
+ #include <string.h>
+ #include "id3tag.h"
+  
+ /*
+  * If "string" is shorter than "length", pad it with ' ' (spaces)
+  */
+ 
+ static void id3_pad(char *string, int length) {
+ 	int l;  l=strlen(string);
+ 	
+ 	while(l<length) { string[l] = ' '; l++; }
+ 	string[l]='\0';
+ 	}
+ 
+ 
+ /*
+  * initialize temporary fields
+  */
+ 
+ void id3_inittag(ID3TAGDATA *tag) {
+ 	strcpy( tag->title, "");
+ 	strcpy( tag->artist, "");
+ 	strcpy( tag->album, "");
+ 	strcpy( tag->year, "");    
+ 	strcpy( tag->comment, "");
+ 
+ 	tag->valid = 0;		// not ready for writing
+ 	}
+ 
+ /*
+  * build an ID3 tag from temporary fields
+  */
+ 
+ void id3_buildtag(ID3TAGDATA *tag) {
+ 	strcpy(tag->tagtext,"TAG");
+ 
+ 	id3_pad( tag->title, 30);   strncat( tag->tagtext, tag->title,30);
+ 	id3_pad( tag->artist, 30);  strncat( tag->tagtext, tag->artist,30);
+ 	id3_pad( tag->album, 30);   strncat( tag->tagtext, tag->album,30);
+ 	id3_pad( tag->year, 4);     strncat( tag->tagtext, tag->year,4);
+ 	id3_pad( tag->comment, 30); strncat( tag->tagtext, tag->comment,30);
+ 
+ 	strncat( tag->tagtext, "�", 1);
+ 	tag->valid = 1;		// ready for writing
+ 	}
+ 
+ /*
+  * write ID3 tag 
+  */
+ 
+ int id3_writetag(char* filename, ID3TAGDATA *tag) {
+ 	FILE* f;
+ 	if( ! tag->valid ) return -1;
+ 
+ 	f=fopen(filename,"rb+");	if(!f) return -1;
+ 
+ 	fseek(f,0,SEEK_END); fwrite(tag->tagtext,1,128,f);
+ 	fclose(f); return 0;
+ 	}
diff -r -c -N encoder/id3tag.h lame3.50/id3tag.h
*** encoder/id3tag.h	Wed Dec 31 17:00:00 1969
--- lame3.50/id3tag.h	Wed Sep 22 00:23:12 1999
***************
*** 0 ****
--- 1,20 ----
+ #ifndef ID3TAG_H_INCLUDED
+ #define ID3TAG_H_INCLUDED
+ 
+ typedef struct
+ {
+ 	int used;
+ 	int valid;
+ 	char title[31];
+ 	char artist[31];
+ 	char album[31];
+ 	char year[5];
+ 	char comment[31];
+ 	char tagtext[128];
+ 
+ }   ID3TAGDATA;
+ 
+ void id3_inittag(ID3TAGDATA *tag);
+ void id3_buildtag(ID3TAGDATA *tag);
+ int id3_writetag(char* filename, ID3TAGDATA *tag);
+ #endif
diff -r -c -N encoder/ieeefloat.c lame3.50/ieeefloat.c
*** encoder/ieeefloat.c	Wed Jan 22 02:43:17 1997
--- lame3.50/ieeefloat.c	Mon Oct 25 12:22:30 1999
***************
*** 82,89 ****
  
  
  defdouble
! ConvertFromIeeeSingle(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	mantissa, expon;
--- 82,88 ----
  
  
  defdouble
! ConvertFromIeeeSingle(char* bytes)
  {
  	defdouble	f;
  	long	mantissa, expon;
***************
*** 106,116 ****
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (bits & 0x7fffff);
! 				f = ldexp((defdouble)mantissa, expon - SEXP_OFFSET - SEXP_POSITION + 1);
  			}
  			else {				/* Normalized number */
  				mantissa = (bits & 0x7fffff) + 0x800000;	/* Insert hidden bit */
! 				f = ldexp((defdouble)mantissa, expon - SEXP_OFFSET - SEXP_POSITION);
  			}
  		}
  	}
--- 105,115 ----
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (bits & 0x7fffff);
! 				f = ldexp((defdouble) mantissa, (int) (expon - SEXP_OFFSET - SEXP_POSITION + 1));
  			}
  			else {				/* Normalized number */
  				mantissa = (bits & 0x7fffff) + 0x800000;	/* Insert hidden bit */
! 				f = ldexp((defdouble) mantissa, (int) (expon - SEXP_OFFSET - SEXP_POSITION));
  			}
  		}
  	}
***************
*** 126,134 ****
  
  
  void
! ConvertToIeeeSingle(num, bytes)
! defdouble num;
! char* bytes;
  {
  	long	sign;
  	register long bits;
--- 125,131 ----
  
  
  void
! ConvertToIeeeSingle(defdouble num, char* bytes)
  {
  	long	sign;
  	register long bits;
***************
*** 195,202 ****
  
  
  defdouble
! ConvertFromIeeeDouble(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	mantissa, expon;
--- 192,198 ----
  
  
  defdouble
! ConvertFromIeeeDouble(char* bytes)
  {
  	defdouble	f;
  	long	mantissa, expon;
***************
*** 223,235 ****
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (first & 0x000FFFFF);
! 				f = ldexp((defdouble)mantissa, expon - DEXP_OFFSET - DEXP_POSITION + 1);
! 				f += ldexp(UnsignedToFloat(second), expon - DEXP_OFFSET - DEXP_POSITION + 1 - 32);
  			}
  			else {				/* Normalized number */
  				mantissa = (first & 0x000FFFFF) + 0x00100000;	/* Insert hidden bit */
! 				f = ldexp((defdouble)mantissa, expon - DEXP_OFFSET - DEXP_POSITION);
! 				f += ldexp(UnsignedToFloat(second), expon - DEXP_OFFSET - DEXP_POSITION - 32);
  			}
  		}
  	}
--- 219,231 ----
  		else {
  			if (expon == 0) {	/* Denormalized number */
  				mantissa = (first & 0x000FFFFF);
! 				f = ldexp((defdouble) mantissa, (int) (expon - DEXP_OFFSET - DEXP_POSITION + 1));
! 				f += ldexp(UnsignedToFloat(second), (int) (expon - DEXP_OFFSET - DEXP_POSITION + 1 - 32));
  			}
  			else {				/* Normalized number */
  				mantissa = (first & 0x000FFFFF) + 0x00100000;	/* Insert hidden bit */
! 				f = ldexp((defdouble) mantissa, (int) (expon - DEXP_OFFSET - DEXP_POSITION));
! 				f += ldexp(UnsignedToFloat(second), (int) (expon - DEXP_OFFSET - DEXP_POSITION - 32));
  			}
  		}
  	}
***************
*** 245,253 ****
  
  
  void
! ConvertToIeeeDouble(num, bytes)
! defdouble num;
! char *bytes;
  {
  	long	sign;
  	long	first, second;
--- 241,247 ----
  
  
  void
! ConvertToIeeeDouble(defdouble num, char *bytes)
  {
  	long	sign;
  	long	first, second;
***************
*** 326,333 ****
   ****************************************************************/
  
  defdouble
! ConvertFromIeeeExtended(bytes)
! char* bytes;
  {
  	defdouble	f;
  	long	expon;
--- 320,326 ----
   ****************************************************************/
  
  defdouble
! ConvertFromIeeeExtended(char* bytes)
  {
  	defdouble	f;
  	long	expon;
***************
*** 359,366 ****
  		}
  		else {
  			expon -= 16383;
! 			f  = ldexp(UnsignedToFloat(hiMant), expon-=31);
! 			f += ldexp(UnsignedToFloat(loMant), expon-=32);
  		}
  	}
  
--- 352,359 ----
  		}
  		else {
  			expon -= 16383;
! 			f  = ldexp(UnsignedToFloat(hiMant), (int) (expon -= 31));
! 			f += ldexp(UnsignedToFloat(loMant), (int) (expon -= 32));
  		}
  	}
  
***************
*** 375,383 ****
  
  
  void
! ConvertToIeeeExtended(num, bytes)
! defdouble num;
! char *bytes;
  {
  	int	sign;
  	int expon;
--- 368,374 ----
  
  
  void
! ConvertToIeeeExtended(defdouble num, char *bytes)
  {
  	int	sign;
  	int expon;
***************
*** 467,474 ****
  
  
  int
! GetHexValue(x)
! register int x;
  {
  	x &= 0x7F;
  	
--- 458,464 ----
  
  
  int
! GetHexValue(register int x)
  {
  	x &= 0x7F;
  	
***************
*** 486,493 ****
  
  
  void
! Hex2Bytes(hex, bytes)
! register char *hex, *bytes;
  {
  	for ( ; *hex; hex += 2) {
  		*bytes++ = (GetHexValue(hex[0]) << 4) | GetHexValue(hex[1]);
--- 476,482 ----
  
  
  void
! Hex2Bytes(register char *hex, register char *bytes)
  {
  	for ( ; *hex; hex += 2) {
  		*bytes++ = (GetHexValue(hex[0]) << 4) | GetHexValue(hex[1]);
***************
*** 498,505 ****
  
  
  int
! GetHexSymbol(x)
! register int x;
  {
  	x &= 0xF;
  	if (x <= 9)
--- 487,493 ----
  
  
  int
! GetHexSymbol(register int x)
  {
  	x &= 0xF;
  	if (x <= 9)
***************
*** 511,519 ****
  
  
  void
! Bytes2Hex(bytes, hex, nBytes)
! register char *bytes, *hex;
! register int nBytes;
  {
  	for ( ; nBytes--; bytes++) {
  		*hex++ = GetHexSymbol(*bytes >> 4);
--- 499,505 ----
  
  
  void
! Bytes2Hex(register char *bytes, register char *hex, register int nBytes)
  {
  	for ( ; nBytes--; bytes++) {
  		*hex++ = GetHexSymbol(*bytes >> 4);
***************
*** 524,532 ****
  
  
  void
! MaybeSwapBytes(bytes, nBytes)
! char* bytes;
! int nBytes;
  {
  #ifdef LITTLE_ENDIAN
  	register char *p, *q, t;
--- 510,516 ----
  
  
  void
! MaybeSwapBytes(char* bytes, int nBytes)
  {
  #ifdef LITTLE_ENDIAN
  	register char *p, *q, t;
***************
*** 543,550 ****
  
  
  float
! MachineIEEESingle(bytes)
! char* bytes;
  {
  	float t;
  	MaybeSwapBytes(bytes, 4);
--- 527,533 ----
  
  
  float
! MachineIEEESingle(char* bytes)
  {
  	float t;
  	MaybeSwapBytes(bytes, 4);
***************
*** 555,562 ****
  
  
  Double
! MachineIEEEDouble(bytes)
! char* bytes;
  {
  	Double t;
  	MaybeSwapBytes(bytes, 8);
--- 538,544 ----
  
  
  Double
! MachineIEEEDouble(char* bytes)
  {
  	Double t;
  	MaybeSwapBytes(bytes, 8);
***************
*** 567,574 ****
  
  
  void
! TestFromIeeeSingle(hex)
! char *hex;
  {
  	defdouble f;
  	union SParts p;
--- 549,555 ----
  
  
  void
! TestFromIeeeSingle(char *hex)
  {
  	defdouble f;
  	union SParts p;
***************
*** 589,596 ****
  
  
  void
! TestToIeeeSingle(f)
! defdouble f;
  {
  	union SParts p;
  	char bytes[4];
--- 570,576 ----
  
  
  void
! TestToIeeeSingle(defdouble f)
  {
  	union SParts p;
  	char bytes[4];
***************
*** 613,620 ****
  
  
  void
! TestFromIeeeDouble(hex)
! char *hex;
  {
  	defdouble f;
  	union DParts p;
--- 593,599 ----
  
  
  void
! TestFromIeeeDouble(char *hex)
  {
  	defdouble f;
  	union DParts p;
***************
*** 636,643 ****
  }
  
  void
! TestToIeeeDouble(f)
! defdouble f;
  {
  	union DParts p;
  	char bytes[8];
--- 615,621 ----
  }
  
  void
! TestToIeeeDouble(defdouble f)
  {
  	union DParts p;
  	char bytes[8];
***************
*** 663,670 ****
  
  
  void
! TestFromIeeeExtended(hex)
! char *hex;
  {
  	defdouble f;
  	union EParts p;
--- 641,647 ----
  
  
  void
! TestFromIeeeExtended(char *hex)
  {
  	defdouble f;
  	union EParts p;
***************
*** 701,708 ****
  
  
  void
! TestToIeeeExtended(f)
! defdouble f;
  {
  	char bytes[12];
  	char hex[24+1];
--- 678,684 ----
  
  
  void
! TestToIeeeExtended(defdouble f)
  {
  	char bytes[12];
  	char hex[24+1];
***************
*** 736,751 ****
  
  #include	<signal.h>
  
! void SignalFPE(i, j)
! int	i;
! void (*j)();
  {
  	printf("[Floating Point Interrupt Caught.]\n", i, j);
  	signal(SIGFPE, SignalFPE);
  }
  	
  void
! main()
  {
  	long d[3];
  	char bytes[12];
--- 712,725 ----
  
  #include	<signal.h>
  
! void SignalFPE(int i, void (*j)())
  {
  	printf("[Floating Point Interrupt Caught.]\n", i, j);
  	signal(SIGFPE, SignalFPE);
  }
  	
  void
! main(void)
  {
  	long d[3];
  	char bytes[12];
diff -r -c -N encoder/l3bitstream.c lame3.50/l3bitstream.c
*** encoder/l3bitstream.c	Wed Jan 22 02:43:15 1997
--- lame3.50/l3bitstream.c	Thu Oct 28 21:52:53 1999
***************
*** 21,29 ****
  
  #include <stdlib.h>
  #include "l3bitstream.h" /* the public interface */
! #include "l3psy.h"
! #include "mdct.h"
! #include "loop.h"
  #include "formatBitstream.h"
  #include "huffman.h"
  #include <assert.h>
--- 21,29 ----
  
  #include <stdlib.h>
  #include "l3bitstream.h" /* the public interface */
! #include "psymodel.h"
! #include "fastmdct.h"
! #include "quantize.h"
  #include "formatBitstream.h"
  #include "huffman.h"
  #include <assert.h>
***************
*** 75,96 ****
  		      char             *ancillary,
  		      int              ancillary_bits )
  {
!     int gr, ch, i, mode_gr;
      fr_ps = in_fr_ps;
      bs = in_bs;
      stereo = fr_ps->stereo;
      mode_gr = (fr_ps->header->version == 1) ? 2 : 1;
!     
      if ( frameData == NULL )
      {
! 	frameData = calloc( 1, sizeof(*frameData) );
  	assert( frameData );
      }
      if ( frameResults == NULL )
      {
! 	frameResults = calloc( 1, sizeof(*frameData) );
  	assert( frameData );
      }
      if ( !PartHoldersInitialized )
      {
  	headerPH = BF_newPartHolder( 12 );
--- 75,107 ----
  		      char             *ancillary,
  		      int              ancillary_bits )
  {
!     int gr, ch,  mode_gr;
!     static BF_FrameData real_frameData;
!     static BF_FrameResults real_frameResults;
! 
! 
      fr_ps = in_fr_ps;
      bs = in_bs;
      stereo = fr_ps->stereo;
      mode_gr = (fr_ps->header->version == 1) ? 2 : 1;
! 
!     frameData = &real_frameData;
!     frameResults = &real_frameResults;
! 
! 
! #if 0
      if ( frameData == NULL )
      {
! 	frameData = (BF_FrameData*) calloc( 1, sizeof(BF_FrameData) );
  	assert( frameData );
      }
      if ( frameResults == NULL )
      {
! 	frameResults = (BF_FrameResults*) calloc( 1, sizeof(BF_FrameResults) );
  	assert( frameData );
      }
+ #endif
+ 
      if ( !PartHoldersInitialized )
      {
  	headerPH = BF_newPartHolder( 12 );
***************
*** 111,126 ****
  	PartHoldersInitialized = 1;
      }
  
! #if 1
      for ( gr = 0; gr < mode_gr; gr++ )
  	for ( ch =  0; ch < stereo; ch++ )
  	{
  	    int *pi = &l3_enc[gr][ch][0];
! 	    double *pr = &xr[gr][ch][0];
! 	    for ( i = 0; i < 576; i++, pr++, pi++ )
! 	    {
! 		if ( (*pr < 0) && (*pi > 0) )
! 		    *pi *= -1;
  	    }
  	}
  #endif
--- 122,143 ----
  	PartHoldersInitialized = 1;
      }
  
! #if 0
!     /* this makes more sense in loop.c */
      for ( gr = 0; gr < mode_gr; gr++ )
  	for ( ch =  0; ch < stereo; ch++ )
  	{
  	    int *pi = &l3_enc[gr][ch][0];
! 	    int i;
! 	    for ( i = 0; i < 576; i++) 	    {
! 	      double pr = xr[gr][ch][i];
!               /* ms stereo fix.  if ms_stereo, l3_enc will be M/S values */
! 	      if (in_fr_ps->header->mode_ext == 2) {
! 		pr = ch ? (xr[gr][0][i]-xr[gr][1][i]) : (xr[gr][0][i]+xr[gr][1][i]);
! 		/* pr /= sqrt(2.0); */
! 	      }
! 
! 	      if ( (pr < 0) && (pi[i] > 0) )   pi[i] *= -1;
  	    }
  	}
  #endif
***************
*** 129,134 ****
--- 146,153 ----
      encodeMainData( l3_enc, l3_side, scalefac );
      write_ancillary_data( ancillary, ancillary_bits );
  
+ 
+ 
      if ( l3_side->resvDrain )
  	drain_into_ancillary_data( l3_side->resvDrain );
      /*
***************
*** 159,168 ****
  
      /* we set this here -- it will be tested in the next loops iteration */
      l3_side->main_data_begin = frameResults->nextBackPtr;
  }
  
  void
! III_FlushBitstream()
  {
      assert( PartHoldersInitialized );
      BF_FlushBitstream( frameData, frameResults );
--- 178,188 ----
  
      /* we set this here -- it will be tested in the next loops iteration */
      l3_side->main_data_begin = frameResults->nextBackPtr;
+ 
  }
  
  void
! III_FlushBitstream(void)
  {
      assert( PartHoldersInitialized );
      BF_FlushBitstream( frameData, frameResults );
***************
*** 179,184 ****
--- 199,207 ----
      int i, gr, ch, sfb, window, mode_gr;
      layer *info = fr_ps->header;
  
+ 
+ 
+ 
      if ( info->version == 1 )
  	mode_gr = 2;
      else
***************
*** 206,211 ****
--- 229,235 ----
  
  		if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  		{
+ #ifdef ALLOW_MIXED
  		    if ( gi->mixed_block_flag )
  		    {
  			for ( sfb = 0; sfb < 8; sfb++ )
***************
*** 221,226 ****
--- 245,251 ----
  
  		    }
  		    else
+ #endif
  		    {
  			for ( sfb = 0; sfb < 6; sfb++ )
  			    for ( window = 0; window < 3; window++ )
***************
*** 262,272 ****
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
- 
  	    assert( gi->sfb_partition_table );
  
  	    if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	    {
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
--- 287,297 ----
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
  	    int *ix = &l3_enc[gr][ch][0];
  	    int sfb_partition;
  	    assert( gi->sfb_partition_table );
  
  	    if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
  	    {
+ #ifdef ALLOW_MIXED
  		if ( gi->mixed_block_flag )
  		{
  		    sfb_partition = 0;
***************
*** 283,288 ****
--- 308,314 ----
  		    }
  		}
  		else
+ #endif
  		{
  		    for ( sfb = 0, sfb_partition = 0; sfb_partition < 4; sfb_partition++ )
  		    {
***************
*** 304,315 ****
  			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen );
  		}
  	    }
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0;
  
  static int encodeSideInfo( III_side_info_t  *si )
  {
--- 330,358 ----
  			*pph = BF_addEntry( *pph,  scalefac->l[gr][ch][sfb], slen );
  		}
  	    }
+ 
+ 
+ 
  	    Huffmancodebits( &codedDataPH[gr][ch], ix, gi );
  	} /* for ch */
      }
  } /* main_data */
  
! static unsigned int crc = 0; /* (jo) current crc */
! 
! /* (jo) this wrapper function for BF_addEntry() updates also the crc */
! static BF_PartHolder *CRC_BF_addEntry( BF_PartHolder *thePH, uint32 value, uint16 length )
! {
!    unsigned int bit = 1 << length;
!    
!    while((bit >>= 1)){
!       crc <<= 1;
!       if (!(crc & 0x10000) ^ !(value & bit))
! 	crc ^= CRC16_POLYNOMIAL;
!    }
!    crc &= 0xffff;   
!    return BF_addEntry(thePH, value, length);
! }
  
  static int encodeSideInfo( III_side_info_t  *si )
  {
***************
*** 317,345 ****
      layer *info = fr_ps->header;
      
      mode_gr =  (info->version == 1) ? 2 : 1;
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
      headerPH = BF_addEntry( headerPH, info->version,            1 );
      headerPH = BF_addEntry( headerPH, 4 - info->lay,            2 );
      headerPH = BF_addEntry( headerPH, !info->error_protection,  1 );
!     headerPH = BF_addEntry( headerPH, info->bitrate_index,      4 );
!     headerPH = BF_addEntry( headerPH, info->sampling_frequency, 2 );
!     headerPH = BF_addEntry( headerPH, info->padding,            1 );
!     headerPH = BF_addEntry( headerPH, info->extension,          1 );
!     headerPH = BF_addEntry( headerPH, info->mode,               2 );
!     headerPH = BF_addEntry( headerPH, info->mode_ext,           2 );
!     headerPH = BF_addEntry( headerPH, info->copyright,          1 );
!     headerPH = BF_addEntry( headerPH, info->original,           1 );
!     headerPH = BF_addEntry( headerPH, info->emphasis,           2 );
      
      bits_sent = 32;
! 
!     if ( fr_ps->header->error_protection )
!     {
! 	headerPH = BF_addEntry( headerPH, crc, 16 );
! 	bits_sent += 16;
!     }
  
      frameSIPH->part->nrEntries = 0;
  
--- 360,387 ----
      layer *info = fr_ps->header;
      
      mode_gr =  (info->version == 1) ? 2 : 1;
+    
+     crc = 0xffff; /* (jo) init crc16 for error_protection */
  
      headerPH->part->nrEntries = 0;
      headerPH = BF_addEntry( headerPH, 0xfff,                    12 );
      headerPH = BF_addEntry( headerPH, info->version,            1 );
      headerPH = BF_addEntry( headerPH, 4 - info->lay,            2 );
      headerPH = BF_addEntry( headerPH, !info->error_protection,  1 );
!     /* (jo) from now on call the CRC_BF_addEntry() wrapper to update crc */
!     headerPH = CRC_BF_addEntry( headerPH, info->bitrate_index,      4 );
!     headerPH = CRC_BF_addEntry( headerPH, info->sampling_frequency, 2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->padding,            1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->extension,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->mode,               2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->mode_ext,           2 );
!     headerPH = CRC_BF_addEntry( headerPH, info->copyright,          1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->original,           1 );
!     headerPH = CRC_BF_addEntry( headerPH, info->emphasis,           2 );
      
      bits_sent = 32;
!    
!     /* (jo) see below for BF_addEntry( headerPH, crc, 16 ); */
  
      frameSIPH->part->nrEntries = 0;
  
***************
*** 352,369 ****
  
      if ( info->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
  	for ( ch = 0; ch < stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
--- 394,411 ----
  
      if ( info->version == 1 )
      {  /* MPEG1 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 9 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 3 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 5 );
  	
  	for ( ch = 0; ch < stereo; ch++ )
  	    for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
  	    {
  		BF_PartHolder **pph = &channelSIPH[ch];
! 		*pph = CRC_BF_addEntry( *pph, si->scfsi[ch][scfsi_band], 1 );
  	    }
  
  	for ( gr = 0; gr < 2; gr++ )
***************
*** 371,405 ****
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
  		    assert( gi->block_type == 0 );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
  	if ( stereo == 2 )
--- 413,447 ----
  	    {
  		BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  		gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 		*pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 		*pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 		*pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  		if ( gi->window_switching_flag )
  		{   
! 		    *pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		    for ( region = 0; region < 2; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		    for ( window = 0; window < 3; window++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  		}
  		else
  		{
  		    assert( gi->block_type == 0 );
  		    for ( region = 0; region < 3; region++ )
! 			*pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		    *pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		    *pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  		}
  
! 		*pph = CRC_BF_addEntry( *pph, gi->preflag,            1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 		*pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	    }
  
  	if ( stereo == 2 )
***************
*** 409,459 ****
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
  	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
  	if ( stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
      return bits_sent;
  }
  
--- 451,508 ----
      }
      else
      {  /* MPEG2 */
! 	frameSIPH = CRC_BF_addEntry( frameSIPH, si->main_data_begin, 8 );
  
  	if ( stereo == 2 )
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 2 );
  	else
! 	    frameSIPH = CRC_BF_addEntry( frameSIPH, si->private_bits, 1 );
  	
  	gr = 0;
  	for ( ch = 0; ch < stereo; ch++ )
  	{
  	    BF_PartHolder **pph = &spectrumSIPH[gr][ch];
  	    gr_info *gi = &(si->gr[gr].ch[ch].tt);
! 	    *pph = CRC_BF_addEntry( *pph, gi->part2_3_length,        12 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->big_values,            9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->global_gain,           8 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_compress,     9 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->window_switching_flag, 1 );
  
  	    if ( gi->window_switching_flag )
  	    {   
! 		*pph = CRC_BF_addEntry( *pph, gi->block_type,       2 );
! 		*pph = CRC_BF_addEntry( *pph, gi->mixed_block_flag, 1 );
  
  		for ( region = 0; region < 2; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region],  5 );
  		for ( window = 0; window < 3; window++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->subblock_gain[window], 3 );
  	    }
  	    else
  	    {
  		for ( region = 0; region < 3; region++ )
! 		    *pph = CRC_BF_addEntry( *pph, gi->table_select[region], 5 );
  
! 		*pph = CRC_BF_addEntry( *pph, gi->region0_count, 4 );
! 		*pph = CRC_BF_addEntry( *pph, gi->region1_count, 3 );
  	    }
  
! 	    *pph = CRC_BF_addEntry( *pph, gi->scalefac_scale,     1 );
! 	    *pph = CRC_BF_addEntry( *pph, gi->count1table_select, 1 );
  	}
  	if ( stereo == 2 )
  	    bits_sent += 136;
  	else
  	    bits_sent += 72;
      }
+ 
+     if ( fr_ps->header->error_protection )
+     {   /* (jo) error_protection: add crc16 information to header */
+ 	headerPH = BF_addEntry( headerPH, crc, 16 );
+ 	bits_sent += 16;
+     }
+ 
      return bits_sent;
  }
  
***************
*** 524,535 ****
      int i, bigvalues, count1End;
      int v, w, x, y, bits, cbits, xbits, stuffingBits;
      unsigned int code, ext;
!     struct huffcodetab *h;
!     int bvbits, c1bits, tablezeros, r0, r1, r2, rt, *pr;
      int bitsWritten = 0;
!     int idx = 0;
!     tablezeros = 0;
!     r0 = r1 = r2 = 0;
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
--- 573,581 ----
      int i, bigvalues, count1End;
      int v, w, x, y, bits, cbits, xbits, stuffingBits;
      unsigned int code, ext;
!     int bvbits, c1bits;
      int bitsWritten = 0;
! 
      
      /* 1: Write the bigvalues */
      bigvalues = gi->big_values * 2;
***************
*** 569,576 ****
  		    {
  			x = (*ix_s)[line][window];
  			y = (*ix_s)[line + 1][window];
- 			assert( idx < 576 );
- 			assert( idx >= 0 );
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
--- 615,620 ----
***************
*** 580,585 ****
--- 624,630 ----
  	    }
  	}
  	else
+ #ifdef ALLOW_MIXED
  	    if ( gi->mixed_block_flag && gi->block_type == 2 )
  	    {  /* Mixed blocks long, short */
  		int sfb, window, line, start, end;
***************
*** 625,630 ****
--- 670,676 ----
  
  	    }
  	    else
+ #endif
  	    { /* Long blocks */
  		int *scalefac = &sfBandIndex[fr_ps->header->sampling_frequency + (fr_ps->header->version * 3)].l[0];
  		unsigned scalefac_index = 100;
***************
*** 642,649 ****
  		    scalefac_index += gi->region1_count + 1;
  		    assert( scalefac_index < 23 );    
  		    region2Start = scalefac[ scalefac_index ];
! 		    assert( region1Start == gi->address1 );
  		}
  		for ( i = 0; i < bigvalues; i += 2 )
  		{
  		    unsigned tableindex = 100;
--- 688,696 ----
  		    scalefac_index += gi->region1_count + 1;
  		    assert( scalefac_index < 23 );    
  		    region2Start = scalefac[ scalefac_index ];
! 		    //		    assert( region1Start == gi->address1 );
  		}
+ 
  		for ( i = 0; i < bigvalues; i += 2 )
  		{
  		    unsigned tableindex = 100;
***************
*** 651,686 ****
  		    if ( i < region1Start )
  		    {
  			tableindex = gi->table_select[0];
- 			pr = &r0;
  		    }
  		    else
  			if ( i < region2Start )
  			{
  			    tableindex = gi->table_select[1];
- 			    pr = &r1;
  			}
  			else
  			{
  			    tableindex = gi->table_select[2];
- 			    pr = &r2;
  			}
  		    assert( tableindex < 32 );
- 		    h = &ht[ tableindex ];
  		    /* get huffman code */
  		    x = ix[i];
  		    y = ix[i + 1];
  		    if ( tableindex )
  		    {
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
! 			bitsWritten += rt = bits;
! 			*pr += rt;
! 		    }
! 		    else
! 		    {
! 			tablezeros += 1;
! 			*pr = 0;
  		    }
  		}
  	    }
--- 698,724 ----
  		    if ( i < region1Start )
  		    {
  			tableindex = gi->table_select[0];
  		    }
  		    else
  			if ( i < region2Start )
  			{
  			    tableindex = gi->table_select[1];
  			}
  			else
  			{
  			    tableindex = gi->table_select[2];
  			}
  		    assert( tableindex < 32 );
  		    /* get huffman code */
  		    x = ix[i];
  		    y = ix[i + 1];
  		    if ( tableindex )
  		    {
+ 
  			bits = HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
  			*pph = BF_addEntry( *pph,  code, cbits );
  			*pph = BF_addEntry( *pph,  ext, xbits );
! 			bitsWritten += bits;
  		    }
  		}
  	    }
***************
*** 689,695 ****
  
      /* 2: Write count1 area */
      assert( (gi->count1table_select < 2) );
!     h = &ht[gi->count1table_select + 32];
      count1End = bigvalues + (gi->count1 * 4);
      assert( count1End <= 576 );
      for ( i = bigvalues; i < count1End; i += 4 )
--- 727,733 ----
  
      /* 2: Write count1 area */
      assert( (gi->count1table_select < 2) );
!     //    h = &ht[gi->count1table_select + 32];
      count1End = bigvalues + (gi->count1 * 4);
      assert( count1End <= 576 );
      for ( i = bigvalues; i < count1End; i += 4 )
***************
*** 698,712 ****
  	w = ix[i+1];
  	x = ix[i+2];
  	y = ix[i+3];
! 	bitsWritten += L3_huffman_coder_count1( pph, h, v, w, x, y );
      }
      c1bits = bitsWritten - bvbits;
      if ( (stuffingBits = gi->part2_3_length - gi->part2_length - bitsWritten) )
      {
  	int stuffingWords = stuffingBits / 32;
  	int remainingBits = stuffingBits % 32;
- 	assert( stuffingBits > 0 );
  
  	/*
  	  Due to the nature of the Huffman code
  	  tables, we will pad with ones
--- 736,756 ----
  	w = ix[i+1];
  	x = ix[i+2];
  	y = ix[i+3];
! 	//	bitsWritten += L3_huffman_coder_count1( pph, h, v, w, x, y );
! 	bitsWritten += L3_huffman_coder_count1( pph, &ht[gi->count1table_select + 32], v, w, x, y );
      }
      c1bits = bitsWritten - bvbits;
+ #ifdef DEBUG
+     fprintf(stderr,"## Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d ##\n",
+ 	    bvbits, c1bits, gi->part2_length, gi->part2_3_length );
+ #endif
      if ( (stuffingBits = gi->part2_3_length - gi->part2_length - bitsWritten) )
      {
  	int stuffingWords = stuffingBits / 32;
  	int remainingBits = stuffingBits % 32;
  
+         printf("opps - adding stuffing bits = %i ... \n",stuffingBits);
+ 	assert( stuffingBits > 0 );
  	/*
  	  Due to the nature of the Huffman code
  	  tables, we will pad with ones
***************
*** 719,725 ****
      }
      assert( bitsWritten == gi->part2_3_length - gi->part2_length );
  #ifdef DEBUG
!     printf( "#### %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ####\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
--- 763,769 ----
      }
      assert( bitsWritten == gi->part2_3_length - gi->part2_length );
  #ifdef DEBUG
!     fprintf(stderr, "## %d Huffman bits written (%02d + %02d), part2_length = %d, part2_3_length = %d, %d stuffing ##\n",
  	    bitsWritten, bvbits, c1bits, gi->part2_length, gi->part2_3_length, stuffingBits );
  #endif
  }
***************
*** 746,755 ****
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      
!     p = v + (w << 1) + (x << 2) + (y << 3);
      huffbits = h->table[p];
      len = h->hlen[ p ];
!     *pph = BF_addEntry( *pph,  huffbits, len );
      totalBits += len;
      if ( v )
      {
--- 790,801 ----
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      
!     // bug fix from Leonid A. Kulakov 9/1999:
!     p = (v << 3) + (w << 2) + (x << 1) + y;  
! 
      huffbits = h->table[p];
      len = h->hlen[ p ];
!     *pph = BF_addEntry(*pph, (uint32) huffbits, len);
      totalBits += len;
      if ( v )
      {
***************
*** 781,787 ****
  int
  HuffmanCode( int table_select, int x, int y, unsigned int *code, unsigned int *ext, int *cbits, int *xbits )
  {
!     unsigned signx, signy, linbitsx, linbitsy, linbits, xlen, ylen, idx;
      struct huffcodetab *h;
  
      *cbits = 0;
--- 827,833 ----
  int
  HuffmanCode( int table_select, int x, int y, unsigned int *code, unsigned int *ext, int *cbits, int *xbits )
  {
!     unsigned signx, signy, linbitsx, linbitsy, linbits, ylen, idx;
      struct huffcodetab *h;
  
      *cbits = 0;
***************
*** 795,801 ****
      signx = abs_and_sign( &x );
      signy = abs_and_sign( &y );
      h = &(ht[table_select]);
-     xlen = h->xlen;
      ylen = h->ylen;
      linbits = h->linbits;
      linbitsx = linbitsy = 0;
--- 841,846 ----
diff -r -c -N encoder/l3bitstream.h lame3.50/l3bitstream.h
*** encoder/l3bitstream.h	Wed Jan 22 02:43:15 1997
--- lame3.50/l3bitstream.h	Tue Oct 12 14:56:11 1999
***************
*** 14,20 ****
  #ifndef L3_BITSTREAM_H
  #define L3_BITSTREAM_H
  
! #include "common.h"
  #include "encoder.h"
  
  void III_format_bitstream( int              bitsPerFrame,
--- 14,20 ----
  #ifndef L3_BITSTREAM_H
  #define L3_BITSTREAM_H
  
! #include "util.h"
  #include "encoder.h"
  
  void III_format_bitstream( int              bitsPerFrame,
***************
*** 28,34 ****
  			   int              anc_bits );
  
  int HuffmanCode( int table_select, int x, int y, unsigned *code, unsigned int *extword, int *codebits, int *extbits );
! void III_FlushBitstream();
  
  int abs_and_sign( int *x ); /* returns signx and changes *x to abs(*x) */
  
--- 28,34 ----
  			   int              anc_bits );
  
  int HuffmanCode( int table_select, int x, int y, unsigned *code, unsigned int *extword, int *codebits, int *extbits );
! void III_FlushBitstream(void);
  
  int abs_and_sign( int *x ); /* returns signx and changes *x to abs(*x) */
  
diff -r -c -N encoder/l3psy.c lame3.50/l3psy.c
*** encoder/l3psy.c	Wed Jan 22 02:43:15 1997
--- lame3.50/l3psy.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1033 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: l3psy.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: l3psy.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
-  *                              replace of floats with FLOAT          *
-  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
-  * 3/16/92  Masahiro Iwadare	Modification for Layer III            *
-  * 17/4/93  Masahiro Iwadare    Updated for IS Modification           *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- #include "l3psy.h"
- #include "l3side.h"
- #include <assert.h>
- 
- #define maximum(x,y) ( (x>y) ? x : y )
- #define minimum(x,y) ( (x<y) ? x : y )
- 
- void L3para_read( double sfreq, int numlines[CBANDS], int partition_l[HBLKSIZE],
- 		  double minval[CBANDS], double qthr_l[CBANDS], double norm_l[CBANDS],
- 		  double s3_l[CBANDS][CBANDS], int partition_s[HBLKSIZE_s], double qthr_s[CBANDS_s],
- 		  double norm_s[CBANDS_s], double SNR_s[CBANDS_s],
- 		  int cbw_l[SBMAX_l], int bu_l[SBMAX_l], int bo_l[SBMAX_l],
- 		  double w1_l[SBMAX_l], double w2_l[SBMAX_l],
- 		  int cbw_s[SBMAX_s], int bu_s[SBMAX_s], int bo_s[SBMAX_s],
- 		  double w1_s[SBMAX_s], double w2_s[SBMAX_s] );
- 									
- void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
- 		    double sfreq, double ratio_d[21], double ratio_ds[12][3],
- 		    double *pe, gr_info *cod_info )
- {
-     static double ratio[2][21];
-     static double ratio_s[2][12][3];
-     int blocktype;
-     unsigned int   b, i, j, k;
-     double         r_prime, phi_prime; /* not FLOAT */
-     FLOAT          freq_mult, bval_lo, min_thres, sum_energy;
-     double         tb, temp1,temp2,temp3;
- 
-     /*         nint(); Layer III */
-     double   thr[CBANDS];
- 
- /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
- /* to be remembered for the unpredictability measure.  For "r" and        */
- /* "phi_sav", the first index from the left is the channel select and     */
- /* the second index is the "age" of the data.                             */
- 
- 
-    static FLOAT window_s[BLKSIZE_s] ;
-  static int     new = 0, old = 1, oldest = 0;
-  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
-  static double 	cw[HBLKSIZE], eb[CBANDS];
-  static double 	ctb[CBANDS];
-  static double	SNR_l[CBANDS], SNR_s[CBANDS_s];
-  static int	init_L3;
-  static double	minval[CBANDS],qthr_l[CBANDS],norm_l[CBANDS];
-  static double	qthr_s[CBANDS_s],norm_s[CBANDS_s];
-  static double	nb_1[2][CBANDS], nb_2[2][CBANDS];
-  static double	s3_l[CBANDS][CBANDS]; /* s3_s[CBANDS_s][CBANDS_s]; */
- 
- /* Scale Factor Bands */
-  static int	cbw_l[SBMAX_l],bu_l[SBMAX_l],bo_l[SBMAX_l] ;
-  static int	cbw_s[SBMAX_s],bu_s[SBMAX_s],bo_s[SBMAX_s] ;
-  static double	w1_l[SBMAX_l], w2_l[SBMAX_l];
-  static double	w1_s[SBMAX_s], w2_s[SBMAX_s];
-  static double	en[SBMAX_l],   thm[SBMAX_l] ;
-  static int	blocktype_old[2] ;
-  int	sb,sblock;
-  static int	partition_l[HBLKSIZE],partition_s[HBLKSIZE_s];
- 
- 
- /* The following static variables are constants.                           */
- 
-  static double  nmt = 5.5;
- 
-  static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
-                                920, 1080, 1270,1480,1720,2000,2320, 2700,
-                               3150, 3700, 4400,5300,6400,7700,9500,12000,
-                              15500,25000,30000};
- 
-  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
-                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
- 
- /* The following pointer variables point to large areas of memory         */
- /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
- /* allocation is used in order to avoid stack frame or data area          */
- /* overflow errors that otherwise would have occurred at compile time     */
- /* on the Macintosh computer.                                             */
- 
-  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
-  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
-  static FLOAT	energy_s[3][256];
-  static FLOAT phi_s[3][256] ; /* 256 samples not 129 */
-  FLOAT          *c, *fthr;
-  F32            *snrtmp;
- 
-  static	int	*numlines ;
-  static int     *partition;
-  static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
-  static double  *tmn;
-  static FCB     *s;
-  static FHBLK   *lthr;
-  static F2HBLK  *r, *phi_sav;
- 
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
- 
-  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
-  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
-  nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
-  cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
-  ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
-  bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
-  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
-  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
-  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
-  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
-  c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
-  fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
-  snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
- 
-     assert( lay == 3 );
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
-      numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
-      partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
-      cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
-      rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
-      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
-      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr"); 
-      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
-      s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
-      lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
-      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
-      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
- 
- /*#if 0 */
-      i = sfreq + 0.5;
-      switch(i){
-         case 32000: sfreq_idx = 0; break;
-         case 44100: sfreq_idx = 1; break;
-         case 48000: sfreq_idx = 2; break;
-         default:    printf("error, invalid sampling frequency: %d Hz\n",i);
-         exit(-1);
-      }
-      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
-      read_absthr(absthr, sfreq_idx);
-      switch(lay){
- 	case 1: sync_flush=576; flush=384; syncsize=1024; break;
- 	case 2: sync_flush=480; flush=576; syncsize=1056; break;
- 	case 3: sync_flush=768; flush=576; syncsize=1344; break;
-        default: printf("Bad lay value:(%d)",lay); exit(-1); break;
-      }
- /* #endif */
- 
- /* calculate HANN window coefficients */
- /*   for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0)));*/
-      for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
-      for(i=0;i<BLKSIZE_s;i++)window_s[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE_s));
- /* reset states used in unpredictability measure */
-      for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
-         lthr[0][i] = 60802371420160.0;
-         lthr[1][i] = 60802371420160.0;
-      }
- /*****************************************************************************
-  * Initialization: Compute the following constants for use later             *
-  *    partition[HBLKSIZE] = the partition number associated with each        *
-  *                          frequency line                                   *
-  *    cbval[CBANDS]       = the center (average) bark value of each          *
-  *                          partition                                        *
-  *    numlines[CBANDS]    = the number of frequency lines in each partition  *
-  *    tmn[CBANDS]         = tone masking noise                               *
-  *****************************************************************************/
- /* compute fft frequency multiplicand */
-      freq_mult = sfreq/BLKSIZE;
-  
- /* calculate fft frequency, then bval of each line (use fthr[] as tmp storage)*/
-      for(i=0;i<HBLKSIZE;i++){
-         temp1 = i*freq_mult;
-         j = 1;
-         while(temp1>crit_band[j])j++;
-         fthr[i]=j-1+(temp1-crit_band[j-1])/(crit_band[j]-crit_band[j-1]);
-      }
-      partition[0] = 0;
- /* temp2 is the counter of the number of frequency lines in each partition */
-      temp2 = 1;
-      cbval[0]=fthr[0];
-      bval_lo=fthr[0];
-      for(i=1;i<HBLKSIZE;i++){
-         if((fthr[i]-bval_lo)>0.33){
-            partition[i]=partition[i-1]+1;
-            cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-            cbval[partition[i]] = fthr[i];
-            bval_lo = fthr[i];
-            numlines[partition[i-1]] = temp2;
-            temp2 = 1;
-         }
-         else {
-            partition[i]=partition[i-1];
-            cbval[partition[i]] += fthr[i];
-            temp2++;
-         }
-      }
-      numlines[partition[i-1]] = temp2;
-      cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-  
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
-      for(j=0;j<CBANDS;j++){
-         for(i=0;i<CBANDS;i++){
-            temp1 = (cbval[i] - cbval[j])*1.05;
-            if(temp1>=0.5 && temp1<=2.5){
-               temp2 = temp1 - 0.5;
-               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
-            }
-            else temp2 = 0;
-            temp1 += 0.474;
-            temp3 = 15.811389+7.5*temp1-17.5*sqrt((double) (1.0+temp1*temp1));
-            if(temp3 <= -100) s[i][j] = 0;
-            else {
-               temp3 = (temp2 + temp3)*LN_TO_LOG10;
-               s[i][j] = exp(temp3);
-            }
-         }
-      }
- 
-   /* Calculate Tone Masking Noise values */
-      for(j=0;j<CBANDS;j++){
-         temp1 = 15.5 + cbval[j];
-         tmn[j] = (temp1>24.5) ? temp1 : 24.5;
-   /* Calculate normalization factors for the net spreading functions */
-         rnorm[j] = 0;
-         for(i=0;i<CBANDS;i++){
-            rnorm[j] += s[j][i];
-         }
-      }
-      init++;
-  }
-  
- /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
- 	for ( i=0; i<lay; i++)
-   {
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-   for (j=0; j<syncsize; j++)
-   {
-     if (j < (sync_flush) )
-       savebuf[j] = savebuf[j+flush];
-     else
-       savebuf[j] = *buffer++;
- 
- /**window data with HANN window***********************************************/
-     if (j<BLKSIZE)
-     {
-       wsamp_r[j] = window[j]*((FLOAT) savebuf[j]); 
-       wsamp_i[j] = 0;
-     }
-   }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- 	   temp1 = r[chn][new][j] * cos((double) phi[j])
- 		   - r_prime * cos(phi_prime);
- 	   temp2=r[chn][new][j] * sin((double) phi[j])
- 		   - r_prime * sin(phi_prime);
-            temp3=r[chn][new][j] + fabs(r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*only update data "age" pointers after you are done with the second channel */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-         if(lay==2 || chn==1){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
- /*         tb = -0.434294482*log((double) cb[j])-0.301029996; */
-            tb = -0.43 *log((double) cb[j]) - 0.29 ;
-            if(tb<0.0) tb=0.0; else if(tb>1.0) tb=1.0;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
-            temp1=nb[partition[j]];		 /* preliminary threshold */
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            min_thres = fthr[j];
-            sum_energy = energy[j];
-            for(k=1;k<17;k++){
-               if(min_thres>fthr[j+k]) min_thres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(min_thres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            min_thres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               min_thres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/min_thres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)		/* if(lay==2 && chn==2) MI */
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
- 
- /*************************************************************************/
- /**       LAYER 3                                                        */
- /*************************************************************************/
- 
-    case 3:
- 	if ( init_L3 == 0 )
- 	{
- 	    L3para_read( sfreq,numlines,partition_l,minval,qthr_l,norm_l,s3_l,
- 			 partition_s,qthr_s,norm_s,SNR_s,
- 			 cbw_l,bu_l,bo_l,w1_l,w2_l, cbw_s,bu_s,bo_s,w1_s,w2_s );
- 	    init_L3 ++ ;
- 	}
- 	
- 	for ( j = 0; j < 21; j++ )
- 	    ratio_d[j] = ratio[chn][j];
- 	for ( j = 0; j < 12; j++ )
- 	    for ( i = 0; i < 3; i++ )
- 		ratio_ds[j][i] = ratio_s[chn][j][i];
- 	
- 	if ( chn == 0 )
- 	    if ( new == 0 )
- 	    {
- 		new = 1;
- 		old = 0;
- 		oldest = 1;
- 	    }
- 	    else
- 	    {
- 		new = 0;
- 		old = 1;
- 		oldest = 0;
- 	    }
- 
- 
- /**********************************************************************
- *  Delay signal by sync_flush=768 samples                             *
- **********************************************************************/
- 	
- 	for ( j = 0; j < sync_flush; j++ ) /* for long window samples */
- 	    savebuf[j] = savebuf[j+flush];
- 	
- 	for ( j = sync_flush; j < syncsize; j++ )
- 	    savebuf[j] = *buffer++;
- 	
- 	for ( j = 0; j < BLKSIZE; j++ )
- 	{ /**window data with HANN window**/
- 	    wsamp_r[j] = window[j] * savebuf[j];  
- 	    wsamp_i[j] = 0.0;
- 	}
- 
- 
- /**********************************************************************
- *    compute unpredicatability of first six spectral lines            * 
- **********************************************************************/
- 
- 	fft( wsamp_r, wsamp_i, energy, phi, 1024 );		/**long FFT**/
- 	for ( j = 0; j < 6; j++ )
- 	{	 /* calculate unpredictability measure cw */
- 	    r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
- 	    phi_prime = 2.0 * phi_sav[chn][old][j]-phi_sav[chn][oldest][j];
- 	    r[chn][new][j] = sqrt((double) energy[j]);
- 	    phi_sav[chn][new][j] = phi[j];
- 	    temp1 = r[chn][new][j] * cos((double) phi[j])
- 		- r_prime * cos(phi_prime);
- 	    temp2 = r[chn][new][j] * sin((double) phi[j])
- 		- r_prime * sin(phi_prime);
- 	    temp3=r[chn][new][j] + fabs(r_prime);
- 	    
- 	    if ( temp3 != 0.0 )
- 		cw[j] = sqrt( temp1*temp1+temp2*temp2 ) / temp3;
- 	    else
- 		cw[j] = 0;
- 	}
- 
- 
- /**********************************************************************
- *     compute unpredicatibility of next 200 spectral lines            *
- **********************************************************************/ 
- 	for ( sblock = 0; sblock < 3; sblock++ )
- 	{ /**window data with HANN window**/
- 	    for ( j = 0, k = 128 * (2 + sblock); j < 256; j++, k++ )
- 	    {
- 		wsamp_r[j] = window_s[j]* savebuf[k]; 
- 		wsamp_i[j] = 0.0;
- 	    }							/* short FFT*/
- 	    
- 	    fft( wsamp_r, wsamp_i, &energy_s[sblock][0], &phi_s[sblock][0], 256 );
-         }
-  
-         sblock = 1;
- 
- 	for ( j = 6; j < 206; j += 4 )
- 	{/* calculate unpredictability measure cw */
- 	    double r2, phi2, temp1, temp2, temp3;
- 	    
- 	    k = (j+2) / 4; 
- 	    r_prime = 2.0 * sqrt((double) energy_s[0][k])
- 		- sqrt((double) energy_s[2][k]);
- 	    phi_prime = 2.0 * phi_s[0][k] - phi_s[2][k];
- 	    r2 = sqrt((double) energy_s[1][k]);
- 	    phi2 = phi_s[1][k];
- 	    temp1 = r2 * cos( phi2 ) - r_prime * cos( phi_prime );
- 	    temp2 = r2 * sin( phi2 ) - r_prime * sin( phi_prime );
- 	    temp3 = r2 + fabs( r_prime );
- 	    if ( temp3 != 0.0 )
- 		cw[j] = sqrt( temp1 * temp1 + temp2 * temp2 ) / temp3;
- 	    else
- 		cw[j] = 0.0;
- 	    cw[j+1] = cw[j+2] = cw[j+3] = cw[j];
- 	}
- 
- 
- /**********************************************************************
- *    Set unpredicatiblility of remaining spectral lines to 0.4        *
- **********************************************************************/
- 	for ( j = 206; j < HBLKSIZE; j++ )
- 	    cw[j] = 0.4;
- 	
- 
- 
- /**********************************************************************
- *    Calculate the energy and the unpredictability in the threshold   *
- *    calculation partitions                                           *
- **********************************************************************/
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    eb[b] = 0.0;
- 	    cb[b] = 0.0;
- 	}
- 	for ( j = 0; j < HBLKSIZE; j++ )
- 	{
- 	    int tp = partition_l[j];
- 	    if ( tp >= 0 )
- 	    {
- 		eb[tp] += energy[j];
- 		cb[tp] += cw[j] * energy[j];
- 	    }
- 	}
- 
- 
- /**********************************************************************
- *      convolve the partitioned energy and unpredictability           *
- *      with the spreading function, s3_l[b][k]                        *
- ******************************************************************** */
- 	
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    ecb[b] = 0.0;
- 	    ctb[b] = 0.0;
- 	}
- 	for ( b = 0;b < CBANDS; b++ )
- 	{
- 	    for ( k = 0; k < CBANDS; k++ )
- 	    {
- 		ecb[b] += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
- 		ctb[b] += s3_l[b][k] * cb[k];
- 	    }
- 	}
- 
- 	/* calculate the tonality of each threshold calculation partition */
- 	/* calculate the SNR in each threshhold calculation partition */
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    double cbb,tbb;
- 	    if (ecb[b] != 0.0 )
-                 {
- 		cbb = ctb[b]/ecb[b];
-                 if (cbb <0.01) cbb = 0.01;
- 		cbb = log( cbb);
-                 }
- 	    else
- 		cbb = 0.0 ;
- 	    tbb = -0.299 - 0.43*cbb;  /* conv1=-0.299, conv2=-0.43 */
- 	    tbb = minimum( 1.0, maximum( 0.0, tbb) ) ;  /* 0<tbb<1 */
- 	    SNR_l[b] = maximum( minval[b], 29.0*tbb+6.0*(1.0-tbb) );
- 	}	/* TMN=29.0,NMT=6.0 for all calculation partitions */
- 	
- 	for ( b = 0; b < CBANDS; b++ ) /* calculate the threshold for each partition */
- 	    nb[b] = ecb[b] * norm_l[b] * exp( -SNR_l[b] * LN_TO_LOG10 );
- 
- 	for ( b = 0; b < CBANDS; b++ )
- 	{ /* pre-echo control */
- 	    double temp_1; /* BUG of IS */
- 	    temp_1 = minimum( nb[b], minimum(2.0*nb_1[chn][b],16.0*nb_2[chn][b]) );
- 	    thr[b] = maximum( qthr_l[b], temp_1 );/* rpelev=2.0, rpelev2=16.0 */
- 	    nb_2[chn][b] = nb_1[chn][b];
- 	    nb_1[chn][b] = nb[b];
- 	}
- 
- 
- 	*pe = 0.0;		/*  calculate percetual entropy */
- 	for ( b = 0; b < CBANDS; b++ )
- 	{
- 	    double tp ;
- 	    tp = minimum( 0.0, log((thr[b]+1.0) / (eb[b]+1.0) ) ) ; /*not log*/
- 	    *pe -= numlines[b] * tp ;
- 	}	/* thr[b] -> thr[b]+1.0 : for non sound portition */
- 	
- #define switch_pe  1800
-         blocktype = NORM_TYPE;
- 	
- 
- 	if ( *pe < switch_pe )
- 	{				/* no attack : use long blocks */
- 	    switch( blocktype_old[chn] ) 
- 	    {
- 	      case NORM_TYPE:
- 	      case STOP_TYPE:
- 		blocktype = NORM_TYPE;
- 		break;
-     
- 	      case SHORT_TYPE:
- 		blocktype = STOP_TYPE;
- 		break;
-     
- 	      case START_TYPE:
- 		fprintf( stderr, "Error in block selecting\n" );
- 		abort();
- 		break; /* problem */
- 	    }
- 
- 	    /* threshold calculation (part 2) */
- 	    for ( sb = 0; sb < SBMAX_l; sb++ )
- 	    {
- 		en[sb] = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
- 		thm[sb] = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
- 		for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
- 		{
- 		    en[sb]  += eb[b];
- 		    thm[sb] += thr[b];
- 		}
- 		if ( en[sb] != 0.0 )
- 		    ratio[chn][sb] = thm[sb]/en[sb];
- 		else
- 		    ratio[chn][sb] = 0.0;
- 	    }
- 	}
- 	else 
- 	{
- 	    /* attack : use short blocks */
- 	    blocktype = SHORT_TYPE;
- 	    
- 	    if ( blocktype_old[chn] == NORM_TYPE ) 
- 		blocktype_old[chn] = START_TYPE;
- 	    if ( blocktype_old[chn] == STOP_TYPE )
- 		blocktype_old[chn] = SHORT_TYPE ;
- 	    
- 	    /* threshold calculation for short blocks */
- 	    
- 	    for ( sblock = 0; sblock < 3; sblock++ )
- 	    {
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    eb[b] = 0.0;
- 		    ecb[b] = 0.0;
- 		}
- 		for ( j = 0; j < HBLKSIZE_s; j++ )
- 		    eb[partition_s[j]] += energy_s[sblock][j];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		    for ( k = 0; k < CBANDS_s; k++ )
- 			ecb[b] += s3_l[b][k] * eb[k];
- 		for ( b = 0; b < CBANDS_s; b++ )
- 		{
- 		    nb[b] = ecb[b] * norm_l[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
- 		    thr[b] = maximum (qthr_s[b],nb[b]);
- 		}
- 		for ( sb = 0; sb < SBMAX_s; sb++ )
- 		{
- 		    en[sb] = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
- 		    thm[sb] = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
- 		    for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
- 		    {
- 			en[sb] += eb[b];
- 			thm[sb] += thr[b];
- 		    }
- 		    if ( en[sb] != 0.0 )
- 			ratio_s[chn][sb][sblock] = thm[sb]/en[sb];
- 		    else
- 			ratio_s[chn][sb][sblock] = 0.0;
- 		}
- 	    }
- 	} 
- 	
- 	cod_info->block_type = blocktype_old[chn];
- 	blocktype_old[chn] = blocktype;
- 
- 	if ( cod_info->block_type == NORM_TYPE )
- 	    cod_info->window_switching_flag = 0;
- 	else
- 	    cod_info->window_switching_flag = 1;
- 	cod_info->mixed_block_flag = 0;
- 	break;
- 
- 
-   default:
-      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
-  }
- 
- /* These mem_free() calls must correspond with the mem_alloc() calls     */
- /* used at the beginning of this function to simulate "automatic"        */
- /* variables placed on the stack.                                        */
- 
-  mem_free((void **) &grouped_c);
-  mem_free((void **) &grouped_e);
-  mem_free((void **) &nb);
-  mem_free((void **) &cb);
-  mem_free((void **) &ecb);
-  mem_free((void **) &bc);
-  mem_free((void **) &wsamp_r);
-  mem_free((void **) &wsamp_i);
-  mem_free((void **) &phi);
-  mem_free((void **) &energy);
-  mem_free((void **) &c);
-  mem_free((void **) &fthr);
-  mem_free((void **) &snrtmp);
- }
- #ifdef DEBUG
- #undef DEBUG
- #endif
- 
- 
- void L3para_read(double sfreq, int *numlines, int *partition_l, double *minval, double *qthr_l, double *norm_l, double (*s3_l)[63], int *partition_s, double *qthr_s, double *norm_s, double *SNR, int *cbw_l, int *bu_l, int *bo_l, double *w1_l, double *w2_l, int *cbw_s, int *bu_s, int *bo_s, double *w1_s, double *w2_s)
- {
-    double freq_tp;
-    static double bval_l[CBANDS], bval_s[CBANDS];
-    int   cbmax, cbmax_tp;
-    static double s3_s[CBANDS][CBANDS];
- 
-    FILE *fin;
-    char tp[256];
-    int  sbmax ;
-    int  i,j,k,k2,loop, part_max ;
- 
-    fin = OpenTableFile( "psy_data" );
-    if (fin == NULL)
-        exit( 1 );
- 
- /* Read long block data */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
- 	cbmax_tp++;
- #ifdef DEBUG
- 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
- #endif
- 
- 	if (sfreq == freq_tp )
- 	  {
- 	     cbmax = cbmax_tp;
- 	     for(i=0,k2=0;i<cbmax_tp;i++)
- 	       {
- 		fscanf(fin,
- 		  "No=%d #lines=%d minval=%lf qthr=%lf norm=%lf bval=%lf\n",
- 		  &j,&numlines[i],&minval[i],&qthr_l[i],&norm_l[i],&bval_l[i]);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data\"");
- 		   exit(-1);
- 	         }
- 		for(k=0;k<numlines[i];k++)
- 		  partition_l[k2++] = i ;
- #ifdef DEBUG
-      printf("No=%2d #lines=%2d minval=%4.1f qthr=%8.3f norm=%5.3f bval=%8.3f\n",
- 		     i,numlines[i],minval[i],qthr_l[i],norm_l[i],bval_l[i] );
- #endif
- 		}
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<cbmax_tp;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"No=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
- #ifdef DEBUG
- 	printf("freq = %f\n",sfreq);
- #endif
- 	  part_max = cbmax ;
-           for(i=0;i<part_max;i++)
- 	  {
- 	  double tempx,x,tempy,temp;
-             for(j=0;j<part_max;j++)
- 	    {
-              tempx = (bval_l[i] - bval_l[j])*1.05;
-              if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
-                else    tempx = (bval_l[i] - bval_l[j])*1.5;
- /*             if (j>=i) tempx = (bval_l[j] - bval_l[i])*3.0;
-                else    tempx = (bval_l[j] - bval_l[i])*1.5; */
-              if(tempx>=0.5 && tempx<=2.5)
- 	     {
-                temp = tempx - 0.5;
-                x = 8.0 * (temp*temp - 2.0 * temp);
-              }
-              else x = 0.0;
-              tempx += 0.474;
-              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
-              if (tempy <= -60.0) s3_l[i][j] = 0.0;
-              else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
- #ifdef DEBUG_S3
- 	     printf("s[%d][%d]=%f\n",i,j,s3_l[i][j]);
- #endif
- 
- #ifdef DEBUGP
- 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
- 	   minval[i] = bmax[j-1];
- 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
- #endif
-             }
-           }
- 
- 
- /* Read short block data */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq = %lf partition = %d\n",&freq_tp,&cbmax_tp);
- 	cbmax_tp++;
- #ifdef DEBUG
- 	printf("freq = %f partition = %d\n",freq_tp,cbmax);
- #endif
- 
- 	if (sfreq == freq_tp )
- 	  {
- 	     cbmax = cbmax_tp;
- 	     for(i=0,k2=0;i<cbmax_tp;i++)
- 	       {
- 		fscanf(fin,
- 		  "No=%d #lines=%d qthr=%lf norm=%lf SNR=%lf bval=%lf\n",
- 		   &j,&numlines[i],&qthr_s[i],&norm_s[i],&SNR[i],&bval_s[i]);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data\"");
- 		   exit(-1);
- 	         }
- 		for(k=0;k<numlines[i];k++)
- 		  partition_s[k2++] = i ;
- #ifdef DEBUG
-       printf("No=%2d #lines=%2d qthr=%8.3f norm=%5.3f SNR=%6.3f bval=%8.3f\n",
- 		      i,numlines[i],qthr_s[i],norm_s[i],SNR[i],bval_s[i] );
- #endif
- 		}
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<cbmax_tp;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"No=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
- #ifdef DEBUG_S3
- fpp=fopen("s3_s","w");
- #endif
- 	  part_max = cbmax ;
-           for(i=0;i<part_max;i++)
- 	  {
- 	  double tempx,x,tempy,temp;
-             for(j=0;j<part_max;j++)
- 	    {
-              tempx = (bval_s[i] - bval_s[j])*1.05;
-              if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
-                else    tempx = (bval_s[i] - bval_s[j])*1.5;
-              if(tempx>=0.5 && tempx<=2.5)
- 	     {
-                temp = tempx - 0.5;
-                x = 8.0 * (temp*temp - 2.0 * temp);
-              }
-              else x = 0.0;
-              tempx += 0.474;
-              tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
-              if (tempy <= -60.0) s3_s[i][j] = 0.0;
-              else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
- #ifdef DEBUG_S3
- 	     fprintf(fpp,"s3_s[%d][%d]=%f\n",i,j,s3_s[i][j]);
- #endif
- #ifdef DEBUGP
- 	     printf("j=%d i=%d tempy=%f s[i][j]=%f \n",i,j,tempy,s[i][j]);
- 	   minval[i] = bmax[j-1];
- 	   printf("minval[%d] = %f, j-1=%d %f\n",i, minval[i] , j,fthr[i]) ;
- #endif
-             }
-           }
- #ifdef DEBUG_S3
- 	fclose(fpp);
- #endif
- /* Read long block data for converting threshold calculation 
-    partitions to scale factor bands */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
- 	sbmax++;
- #ifdef DEBUG
- 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
- #endif
- 
- 	if (sfreq == freq_tp)
- 	  {
- 	     for(i=0;i<sbmax;i++)
- 	      {
- 		fscanf(fin,
- 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
- 		  &j,&cbw_l[i],&bu_l[i],&bo_l[i],&w1_l[i],&w2_l[i]);
- 	        if (j!=i)
- 	         { printf("30:please check \"psy_data\"\n");
- 		   exit(-1);
- 	         }
- #ifdef DEBUG
- 		printf(
- 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
- 		  j,cbw_l[i],bu_l[i],bo_l[i],w1_l[i],w2_l[i]);
- #endif
- 	        if (i!=0)
- 		 if ( (bo_l[i] != (bu_l[i]+cbw_l[i])) ||
- 				 (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
- 	         { printf("31:please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	      }
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<sbmax;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"sb=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- /* Read short block data for converting threshold calculation 
-    partitions to scale factor bands */
- 
-       for(loop=0;loop<6;loop++)
-       {
- 	fscanf(fin,"freq=%lf sb=%d\n",&freq_tp,&sbmax);
- 	sbmax++;
- #ifdef DEBUG
- 	printf("freq = %f sb = %d\n",freq_tp,sbmax);
- #endif
- 
- 	if (sfreq == freq_tp)
- 	  {
- 	     for(i=0;i<sbmax;i++)
- 	      {
- 		fscanf(fin,
- 		  "sb=%d cbw=%d bu=%d bo=%d w1=%lf w2=%lf\n",
- 		  &j,&cbw_s[i],&bu_s[i],&bo_s[i],&w1_s[i],&w2_s[i]);
- 	        if (j!=i)
- 	         { printf("30:please check \"psy_data\"\n");
- 		   exit(-1);
- 	         }
- #ifdef DEBUG
- 		printf(
- 		  "sb=%2d cbw=%1d bu=%2d bo=%2d w1=%5.3f w2=%5.3f\n",
- 		  j,cbw_s[i],bu_s[i],bo_s[i],w1_s[i],w2_s[i]);
- #endif
- 	        if (i!=0)
- 		 if ( (bo_s[i] != (bu_s[i]+cbw_s[i])) ||
- 				 (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
- 	         { printf("31:please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	      }
- 	   }
- 	   else
- 	   {
- 	     for(j=0;j<sbmax;j++)
- 	       {
- 		fgets(tp,255,fin);
- 	        sscanf(tp,"sb=%d %s\n",&i,tp);
- 	        if (j!=i)
- 	         { printf("please check \"psy_data.\"\n");
- 		   exit(-1);
- 	         }
- 	       }
- 	   }
-        }
- 
- }
--- 0 ----
diff -r -c -N encoder/l3psy.h lame3.50/l3psy.h
*** encoder/l3psy.h	Wed Jan 22 02:43:16 1997
--- lame3.50/l3psy.h	Wed Dec 31 17:00:00 1969
***************
*** 1,37 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: l3psy.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: l3psy.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef L3PSY_DOT_H_
- #define L3PSY_DOT_H_
- /* #define CBANDS 63 */
- #define CBANDS_s 42
- #define BLKSIZE_s 256
- #define HBLKSIZE_s 129
- #define TCBMAX_l 63
- #define TCBMAX_s 42
- #define SBMAX_l 21
- #define SBMAX_s 12
- 
- /* #define switch_pe        1800 */
- #define NORM_TYPE       0
- #define START_TYPE      1
- #define SHORT_TYPE      2
- #define STOP_TYPE       3
- 
- /* l3psy.c */
- #include "l3side.h"
- void L3psycho_anal( short int *buffer, short int savebuf[1344], int chn, int lay, FLOAT snr32[32],
- 					double sfreq, double ratio_d[21], double ratio_ds[12][3],
- 					double *pe, gr_info *cod_info );
- /* void read_absthr(float *absthr, int table); */
- #endif
--- 0 ----
diff -r -c -N encoder/l3side.h lame3.50/l3side.h
*** encoder/l3side.h	Wed Jan 22 02:43:16 1997
--- lame3.50/l3side.h	Tue Sep 14 18:21:02 1999
***************
*** 25,32 ****
  
  /* #define CBLIMIT_SHORT 12 */
  
- void l3deco();
- 
  typedef double	D576[576];
  typedef int	I576[576];
  typedef double	D192_3[192][3];
--- 25,30 ----
***************
*** 39,61 ****
  
  
  typedef struct {
! 	double	l[2][2][21];
! 	double	s[2][2][12][3];
  } III_psy_ratio;
  
  typedef struct {
  	double	l[2][2][21];
  	double	s[2][2][12][3];
  } III_psy_xmin;
- 
- typedef struct {
- 	double	xr[576];
- 	double	xr_s[3][192];
- 	double	xmin[21];
- 	double	xmin_s[3][192];
- 	int	ix[576];
- 	int	ix_s[3][192];
- 	} III_input3; /* ch */
  
  typedef struct {
  	unsigned part2_3_length;
--- 37,50 ----
  
  
  typedef struct {
! 	double	l[2][4][21];
! 	double	s[2][4][12][3];
  } III_psy_ratio;
  
  typedef struct {
  	double	l[2][2][21];
  	double	s[2][2][12][3];
  } III_psy_xmin;
  
  typedef struct {
  	unsigned part2_3_length;
diff -r -c -N encoder/lame.c lame3.50/lame.c
*** encoder/lame.c	Wed Dec 31 17:00:00 1969
--- lame3.50/lame.c	Wed Oct 27 16:14:58 1999
***************
*** 0 ****
--- 1,1431 ----
+ /*
+  *	LAME MP3 encoding engine
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include <assert.h>
+ 
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ #include "util.h"
+ #include "globalflags.h"
+ #include "psymodel.h"
+ #include "fastmdct.h"
+ #include "quantize.h"
+ #include "l3bitstream.h"
+ #include "reservoir.h"
+ #include "formatBitstream.h"
+ #include "version.h"
+ #include "VbrTag.h"
+ #include "id3tag.h"
+ #include "get_audio.h"
+ 
+ 
+ 
+ /* Global flags.  defined extern in globalflags.h */
+ /* default values set in lame_init() */
+ int allow_diff_short;
+ int ATHonly;
+ int autoconvert;
+ int experimentalX;
+ int experimentalY;
+ int experimentalZ;
+ int force_ms;
+ int fast_mode;
+ long int frameNum;
+ int gtkflag;
+ int g_bWriteVbrTag;
+ int gpsycho;
+ int highq;
+ sound_file_format input_format;
+ int lame_nowrite;
+ double resample_ratio;
+ int sfb21;
+ int silent;
+ int swapbytes;           /* force byte swapping */
+ long totalframes;        /* frames: 0..totalframes-1 */
+ int VBR;
+ int VBR_q;
+ int VBR_min_bitrate;   /* 32kbs */
+ int VBR_max_bitrate;  /* 256kbs */
+ int voice_mode;
+ 
+ 
+ 
+ /* Global variable definitions for "musicin.c" */
+ ID3TAGDATA id3tag;
+ struct stat sb;
+ Bit_stream_struc   bs;
+ III_side_info_t l3_side;
+ frame_params fr_ps;
+ char    inPath[MAX_NAME_SIZE];
+ char    outPath[MAX_NAME_SIZE];
+ int target_bitrate;
+ char               *programName;
+ unsigned long num_samples;
+ static layer info;
+ 
+ #ifdef BRHIST
+ #include <string.h>
+ #include <termcap.h>
+ void brhist_init(int br_min, int br_max);
+ void brhist_add_count(void);
+ void brhist_disp(void);
+ void brhist_disp_total(void);
+ extern long brhist_temp[15];
+ int disp_brhist = 1;
+ #endif
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * usage
+ *
+ * PURPOSE:  Writes command line syntax to the file specified by #stderr#
+ *
+ ************************************************************************/
+ 
+ void lame_usage(char *name)  /* print syntax & exit */
+ {
+   fprintf(stderr,"\n");
+   fprintf(stderr,"USAGE   :  %s [options] <infile> [outfile]\n",name);
+   fprintf(stderr,"\n<infile> and/or <outfile> can be \"-\", which means stdin/stdout.\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"OPTIONS :\n");
+   fprintf(stderr,"    -m mode         (s)tereo, (j)oint, (f)orce or (m)ono  (default %c)\n",DFLT_MOD);
+   fprintf(stderr,"                    force = force ms_stereo on all frames. Faster and\n");
+   fprintf(stderr,"                    uses special Mid & Side masking thresholds\n");
+   fprintf(stderr,"    -b <bitrate>    set the bitrate, default 128kbps\n");
+   fprintf(stderr,"                    (for VBR, this sets the allowed minimum bitrate)\n");
+   fprintf(stderr,"    -s sfreq        sampling frequency of input file(kHz) - default %4.1f\n",DFLT_SFQ);
+   fprintf(stderr,"  --resample sfreq  sampling frequency of output file(kHz)- default=input sfreq\n");
+   fprintf(stderr,"  --mp3input        input file is a MP3 file\n");
+   fprintf(stderr,"  --voice           experimental voice mode\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"    -v              use variable bitrate (VBR)\n");
+   fprintf(stderr,"    -V n            quality setting for VBR.  default n=%i\n",VBR_q);
+   fprintf(stderr,"                    0=high quality,bigger files. 9=smaller files\n");
+   fprintf(stderr,"    -t              disable Xing VBR informational tag\n");
+   fprintf(stderr,"    --nohist        disable VBR histogram display\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"    -h              use (maybe) quality improvements\n");
+   fprintf(stderr,"    -f              fast mode (low quality)\n");
+   fprintf(stderr,"    -k              disable sfb=21 cutoff\n");
+   fprintf(stderr,"    -d              allow channels to have different blocktypes\n");
+   fprintf(stderr,"  --athonly         only use the ATH for masking\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"    -r              input is raw pcm\n");
+   fprintf(stderr,"    -x              force byte-swapping of input\n");
+   fprintf(stderr,"    -a              downmix from stereo to mono file for mono encoding\n");
+   fprintf(stderr,"    -e emp          de-emphasis n/5/c  (obsolete)\n");
+   fprintf(stderr,"    -p              error protection.  adds 16bit checksum to every frame\n");
+   fprintf(stderr,"                    (the checksum is computed correctly)\n");
+   fprintf(stderr,"    -c              mark as copyright\n");
+   fprintf(stderr,"    -o              mark as non-original\n");
+   fprintf(stderr,"    -S              don't print progress report, VBR histograms\n");
+   fprintf(stderr,"\n");
+   fprintf(stderr,"  Specifying any of the following options will add an ID3 tag\n");
+   fprintf(stderr,"     --tt <title>     title of song (max 30 chars)\n");
+   fprintf(stderr,"     --ta <artist>    artist who did the song (max 30 chars)\n");
+   fprintf(stderr,"     --tl <album>     album where it came from (max 30 chars)\n");
+   fprintf(stderr,"     --ty <year>      year in which the song/album was made (max 4 chars)\n");
+   fprintf(stderr,"     --tc <comment>   additional info (max 30 chars)\n");
+   fprintf(stderr,"\n");
+ #ifdef HAVEGTK
+   fprintf(stderr,"    -g              run graphical analysis on <infile>\n");
+ #endif
+   display_bitrates(2);
+   exit(1);
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * parse_args
+ *
+ * PURPOSE:  Sets encoding parameters to the specifications of the
+ * command line.  Default settings are used for parameters
+ * not specified in the command line.
+ *
+ * If the input file is in WAVE or AIFF format, the sampling frequency is read
+ * from the AIFF header.
+ *
+ * The input and output filenames are read into #inpath# and #outpath#.
+ *
+ ************************************************************************/
+ void lame_parse_args(int argc, char **argv)
+ {
+   FLOAT srate;
+   int   brate;
+   layer *info = fr_ps.header;
+   int   err = 0, i = 0;
+   int mode_given=0;
+   int num_channels=2;   /* number of channels of INPUT file */
+   int samplerate,resamplerate=0;
+   int framesize;
+   double compression_ratio;
+ 
+   /* preset defaults */
+   programName = argv[0]; 
+   inPath[0] = '\0';   outPath[0] = '\0';
+   info->lay = DFLT_LAY;
+   switch(DFLT_MOD) {
+   case 's': info->mode = MPG_MD_STEREO; info->mode_ext = MPG_MD_LR_LR; break;
+   case 'd': info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=MPG_MD_LR_LR; break;
+   case 'j': info->mode = MPG_MD_JOINT_STEREO; info->mode_ext=MPG_MD_LR_LR; break;
+   case 'm': info->mode = MPG_MD_MONO; info->mode_ext = MPG_MD_LR_LR; break;
+   default:
+     fprintf(stderr, "%s: Bad mode dflt %c\n", programName, DFLT_MOD);
+     abort();
+   }
+   samplerate = 1000*DFLT_SFQ;
+   if((info->sampling_frequency = SmpFrqIndex((long)samplerate, &info->version)) < 0) {
+     fprintf(stderr, "%s: bad sfrq default %.2f\n", programName, DFLT_SFQ);
+     abort();
+   }
+ 
+   info->bitrate_index = 9;
+   brate = 0;
+   switch(DFLT_EMP) {
+   case 'n': info->emphasis = 0; break;
+   case '5': info->emphasis = 1; break;
+   case 'c': info->emphasis = 3; break;
+   default: 
+     fprintf(stderr, "%s: Bad emph dflt %c\n", programName, DFLT_EMP);
+     abort();
+   }
+   info->copyright = 0;
+   info->original = 1;
+   info->error_protection = FALSE;
+   
+ #ifndef _BLADEDLL
+   id3_inittag(&id3tag);
+   id3tag.used = 0;
+ #endif
+ 
+   /* process args */
+   while(++i<argc && err == 0) {
+     char c, *token, *arg, *nextArg;
+     int  argUsed;
+     
+     token = argv[i];
+     if(*token++ == '-') {
+       if(i+1 < argc) nextArg = argv[i+1];
+       else           nextArg = "";
+       argUsed = 0;
+       if (! *token) {
+ 	/* The user wants to use stdin and/or stdout. */
+ 	if(inPath[0] == '\0')       strncpy(inPath, argv[i],MAX_NAME_SIZE);
+ 	else if(outPath[0] == '\0') strncpy(outPath, argv[i],MAX_NAME_SIZE);
+       } 
+       if (*token == '-') {
+ 	/* GNU style */
+ 	token++;
+ 
+ 	if (strcmp(token, "resample")==0) {
+ 	  argUsed=1;
+ 	  srate = atof( nextArg );
+ 	  /* samplerate = rint( 1000.0 * srate ); $A  */
+ 	  resamplerate =  (( 1000.0 * srate ) + 0.5);
+ 	  if (srate  < 1) {
+ 	    fprintf(stderr,"Must specify samplerate with --resample\n");
+ 	    exit(1);
+ 	  }
+ 	}
+ 	else if (strcmp(token, "mp3input")==0) {
+ 	  input_format=sf_mp3;
+ 	}
+ 	else if (strcmp(token, "voice")==0) {
+ 	  voice_mode=1;
+ 	}
+ 	else if (strcmp(token, "athonly")==0) {
+ 	  ATHonly=1;
+ 	}
+ 	else if (strcmp(token, "nohist")==0) {
+ #ifdef BRHIST
+ 	  disp_brhist = 0;
+ #endif
+ 	}
+ 	/* options for ID3 tag */
+  	else if (strcmp(token, "tt")==0) {
+  		id3tag.used=1;      argUsed = 1;
+   		strncpy(id3tag.title, nextArg, 30);
+  		}
+  	else if (strcmp(token, "ta")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.artist, nextArg, 30);
+  		}
+  	else if (strcmp(token, "tl")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.album, nextArg, 30);
+  		}
+  	else if (strcmp(token, "ty")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.year, nextArg, 4);
+  		}
+  	else if (strcmp(token, "tc")==0) {
+  		id3tag.used=1; argUsed = 1;
+   		strncpy(id3tag.comment, nextArg, 30);
+  		}
+ 	else
+ 	  {
+ 	    fprintf(stderr,"%s: unrec option --%s\n",
+ 		    programName, token);
+ 	  }
+ 	i += argUsed;
+ 	
+       } else  while( (c = *token++) ) {
+ 	if(*token ) arg = token;
+ 	else                             arg = nextArg;
+ 	switch(c) {
+ 	case 'm':        argUsed = 1;
+ 	  mode_given=1;
+ 	  if (*arg == 's')
+ 	    { info->mode = MPG_MD_STEREO; info->mode_ext = MPG_MD_LR_LR; }
+ 	  else if (*arg == 'd')
+ 	    { info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=MPG_MD_LR_LR; }
+ 	  else if (*arg == 'j')
+ 	    { info->mode = MPG_MD_JOINT_STEREO; info->mode_ext=MPG_MD_LR_LR; }
+ 	  else if (*arg == 'f')
+ 	    { info->mode = MPG_MD_JOINT_STEREO; force_ms=1; info->mode_ext=MPG_MD_LR_LR; }
+ 	  else if (*arg == 'm')
+ 	    { info->mode = MPG_MD_MONO; info->mode_ext = MPG_MD_LR_LR; }
+ 	  else {
+ 	    fprintf(stderr,"%s: -m mode must be s/d/j/f/m not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 	case 'V':        argUsed = 1;   VBR = 1;
+ 	  if (*arg == '0')
+ 	    { VBR_q=0; }
+ 	  else if (*arg == '1')
+ 	    { VBR_q=1; }
+ 	  else if (*arg == '2')
+ 	    { VBR_q=2; }
+ 	  else if (*arg == '3')
+ 	    { VBR_q=3; }
+ 	  else if (*arg == '4')
+ 	    { VBR_q=4; }
+ 	  else if (*arg == '5')
+ 	    { VBR_q=5; }
+ 	  else if (*arg == '6')
+ 	    { VBR_q=6; }
+ 	  else if (*arg == '7')
+ 	    { VBR_q=7; }
+ 	  else if (*arg == '8')
+ 	    { VBR_q=8; }
+ 	  else if (*arg == '9')
+ 	    { VBR_q=9; }
+ 	  else {
+ 	    fprintf(stderr,"%s: -V n must be 0-9 not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 	  
+ 	case 's':
+ 	  argUsed = 1;
+ 	  srate = atof( arg );
+ 	  /* samplerate = rint( 1000.0 * srate ); $A  */
+ 	  samplerate =  (( 1000.0 * srate ) + 0.5);
+ 	  break;
+ 	case 'b':        
+ 	  argUsed = 1;
+ 	  brate = atoi(arg); 
+ 	  break;
+ 	case 't':  /* dont write VBR tag */
+ 		g_bWriteVbrTag=0;
+ 	  break;
+ 	case 'r':  /* force raw pcm input file */
+ #ifdef LIBSNDFILE
+ 	  fprintf(stderr,"WARNING: libsndfile may ignore -r and perform fseek's on the input.\n");
+ 	  fprintf(stderr,"Compile without libsndfile if this is a problem.\n");
+ #endif
+ 	  input_format=sf_raw;
+ 	  break;
+ 	case 'x':  /* force byte swapping */
+ 	  swapbytes=TRUE;
+ 	  break;
+ 	case 'p': /* (jo) error_protection: add crc16 information to stream */
+ 	  info->error_protection = 1; 
+ 	  break;
+ 	case 'a': /* autoconvert input file from stereo to mono - for mono mp3 encoding */
+ 	  autoconvert = TRUE;
+ 	  break;
+ 	case 'h': 
+ 	  highq = TRUE;
+ 	  break;
+ 	case 'k': 
+ 	  sfb21 = FALSE;
+ 	  break;
+ 	case 'd': 
+ 	  allow_diff_short = 1;
+ 	  break;
+ 	case 'v': 
+ 	  VBR = 1;
+ 	  break;
+ 	case 'S': 
+ 	  silent = TRUE;
+ 	  break;
+ 	case 'X':        argUsed = 1;   experimentalX = 0;
+ 	  if (*arg == '0')
+ 	    { experimentalX=0; }
+ 	  else if (*arg == '1')
+ 	    { experimentalX=1; }
+ 	  else if (*arg == '2')
+ 	    { experimentalX=2; }
+ 	  else if (*arg == '3')
+ 	    { experimentalX=3; }
+ 	  else if (*arg == '4')
+ 	    { experimentalX=4; }
+ 	  else if (*arg == '5')
+ 	    { experimentalX=5; }
+ 	  else {
+ 	    fprintf(stderr,"%s: -X n must be 0-5 not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 
+ 
+ 	case 'Y': 
+ 	  experimentalY = TRUE;
+ 	  break;
+ 	case 'Z': 
+ 	  experimentalZ = TRUE;
+ 	  break;
+ 	case 'f': 
+ 	  fast_mode = 1;
+ 	  break;
+ #ifdef HAVEGTK
+ 	case 'g': /* turn on gtk analysis */
+ 	  gtkflag = TRUE;
+ 	  break;
+ #endif
+ 	case 'e':        argUsed = 1;
+ 	  if (*arg == 'n')                    info->emphasis = 0;
+ 	  else if (*arg == '5')               info->emphasis = 1;
+ 	  else if (*arg == 'c')               info->emphasis = 3;
+ 	  else {
+ 	    fprintf(stderr,"%s: -e emp must be n/5/c not %s\n",
+ 		    programName, arg);
+ 	    err = 1;
+ 	  }
+ 	  break;
+ 	case 'c':       info->copyright = 1; break;
+ 	case 'o':       info->original  = 0; break;
+ 	default:        fprintf(stderr,"%s: unrec option %c\n",
+ 				programName, c);
+ 	err = 1; break;
+ 	}
+ 	if(argUsed) {
+ 	  if(arg == token)    token = "";   /* no more from token */
+ 	  else                ++i;          /* skip arg we used */
+ 	  arg = ""; argUsed = 0;
+ 	}
+       }
+     }
+     else {
+       if(inPath[0] == '\0')       strncpy(inPath, argv[i], MAX_NAME_SIZE);
+       else if(outPath[0] == '\0') strncpy(outPath, argv[i], MAX_NAME_SIZE);
+       else {
+ 	fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
+ 	err = 1;
+       }
+     }
+   }
+ 
+   // Do not write VBR tag if VBR flag is not specified
+   if (g_bWriteVbrTag==1 && VBR==0) g_bWriteVbrTag=0;
+ 
+   if(err || inPath[0] == '\0') lame_usage(programName);  /* never returns */
+   if (inPath[0]=='-') silent=1;  /* turn off status - it's broken for stdin */
+   if(outPath[0] == '\0') {
+     if (inPath[0]=='-') {
+       /* if input is stdin, default output is stdout */
+       strcpy(outPath,"-");
+     }else {
+       strncpy(outPath, inPath, MAX_NAME_SIZE - strlen(DFLT_EXT));
+       strncat(outPath, DFLT_EXT, strlen(DFLT_EXT) );
+     }
+   }
+   /* some file options not allowed with stdout */
+   if (outPath[0]=='-') {
+     g_bWriteVbrTag=0; /* turn off VBR tag */
+     if (id3tag.used) {
+       id3tag.used=0;         /* turn of id3 tagging */
+       fprintf(stderr,"id3tag ignored: id3 tagging not supported for stdout.\n");
+     }
+   }
+ 
+ 
+   /* if user did not explicitly specify input is mp3, check file name */
+   if (input_format != sf_mp3)
+     if (!(strcmp((char *) &inPath[strlen(inPath)-4],".mp3")))
+       input_format = sf_mp3;
+ 
+   /* default guess for number of channels */
+   if (autoconvert) num_channels=2; 
+   else if (info->mode == MPG_MD_MONO) num_channels=1;
+   else num_channels=2;
+   
+ #ifdef _BLADEDLL
+   num_samples=0;
+ #else
+   /* open the input file */
+   OpenSndFile(inPath,info,samplerate,num_channels);  
+   /* if GetSndSampleRate is non zero, use it to overwrite the default */
+   if (GetSndSampleRate()) samplerate=GetSndSampleRate();
+   if (GetSndChannels()) num_channels=GetSndChannels();
+   num_samples = GetSndSamples();
+ #endif
+ 
+   if (autoconvert==TRUE) {
+     info->mode = MPG_MD_MONO; 
+     info->mode_ext = MPG_MD_LR_LR;
+   }
+   if (num_channels==1) {
+     autoconvert = FALSE;  /* avoid 78rpm emulation mode from downmixing mono file! */
+     info->mode = MPG_MD_MONO;
+     info->mode_ext = MPG_MD_LR_LR;
+   }      
+   /* if user specified mono and there are 2 channels, autoconvert */
+   if ((num_channels==2) && (info->mode == MPG_MD_MONO))
+     autoconvert = TRUE;
+   
+   if ((num_channels==1) && (info->mode!=MPG_MD_MONO)) {
+     fprintf(stderr,"Error: mono input, stereo output not supported. \n");
+     exit(1);
+   }
+   if (autoconvert==TRUE) {
+     fprintf(stderr, "Autoconverting from stereo to mono. Setting encoding to mono mode.\n");
+   }
+ 
+ 
+ 
+   /* set the output sampling rate, and resample options if necessary 
+      samplerate = input sample rate
+      resamplerate = ouput sample rate
+   */
+   if (resamplerate==0) {
+     /* user did not specify output sample rate */
+     resamplerate=samplerate;   /* default */
+   }
+ 
+   info->sampling_frequency = SmpFrqIndex((long)resamplerate, &info->version);
+   if( info->sampling_frequency < 0) {
+     display_bitrates(2);
+     exit(1);
+   }
+ 
+ #ifndef _BLADEDLL
+   /* estimate total frames.  must be done after setting sampling rate so
+    * we know the framesize.  */
+   totalframes=0;
+   framesize = (info->version==0) ? 576 : 1152;
+   if (num_samples == MAX_U_32_NUM) { 
+     stat(inPath,&sb);  /* try file size, assume 2 bytes per sample */
+     if (input_format == sf_mp3) {
+       double totalseconds = (sb.st_size*8.0/(1000.0*GetSndBitrate()));
+       double framespersecond =  (double)samplerate/(double)framesize;
+       totalframes = 1+(totalseconds*framespersecond);
+     }else{
+       totalframes = 2+(sb.st_size/(2*framesize*num_channels));
+     }
+   }else{
+     totalframes = 2+(num_samples/framesize);
+   }
+ #endif /* _BLADEDLL */
+ 
+ 
+ 
+   if ( brate == 0 ) {
+     info->bitrate_index=9;
+     brate = bitrate[info->version][info->lay-1][info->bitrate_index];
+   } else {
+     if( (info->bitrate_index = BitrateIndex(info->lay, brate, info->version,resamplerate)) < 0) {
+       display_bitrates(2);
+       exit(1);
+     }
+     /* a bit rate was specified.  for VBR, take this to be the minimum */
+     VBR_min_bitrate=info->bitrate_index;
+   }
+ 
+   resample_ratio=0;
+   if (resamplerate != samplerate) {
+     fprintf(stderr,"Resampling:  input=%iHz  output=%iHz\n",
+ 	    (int)samplerate,(int)resamplerate);
+     resample_ratio = (double)samplerate/(double)resamplerate;
+   }
+   compression_ratio = resamplerate*16*num_channels/(1000.0*brate);
+   if (compression_ratio > 12 ) {
+     /* print message suggesting downsampling or low-pass filter */
+   }
+ 
+ 
+   /* default is STEREO for higher bitrates, not JSTEREO, unless of course
+    * the user specified a mode */
+   if ((!mode_given) && (compression_ratio <= 8 )) {
+     if (info->mode != MPG_MD_MONO){
+       info->mode = MPG_MD_STEREO; info->mode_ext = MPG_MD_LR_LR;
+     }
+   }
+   if ((!mode_given) && (VBR_q <= 3 )) {
+     if (info->mode != MPG_MD_MONO){
+       info->mode = MPG_MD_STEREO; info->mode_ext = MPG_MD_LR_LR;
+     }
+   }
+ 
+ 	
+ 
+   if (info->bitrate_index==14) VBR=0;  /* dont bother with VBR at 320kbs */
+   if (VBR) {
+     /* default max bitrate is 256kbs */
+     /* we do not normally allow 320bps frams with VBR, unless: */
+     if (info->bitrate_index==13) VBR_max_bitrate=14;  
+     if (VBR_q == 0) VBR_max_bitrate=14;   /* allow 320kbs */
+     if (VBR_q >= 5) VBR_max_bitrate=12;   /* max = 224kbs */
+     if (VBR_q >= 8) VBR_max_bitrate=9;    /* low quality, max = 128kbs */
+     if (voice_mode) VBR_max_bitrate=10;
+     highq = TRUE;
+   }
+ 
+ 
+   /* Should we disable the scalefactor band 21 cutoff? */
+   /* NOTE: dont *enable* it here, since that could override the users' 
+    * -k option, which disables sfb21 cufoff */
+   /* remove coefficients in scalefactor band 21 (12 for short blocks)
+    * FhG does this for bps <= 128kbs, so we will too.  
+    * This amounds to a 16kHz low-pass filter.  If that offends you, you
+    * probably should not be encoding at 128kbs!
+    * There is no ratio[21] or xfsf[21], so when these coefficients are
+    * included they are just quantized as is.  mt 5/99
+    */
+   /* disable sfb21 cutoff for high quality VBR */
+   if (VBR && (VBR_q <4) ) sfb21 = 0;
+   /* 44.1kHz at 128kbs: compression factor of 11 */
+   /* 44.1kHz at 160kbs: compression factor of 8.82 */
+   if (compression_ratio<9.0) sfb21=0;
+ 
+   /* dont allow forced mid/side stereo for mono output */
+   if (info->mode == MPG_MD_MONO) force_ms=0;  
+ 
+   if (gtkflag) {
+     lame_nowrite=1;    /* disable all file output */
+     g_bWriteVbrTag=0;  /* disable Xing VBR tag */
+   }
+ 
+   if (info->version==0) {
+     g_bWriteVbrTag=0;      /* no MPEG2 Xing VBR tags yet */
+   }
+ 
+ 
+   /* open the output file */
+   /* if gtkflag, no output.  but set outfile = stdout */
+   open_bit_stream_w(&bs, outPath, BUFFER_SIZE,lame_nowrite);  
+ 
+   /* copy some header information */
+   fr_ps.actual_mode = info->mode;
+   fr_ps.stereo = (info->mode == MPG_MD_MONO) ? 1 : 2;
+ 
+ 
+ #ifdef BRHIST
+   if (VBR) {
+     if (disp_brhist)
+       brhist_init(VBR_min_bitrate, VBR_max_bitrate);
+   } else
+     disp_brhist = 0;
+ #endif
+ 
+   if (g_bWriteVbrTag)
+     {
+       // Write initial VBR Header to bitstream
+       InitVbrTag(&bs,info->version-1,info->mode,info->sampling_frequency);
+       /* flush VBR header frame to mp3 file */
+       if (!lame_nowrite) 
+ 	  {
+ 		write_buffer(&bs);
+ 		empty_buffer(&bs);
+ 	  }
+       /* note: if lame_nowrite==0, we do not empty the buffer, the VBR header will
+        * remain in the bit buffer and the first mp3 frame will be
+        * appeneded.  this way, lame_encode() will return to the calling
+        * program the VBR header along with the first mp3 frame */
+     }
+ 
+   return;
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************
+  *
+  * print_config
+  *
+  * PURPOSE:  Prints the encoding parameters used
+  *
+  ************************************************************************/
+ void lame_print_config(void)
+ {
+   layer *info = fr_ps.header;
+   char *mode_names[4] = { "stereo", "j-stereo", "dual-ch", "single-ch" };
+ 
+   if (gtkflag) {
+     fprintf(stderr, "Analyzing %s \n",inPath);
+   }
+   else {
+     fprintf(stderr, "Encoding %s to %s\n",
+ 	    (strcmp(inPath, "-")? inPath : "stdin"),
+ 	    (strcmp(outPath, "-")? outPath : "stdout"));
+     if (VBR)
+       fprintf(stderr, "Encoding as %.1fkHz VBR(q=%i) %s MPEG%i LayerIII file\n",
+ 	      s_freq[info->version][info->sampling_frequency],
+ 	      VBR_q,mode_names[info->mode],2-info->version);
+     else
+       fprintf(stderr, "Encoding as %.1f kHz %d kbps %s MPEG%i LayerIII file\n",
+ 	      s_freq[info->version][info->sampling_frequency],
+ 	      bitrate[info->version][info->lay-1][info->bitrate_index],
+ 	      mode_names[info->mode],2-info->version);
+   }
+   fflush(stderr);
+ }
+ 
+ 
+ 
+  
+ #ifdef BRHIST
+ 
+ #define BRHIST_BARMAX 50
+ 
+ long brhist_count[15];
+ long brhist_temp[15];
+ int brhist_vbrmin;
+ int brhist_vbrmax;
+ long brhist_max;
+ char brhist_bps[15][5];
+ char brhist_backcur[200];
+ char brhist_bar[BRHIST_BARMAX+10];
+ char brhist_spc[BRHIST_BARMAX+1];
+ 
+ char stderr_buff[BUFSIZ];
+ 
+ 
+ void brhist_init(int br_min, int br_max)
+ {
+   int i;
+   char term_buff[1024];
+   layer *info = fr_ps.header;
+   char *termname;
+   char *tp;
+   char tc[10];
+ 
+   for(i = 0; i < 15; i++)
+     {
+       sprintf(brhist_bps[i], "%3d:", bitrate[info->version][info->lay-1][i]);
+       brhist_count[i] = 0;
+       brhist_temp[i] = 0;
+     }
+ 
+   brhist_vbrmin = br_min;
+   brhist_vbrmax = br_max;
+ 
+   brhist_max = 0;
+ 
+   memset(&brhist_bar[0], '*', BRHIST_BARMAX);
+   brhist_bar[BRHIST_BARMAX] = '\0';
+   memset(&brhist_spc[0], ' ', BRHIST_BARMAX);
+   brhist_spc[BRHIST_BARMAX] = '\0';
+   brhist_backcur[0] = '\0';
+ 
+   if ((termname = getenv("TERM")) == NULL)
+     {
+       fprintf(stderr, "can't get TERM environment string.\n");
+       disp_brhist = 0;
+       return;
+     }
+ 
+   if (tgetent(term_buff, termname) != 1)
+     {
+       fprintf(stderr, "can't find termcap entry: %s\n", termname);
+       disp_brhist = 0;
+       return;
+     }
+ 
+   tc[0] = '\0';
+   tp = &tc[0];
+   tgetstr("up", &tp);
+   brhist_backcur[0] = '\0';
+   for(i = br_min-1; i <= br_max; i++)
+     strcat(brhist_backcur, tc);
+ 
+   /*
+     tc[0] = '\0';
+     tp = &tc[0];
+     tgetstr("ce", &tp);
+     strcat(brhist_bar, tc);
+   */
+ 
+   setbuf(stderr, stderr_buff);
+ }
+ 
+ void brhist_add_count(void)
+ {
+   int i;
+ 
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       brhist_count[i] += brhist_temp[i];
+       if (brhist_count[i] > brhist_max)
+ 	brhist_max = brhist_count[i];
+       brhist_temp[i] = 0;
+     }
+ }
+ 
+ void brhist_disp(void)
+ {
+   int i;
+   long full;
+   int barlen;
+ 
+   full = (brhist_max < BRHIST_BARMAX) ? BRHIST_BARMAX : brhist_max;
+   fputc('\n', stderr);
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       barlen = (brhist_count[i]*BRHIST_BARMAX+full-1) / full;
+       fputs(brhist_bps[i], stderr);
+       fputs(&brhist_bar[BRHIST_BARMAX - barlen], stderr);
+       fputs(&brhist_spc[barlen], stderr);
+       fputc('\n', stderr);
+     }
+   fputs(brhist_backcur, stderr);
+   fflush(stderr);
+ }
+ 
+ void brhist_disp_total(void)
+ {
+   int i;
+   double ave;
+   layer *info = fr_ps.header;
+ 
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     fputc('\n', stderr);
+ 
+   ave=0;
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     ave += bitrate[info->version][info->lay-1][i]*
+       (double)brhist_count[i] / totalframes;
+   fprintf(stderr, "\naverage: %2.0f kbs\n",ave);
+     
+ #if 0
+   fprintf(stderr, "----- bitrate statistics -----\n");
+   fprintf(stderr, " [kbps]      frames\n");
+   for(i = brhist_vbrmin; i <= brhist_vbrmax; i++)
+     {
+       fprintf(stderr, "   %3d  %8ld (%.1f%%)\n",
+ 	      bitrate[info->version][info->lay-1][i],
+ 	      brhist_count[i],
+ 	      (double)brhist_count[i] / totalframes * 100.0);
+     }
+ #endif
+   fflush(stderr);
+ }
+ 
+ #endif
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /************************************************************************
+ * 
+ * encodeframe()
+ *
+ * SEMANTICS:  One overlapping frame of audio of up to 2 channels are
+ * processed at a time in the following order:
+ * (associated routines are in parentheses)
+ *
+ * 1.  Filter sliding window of data to get 32 subband
+ * samples per channel.
+ * (window_subband,filter_subband)
+ *
+ * 2.  Calculate scalefactors for the frame, and if layer 2,
+ * also calculate scalefactor select information.
+ * (*_scale_factor_calc)
+ *
+ * 3.  Calculate psychoacoustic masking levels using selected
+ * psychoacoustic model.
+ * (*_Psycho_One, psycho_anal)
+ *
+ * 4.  Perform iterative bit allocation for subbands with low
+ * mask_to_noise ratios using masking levels from step 4.
+ * (*_main_bit_allocation)
+ *
+ * 5.  Pack bit allocation and scalefactors onto bitstream.
+ * (*_encode_bit_alloc,*_encode_scale)
+ *
+ * 6.  Quantize subbands and pack them into bitstream
+ * (*_subband_quantization, *_sample_encoding)
+ *
+ ************************************************************************/
+ int lame_encode(short int Buffer[2][1152],char *mpg123bs)
+ {
+   static unsigned long frameBits;
+   static unsigned long bitsPerSlot;
+   static double frac_SpF;
+   static double slot_lag;
+   static int mode_gr;
+   static int old_bitrate;
+   static unsigned long sentBits = 0;
+   static L3SBS     l3_sb_sample;
+   /* set to 56 to sync with FhG */
+ #define EXTRADELAY 56
+   static int samplesPerFrame;
+   static short int mfbuf[2][1152+576+EXTRADELAY];   /* 3 granule internal buffer */
+   double xr[2][2][576];
+   double win_que[64];
+   int l3_enc[2][2][576];
+   int mpg123count;
+   III_psy_ratio ratio;
+   III_scalefac_t scalefac;
+ 
+   int j,ch,gr,mean_bits;
+   int bitsPerFrame;
+   double pe[2][4];
+   double pe_use[2][2];
+   double pe_sum_old=0;
+   static double pe_sum=0;
+   short *win_buf[2];
+   int stereo;
+   layer *info;
+   int i;
+   int check_ms_stereo;
+   int bit_rate;
+   double samp;
+   double ms_ener_ratio[2];
+ 
+   stereo = fr_ps.stereo;
+   info = fr_ps.header;
+ 
+   info->mode_ext = MPG_MD_LR_LR; 
+ 
+   /* use m/s stereo? */
+   check_ms_stereo =   ((info->mode == MPG_MD_JOINT_STEREO) && 
+ 		       (!force_ms) && (info->version == 1) &&
+ 		       (stereo==2));
+ 
+ 
+   if (frameNum==0) old_bitrate=info->bitrate_index;
+   info->bitrate_index = old_bitrate;
+ 
+ 
+   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
+   samp =      s_freq[info->version][info->sampling_frequency];
+   
+   if (frameNum==0)  {    
+     double avg_slots_per_frame;
+     int whole_SpF;
+     sentBits = 0;
+     memset((char *) mfbuf, 0, sizeof(mfbuf));
+ 
+     /* Figure average number of 'slots' per frame. */
+     /* Bitrate means TOTAL for both channels, not per side. */
+     bitsPerSlot = 8;
+     samplesPerFrame = info->version == 1 ? 1152 : 576;
+     avg_slots_per_frame = ((double)samplesPerFrame /samp) *
+       ((double)bit_rate /  (double)bitsPerSlot);
+     whole_SpF = (int) avg_slots_per_frame;
+     frac_SpF  = avg_slots_per_frame - (double)whole_SpF;
+     slot_lag  = -frac_SpF;
+     info->padding = 1;
+     if (fabs(frac_SpF) < 1e-9) info->padding = 0;
+     mode_gr = (info->version == 1) ? 2 : 1;  /* mode_gr = 2 */
+   }
+ 
+ 
+   /* shift in new samples, delayed by 576+EXTRADELAY */
+    for (ch=0; ch<stereo; ch++)
+      for (i=0; i<576+EXTRADELAY; i++)
+        mfbuf[ch][i]=mfbuf[ch][i+samplesPerFrame];
+    for (ch=0; ch<stereo; ch++)
+      for (i=0; i<samplesPerFrame; i++)
+        mfbuf[ch][i+576+EXTRADELAY]=Buffer[ch][i];
+ 
+ 
+ 
+ 
+   /********************** padding *****************************/
+   if (VBR) {
+   /* leave info_padding as it was set above */
+   } else {
+     if (frac_SpF != 0) {
+       if (slot_lag > (frac_SpF-1.0) ) {
+ 	slot_lag -= frac_SpF;
+ 	info->padding = 0;
+       }
+       else {
+ 	info->padding = 1;
+ 	slot_lag += (1-frac_SpF);
+       }
+     }
+   }
+ 
+ #ifndef _BLADEDLL
+   /********************** status display  *****************************/
+   if (!gtkflag && !silent) {
+     int mod = info->version == 0 ? 100 : 20;
+     if (frameNum%mod==0) {
+       timestatus(info,frameNum,totalframes);
+ #ifdef BRHIST
+       if (disp_brhist)
+ 	{
+ 	  brhist_add_count();
+ 	  brhist_disp();
+ 	}
+ #endif
+     }
+   }
+ 
+ #endif /* _BLADEDLL */
+ 
+   /********************** process InputBuffer *****************************/
+ 
+ 
+   if (force_ms)
+     for (i=0; i< samplesPerFrame; i++) {
+       /* dont overflow the short int */
+       double mid = ((int)mfbuf[0][576+i]+(int)mfbuf[1][576+i])/(2.0);
+       double side= ((int)mfbuf[0][576+i]-(int)mfbuf[1][576+i])/(2.0);
+       mfbuf[0][576+i]=mid;
+       mfbuf[1][576+i]=side;
+     }
+ 
+ 
+   
+   /***************************** Layer 3 **********************************
+    * mfbuf contains 3 granules:  [0 1 2 ] 
+    * encoder will encode granules 0 1 
+    * psy-model will be fed granules 1 2, and because of its 1 granule delay 
+    * it will return thresholds for granules 0 1 */
+   
+   win_buf[0] = &mfbuf[0][0];
+   win_buf[1] = &mfbuf[1][0];
+ 
+   
+   if (!fast_mode) {  
+     /* psychoacoustic model 
+      * psy model adds a 544 delay to sync with the filterbanks
+      * in addition to this delay, it also adds a 1 granule (576) delay
+      * that we must compensate for (mt 6/99). 
+      */
+     short int *bufp[2];  /* address of beginning of left & right granule */
+     int blocktype[2];
+     
+     for (gr=0; gr < mode_gr ; gr++) {
+       for ( ch = 0; ch < stereo; ch++ ) bufp[ch] = &mfbuf[ch][576 + gr*576];
+       L3psycho_anal( bufp, stereo, gr, info,
+          s_freq[info->version][info->sampling_frequency] * 1000.0,
+ 	 check_ms_stereo,&ms_ener_ratio[gr],
+          ratio.l[gr], ratio.s[gr], pe[gr], blocktype);
+       for ( ch = 0; ch < stereo; ch++ ) 
+ 	l3_side.gr[gr].ch[ch].tt.block_type=blocktype[ch];
+     }
+   }else{
+     for (gr=0; gr < mode_gr ; gr++) 
+       for ( ch = 0; ch < stereo; ch++ ) {
+ 	l3_side.gr[gr].ch[ch].tt.block_type=NORM_TYPE;
+ 	pe[gr][ch]=700;
+       }
+   }
+ 
+   pe_sum_old=pe_sum;
+   pe_sum=0;
+   for( gr = 0; gr < mode_gr; gr++ ) 
+     for ( ch = 0; ch < stereo; ch++ ) 
+       pe_sum+=pe[gr][ch];
+   
+ 
+ 
+   /* for VBR, what bitrate should we try first? */
+   if (VBR){
+     info->bitrate_index=old_bitrate-1;
+     if (abs(pe_sum_old - pe_sum)>200){
+       if (pe_sum_old>pe_sum)
+         info->bitrate_index--;
+     }
+ 
+     if (info->bitrate_index < VBR_min_bitrate)
+       info->bitrate_index=VBR_min_bitrate;
+     if (info->bitrate_index > VBR_max_bitrate)
+       info->bitrate_index=VBR_max_bitrate;
+   }
+ 
+ 
+   /* block type flags */
+   for( gr = 0; gr < mode_gr; gr++ ) {
+     for ( ch = 0; ch < stereo; ch++ ) {
+       gr_info *cod_info = &l3_side.gr[gr].ch[ch].tt;
+       cod_info->mixed_block_flag = 0;     /* never used by this model */
+       if (cod_info->block_type == NORM_TYPE )
+ 	cod_info->window_switching_flag = 0;
+       else
+ 	cod_info->window_switching_flag = 1;
+     }
+   }
+ 
+ 
+   /* polyphase filtering  */
+   for( gr = 0; gr < mode_gr; gr++ )
+     for ( ch = 0; ch < stereo; ch++ )
+       for ( j = 0; j < 18; j++ )   {
+ 	window_subband( &win_buf[ch], win_que, ch );
+ 	filter_subband( win_que,  &(l3_sb_sample)[ch][gr+1][j][0] ); }
+   
+   /* apply mdct to the polyphase outputs */
+   mdct_sub( l3_sb_sample, xr, stereo, &l3_side, mode_gr );
+ 
+   /* data was scaled by 1/2.  fix so effectively it was scaled by 1/sqrt(2) */
+   if (force_ms) {
+     for ( gr = 0; gr < mode_gr; gr++ )
+       for ( ch = 0; ch < stereo; ch++ ) 
+ 	for (i =0 ; i< 576; i++) 
+ 	  xr[gr][ch][i] *= SQRT2;
+   }
+ 
+   /* set a default for ms_ener_ratio since it was not computed in these cases */
+   if (force_ms || fast_mode) {
+     ms_ener_ratio[0]=.25;
+     ms_ener_ratio[1]=.25;
+   }
+ 
+ 
+   if (check_ms_stereo) {
+     /* make sure block type is the same in each channel */
+     check_ms_stereo = 
+       (l3_side.gr[0].ch[0].tt.block_type==l3_side.gr[0].ch[1].tt.block_type) &&
+       (l3_side.gr[1].ch[0].tt.block_type==l3_side.gr[1].ch[1].tt.block_type);
+   }
+   if (check_ms_stereo) {
+     if ( (ms_ener_ratio[0] + ms_ener_ratio[1])<.70) 
+            info->mode_ext = MPG_MD_MS_LR;
+     ms_ener_ratio[0]=Min(ms_ener_ratio[0],.5);
+     ms_ener_ratio[1]=Min(ms_ener_ratio[1],.5);
+   }
+ 
+ #ifdef HAVEGTK
+   if (gtkflag) { 
+     for ( gr = 0; gr < mode_gr; gr++ )
+       for ( ch = 0; ch < stereo; ch++ ) {
+ 	pinfo->ms_ratio[gr]=ms_ener_ratio[gr];
+ 	pinfo->blocktype[gr][ch]=
+ 	  l3_side.gr[gr].ch[ch].tt.block_type;
+ 	for ( j = 0; j < 576; j++ ) pinfo->xr[gr][ch][j]=xr[gr][ch][j];
+       }
+   }
+ #endif
+ 
+   /* if MS stereo, switch to MS psy data */
+   for ( gr = 0; gr < mode_gr; gr++ ) {
+     for ( ch = 0; ch < stereo; ch++ ) {
+       if (highq && (info->mode_ext==MPG_MD_MS_LR)) {
+ 	pe_use[gr][ch]=pe[gr][ch+2];
+ 	memcpy(ratio.l[gr][ch],ratio.l[gr][ch+2],sizeof(ratio.l[gr][ch]));
+ 	memcpy(ratio.s[gr][ch],ratio.s[gr][ch+2],sizeof(ratio.s[gr][ch]));
+ #ifdef HAVEGTK
+        if (gtkflag) {
+ 	 pinfo->ers[gr][ch]=pinfo->ers[gr][ch+2];
+ 	 pinfo->pe[gr][ch]=pinfo->pe[gr][ch+2];
+          memcpy(pinfo->energy[gr][ch],pinfo->energy[gr][ch+2],
+ 		sizeof(pinfo->energy[gr][ch]));
+ 	 memcpy(pinfo->thr[gr][ch],pinfo->thr[gr][ch+2],
+ 		sizeof(pinfo->thr[gr][ch]));
+ 	 memcpy(pinfo->en[gr][ch],pinfo->en[gr][ch+2],
+ 		sizeof(pinfo->en[gr][ch]));
+ 	 memcpy(pinfo->thr_s[gr][ch],pinfo->thr_s[gr][ch+2],
+                 sizeof(pinfo->thr_s[gr][ch]));
+ 	 memcpy(pinfo->en_s[gr][ch],pinfo->en_s[gr][ch+2],
+ 		sizeof(pinfo->en_s[gr][ch]));
+        }
+ #endif
+       }else{
+ 	pe_use[gr][ch]=pe[gr][ch];
+       }
+     }
+   }
+ 
+   /* bit and noise allocation */
+   if (VBR) 
+     VBR_iteration_loop( pe_use, ms_ener_ratio, xr, &ratio, &l3_side, l3_enc, 
+ 		    &scalefac, &fr_ps);
+   else
+     iteration_loop( pe_use, ms_ener_ratio, xr, &ratio, &l3_side, l3_enc, 
+ 		    &scalefac, &fr_ps);
+ 
+ #ifdef BRHIST
+   brhist_temp[info->bitrate_index]++;
+ #endif
+ 
+   /* flag for our ms_stereo with psy-model on mid & side channels */
+   if (force_ms) info->mode_ext = MPG_MD_MS_LR;
+ 
+   /*  write the frame to the bitstream  */
+   old_bitrate = info->bitrate_index;
+   getframebits(info,stereo,&bitsPerFrame,&mean_bits);
+   III_format_bitstream( bitsPerFrame, &fr_ps, l3_enc, &l3_side, 
+ 			&scalefac, &bs, xr, NULL, 0 );
+ 
+ 
+   frameBits = bs.totbit - sentBits;
+ 
+   
+   if ( frameBits % bitsPerSlot )   /* a program failure */
+     fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
+ 	     frameBits, frameBits/bitsPerSlot,
+ 	     frameBits%bitsPerSlot );
+   sentBits += frameBits;
+ 
+   /* copy mp3 bit buffer into array */
+   mpg123count = copy_buffer(mpg123bs,&bs);
+   if (!lame_nowrite) write_buffer(&bs);  /* ouput to mp3 file */
+   empty_buffer(&bs);  /* empty buffer */
+ 
+   if (g_bWriteVbrTag) AddVbrFrame((int)(sentBits/8));
+ 
+ #ifdef HAVEGTK 
+   if (gtkflag) { 
+     int adj=0;
+     if (info->version == 0) adj=576;
+     for ( ch = 0; ch < stereo; ch++ ) {
+       for ( j = 0; j < WINDELAY; j++ )
+ 	pinfo->pcmdata[ch][j] = pinfo->pcmdata[ch][j+1152-adj];
+       for ( j = 0; j < 1152-adj; j++ ) {
+ 	pinfo->pcmdata[ch][j+WINDELAY] = mfbuf[ch][j];
+       }
+     }
+   }
+ #endif
+   //  fprintf(stderr,"finished frameNum=%i \n",frameNum);
+   frameNum++;
+   return mpg123count;
+ }
+ 
+ 
+ #ifndef _BLADEDLL
+ int lame_readframe(short int Buffer[2][1152])
+ {
+   int iread,ifreq,ofreq;
+   static int eof;
+ 
+   if (frameNum==0) eof=0;
+   iread = get_audio(Buffer,fr_ps.stereo,fr_ps.header);
+   /* note: if input is stereo and output is mono, get_audio() 
+    * will return stereo=1 and .5*(L+R) in channel 0, 
+    * and nothing in channel 1. */
+   /* DOWNSAMPLE, ETC */
+   ofreq=1000*s_freq[info.version][info.sampling_frequency];  /* output */
+   ifreq=ofreq*resample_ratio;                                /* input */
+ 
+ #ifdef HAVEGTK
+   if (gtkflag) {
+     pinfo->frameNum = frameNum;
+     pinfo->sampfreq=ofreq;
+     pinfo->framesize=(fr_ps.header->version==0) ? 576 : 1152;
+     pinfo->stereo = fr_ps.stereo;
+   }
+ #endif
+ 
+   if (resample_ratio>0) {
+     fprintf(stderr,"Error: resample code not yet written! \n");
+     exit(1);
+   }
+ 
+   /* check to see if we overestimated/underestemated totalframes */
+   if (!eof) {
+     if (iread==0) {
+       /* this is the last frame */
+       totalframes=frameNum+1;  
+       eof=1;
+     }else{
+       if (frameNum > (totalframes-1)) totalframes = frameNum;
+     }
+   }
+ 
+ 
+ 
+   return iread;
+ }
+ #endif /* _BLADEDLL */
+ 
+ /* initialize mp3 encoder */
+ void lame_init(int nowrite)
+ {
+ 
+ #ifdef __FreeBSD__
+ #include <floatingpoint.h>
+   {
+   /* seet floating point mask to the Linux default */
+   fp_except_t mask;
+   mask=fpgetmask();
+   /* if bit is set, we get SIGFPE on that error! */
+   fpsetmask(mask & ~(FP_X_INV|FP_X_DZ));
+   /*  fprintf(stderr,"FreeBSD mask is 0x%x\n",mask); */
+   }
+ #endif
+ #ifdef ABORTFP
+   {
+ #include <fpu_control.h>
+   unsigned int mask;
+   _FPU_GETCW(mask);
+   /* Set the Linux mask to abort on most FPE's */
+   /* if bit is set, we _mask_ SIGFPE on that error! */
+   //   mask &= ~( _FPU_MASK_IM | _FPU_MASK_ZM | _FPU_MASK_OM | _FPU_MASK_UM );
+    mask &= ~( _FPU_MASK_IM | _FPU_MASK_ZM | _FPU_MASK_OM );
+   _FPU_SETCW(mask);
+   }
+ #endif
+ 
+ 
+ #ifndef _BLADEDLL
+   fprintf(stderr,"LAME version %s (www.sulaco.org/mp3) \n",get_lame_version());
+   fprintf(stderr,"GPSYCHO: GPL psycho-acoustic model version %s. \n",get_psy_version());
+ #ifdef LIBSNDFILE
+   fprintf(stderr,"Input handled by libsndfile (www.zip.com.au/~erikd/libsndfile)\n");
+ #endif
+ #endif /* _BLADEDLL */
+ 
+   /* Global flags.  set defaults here */
+   allow_diff_short=0;
+   ATHonly=0;
+   autoconvert=FALSE;
+   experimentalX = 0;
+   experimentalY = 0;
+   experimentalZ = 0;
+   force_ms=FALSE;
+   fast_mode=0;
+   frameNum=0;
+   g_bWriteVbrTag=1;
+   gtkflag=0;
+   gpsycho=1;
+   highq=0;
+   input_format=sf_unknown;
+   lame_nowrite=nowrite;
+   resample_ratio=0;
+   sfb21=1;
+   silent=0;
+   swapbytes=0;
+   totalframes=0;
+   VBR=0;
+   VBR_q=4;
+   VBR_min_bitrate=1;   /* 32kbs */
+   VBR_max_bitrate=13;  /* 256kbs */
+   voice_mode=0;
+ 
+ 
+   // Clear info structure
+   memset(&info,0,sizeof(info));
+   memset(&bs, 0, sizeof(Bit_stream_struc));
+   memset(&fr_ps, 0, sizeof(frame_params));
+   memset(&l3_side,0x00,sizeof(III_side_info_t));
+   
+   fr_ps.header = &info;
+   fr_ps.tab_num = -1;             /* no table loaded */
+   fr_ps.alloc = NULL;
+   info.version = MPEG_AUDIO_ID;   /* =1   Default: MPEG-1 */
+   info.extension = 0;       
+ 
+   InitFormatBitStream();
+   InitReservoir();
+ 
+ }
+ 
+ 
+ #ifndef _BLADEDLL
+ int lame_cleanup(char *mpg123bs)
+ {
+   int mpg123count;
+   frameNum--;
+   if (!gtkflag && !silent) {
+       timestatus(&info,frameNum,totalframes);
+       fprintf(stderr,"\n");
+ #ifdef BRHIST
+       if (disp_brhist)
+ 	{
+ 	  brhist_add_count();
+ 	  brhist_disp();
+ 	}
+ #endif
+ #ifdef BRHIST
+       if (disp_brhist)
+ 	brhist_disp_total();
+ #endif
+       fflush(stderr);
+   }
+ 
+ 
+   CloseSndFile();
+ 
+ 
+   III_FlushBitstream();
+   mpg123count = copy_buffer(mpg123bs,&bs);
+ 
+   if (!lame_nowrite)
+   {
+     write_buffer(&bs);  /* ouput to mp3 file */
+     empty_buffer(&bs);  /* empty buffer */
+ 
+     // Close the file
+     fclose(bs.pt);
+   
+     // Deallocate all buffers
+     desalloc_buffer(&bs);
+   
+     
+     // AF ADDED
+     if (g_bWriteVbrTag)
+ 	{
+ 		// Calculate relative quality of VBR stream 
+ 		// 0=best, 100=worst
+ 		int nQuality=VBR_q*100/9;
+ 
+ 		// Write Xing header again
+ 		PutVbrTag(outPath,nQuality);
+ 	}
+     // AF END
+     
+     // write an ID3 tag 
+     if(id3tag.used) {
+       id3_buildtag(&id3tag);
+       id3_writetag(outPath, &id3tag);
+     }
+   }
+   return mpg123count;
+ }
+ #endif /* _BLADEDLL */
diff -r -c -N encoder/lame.dsp lame3.50/lame.dsp
*** encoder/lame.dsp	Wed Dec 31 17:00:00 1969
--- lame3.50/lame.dsp	Sun Oct 17 12:24:26 1999
***************
*** 0 ****
--- 1,352 ----
+ # Microsoft Developer Studio Project File - Name="lame" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Console Application" 0x0103
+ 
+ CFG=lame - Win32 Debug GTK
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "lame.mak" CFG="lame - Win32 Debug GTK"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "lame - Win32 Release" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Debug GTK" (based on "Win32 (x86) Console Application")
+ !MESSAGE "lame - Win32 Release GTK" (based on\
+  "Win32 (x86) Console Application")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ RSC=rc.exe
+ 
+ !IF  "$(CFG)" == "lame - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "Release"
+ # PROP Intermediate_Dir "Release"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "Debug"
+ # PROP Intermediate_Dir "Debug"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+ # ADD CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Debug GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "lame___W"
+ # PROP BASE Intermediate_Dir "lame___W"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "DebugGTK"
+ # PROP Intermediate_Dir "DebugGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /Zp4 /W3 /Gm /GX /Zi /Od /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "_DEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "_DEBUG"
+ # ADD RSC /l 0x409 /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ELSEIF  "$(CFG)" == "lame - Win32 Release GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "lame___0"
+ # PROP BASE Intermediate_Dir "lame___0"
+ # PROP BASE Ignore_Export_Lib 0
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "ReleaseGTK"
+ # PROP Intermediate_Dir "ReleaseGTK"
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /I "../WinGTK/gtk-plus" /I "../WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /I "./WinGTK/gtk-plus" /I "./WinGTK/glib-1.2" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D BS_FORMAT=BINARY /D "HAVEGTK" /YX /FD /c
+ # ADD BASE RSC /l 0x409 /d "NDEBUG"
+ # ADD RSC /l 0x409 /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=xilink.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /profile /map /machine:I386
+ # ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib glib-1.2.lib gdk-1.3.lib gtk-1.3.lib /nologo /subsystem:console /profile /map /machine:I386 /libpath:"./WinGTK/glib-1.2" /libpath:"./WinGTK/gtk-plus/gdk" /libpath:"./WinGTK/gtk-plus/gtk"
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "lame - Win32 Release"
+ # Name "lame - Win32 Debug"
+ # Name "lame - Win32 Debug GTK"
+ # Name "lame - Win32 Release GTK"
+ # Begin Source File
+ 
+ SOURCE=.\encoder.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fastmdct.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fastmdct.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fft.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\fft.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\filterbank.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\formatBitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\get_audio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\get_audio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\globalflags.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gpkplotting.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\gtkanal.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\id3tag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\id3tag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\ieeefloat.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\l3bitstream-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3bitstream.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\l3side.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\lame.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\lame.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\machine.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\main.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\musicin.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\portableio.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\profile.txt
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\psymodel.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\psymodel.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=".\quantize-pvt.h"
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\quantize.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\quantize.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\reservoir.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\sqrttab.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tables.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tables.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\takehiro.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\timestatus.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\timestatus.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\util.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\util.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\VbrTag.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\version.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\wavheader.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\WinGTK.txt
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/lame.dsw lame3.50/lame.dsw
*** encoder/lame.dsw	Wed Dec 31 17:00:00 1969
--- lame3.50/lame.dsw	Fri Sep 10 09:52:04 1999
***************
*** 0 ****
--- 1,44 ----
+ Microsoft Developer Studio Workspace File, Format Version 5.00
+ # WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+ 
+ ###############################################################################
+ 
+ Project: "lame"=.\lame.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+     Begin Project Dependency
+     Project_Dep_Name mpglib
+     End Project Dependency
+ }}}
+ 
+ ###############################################################################
+ 
+ Project: "mpglib"=.\mpglib\mpglib.dsp - Package Owner=<4>
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<4>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
+ Global:
+ 
+ Package=<5>
+ {{{
+ }}}
+ 
+ Package=<3>
+ {{{
+ }}}
+ 
+ ###############################################################################
+ 
diff -r -c -N encoder/lame.h lame3.50/lame.h
*** encoder/lame.h	Wed Dec 31 17:00:00 1969
--- lame3.50/lame.h	Tue Sep 28 22:00:44 1999
***************
*** 0 ****
--- 1,62 ----
+ /*
+  *	Interface to MP3 LAME encoding engine
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include <stdio.h>
+ #define LAME_MAXMP3BUFFER 16384
+ 
+ /* if no_output=1, all LAME output is disabled, and it is up to the
+  * calling program to write the mp3 data (returned by lame_encode() and
+  * lame_cleanup()).  In this case, the calling program is responsible 
+  * for filling in the Xing VBR header data and adding the id3 tag.
+  * see lame_cleanup() for details. */
+ void lame_init(int no_output);
+ 
+ /* lame_cleanup will flush the buffers and may return a final mp3 frame */
+ int lame_cleanup(char *mp3buf);
+ 
+ void lame_usage(char *);
+ void lame_parse_args(int, char **);
+ void lame_print_config(void);
+ 
+ /* read one frame of PCM data from audio input file opened by lame_parse_args*/
+ /* input file can be either mp3 or uncompressed audio file */
+ int lame_readframe(short int Buffer[2][1152]);
+ 
+ /* 
+ NOTE: for lame_encode and lame_decode, because of the bit reservoir
+ capability of mp3 frames, there can be a delay between the input
+ and output.  lame_decode/lame_encode should always return exactly
+ one frame of output, but it may not return any output 
+ until a second call with a second frame.  (or even 3 or 4 more calls)
+ */
+ 
+ /* input 1 pcm frame, output (maybe) 1 mp3 frame. */ 
+ int lame_encode(short int Buffer[2][1152],char *mp3buffer);
+ 
+ /* input 1 mp3 frame, output (maybe) 1 pcm frame.   */
+ int lame_decode_init(void);
+ int lame_decode(char *mp3buf,int len,short pcm[][1152]);
+ 
+ /* read mp3 file until mpglib returns one frame of PCM data */
+ int lame_decode_initfile(FILE *fd,int *stereo,int *samp,int *bitrate);
+ int lame_decode_fromfile(FILE *fd,short int mpg123pcm[2][1152]);
+ 
+ 
+ 
diff -r -c -N encoder/loop-pvt.h lame3.50/loop-pvt.h
*** encoder/loop-pvt.h	Wed Jan 22 02:43:16 1997
--- lame3.50/loop-pvt.h	Wed Dec 31 17:00:00 1969
***************
*** 1,119 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop-pvt.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * Private interface declarations for loop.c
-  *
-  * $Log: loop-pvt.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef LOOP_PVT_H
- #define LOOP_PVT_H
- 
- /*
-   Revision History:
- 
-   Date        Programmer                Comment
-   ==========  ========================= ===============================
-   1995/10/01  mc@fivebats.com           created
- 
- */
- 
- int outer_loop( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
-                 int max_bits,
-                 III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
-                 int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
- 		frame_params *fr_ps,
-                 III_scalefac_t *scalefac, /* scalefactors */
-                 int gr,
-                 int ch,
- 		III_side_info_t *l3_side );
- 
- int part2_length( III_scalefac_t *scalefac,
- 		  frame_params *fr_ps,
- 		  int gr,
- 		  int ch,
- 		  III_side_info_t *si );
- 
- int quantanf_init( double xr[576] );
- 
- int inner_loop( double xr[2][2][576],
-                 int l3_enc[2][2][576],
-                 int max_bits,
-                 gr_info *cod_info,
-                 int gr,
-                 int ch );
- void calc_xmin( double xr[2][2][576],
-                III_psy_ratio *ratio,
-                gr_info *cod_info,
-                III_psy_xmin *l3_xmin,
-                int gr,
-                int ch );
- double xr_max( double xr[576],
-                unsigned int begin,
-                unsigned int end );
- 
- void calc_scfsi( double  xr[576],
-                  III_side_info_t *l3_side,
-                  III_psy_xmin  *l3_xmin,
-                  int ch,
-                  int gr );
- 
- void gr_deco( gr_info *cod_info );
- 
- 
- int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table);
- int bigv_bitcount( int ix[576], gr_info *cod_info );
- int choose_table( int max);
- void bigv_tab_select( int ix[576], gr_info *cod_info );
- void subdivide( gr_info *cod_info );
- int count1_bitcount( int ix[576], gr_info *cod_info );
- void  calc_runlen( int ix[576],
-                    gr_info *cod_info );
- int scale_bitcount( III_scalefac_t *scalefac,
-                     gr_info *cod_info,
-                     int gr,
-                     int ch );
- void calc_noise( double xr[576],
-                  int ix[576],
-                  gr_info *cod_info,
-                  double xfsf[4][CBLIMIT] );
- 
- 
- int loop_break( III_scalefac_t *scalefac,
-                 gr_info *cod_info,
-                 int gr,
-                 int ch );
- void preemphasis( double xr[576],
-                   double xfsf[4][CBLIMIT],
-                   III_psy_xmin  *l3_xmin,
-                   int gr,
-                   int ch,
- 		  III_side_info_t *l3_side );
- int amp_scalefac_bands( double xr[576],
-                         double xfsf[4][CBLIMIT],
-                         III_psy_xmin  *l3_xmin,
- 			III_side_info_t *l3_side,
-                         III_scalefac_t *scalefac,
-                         int gr,
-                         int ch,
- 			int iteration );
- void quantize( double xr[576],
-                int  ix[576],
-                gr_info *cod_info );
- int ix_max( int ix[576],
-             unsigned int begin,
-             unsigned int end );
- 
- 
- int
- new_choose_table( int ix[576],
- 		  unsigned int begin,
- 		  unsigned int end );
- #endif
--- 0 ----
diff -r -c -N encoder/loop.c lame3.50/loop.c
*** encoder/loop.c	Wed Jan 22 02:43:16 1997
--- lame3.50/loop.c	Wed Dec 31 17:00:00 1969
***************
*** 1,2220 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: loop.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers                comment                        *
-  *25. 6.92  Toshiyuki Ishino           Ver 1.0                        *
-  *29.10.92  Masahiro Iwadare           Ver 2.0                        *
-  *17. 4.93  Masahiro Iwadare           Updated for IS Modification    *
-  *04.11.93  Seymour Shlien             Speed up inner loop            *
-  *09.09.95  mc@fivebats.com            Several changes for updated IS,*
-  *                                     and some MPEG2-LSF support     *
-  *20.12.96  seymour.shlien@crc.doc.ca  Fixed some bugs and improved   *
-  *                                     the appearance                 *
-  *********************************************************************/ 
- 
- #include <stdio.h>
- #include <stdlib.h>
- #include <math.h>
- #include <assert.h>
- #include "l3side.h"
- #include "loop.h"
- #include "huffman.h"
- #include "l3bitstream.h"
- #include "reservoir.h"
- #include "loop-pvt.h"
- 
- /* #define DEBUG */
- /* #define DEBUGSC */
- /* #define PERFORM 3 */
- /* If PERFORM is defined to some number, then a file encode.log
-    is preduced showing the intermediate results produced by the
-    outer_loop code for the frame number = PERFORM.
- */
- #define BIN_SEARCH 
- /* for speeding up the iteration_loop algorithm */
- 
- #ifdef PERFORM
- FILE *log_output;
- extern int frameNum;
- float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
-                              ,int block_type,int gr,int ch);
- #endif
- 
- /* New SS 20-12-96 */
- #ifdef BIN_SEARCH 
- int bin_search_StepSize(int desired_rate, double start, int ix[576],
-            double xrs[576], gr_info * cod_info);
- int count_bits();
- float worst_xfsf_to_xmin_ratio();
- #endif
- 
- 
- /*
-   Here are MPEG1 Table B.8 and MPEG2 Table B.1
-   -- Layer III scalefactor bands.
-   Index into this using a method such as:
-     idx  = fr_ps->header->sampling_frequency
-            + (fr_ps->header->version * 3)
- */
- 
- struct scalefac_struct sfBandIndex[6] =
- {
- 
-   { /* Table B.2.b: 22.05 kHz */
-     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
-     {0,4,8,12,18,24,32,42,56,74,100,132,174,192}
-   },
-   { /* Table B.2.c: 24 kHz */
-     {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
-     {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
-   },
-   { /* Table B.2.a: 16 kHz */
-     {0,6,12,18,24,30,36,44,45,66,80,96,116,140,168,200,238,248,336,396,464,522,576},
-     {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
-   },
-   { /* Table B.8.b: 44.1 kHz */
-     {0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
-     {0,4,8,12,16,22,30,40,52,66,84,106,136,192}
-   },
-   { /* Table B.8.c: 48 kHz */
-     {0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
-     {0,4,8,12,16,22,28,38,50,64,80,100,126,192}
-   },
-   { /* Table B.8.a: 32 kHz */
-     {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
-     {0,4,8,12,16,22,30,42,58,78,104,138,180,192}
-   }
- };
- 
- /*
-   The following table is used to implement the scalefactor
-   partitioning for MPEG2 as described in section
-   2.4.3.2 of the IS. The indexing corresponds to the
-   way the tables are presented in the IS:
- 
-   [table_number][row_in_table][column of nr_of_sfb]
- */
- static unsigned nr_of_sfb_block[6][3][4] =
- {
-   {
-     {6, 5, 5, 5},
-     {9, 9, 9, 9},
-     {6, 9, 9, 9}
-   },
-   {
-     {6, 5, 7, 3},
-     {9, 9, 12, 6},
-     {6, 9, 12, 6}
-   },
-   {
-     {11, 10, 0, 0},
-     {18, 18, 0, 0},
-     {15,18,0,0}
-   },
-   {
-     {7, 7, 7, 0},
-     {12, 12, 12, 0},
-     {6, 15, 12, 0}
-   },
-   {
-     {6, 6, 6, 3},
-     {12, 9, 9, 6},
-     {6, 12, 9, 6}
-   },
-   {
-     {8, 8, 5, 0},
-     {15,12,9,0},
-     {6,18,9,0}
-   }
- };
- 
- /*
-   table of largest scalefactors for MPEG2
- */
- static unsigned max_sfac_tab[6][4] =
- {
-     {4, 4, 3, 3},
-     {4, 4, 3, 0},
-     {3, 2, 0, 0},
-     {4, 5, 5, 0},
-     {3, 3, 3, 0},
-     {2, 2, 0, 0}
- };
- 
- /* Table B.6: layer3 preemphasis */
- int  pretab[21] =
- {
-     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-     1, 1, 1, 1, 2, 2, 3, 3, 3, 2
- };
- 
- /* This is the scfsi_band table from 2.4.2.7 of the IS */
- int scfsi_band_long[5] = { 0, 6, 11, 16, 21 };
- 
- int *scalefac_band_long  = &sfBandIndex[3].l[0];
- int *scalefac_band_short = &sfBandIndex[3].s[0];
- 
- 
- 
- /************************************************************************/
- /*  iteration_loop()                                                    */
- /************************************************************************/
- void
- iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
- 		III_side_info_t *l3_side, int l3_enc[2][2][576],
- 		int mean_bits, int stereo, double xr_dec[2][2][576],
- 		III_scalefac_t *scalefac, frame_params *fr_ps,
- 		int ancillary_pad, int bitsPerFrame ) 
- {
-     static int firstcall = 1;
-     III_psy_xmin l3_xmin;
-     gr_info *cod_info;
-     layer *info;
-     int *main_data_begin;
- 
-     int max_bits;
-     int ch, gr, sfb, i, mode_gr;
-     static int huffman_read_flag = 0; 
- 
-     double xr[2][2][576];
-     I576  *ix;
- 
-     main_data_begin = &l3_side->main_data_begin;
-     l3_side->resvDrain = 0;
- 
-     if ( firstcall )
-     {
- 	*main_data_begin = 0;
- 	firstcall = 0;
- #ifdef PERFORM
- 	log_output = fopen("encode.log","w");
- #endif
-     }
- 
-     info = fr_ps->header;
-     mode_gr = (info->version == 1) ? 2 : 1;
- 
-     scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
-     scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
- 
-     /* reading huffman code table */
-     if (huffman_read_flag == 0) {
-         FILE *fi = OpenTableFile( "huffcode" );
-         if ( fi == NULL )
-             exit( EXIT_FAILURE );
-         read_huffcodetab( fi );
-         huffman_read_flag++;
-         fclose( fi );
-     }
- 
- 
-     for ( gr = 0; gr < mode_gr; gr++ )
-     {
-         for ( ch = 0; ch < stereo; ch++ )
- 	{
-             for ( i = 0; i < 576; i++ ) 
-                 xr[gr][ch][i] = xr_org[gr][ch][i];
- 	}
-     }
- 
-     ResvFrameBegin( fr_ps, l3_side, mean_bits, bitsPerFrame );
- 
-     for ( gr = 0; gr < mode_gr; gr++ )
-     {
-         for ( ch = 0; ch < stereo; ch++ )
-         {
-             ix = (I576 *) l3_enc[gr][ch];
-             cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
-             gr_deco(cod_info);
-             calc_xmin( xr, ratio, cod_info, &l3_xmin, gr, ch );
- 	    
- #ifdef DEBUG
-             printf( "----- start gr[%d] ch[%1d] : block_type=%1d, window_switching_flag=%1d (loop)\n",
-                     gr,ch, cod_info->block_type, cod_info->window_switching_flag ); 
- #endif
- 	    
-             if ( info->version == 1 )
-                 calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr );
- 	    
-             /* calculation of number of available bit( per granule ) */
- 	    max_bits = ResvMaxBits( fr_ps, l3_side, &pe[gr][ch], mean_bits );
- #ifdef DEBUG
-             printf( " max_bits = %d, mean_bits = %d (iteration_loop)\n", max_bits, mean_bits ); 
- #endif
- 	    
-             /* reset of iteration variables */
- 	    
-             for ( sfb = 0; sfb < 21; sfb++ )
-                 scalefac->l[gr][ch][sfb] = 0;
-             for ( sfb = 0; sfb < 13; sfb++ )
-                 for ( i = 0; i < 3; i++ )
-                     scalefac->s[gr][ch][sfb][i] = 0;
- 
- 	    for ( i = 0; i < 4; i++ )
- 		cod_info->slen[i] = 0;
- 	    cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
- 
-             cod_info->part2_3_length    = 0;
-             cod_info->big_values        = 0;
-             cod_info->count1            = 0;
-             cod_info->scalefac_compress = 0;
-             cod_info->table_select[0]   = 0;
-             cod_info->table_select[1]   = 0;
-             cod_info->table_select[2]   = 0;
-             cod_info->subblock_gain[0]  = 0;
-             cod_info->subblock_gain[1]  = 0;
-             cod_info->subblock_gain[2]  = 0;
-             cod_info->region0_count     = 0;
-             cod_info->region1_count     = 0;
-             cod_info->part2_length      = 0;
-             cod_info->preflag           = 0;
-             cod_info->scalefac_scale    = 0;
-             cod_info->quantizerStepSize = 0.0;
-             cod_info->count1table_select= 0;
-             
-             /* all spectral values zero ? */
-             if ( fabs(xr_max(xr[gr][ch], 0, 576)) != 0.0 )
-             {
-                 cod_info->quantizerStepSize =
- 			 (double) quantanf_init( xr[gr][ch] );
-                 cod_info->part2_3_length = outer_loop( xr, max_bits, &l3_xmin,
-                                                        l3_enc, fr_ps, scalefac,
-                                                        gr, ch, l3_side );
-             }
- 	    ResvAdjust( fr_ps, cod_info, l3_side, mean_bits );
- 
- 	    cod_info->global_gain = nint( cod_info->quantizerStepSize + 210.0 );
- 	    assert( cod_info->global_gain < 256 );
-         } /* for ch */
-     } /* for gr */
-     ResvFrameEnd( fr_ps, l3_side, mean_bits );
- }
- 
- 
- 
- /************************************************************************/
- /*  quantanf_init                                                       */
- /************************************************************************/
- int quantanf_init( double xr[576] )
- /* Function: Calculate the first quantization step quantanf.       */
- {
-     int i, tp = 0;
-     double system_const, minlimit;
-     double sfm = 0.0, sum1 = 0.0, sum2 = 0.0;
-     
-     system_const = 8.0;
-     minlimit = -100.0;
- 
-     for ( i = 0; i < 576; i++ )
-     {
-         if ( xr[i] != 0 )
- 	{
-             double tpd = xr[i] * xr[i];
-             sum1 += log( tpd );
-             sum2 += tpd;
-         }
-     }
-     if ( sum2 != 0.0 )
-     {
-         sfm = exp( sum1 / 576.0 ) / (sum2 / 576.0);
-         tp = nint( system_const * log(sfm) );
- 	if ( tp < minlimit )
- 	    tp = minlimit;
- #ifdef DEBUG
-         printf(" quantanf = %d (quantanf_init)\n",tp );
- #endif
-     }
-       return(tp-70.0); /* SS 19-12-96. Starting value of
-                           global_gain or quantizerStepSize 
-                           has to be reduced for iteration_loop
-                        */
- }
- 
- 
- 
- 
- 
- /************************************************************************/
- /*  outer_loop                                                          */
- /************************************************************************/
- /*  Function: The outer iteration loop controls the masking conditions  */
- /*  of all scalefactorbands. It computes the best scalefac and          */
- /*  global gain. This module calls the inner iteration loop             */
- /************************************************************************/
- int outer_loop(
-     double xr[2][2][576],     /*  magnitudes of the spectral values */
-     int max_bits,
-     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
-     int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
-     frame_params *fr_ps,
-     III_scalefac_t *scalefac, /* scalefactors */
-     int gr, int ch, III_side_info_t *l3_side )
- {
-     int status ;
-     int scalesave_l[CBLIMIT], scalesave_s[CBLIMIT][3];
-     int sfb, bits, huff_bits, save_preflag, save_compress;
-     double xfsf[4][CBLIMIT];
-     int i, over, iteration;
-     float max_ratio;
- 
- 
- /* D576 *xrs; */ /* to eliminate warning messages from gcc compiler */
- /* I576 *ix; */  /* replace this code with below. S. Shlien 15-1-97 */
- 
-   double *xrs; 
-   int *ix;  
-   gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
- /* xrs = (D576 *) &xr[gr][ch][0]; */ 
- /* ix  = (I576 *) l3_enc[gr][ch]; */
-  
- 
- xrs = (double *) &(xr[gr][ch][0]); 
- ix  = (int *) &(l3_enc[gr][ch][0]);
- 
- 
-     iteration = 0;
- #ifdef PERFORM
-     if(frameNum == PERFORM)
-     fprintf(log_output,"\n\nframe = %d ch = %d gr= %d\n",frameNum,ch,gr);
- #endif
-     do 
-     {
- 	iteration += 1;
- 	cod_info->part2_length = part2_length( scalefac, fr_ps, gr, ch, l3_side );
-         huff_bits = max_bits - cod_info->part2_length;
- 
- #ifdef BIN_SEARCH
- 	if(iteration == 1)
-         {
-        bin_search_StepSize(max_bits,cod_info->quantizerStepSize,
-           ix,xrs,cod_info); /* speeds things up a bit */
-         }
- #endif
- #ifdef PERFORM
- 	if(frameNum==PERFORM)
-           fprintf(log_output,"\n    Interim Results %d\n\n",iteration);
-         bits = test_inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch,
-          xfsf,l3_xmin);
- #else
-         bits = inner_loop( xr, l3_enc, huff_bits, cod_info, gr, ch );
- #endif
- 
-         calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf ); /* distortion calculation */
- 
-         for ( sfb = 0; sfb < CBLIMIT; sfb++ ) /* save scaling factors */
-             scalesave_l[sfb] = scalefac->l[gr][ch][sfb];
- 
-         for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
-             for ( i = 0; i < 3; i++ )
-                 scalesave_s[sfb][i] = scalefac->s[gr][ch][sfb][i];
-         
-         save_preflag  = cod_info->preflag;
-         save_compress = cod_info->scalefac_compress;
- 
-         preemphasis( &xr[gr][ch][0], xfsf, l3_xmin, gr, ch, l3_side );
- 
- 
- 
- #ifdef PERFORM 
-     if(frameNum == PERFORM)  
-     {
-     fprintf(log_output,"\nbits = %d  huff_bits= %d ", bits,huff_bits);
-     fprintf(log_output," max_bits = %d\n",max_bits);
-     fprintf(log_output,"Stepsize = %f ",cod_info->quantizerStepSize);
-     fprintf(log_output," scale_bits    = %d \n", cod_info->part2_length );  
-     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
-     /*if (gr==0 && ch==0)
-       print_quantized_values(log_output,l3_enc[gr][ch] ,cod_info);*/
-     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
-     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fprintf(log_output,"\n\n");
-     fflush(log_output);
-     }
- #endif
-         over = amp_scalefac_bands( &xr[gr][ch][0], xfsf, l3_xmin,
-                                    l3_side, scalefac, gr, ch, iteration );
- 
- #if 1
-         if ( (status = loop_break(scalefac, cod_info, gr, ch)) == 0 )
- 	{
- 	    if ( fr_ps->header->version == 1 )
- 		status = scale_bitcount( scalefac, cod_info, gr, ch );
- 	    else
- 		status = scale_bitcount_lsf( scalefac, cod_info, gr, ch );
- 	}
- #else
-         status = loop_break( scalefac, cod_info, gr, ch );
- 	if ( fr_ps->header->version == 1 )
- 	    status += scale_bitcount( scalefac, cod_info, gr, ch );
- 	else
- 	    status += scale_bitcount_lsf( scalefac, cod_info, gr, ch );
- #endif
- 
-     }
-     while ( (status == 0) && (over > 0) );
- 
-     cod_info->preflag = save_preflag;
-     cod_info->scalefac_compress = save_compress;
- 
-     for ( sfb = 0; sfb < 21; sfb++ )
-         scalefac->l[gr][ch][sfb] = scalesave_l[sfb];    
- 
-     for ( i = 0; i < 3; i++ )
-         for ( sfb = 0; sfb < 12; sfb++ )
-             scalefac->s[gr][ch][sfb][i] = scalesave_s[sfb][i];    
- 
-     cod_info->part2_length   = part2_length( scalefac, fr_ps, gr, ch, l3_side );
-     cod_info->part2_3_length = cod_info->part2_length + bits;
- 
- #ifdef PERFORM 
-     if(frameNum == PERFORM)
-     {
-     fprintf(log_output,"\n  Final Results\n");
-     fprintf(log_output,"bits = %d  huff_bits= %d", bits,huff_bits);
-     fprintf(log_output," max_bits = %d\n",max_bits);
-     fprintf(log_output," Stepsize = %f ",cod_info->quantizerStepSize);
-     fprintf(log_output, " scale_bits    = %d \n", cod_info->part2_length );  
-     max_ratio = worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     print_scalefacs(log_output,scalefac,cod_info->block_type,gr,ch);
-     fprintf(log_output,"max_ratio = %6.2f\n",max_ratio );
-     print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-     fflush(log_output);
-     }
- #endif    
-     return cod_info->part2_3_length;
- }
- 
- 
- 
- 
- /***************************************************************************/ 
- /*         inner_loop                                                      */ 
- /***************************************************************************/ 
- /* The code selects the best quantizerStepSize for a particular set
- /* of scalefacs                                                            */
-  
- int
- inner_loop( double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
- 	    gr_info *cod_info, int gr, int ch )
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
- 
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
- 
-         calc_runlen( ix, cod_info );  /*rzero,count1,big_values*/
-         bits = c1bits = count1_bitcount( ix, cod_info );  /*count1_table selection*/
-         subdivide( cod_info );  /* bigvalues sfb division */
-         bigv_tab_select( ix, cod_info );  /* codebook selection*/
-         bits += bvbits = bigv_bitcount( ix, cod_info );  /* bit count */
- 
- #ifdef PERFORM
-         if(frameNum == PERFORM)
- 	fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-            cod_info->quantizerStepSize,bits,max_bits);
- #endif
- 
-     }
-     while ( bits > max_bits );
- 
-     return bits;
- }
- 
- 
- 
- /***************************************************************************/ 
- /*        calc_scfsi                                                       */ 
- /***************************************************************************/ 
- /* calculation of the scalefactor select information ( scfsi )        */
- 
- void calc_scfsi( double  xr[576], III_side_info_t *l3_side,
- 	    III_psy_xmin *l3_xmin, int ch, int gr )
- {
-     static int en_tot[2][2]; /* ch,gr */
-     static int en[2][2][21];
-     static int xm[2][2][21];
-     static int xrmax[2][2];
- 
-     int en_tot_krit        = 10;
-     int en_dif_krit        = 100;
-     int en_scfsi_band_krit = 10;
-     int xm_scfsi_band_krit = 10;
- 
-     int scfsi_band;
-     unsigned scfsi_set;
- 
-     int sfb, start, end, i;
-     int condition = 0;
-     double temp, log2 = log( 2.0 );
-     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
-     xrmax[gr][ch] = xr_max( xr, 0, 576 );
-     scfsi_set = 0;
- 
-     /* the total energy of the granule */    
-     for ( temp = 0.0, i = 0; i < 576; i++ )
-         temp += xr[i] * xr[i];
-     if ( temp == 0.0 )
-         en_tot[gr][ch] = 0.0;
-     else
-         en_tot[gr][ch] = log( temp ) / log2 ;
- 
-     /* the energy of each scalefactor band, en */
-     /* the allowed distortion of each scalefactor band, xm */
- 
-     if ( cod_info->window_switching_flag == 0 ||
-          cod_info->block_type != 2 )
-         for ( sfb = 0; sfb < 21; sfb++ )
-         {
-             start = scalefac_band_long[ sfb ];
-             end   = scalefac_band_long[ sfb+1 ];
- 
-             for ( temp = 0.0, i = start; i < end; i++ )
-                 temp += xr[i] * xr[i];
-             if ( temp == 0.0 )
-                 en[gr][ch][sfb] = 0.0;
-             else
-                 en[gr][ch][sfb] = log( temp )/ log2;
- 
-             if ( l3_xmin->l[gr][ch][sfb] == 0.0 )
-                 xm[gr][ch][sfb] = 0.0;
-             else
-                 xm[gr][ch][sfb] = log( l3_xmin->l[gr][ch][sfb] ) / log2;
-         }
-     if ( gr == 1 )
-     {
-         int gr2, tp;
- 
-         for ( gr2 = 0; gr2 < 2; gr2++ )
-         {
-             /* The spectral values are not all zero */
-             if ( xrmax[ch][gr2] != 0.0 )
-                 condition++;
-             /* None of the granules contains short blocks */
-             if ( (cod_info->window_switching_flag == 0) ||
-                  (cod_info->block_type != 2) )
-                 condition++;
-         }
-         if ( abs(en_tot[0] - en_tot[1]) < en_tot_krit )
-             condition++;
-         for ( tp = 0, sfb = 0; sfb < 21; sfb++ ) 
-             tp += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-         if ( tp < en_dif_krit ) 
-             condition++;
- 
-         if ( condition == 6 )
-         {
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-             {
-                 int sum0 = 0, sum1 = 0;
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-                 start = scfsi_band_long[scfsi_band];
-                 end   = scfsi_band_long[scfsi_band+1];
-                 for ( sfb = start; sfb < end; sfb++ )
-                 { 
-                     sum0 += abs( en[ch][0][sfb] - en[ch][1][sfb] );
-                     sum1 += abs( xm[ch][0][sfb] - xm[ch][1][sfb] );
-                 }
- 
-                 if ( sum0 < en_scfsi_band_krit && sum1 < xm_scfsi_band_krit )
- 		{
-                     l3_side->scfsi[ch][scfsi_band] = 1;
- 		    scfsi_set |= (1 << scfsi_band);
- 		}
-                 else
-                     l3_side->scfsi[ch][scfsi_band] = 0;
-             } /* for scfsi_band */
- #ifdef DEBUG
- 	    fprintf( stderr, "calc_scfsi: scfsi_set = 0x%02x\n", scfsi_set );
- #endif
-         } /* if condition == 6 */
-         else
-             for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
-                 l3_side->scfsi[ch][scfsi_band] = 0;
-     } /* if gr == 1 */
- }
- 
- 
- 
- /***************************************************************************/ 
- /*        part2_length                                                     */ 
- /***************************************************************************/ 
- 
- /* calculates the number of bits needed to encode the scalefacs in the     */
- /* main data block                                                         */
- 
- int part2_length( III_scalefac_t *scalefac, frame_params *fr_ps,
- 	      int gr, int ch, III_side_info_t *si )
- {
-     int slen1, slen2, slen3, slen4, bits, sfb, window, partition;
-     gr_info *gi = &si->gr[gr].ch[ch].tt;
- 
-     bits = 0;
-     if ( fr_ps->header->version == 1 )
-     {
- 	static int slen1_tab[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
- 	static int slen2_tab[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
- 
- 	slen1 = slen1_tab[ gi->scalefac_compress ];
- 	slen2 = slen2_tab[ gi->scalefac_compress ];
- 
- 	if ( (gi->window_switching_flag == 1) && (gi->block_type == 2) )
- 	{
- 	    if ( gi->mixed_block_flag )
- 	    {
- 		bits += (8 * slen1) + (9 * slen1) + (18 * slen2);
- 	    }
- 	    else
- 	    {
- 		bits += (18 * slen1) + (18 * slen2);
- 	    }
- 	}
- 	else
- 	{
- 	    if ( (gr == 0) || (si->scfsi[ch][0] == 0) )
- 		bits += (6 * slen1);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][1] == 0) )
- 		/*  bits += (6 * slen1);  This is wrong SS 19-12-96 */
- 		bits += (5 * slen1);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][2] == 0) )
- 		/*  bits += (6 * slen1);   This is wrong SS 19-12-96 */
- 		bits += (5 * slen2);
- 
- 	    if ( (gr == 0) || (si->scfsi[ch][3] == 0) )
- 		/* bits += (6 * slen1);   This is wrong SS 19-12-96 */
- 		bits += (5 * slen2);
- 	}
-     }
-     else
-     {   /* MPEG 2 */
- 	assert( gi->sfb_partition_table );
- 	for ( partition = 0; partition < 4; partition++ )
- 	    bits += gi->slen[partition] * gi->sfb_partition_table[partition];
-     }
-     return bits;
- }
- 
- 
- 
- /*************************************************************************/
- /*            scale_bitcount                                             */
- /*************************************************************************/
- 
- /* Also calculates the number of bits necessary to code the scalefactors. */
- 
- int scale_bitcount( III_scalefac_t *scalefac, gr_info *cod_info,
- 		int gr, int ch )
- {
-     int i, k, sfb, max_slen1 = 0, max_slen2 = 0, /*a, b, */ ep = 2;
- 
-     static int slen1[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
-     static int slen2[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
-     static int pow2[5]   = { 1, 2, 4, 8, 16 };
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-     {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
-             /* a = 18; b = 18;  */
-             for ( i = 0; i < 3; i++ )
-             {
-                 for ( sfb = 0; sfb < 6; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
-                         max_slen1 = scalefac->s[gr][ch][sfb][i];
-                 for (sfb = 6; sfb < 12; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
-                         max_slen2 = scalefac->s[gr][ch][sfb][i];
-             }
-         }
-         else
-         {/* mixed_block_flag = 1 */
-             /* a = 17; b = 18;  */
-             for ( sfb = 0; sfb < 8; sfb++ )
-                 if ( scalefac->l[gr][ch][sfb] > max_slen1 )
-                     max_slen1 = scalefac->l[gr][ch][sfb];
-             for ( i = 0; i < 3; i++ )
-             {
-                 for ( sfb = 3; sfb < 6; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
-                         max_slen1 = scalefac->s[gr][ch][sfb][i];
-                 for ( sfb = 6; sfb < 12; sfb++ )
-                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
-                         max_slen2 = scalefac->s[gr][ch][sfb][i];
-             }
-         }
-     }
-     else
-     { /* block_type == 1,2,or 3 */
-         /* a = 11; b = 10;   */
-         for ( sfb = 0; sfb < 11; sfb++ )
-             if ( scalefac->l[gr][ch][sfb] > max_slen1 )
-                 max_slen1 = scalefac->l[gr][ch][sfb];
-         for ( sfb = 11; sfb < 21; sfb++ )
-             if ( scalefac->l[gr][ch][sfb] > max_slen2 )
-                 max_slen2 = scalefac->l[gr][ch][sfb];
-     }
- 
-     for ( k = 0; k < 16; k++ )
-     {
-         if ( (max_slen1 < pow2[slen1[k]]) && (max_slen2 < pow2[slen2[k]]) )
-         { 
-             ep = 0;
-             break;
-         } 
-     }
- 
-     if ( ep == 0 )
-         cod_info->scalefac_compress = k;
- #ifdef DEBUG
-     if ( ep != 0 ) 
-         printf( "---WARNING !! Amplification of some bands over limits\n" );
- #endif
-     return ep;
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            scale_bitcount_lsf                                         */
- /*************************************************************************/
- 
- /* Also counts the number of bits to encode the scalefacs but for MPEG 2 */ 
- /* Lower sampling frequencies  (24, 22.05 and 16 kHz.)                   */
-  
- /*  This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,     */
- /* "Audio Decoding Layer III"                                            */
- 
- int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info,
- 		    int gr, int ch )
- {
-     int table_number, row_in_table, partition, nr_sfb, window, over;
-     int i, k, sfb, max_sfac[ 4 ];
-     unsigned *partition_table;
- 
-     /*
-       Set partition table. Note that should try to use table one,
-       but do not yet...
-     */
-     if ( cod_info->preflag )
- 	table_number = 2;
-     else
- 	table_number = 0;
- 
-     for ( i = 0; i < 4; i++ )
- 	max_sfac[i] = 0;
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-     {
-         if ( cod_info->mixed_block_flag == 0 ) 
-         {
- 	    row_in_table = 1;
- 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	    for ( sfb = 0, partition = 0; partition < 4; partition++ )
- 	    {
- 		nr_sfb = partition_table[ partition ] / 3;
- 		for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		    for ( window = 0; window < 3; window++ )
- 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
- 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
- 	    }
-         }
-         else
-         {/* mixed_block_flag = 1 */
- 	    row_in_table = 2;
- 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	    partition = 0;
- 	    nr_sfb = partition_table[ partition ];
- 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
- 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
- 	    
- 	    for ( sfb = 0, partition = 1; partition < 4; partition++ )
- 	    {
- 		nr_sfb = partition_table[ partition ] / 3;
- 		for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		    for ( window = 0; window < 3; window++ )
- 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
- 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
- 	    }
-         }
-     }
-     else
-     {
- 	row_in_table = 0;
- 	partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	partition = 0;
- 	for ( sfb = 0, partition = 0; partition < 4; partition++ )
- 	{
- 	    nr_sfb = partition_table[ partition ];
- 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
- 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
- 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
- 	}
-     }
- 
-     for ( over = 0, partition = 0; partition < 4; partition++ )
-     {
- 	if ( max_sfac[partition] > max_sfac_tab[table_number][partition] )
- 	    over++;
-     }
-     if ( !over )
-     {
- 	/*
- 	  Since no bands have been over-amplified, we can set scalefac_compress
- 	  and slen[] for the formatter
- 	*/
- 	static int log2tab[] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 };
- 
- 	unsigned slen1, slen2, slen3, slen4;
- 
-         cod_info->sfb_partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
- 	for ( partition = 0; partition < 4; partition++ )
- 	    cod_info->slen[partition] = log2tab[max_sfac[partition]];
- 
- 	/* set scalefac_compress */
- 	slen1 = cod_info->slen[ 0 ];
- 	slen2 = cod_info->slen[ 1 ];
- 	slen3 = cod_info->slen[ 2 ];
- 	slen4 = cod_info->slen[ 3 ];
- 
- 	switch ( table_number )
- 	{
- 	  case 0:
- 	    cod_info->scalefac_compress = (((slen1 * 5) + slen2) << 4)
- 		+ (slen3 << 2)
- 		+ slen4;
- 	    break;
- 
- 	  case 1:
- 	    cod_info->scalefac_compress = 400
- 		+ (((slen1 * 5) + slen2) << 2)
- 		+ slen3;
- 	    break;
- 
- 	  case 2:
- 	    cod_info->scalefac_compress = 500 + (slen1 * 3) + slen2;
- 	    break;
- 
- 	  default:
- 	    fprintf( stderr, "intensity stereo not implemented yet\n" );
- 	    exit( EXIT_FAILURE );
- 	    break;
- 	}
-     }
- #ifdef DEBUG
-     if ( over ) 
-         printf( "---WARNING !! Amplification of some bands over limits\n" );
- #endif
-     return over;
- }
- 
- 
- /*************************************************************************/
- /*            calc_noise                                                 */
- /*************************************************************************/
- 
- /*   Function: Calculate the distortion introduced by the quantization   */
- /*   in each scale factor band.                                          */
- 
- void calc_noise( double xr[576], int ix[576], gr_info *cod_info,
- 	    double xfsf[4][CBLIMIT] )
- {
-     int start, end, sfb, l, i;
-     double sum,step,bw;
- 
-     D192_3 *xr_s;
-     I192_3 *ix_s;
- 
-     xr_s = (D192_3 *) xr;
-     ix_s = (I192_3 *) ix;
- 
-     step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 );
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
-         start = scalefac_band_long[ sfb ];
-         end   = scalefac_band_long[ sfb+1 ];
- 	bw = end - start;
- 
-         for ( sum = 0.0, l = start; l < end; l++ )
-         {
-             double temp;
-             temp = fabs( xr[l] ) - pow( (double) ix[l], 4.0 / 3.0 ) * step;
-             sum += temp * temp; 
-         }
-         xfsf[0][sfb] = sum / bw;
-     }
- 
-     for ( i = 0; i < 3; i++ )
-     {
-         step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 ); /* subblock_gain ? */
-         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-         {
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
- 	    bw = end - start;
-             
-             for ( sum = 0.0, l = start; l < end; l++ )
-             {
-                 double temp;
-                 temp = fabs( (*xr_s)[l][i] ) - pow( (double) (*ix_s)[l][i], 4.0 / 3.0 ) * step;
-                 sum += temp * temp;
-             }       
-             xfsf[i+1][sfb] = sum / bw;
-         }
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            calc_xmin                                                  */
- /*************************************************************************/
- 
- /*
-   Calculate the allowed distortion for each scalefactor band,
-   as determined by the psychoacoustic model.
-   xmin(sb) = ratio(sb) * en(sb) / bw(sb)
- */
- 
- void calc_xmin( double xr[2][2][576], III_psy_ratio *ratio,
- 	   gr_info *cod_info, III_psy_xmin *l3_xmin,
- 	   int gr, int ch )
- {
-     int start, end, sfb, l, b;
-     double en, bw;
- 
-     D192_3 *xr_s;
- 
-     xr_s = (D192_3 *) xr[gr][ch] ;
- 
-     for ( sfb = cod_info->sfb_smax; sfb < SFB_SMAX - 1; sfb++ )
-     {
-         start = scalefac_band_short[ sfb ];
-         end   = scalefac_band_short[ sfb + 1 ];
- 	bw = end - start;
-         for ( b = 0; b < 3; b++ )
-         {
-             for ( en = 0.0, l = start; l < end; l++ )
-                 en += (*xr_s)[l][b] * (*xr_s)[l][b];
-             l3_xmin->s[gr][ch][sfb][b] = ratio->s[gr][ch][sfb][b] * en / bw;
-         }
-     }
- 
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
-         start = scalefac_band_long[ sfb ];
-         end   = scalefac_band_long[ sfb+1 ];
- 	bw = end - start;
- 
-         for ( en = 0.0, l = start; l < end; l++ )
-             en += xr[gr][ch][l] * xr[gr][ch][l];
-         l3_xmin->l[gr][ch][sfb] = ratio->l[gr][ch][sfb] * en / bw;
-     }
- }
- 
- 
- 
- /*************************************************************************/
- /*            loop_break                                                 */
- /*************************************************************************/
- 
- /*  Function: Returns zero if there is a scalefac which has not been
-     amplified. Otherwise it returns one. 
- */
- 
- int loop_break( III_scalefac_t *scalefac, gr_info *cod_info,
- 	    int gr, int ch )
- {
-     int i, sfb, temp = 1;
- 
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-         if ( scalefac->l[gr][ch][sfb] == 0 )
-             temp = 0;
- 
-     for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-         for ( i = 0; i < 3; i++ )
-             if ( scalefac->s[gr][ch][sfb][i] == 0 )
-                 temp = 0;
- #ifdef DEBUG
-     if ( temp != 0 )
-         printf( "---WARNING !! All scalefactor bands amplified\n" );
- #endif
-     return temp;
- }
- 
- 
- 
- /*************************************************************************/
- /*            preemphasis                                                */
- /*************************************************************************/
- 
- /*
-   See ISO 11172-3  section  C.1.5.4.3.4
- */
- 
- void preemphasis( double xr[576], double xfsf[4][CBLIMIT],
- 	     III_psy_xmin  *l3_xmin,
- 	     int gr, int ch, III_side_info_t *l3_side )
- {
-     int i, sfb, start, end, scfsi_band, over;
-     double ifqstep;
-     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
- 
-     if ( gr == 1 )
-     {
- 	/*
- 	  If the second granule is being coded and scfsi is active in
- 	  at least one scfsi_band, the preemphasis in the second granule
- 	  is set equal to the setting in the first granule
- 	*/
- 	for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		cod_info->preflag = l3_side->gr[0].ch[ch].tt.preflag;
- 		return;
- 	    }
- 	
-     }
- 
-     /*
-       Preemphasis is switched on if in all the upper four scalefactor
-       bands the actual distortion exceeds the threshold after the
-       first call of the inner loop
-     */
-     if ( cod_info->block_type != 2 && cod_info->preflag == 0 )
-     {	
- 	over = 0;
- 	for ( sfb = 17; sfb < 21; sfb++ )
- 	    if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
- 		over++;
- 
- 	if (over == 4 )
- 	{
- 	    cod_info->preflag = 1;
- 	    ifqstep = ( cod_info->scalefac_scale == 0 ) ? sqrt(2.)
- 		: pow( 2.0, (0.5 * (1.0 + (double) cod_info->scalefac_scale)) );
- 
- 	    for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
- 	    {
- 		l3_xmin->l[gr][ch][sfb] *= pow( ifqstep, 2.0 * (double) pretab[sfb] );
- 		start = scalefac_band_long[ sfb ];
- 		end   = scalefac_band_long[ sfb+1 ];
- 		for( i = start; i < end; i++ )
- 		    xr[i] *= pow( ifqstep, (double) pretab[sfb] );
- 	    }
- 	}
-     }
- }
- 
- 
- /*************************************************************************/
- /*            amp_scalefac_bands                                         */
- /*************************************************************************/
- 
- /* 
-   Amplify the scalefactor bands that violate the masking threshold.
-   See ISO 11172-3 Section C.1.5.4.3.5
- */
- 
- int amp_scalefac_bands( double xr[576], double xfsf[4][CBLIMIT],
- 		    III_psy_xmin *l3_xmin, III_side_info_t *l3_side,
- 		    III_scalefac_t *scalefac,
- 		    int gr, int ch, int iteration )
- {
-     int start, end, l, sfb, i, scfsi_band, over = 0;
-     double ifqstep, ifqstep2;
-     D192_3 *xr_s;
-     gr_info *cod_info, *gr0;
-     int copySF, preventSF;
-     cod_info = &l3_side->gr[gr].ch[ch].tt;
-     gr0      = &l3_side->gr[0].ch[ch].tt;
- 
-     xr_s = (D192_3 *) xr;
-     copySF = 0;
-     preventSF = 0;
- 
-     if ( cod_info->scalefac_scale == 0 )
- 	ifqstep = sqrt( 2.0 );
-     else
- 	ifqstep = pow( 2.0, 0.5 * (1.0 + (double) cod_info->scalefac_scale) );
- 
-     if ( gr == 1 )
-     {
- 	/*
- 	  If the second granule is being coded and scfsi is active in at
- 	  least one scfsi_band...
- 	*/
- 	for ( scfsi_band = 0; scfsi_band < 4; scfsi_band++ )
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		/*
- 		  a) ifqstep has to be set similar to the
- 		   first granule...
- 		*/
- 		if ( gr0->scalefac_scale == 0 )
- 		    ifqstep = sqrt( 2.0 );
- 		else
- 		    ifqstep = pow( 2.0, 0.5 * (1.0 + (double) gr0->scalefac_scale) );
- 
- 		if ( iteration == 1 )
- 		{
- 		    /*
- 		      b) If it is the first iteration, the scalefactors
- 		      of scalefactor bands in which scfsi is enabled
- 		      must be taken from the first granule
- 		    */  
- 		    copySF = 1;
- 		}
- 		else
- 		{
- 		    /*
- 		      c) If it is not the first iteration, the amplification
- 		      must be prevented for scalefactor bands in which
- 		      scfsi is enabled
- 		    */
- 		    preventSF = 1;
- 		}
- 		break;
- 	    }
- 	
-     }
- 
-     ifqstep2 = ifqstep * ifqstep;
-     scfsi_band = 0;
-     
-     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
-     {
- 	if ( copySF || preventSF )
- 	{
- 	    if ( sfb == scfsi_band_long[scfsi_band + 1] )
- 		scfsi_band += 1;
- 	    if ( l3_side->scfsi[ch][scfsi_band] )
- 	    {
- 		if ( copySF )
- 		    scalefac->l[gr][ch][sfb] = scalefac->l[0][ch][sfb];
- 		continue;
- 	    }
- 	}	    
- 	if ( xfsf[0][sfb] > l3_xmin->l[gr][ch][sfb] )
- 	{
- 	    over++;
- 	    l3_xmin->l[gr][ch][sfb] *= ifqstep2;
- 	    scalefac->l[gr][ch][sfb]++;
- 	    start = scalefac_band_long[sfb];
- 	    end   = scalefac_band_long[sfb+1];
- 	    for ( l = start; l < end; l++ )
- 		xr[l] *= ifqstep;
- 	}
-     }
- 
-     /*
-       Note that scfsi is not enabled for frames containing
-       short blocks
-     */
-     for ( i = 0; i < 3; i++ )
-         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
-             if ( xfsf[i+1][sfb] > l3_xmin->s[gr][ch][sfb][i] )
-             {
-                 over++;
-                 l3_xmin->s[gr][ch][sfb][i] *= ifqstep2;
-                 scalefac->s[gr][ch][sfb][i]++;
- #ifdef DEBUGSC
-                 printf( "cod_info->scalefac[%d][%d] = %d (amp_scale)\n",
-                         i,sfb,scalefac->s[gr][ch][sfb][i] );
- #endif
-                 start = scalefac_band_short[sfb];
-                 end   = scalefac_band_short[sfb+1];
-                 for ( l = start; l < end; l++ )
-                     (*xr_s)[l][i] *= ifqstep;
-             }
-     return over;
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            quantize                                                   */
- /*************************************************************************/
- 
- /*
-   Function: Quantization of the vector xr ( -> ix)
- */
- 
- void quantize( double xr[576], int ix[576], gr_info *cod_info )
- {
-     int i, b, l_end, s_start;
-     double step, quantizerStepSize;
- 
-     D192_3 *xr_s;
-     I192_3 *ix_s;
- 
-     xr_s = (D192_3 *) xr;
-     ix_s = (I192_3 *) ix;
- 
-     quantizerStepSize = (double) cod_info->quantizerStepSize;
- 
-     for ( i = 0; i < 576; i++ )
- 	ix[i] = 0;
- 
-     if ( cod_info->quantizerStepSize == 0.0 )
- 	step = 1.0;
-     else
- 	step = pow ( 2.0, quantizerStepSize * 0.25 );
- 
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
- 	if ( cod_info->mixed_block_flag == 0 )
- 	{
- 	    l_end = 0;
- 	    s_start = 0;
- 	}
- 	else
- 	{
- 	    l_end = 18 * 2;
- 	    s_start = 6 * 2;
- 	}
-     else
-     {
- 	l_end = 576;
- 	s_start = 192;
-     }
- 
-     for ( i = 0; i < l_end; i++ )
- 	ix[i] = nint( pow(fabs(xr[i]) / step, 0.75) - 0.0946 );
-     
-     if ( s_start < 192 )
- 	for ( b = 0; b < 3; b++ )
- 	{
- 	    step = pow( 2.0, (quantizerStepSize + 8.0 * (double) cod_info->subblock_gain[b]) * 0.25 );
- 	    for ( i = s_start; i < 192; i++ )
- 		(*ix_s)[i][b] = nint( pow(fabs((*xr_s)[i][b]) / step, 0.75) - 0.0946 );
- 	}
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            ix_max                                                     */
- /*************************************************************************/
- 
- /*
-   Function: Calculate the maximum of ix from 0 to 575
- */
- 
- int ix_max( int ix[576], unsigned int begin, unsigned int end )
- {
-     int i, max = 0;
- 
-     for ( i = begin; i < end; i++ )
-     {
-         int x = abs( ix[i] );
-         if ( x > max )
-             max = x;
-     }
-     return max;
- }
- 
- 
- /*************************************************************************/
- /*            xr_max                                                     */
- /*************************************************************************/
- 
- /*
-   Function: Calculate the maximum of xr[576]  from 0 to 575
- */
- 
- double xr_max( double xr[576], unsigned int begin, unsigned int end )
- {
-     int i;
-     double max = 0.0, temp;
- 
-     for ( i = begin; i < end; i++ )
-         if( (temp = fabs(xr[i])) > max )
- 	    max = temp;
-     return max;
- }
- 
- 
- 
- /*        Noiseless coding  -- Huffman coding   */
- 
- 
- /*************************************************************************/
- /*            calc_runlen                                                */
- /*************************************************************************/
- 
- /*
- Function: Calculation of rzero, count1, big_values
- (Partitions ix into big values, quadruples and zeros).
- */
- 
- void calc_runlen( int ix[576], gr_info *cod_info )
- {
-     int i;
-     int rzero = 0; 
- 
-     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
-     {  /* short blocks */
-         cod_info->count1 = 0;
-         cod_info->big_values = 288;
-     }
-     else
-     {
-         for ( i = 576; i > 1; i -= 2 )
-             if ( ix[i-1] == 0 && ix[i-2] == 0 )
-                 rzero++;
-             else
-                 break;
-         
-         cod_info->count1 = 0 ;
-         for ( ; i > 3; i -= 4 )
-             if ( abs(ix[i-1]) <= 1
-               && abs(ix[i-2]) <= 1
-               && abs(ix[i-3]) <= 1
-               && abs(ix[i-4]) <= 1 )
-                 cod_info->count1++;
-             else
-                 break;
-         
-         cod_info->big_values = i/2;
-     }
-     assert( (2 * rzero + 4 * cod_info->count1 + 2 * cod_info->big_values) == 576 );
- }
- 
- 
- 
- /*************************************************************************/
- /*            count1_bitcount                                            */
- /*************************************************************************/
- 
- /*
-   Determines the number of bits to encode the quadruples.
- */
- 
- int count1_bitcount( int ix[ 576 ], gr_info *cod_info )
- {
-     int abs_and_sign( int *x );
- 
-     int p, i, k, bitsum_count1;
-     int v, w, x, y, signbits;
-     int sum0 = 0, sum1 = 0;
- 
-     for ( i = cod_info->big_values * 2, k = 0; k < cod_info->count1; i += 4, k++ )
-     {
-         v = ix[ i ];
-         w = ix[ i + 1 ];
-         x = ix[ i + 2 ];
-         y = ix[ i + 3 ];
-         
-         abs_and_sign( &v );
-         abs_and_sign( &w );
-         abs_and_sign( &x );
-         abs_and_sign( &y );
- 
-         p = v + (w << 1) + (x << 2) + (y << 3);
-         
-         signbits = 0;
- 
-         if ( v != 0 )
-             signbits += 1;
-         if ( w != 0 )
-             signbits += 1;
-         if ( x != 0 )
-             signbits += 1;
-         if ( y != 0 )
-             signbits += 1;
- 
-         sum0 += signbits;
-         sum1 += signbits;
- 
-         sum0 += ht[ 32 ].hlen[ p ];
-         sum1 += ht[ 33 ].hlen[ p ];
-     }
- 
-     if ( sum0 < sum1 )
-     {
-         bitsum_count1 = sum0;
-         cod_info->count1table_select = 0;
-     }
-     else
-     {
-         bitsum_count1 = sum1;
-         cod_info->count1table_select = 1;
-     }
-     return( bitsum_count1 );
- }
- 
- 
- 
- 
- 
- struct
- {
-     unsigned region0_count;
-     unsigned region1_count;
- } subdv_table[ 23 ] =
- {
- {0, 0}, /* 0 bands */
- {0, 0}, /* 1 bands */
- {0, 0}, /* 2 bands */
- {0, 0}, /* 3 bands */
- {0, 0}, /* 4 bands */
- {0, 1}, /* 5 bands */
- {1, 1}, /* 6 bands */
- {1, 1}, /* 7 bands */
- {1, 2}, /* 8 bands */
- {2, 2}, /* 9 bands */
- {2, 3}, /* 10 bands */
- {2, 3}, /* 11 bands */
- {3, 4}, /* 12 bands */
- {3, 4}, /* 13 bands */
- {3, 4}, /* 14 bands */
- {4, 5}, /* 15 bands */
- {4, 5}, /* 16 bands */
- {4, 6}, /* 17 bands */
- {5, 6}, /* 18 bands */
- {5, 6}, /* 19 bands */
- {5, 7}, /* 20 bands */
- {6, 7}, /* 21 bands */
- {6, 7}, /* 22 bands */
- };
- 
- 
- 
- 
- /*************************************************************************/
- /*            subdivide                                                  */
- /*************************************************************************/
- 
- /* presumable subdivides the bigvalue region which will
-    use separate Huffman tables.
- */
- 
- void subdivide( gr_info *cod_info )
- {
-     int scfb_anz = 0;
-     int bigvalues_region;
-     
-     if ( cod_info->big_values == 0 )
-     { /* no big_values region */
-         cod_info->region0_count = 0;
-         cod_info->region1_count = 0;
-     }
-     else
-     {
-         bigvalues_region = 2 * cod_info->big_values;
- 
-         if ( (cod_info->window_switching_flag == 0) )
-         { /* long blocks */
-             int thiscount, index;
-             /* Calculate scfb_anz */
-             while ( scalefac_band_long[scfb_anz] < bigvalues_region )
-                 scfb_anz++;
-             assert( scfb_anz < 23 );
- 
-             cod_info->region0_count = subdv_table[scfb_anz].region0_count;
-             thiscount = cod_info->region0_count;
-             index = thiscount + 1;
-             while ( thiscount && (scalefac_band_long[index] > bigvalues_region) )
-             {
-                 thiscount -= 1;
-                 index -= 1;
-             }
-             cod_info->region0_count = thiscount;
- 
-             cod_info->region1_count = subdv_table[scfb_anz].region1_count;
-             index = cod_info->region0_count + cod_info->region1_count + 2;
-             thiscount = cod_info->region1_count;
-             while ( thiscount && (scalefac_band_long[index] > bigvalues_region) )
-             {
-                 thiscount -= 1;
-                 index -= 1;
-             }
-             cod_info->region1_count = thiscount;
-             cod_info->address1 = scalefac_band_long[cod_info->region0_count+1];
-             cod_info->address2 = scalefac_band_long[cod_info->region0_count
-                                                     + cod_info->region1_count + 2 ];
-             cod_info->address3 = bigvalues_region;
-         }
-         else
-         {
-             if ( (cod_info->block_type == 2) && (cod_info->mixed_block_flag == 0) )
-             { 
-                 cod_info->region0_count =  8;
-                 cod_info->region1_count =  36;
-                 cod_info->address1 = 36;
-                 cod_info->address2 = bigvalues_region;
-                 cod_info->address3 = 0;  
-             }
-             else
-             {
-                 cod_info->region0_count = 7;
-                 cod_info->region1_count = 13;
-                 cod_info->address1 = scalefac_band_long[cod_info->region0_count+1];
-                 cod_info->address2 = bigvalues_region;
-                 cod_info->address3 = 0;
-             }
-         }
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            bigv_tab_select                                            */
- /*************************************************************************/
- 
- /*
- /*  Function: Select huffman code tables for bigvalues regions 
- */
- 
- void bigv_tab_select( int ix[576], gr_info *cod_info )
- {
-     /* int max; */
- 
-     cod_info->table_select[0] = 0;
-     cod_info->table_select[1] = 0;
-     cod_info->table_select[2] = 0;
-     
-     if ( cod_info->window_switching_flag && (cod_info->block_type == 2) )
-     {
-         /*
-           Within each scalefactor band, data is given for successive
-           time windows, beginning with window 0 and ending with window 2.
-           Within each window, the quantized values are then arranged in
-           order of increasing frequency...
-           */
-         int sfb, window, line, start, end, max1, max2, x, y;
-         int region1Start;
-         int *pmax;
- 
-         region1Start = 12;
-         max1 = max2 = 0;
- 
-         for ( sfb = 0; sfb < 13; sfb++ )
-         {
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
-             
-             if ( start < region1Start )
-                 pmax = &max1;
-             else
-                 pmax = &max2;
-             
-             for ( window = 0; window < 3; window++ )
-                 for ( line = start; line < end; line += 2 )
-                 {
-                     assert( line >= 0 );
-                     assert( line < 576 );
-                     x = abs( ix[ (line * 3) + window ] );
-                     y = abs( ix[ ((line + 1) * 3) + window ]);
-                     *pmax = *pmax > x ? *pmax : x;
-                     *pmax = *pmax > y ? *pmax : y;
-                 }
-         }
-         cod_info->table_select[0] = choose_table( max1 );
-         cod_info->table_select[1] = choose_table( max2 );
-     }
-     else
-     {
-         if ( cod_info->address1 > 0 )
-             cod_info->table_select[0] = new_choose_table( ix, 0, cod_info->address1 );
- 
-         if ( cod_info->address2 > cod_info->address1 )
-             cod_info->table_select[1] = new_choose_table( ix, cod_info->address1, cod_info->address2 );
- 
-         if ( cod_info->big_values * 2 > cod_info->address2 )
-             cod_info->table_select[2] = new_choose_table( ix, cod_info->address2, cod_info->big_values * 2 );
-     }
- }
- 
- 
- 
- 
- /*************************************************************************/
- /*            new_choose table                                           */
- /*************************************************************************/
- 
- /*
-   Choose the Huffman table that will encode ix[begin..end] with
-   the fewest bits.
- 
-   Note: This code contains knowledge about the sizes and characteristics
-   of the Huffman tables as defined in the IS (Table B.7), and will not work
-   with any arbitrary tables.
- */
- 
- int new_choose_table( int ix[576], unsigned int begin, unsigned int end )
- {
-     int i, max;
-     int choice[ 2 ];
-     int sum[ 2 ];
- 
-     max = ix_max( ix, begin, end );
- 
-     if ( max == 0 )
-         return 0;
-     
-     max = abs( max );
- 
-     choice[ 0 ] = 0;
-     choice[ 1 ] = 0;
- 
-     if ( max < 15 )
-     {
- 	/* try tables with no linbits */
-         for ( i = 0; i < 14; i++ )
-             if ( ht[i].xlen > max )
- 	    {
- 		choice[ 0 ] = i;
-                 break;
- 	    }
- 	assert( choice[0] );
- 
- 	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
- 
- 	switch ( choice[0] )
- 	{
- 	  case 2:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 3 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 3;
- 	    break;
- 
- 	  case 5:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 6 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 6;
- 	    break;
- 
- 	  case 7:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 8 );
- 	    if ( sum[1] <= sum[0] )
- 	    {
- 		choice[ 0 ] = 8;
- 		sum[ 0 ] = sum[ 1 ];
- 	    }
- 	    sum[ 1 ] = count_bit( ix, begin, end, 9 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 9;
- 	    break;
- 
- 	  case 10:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 11 );
- 	    if ( sum[1] <= sum[0] )
- 	    {
- 		choice[ 0 ] = 11;
- 		sum[ 0 ] = sum[ 1 ];
- 	    }
- 	    sum[ 1 ] = count_bit( ix, begin, end, 12 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 12;
- 	    break;
- 
- 	  case 13:
- 	    sum[ 1 ] = count_bit( ix, begin, end, 15 );
- 	    if ( sum[1] <= sum[0] )
- 		choice[ 0 ] = 15;
- 	    break;
- 
- 	  default:
- 	    break;
- 	}
-     }
-     else
-     {
- 	/* try tables with linbits */
- 	max -= 15;
- 	
- 	for ( i = 15; i < 24; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice[ 0 ] = i;
- 		break;
- 	    }
- 	}
- 	for ( i = 24; i < 32; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice[ 1 ] = i;
- 		break;
- 	    }
- 	}
- 	assert( choice[0] );
- 	assert( choice[1] );
- 	
- 	sum[ 0 ] = count_bit( ix, begin, end, choice[0] );
- 	sum[ 1 ] = count_bit( ix, begin, end, choice[1] );
- 	if ( sum[1] < sum[0] )
- 	    choice[ 0 ] = choice[ 1 ];
-     }
-     return choice[ 0 ];
- }
- 
- 
- 
- /*************************************************************************/
- /*            choose table                                               */
- /*************************************************************************/
- 
- int choose_table( int max )
- {
-     int  i, choice;
- 
-     if ( max == 0 )
-         return 0;
-     
-     max = abs( max );    
-     choice = 0;
- 
-     if ( max < 15 )
-     {
-         for ( i = 0; i < 15; i++ )
-         {
-             if ( ht[i].xlen > max )
-             {
- 		choice = i;
- 		break;
-             }
-         }
-     }
-     else
-     {	
- 	max -= 15;
- 	for (i = 15; i < 32; i++ )
- 	{
- 	    if ( ht[i].linmax >= max )
- 	    {
- 		choice = i;
- 		break;
- 	    }
- 	}
-     }
-     assert( choice );
-     return choice;
- }
- 
- 
- /*************************************************************************/
- /*            bigv_bitcount                                              */
- /*************************************************************************/
- 
- /*
- Function: Count the number of bits necessary to code the bigvalues region.
- */
- 
- int bigv_bitcount( int ix[576], gr_info *gi )
- {
-     int bits = 0;
-     
-     if ( gi->window_switching_flag && gi->block_type == 2 )
-     {
-         /*
-           Within each scalefactor band, data is given for successive
-           time windows, beginning with window 0 and ending with window 2.
-           Within each window, the quantized values are then arranged in
-           order of increasing frequency...
-           */
-         int sfb, window, line, start, end;
-         I192_3 *ix_s;
- 
-         if ( gi->mixed_block_flag )
-         {
-             unsigned int table;
- 
-             if ( (table = gi->table_select[0]) != 0 )
-                 bits += count_bit( ix, 0, gi->address1, table );
-             sfb = 2;
-         }
-         else
-             sfb = 0;
- 
-         ix_s = (I192_3 *) &ix[0];
- 
-         for ( ; sfb < 13; sfb++ )
-         {
-             unsigned tableindex = 100;
- 
-             start = scalefac_band_short[ sfb ];
-             end   = scalefac_band_short[ sfb+1 ];
- 
-             if ( start < 12 )
-                 tableindex = gi->table_select[ 0 ];
-             else
-                 tableindex = gi->table_select[ 1 ];
-             assert( tableindex < 32 );
- 
-             for ( window = 0; window < 3; window++ )
-                 for ( line = start; line < end; line += 2 )
-                 {
-                     unsigned int code, ext;
-                     int cbits, xbits;
-                     int x = (*ix_s)[line][window];
-                     int y = (*ix_s)[line + 1][window];
-                     bits += HuffmanCode( tableindex, x, y, &code, &ext, &cbits, &xbits );
-                 }
-         }
-     }
-     else
-     {
-         unsigned int table;
-         
-         if( (table=gi->table_select[0]) != 0 )  /* region0 */ 
-             bits += count_bit(ix, 0, gi->address1, table );
-         if( (table=gi->table_select[1]) != 0 )  /* region1 */ 
-             bits += count_bit(ix, gi->address1, gi->address2, table );
-         if( (table=gi->table_select[2]) != 0 )  /* region2 */ 
-             bits += count_bit(ix, gi->address2, gi->address3, table );
-     }
-     return bits;
- }
- 
- 
- 
- /*************************************************************************/
- /*            count_bit                                                  */
- /*************************************************************************/
- 
- /*
-  Function: Count the number of bits necessary to code the subregion. 
- */
- 
- int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table )
- {
-     int i, sum;
- 
-     sum = 0;
-     for ( i = start; i < end; i += 2 )
-     {
-         unsigned int code, ext;
-         int cbits, xbits;
-         sum += HuffmanCode( table, ix[i], ix[i+1], &code, &ext, &cbits, &xbits );
-     }
-     return sum;
- }
- 
- 
- 
- #ifndef HAVE_NINT
- int
- nint( double in )
- {
-     int    temp;
- 
-     if( in < 0 )  temp = (int)(in - 0.5);
-     else    temp = (int)(in + 0.5);
- 
-     return(temp);
- }
- 
- double
- aint(double in) {
- 	return((long) in);
- }
- #endif
- 
- 
- 
- /*
-   Seymour's comment:  Jan 8 1995
-   When mixed_block_flag is set, the low subbands 0-1 undergo the long
-   window transform and are each split into 18 frequency lines, while
-   the remaining 30 subbands undergo the short window transform and are
-   each split into 6 frequency lines. A problem now arises, as neither
-   the short or long scale factor bands apply to this mixed spectrum.
-   The standard resolves this situation by using the first 8 long scale
-   factor bands for the low spectrum and the short scale factor bands
-   in the range of 3 to 11 (inclusive) for the remaining frequency lines.
-   These scale factor bands do not match exactly to the 0-1 subbands
-   for all sampling frequencies (32,44.1 and 48 kHz); however they
-   were designed so that there would not be a frequency gap or overlap
-   at the switch over point. (Note multiply short frequency lines by 3
-   to account for wider frequency line.) 
-   */
- 
- 
- 
- /*************************************************************************/
- /*            gr_deco                                                    */
- /*************************************************************************/
- 
- void gr_deco( gr_info *cod_info )
- {
-     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
-         if ( cod_info->mixed_block_flag == 0 )
-         {
-             cod_info->sfb_lmax = 0; /* No sb*/
-             cod_info->sfb_smax = 0;
-         }
-         else
-         {
-             cod_info->sfb_lmax = 8;
-             cod_info->sfb_smax = 3;
-         }
-     else
-     {
-         cod_info->sfb_lmax = SFB_LMAX - 1;
-         cod_info->sfb_smax = SFB_SMAX - 1;    /* No sb */
-     }
- }
- 
- 
- 
- 
- 
- 
- 
- 
- /* The following optional code written by Seymour Shlien
-    will speed up the outer_loop code which is called
-    by iteration_loop. When BIN_SEARCH is defined, the
-    outer_loop function precedes the call to the function inner_loop
-    with a call to bin_search gain defined below, which
-    returns a good starting quantizerStepSize.
- */
- 
- #if defined(BIN_SEARCH) || defined(PERFORM) 
- int count_bits(ix,cod_info)  
- int  *ix; /*  I576  *ix; */
- gr_info *cod_info;
- {
- int bits,max;
-   calc_runlen(ix,cod_info);		/*rzero,count1,big_values*/
-   max = ix_max( ix, 0,576);
-   if(max > 8192) return 100000;         /* report unsuitable quantizer */
-   bits = count1_bitcount(ix, cod_info); /*count1_table selection*/
-   subdivide(cod_info);			/* bigvalues sfb division */
-   bigv_tab_select(ix,cod_info);		/* codebook selection*/
-   bits += bigv_bitcount(ix,cod_info);	/* bit count */
- /* printf("\nglobal_gain = %f  bits= %d ",cod_info->quantizerStepSize,bits);*/
- return bits;
- }
- #endif
- 
- 
- #ifdef BIN_SEARCH
- 
- int bin_search_StepSize(int desired_rate, double start, int *ix,
-            double xrs[576], gr_info * cod_info)
- {
- double top,bot,next,last;
- int bit;
- top = start;
- bot = 200;
- next = start;
- do
-   {
-   last = next;
-   next = aint((top+bot)/2.0);
-   cod_info->quantizerStepSize = next;
-   quantize(xrs,ix,cod_info);
-   bit = count_bits(ix,cod_info);
-   if (bit>desired_rate) top = next;
-   else bot = next;
- /*  printf("\n%f %f %f %d %d",next, top,bot,bit,desired_rate);*/
-   }
-   while ((bit != desired_rate) && fabs(last - next) > 1.0);
- return next;
- }
- 
- #endif
- 
- 
- 
- 
- #ifdef PERFORM
- 
- /* The following code is used for exposing some problems with
-    the outer_loop code. PERFORM should be defined to the
-    frame number you wish to have additional output recorded
-    in the file encode.log  - Seymour Shlien 14-Jan-97
- */
- 
- /*
- float worst_xfsf_to_xmin_ratio(l3_xmin,xfsf,block_type,gr,ch)
- double xfsf[4][CBLIMIT];
- III_psy_xmin *l3_xmin;
- int block_type,gr,ch;
- */
- float worst_xfsf_to_xmin_ratio(III_psy_xmin *l3_xmin, double xfsf[4][CBLIMIT]
-                              ,int block_type,int gr,int ch)
- 
- {
- float ratio,maxratio;
- int i,j;
- maxratio =-100.0;
- if (block_type != 2)
-   for(i=0;i<21;i++)
-     {
-     ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
-     if (ratio > maxratio) maxratio = ratio;
-     }
- else
-   {
-   for(j=0;j<3;j++)
- /* for(i = cod_info->sfb_smax; i <SFB_SMAX; i++) */
-      for(i = 0; i <11; i++)
-     {
-     ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
-     if (ratio > maxratio) maxratio = ratio;
-     }
-   }
- return maxratio;
- }
-  
- 
- print_ratios(handle_out,l3_xmin,xfsf,block_type,gr,ch)
- FILE *handle_out;
- double xfsf[4][CBLIMIT];
- III_psy_xmin *l3_xmin;
- int gr,ch;
- int block_type;
- {
- float ratio;
- int i,j;
- if(block_type !=2)
-  for (i=0;i<21;i++)
-   {
-    ratio = 100.0; /* signals undefined value in output */
-    if(l3_xmin->l[gr][ch][i] >1.0e-20)
-      ratio = 10.*log10(xfsf[0][i] /l3_xmin->l[gr][ch][i]);
-    fprintf(handle_out,"%6.2f ",ratio);
-    if(i%5==4) fprintf(handle_out,"\n");
-   }
- else
-   
-   for(j=0;j<3;j++)
-    { fprintf(handle_out,"\n  block %d\n",j);
-      for(i = 0; i <11; i++)
-       {
-       ratio = 10.*log10(xfsf[j+1][i] /l3_xmin->s[gr][ch][i][j]);
-       fprintf(handle_out,"%6.2f ",ratio);
-       if(i%5==4) fprintf(handle_out,"\n");
-       }
-    }
- fprintf(handle_out,"\n");
- }
- 
- 
- print_scalefacs(handle_out,scalefac,block_type,gr,ch)
- FILE *handle_out;
- III_scalefac_t *scalefac;
- int gr,ch;
- int block_type;
- {
- int sfb,j;
- 
- if(block_type !=2)
-  for ( sfb = 0; sfb < 21; sfb++ )
-    {
-    fprintf(handle_out,"%6d ", scalefac->l[gr][ch][sfb]);    
-    if(sfb%5==4) fprintf(handle_out,"\n");
-    }
- else
-  for (j=0;j<3;j++)
-   {
-   fprintf(handle_out,"\n block %d\n",j);
-   for (sfb=0;sfb<11;sfb++)
-    {
-    fprintf(handle_out,"%6d ",scalefac->s[gr][ch][sfb][j]);
-    if(sfb%5==4) fprintf(handle_out,"\n");
-    }
-   }
- fprintf(handle_out,"\n");
- }
- 
- 
- print_quantized_values(FILE *handle, int ix[576], gr_info *cod_info)
- {
- int sfb,start,end,i,bw;
- for (sfb=0;sfb<cod_info->sfb_lmax;sfb++)
-   {
-   start = scalefac_band_long[sfb];
-   end = scalefac_band_long[sfb+1];
-   bw = end - start;
-   fprintf(handle,"scalefac band %d from %d to %d\n",sfb,start,end);
-   for (i=0;i<bw;i++)
-     {
-     fprintf(handle,"%8d",ix[start+i]);
-     if(i%5==4) fprintf(handle,"\n");
-     }
-   fprintf(handle,"\n");
-   }
- }
- 
- 
- test_inner_loop(double xr[2][2][576], int l3_enc[2][2][576], int max_bits,
-             gr_info *cod_info, int gr, int ch, double xfsf[4][CBLIMIT], 
-             III_psy_xmin  *l3_xmin) 
- {
-     int bits, c1bits, bvbits;
-     double *xrs;  /*  D576  *xr; */
-     int *ix;  /*  I576  *ix; */
-     xrs = &xr[gr][ch][0];
-     ix = l3_enc[gr][ch];
-  
-     assert( max_bits >= 0 );
-     cod_info->quantizerStepSize -= 1.0;;
-     do
-     {
-         do
-         {
-             cod_info->quantizerStepSize += 1.0;
-             quantize( xrs, ix, cod_info );
-         }  
-         while ( ix_max(ix, 0, 576) > 8191 + 14 ); /* within table range? */
-  
-     bits = count_bits(ix,cod_info);       
- 
-         if(frameNum == PERFORM)
-         {
-           fprintf(log_output,"StepSize=%f bits = %d huff_bits = %d\n",
-             cod_info->quantizerStepSize,bits,max_bits);
-           calc_noise( &xr[gr][ch][0], &l3_enc[gr][ch][0], cod_info, xfsf );
-                                              /* distortion calculation */
-           print_ratios(log_output,l3_xmin,xfsf,cod_info->block_type,gr,ch);
-           fprintf(log_output,"\n\n");
-           }
- 
-     }
-     while ( bits > max_bits );
-  
-     return bits;
- }
-  
- #endif PERFORM 
--- 0 ----
diff -r -c -N encoder/loop.h lame3.50/loop.h
*** encoder/loop.h	Wed Jan 22 02:43:16 1997
--- lame3.50/loop.h	Wed Dec 31 17:00:00 1969
***************
*** 1,90 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: loop.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: loop.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef LOOP_DOT_H
- #define LOOP_DOT_H
- #include "common.h"
- #include "l3side.h"
- 
- /**********************************************************************
-  *   date   programmers                comment                        *
-  * 25. 6.92  Toshiyuki Ishino          Ver 1.0                        *
-  * 29.10.92  Masahiro Iwadare          Ver 2.0                        *
-  * 17. 4.93  Masahiro Iwadare          Updated for IS Modification    *
-  *                                                                    *
-  *********************************************************************/
- 
- extern int cont_flag;
- 
- #define e              2.71828182845
- 
- /*#define SBLIMIT       32*/
- #define CBLIMIT       21
- 
- #define SFB_LMAX 22
- #define SFB_SMAX 13
- 
- extern int pretab[];
- 
- struct scalefac_struct
- {
-    int l[23];
-    int s[14];
- };
- 
- extern struct scalefac_struct sfBandIndex[];  /* Table B.8 -- in loop.c */
- 
- 
- void iteration_loop( double pe[][2], double xr_org[2][2][576], III_psy_ratio *ratio,
- 		     III_side_info_t *l3_side, int l3_enc[2][2][576], int mean_bits,
- 		     int stereo, double xr_dec[2][2][576],
- 		     III_scalefac_t *scalefac, frame_params *fr_ps,
- 		     int ancillary_pad, int bitsPerFrame );
- 
- 
- int nint( double in );
- 
- /* #define PI 3.1415926535 */
- #define maximum(A,B) ( (A) > (B) ? (A) : (B) )
- #define minimum(A,B) ( (A) < (B) ? (A) : (B) )
- #define signum( A ) ( (A) > 0 ? 1 : -1 )
- 
- /* GLOBALE VARIABLE */
- 
- /*extern FILE     *debp;
- extern FILE     *huffcp,*huffdp;
- extern FILE     *musicin,*cod_music;*/
- 
- /* Beachte:Partitonen nur fuer 48 kHz */
- /* andere ev. fehlerhaft  */
- 
- /* static int     scalefac_band_long[22];
-   static int     scalefac_band_short[13];
- */
- /*static int     huffman_tab_quad[2][16][2];
- extern int     bigv_cod_tab[17][2][16][16];
- extern int     bigv_dec_tab[17][512][5];
- extern int     bigv_root_node[17];
- extern int     count1_root_node[2];*/
- /* extern int     cod_tab_info[2][31]; */
- 
- 
- 
- 
- /* in max spalte war um 1 zuviel */
- /* [0][i] : maximalwert der Tabelle mit index i
-    [1][i] : anzahl der linbits der TAb. i        */
- 
- extern int bit_buffer[50000];
- 
- #endif
--- 0 ----
diff -r -c -N encoder/loopold.c lame3.50/loopold.c
*** encoder/loopold.c	Wed Dec 31 17:00:00 1969
--- lame3.50/loopold.c	Mon Oct 11 12:17:30 1999
***************
*** 0 ****
--- 1,662 ----
+ /************************************************************************/
+ /*  init_outer_loop  mt 6/99                                            */
+ /************************************************************************/
+ void init_outer_loop_dual(
+     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
+     double xr_org[2][2][576],
+     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
+     III_scalefac_t *scalefac, /* scalefactors */
+     int gr, int stereo, III_side_info_t *l3_side,
+     III_psy_ratio *ratio, int ch)
+ {
+   int sfb,i;
+   gr_info *cod_info;  
+   cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 
+   /* compute max allowed distortion */
+   if (convert_psy) /* l/r thresholds, use unconverted data */
+     calc_xmin( xr_org, ratio, cod_info, l3_xmin, gr, ch );
+   else
+     calc_xmin( xr, ratio, cod_info, l3_xmin, gr, ch );
+   
+   /* if ( info->version == 1 )
+      calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr ); 
+   */
+   
+     
+   /* reset of iteration variables */
+     
+   for ( sfb = 0; sfb < SFB_LMAX; sfb++ )
+     scalefac->l[gr][ch][sfb] = 0;
+   for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
+     for ( i = 0; i < 3; i++ )
+       scalefac->s[gr][ch][sfb][i] = 0;
+   
+   for ( i = 0; i < 4; i++ )
+     cod_info->slen[i] = 0;
+   cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
+   
+   cod_info->part2_3_length    = 0;
+   cod_info->big_values        = ((cod_info->block_type==2)?288:0);
+   cod_info->count1            = 0;
+   cod_info->scalefac_compress = 0;
+   cod_info->table_select[0]   = 0;
+   cod_info->table_select[1]   = 0;
+   cod_info->table_select[2]   = 0;
+   cod_info->subblock_gain[0]  = 0;
+   cod_info->subblock_gain[1]  = 0;
+   cod_info->subblock_gain[2]  = 0;
+   cod_info->region0_count     = 0;
+   cod_info->region1_count     = 0;
+   cod_info->part2_length      = 0;
+   cod_info->preflag           = 0;
+   cod_info->scalefac_scale    = 0;
+   cod_info->quantizerStepSize = 0.0;
+   cod_info->count1table_select= 0;
+   cod_info->address1          = 0;
+   cod_info->address2          = 0;
+   cod_info->address3          = 0;
+   
+   
+   if (experimentalZ) {
+     /* compute subblock gains */
+     int j,b;  double en[3],mx;
+     if ((cod_info->block_type ==2) ) {
+       /* estimate energy within each subblock */
+       for (b=0; b<3; b++) en[b]=0;
+       for ( i=0,j = 0; j < 192; j++ ) {
+ 	for (b=0; b<3; b++) {
+ 	  en[b]+=xr[gr][ch][i]*xr[gr][ch][i];
+ 	  i++;
+ 	}
+       }
+       mx = 1e-12;
+       for (b=0; b<3; b++) mx=Max(mx,en[b]);
+       for (b=0; b<3; b++) en[b] = Max(en[b],1e-12)/mx;
+       /* pick gain so that 2^(2gain)*en[0] = 1  */
+       /* gain = .5* log( 1/en[0] )/log(2) = -.5*log(en[])/log(2) */
+       for (b=0; b<3; b++) {
+ 	cod_info->subblock_gain[b]=nint2(-.5*log(en[b])/log(2.0));
+ 	if (cod_info->subblock_gain[b] > 2) 
+ 	  cod_info->subblock_gain[b]=2;
+ 	if (cod_info->subblock_gain[b] < 0) 
+ 	  cod_info->subblock_gain[b]=0;
+       }
+     }
+   }
+ }
+ 
+ 
+ 
+ 
+ void quant_compare_dual(int better[2], int notdone[2], int stereo, 
+ double ms_ener_ratio,
+ int best_over[2],double best_tot_noise[2],double best_over_noise[2],double best_max_noise[2],
+ int over[2],double tot_noise[2], double over_noise[2], double max_noise[2]) 
+ {
+   int ch;
+   /*
+     noise is given in decibals (db) relative to masking thesholds.
+ 
+     over_noise:  sum of quantization noise > masking
+     tot_noise:   sum of all quantization noise
+     max_noise:   max quantization noise 
+ 
+    */
+ 
+ 
+   for (ch=0 ; ch < stereo ; ch ++ ) {
+     better[ch]=0;
+     if (notdone[ch]) {
+       if (convert_psy) {
+ 	better[ch] = (over[0]+over[1]) < (best_over[0]+best_over[1]);
+ 	if ((over[0]+over[1])==(best_over[0]+best_over[1])) {
+ 	  better[ch] = (over_noise[0]+over_noise[1]) < (best_over_noise[0]+best_over_noise[1]);
+ 	}
+       }else{
+ 	better[ch] = ((over[ch] < best_over[ch]) ||
+ 		      ((over[ch]==best_over[ch]) && (over_noise[ch]<best_over_noise[ch])) ) ;
+       }
+     }
+   }
+ }
+   
+ 
+ 
+ 
+ /************************************************************************/
+ /*  outer_loop                                                         */
+ /************************************************************************/
+ /*  Function: The outer iteration loop controls the masking conditions  */
+ /*  of all scalefactorbands. It computes the best scalefac and          */
+ /*  global gain. This module calls the inner iteration loop             
+  * 
+  *  mt 5/99 completely rewritten to allow for bit reservoir control,   
+  *  mid/side channels with L/R or mid/side masking thresholds, 
+  *  and chooses best quantization instead of last quantization when 
+  *  no distortion free quantization can be found.  
+  *  
+  *  added VBR support mt 5/99
+  ************************************************************************/
+ void outer_loop_dual(
+     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
+     double xr_org[2][2][576],
+     int mean_bits,
+     int VBRbits[2][2],
+     int bit_rate,
+     int best_over[2],
+     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
+     int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
+     frame_params *fr_ps,
+     III_scalefac_t *scalefac, /* scalefactors */
+     int gr, int stereo, III_side_info_t *l3_side,
+     III_psy_ratio *ratio, double pe[2][2], double ms_ener_ratio[2])
+ {
+   int status[2],notdone[2]={0,0},count[2]={0,0},bits_found[2];
+   int targ_bits[2],real_bits[2],tbits,extra_bits; 
+   int scalesave_l[2][CBLIMIT], scalesave_s[2][CBLIMIT][3];
+   int sfb, bits, huff_bits, save_preflag[2], save_compress[2];
+   double xfsf[2][4][CBLIMIT];
+   double xrpow[2][2][576],temp;
+   double distort[2][4][CBLIMIT];
+   int save_l3_enc[2][576];  
+   int save_real_bits[2];
+   int i,over[2], iteration, ch, compute_stepsize;
+   int better[2];
+   double max_noise[2];
+   double best_max_noise[2];
+   double over_noise[2];
+   double best_over_noise[2];
+   double tot_noise[2];
+   double best_tot_noise[2];
+   gr_info save_cod_info[2];
+   gr_info *cod_info[2];  
+ 
+   cod_info[0] = &l3_side->gr[gr].ch[0].tt;
+   cod_info[1] = &l3_side->gr[gr].ch[1].tt;
+   for (ch=0 ; ch < stereo ; ch ++) 
+     best_over[ch] = 100;
+       
+ 
+   if (convert_mdct) ms_convert(xr[gr],xr_org[gr]);
+   else memcpy(xr[gr],xr_org[gr],sizeof(double)*2*576);   
+   for (ch=0; ch<stereo; ch++)
+     init_outer_loop_dual(xr,xr_org,l3_xmin,scalefac,gr,stereo,l3_side,ratio,ch);  
+   
+   for (ch=0 ; ch < stereo ; ch ++) {
+     count[ch]=0;
+     for (i=0; i<576; i++) {
+       if ( fabs(xr[gr][ch][i]) > 0 ) count[ch]++; 
+     }
+     notdone[ch]=count[ch];
+     if (count[ch]==0) best_over[ch]=0;
+   }
+ 
+   /******************************************************************
+    * allocate bits for each channel 
+    ******************************************************************/
+   if (VBR) {
+     for (ch=0 ; ch < stereo ; ch ++ )
+       targ_bits[ch]=VBRbits[gr][ch];
+ 
+   }else { 
+     int add_bits[2]; 
+ 
+     /* allocate targ_bits for granule */
+     ResvMaxBits2( mean_bits, &tbits, &extra_bits, gr);
+ 
+     for (ch=0 ; ch < stereo ; ch ++ )
+       targ_bits[ch]=tbits/stereo;
+ 
+     
+     // allocate extra bits from reservoir based on PE 
+     bits=0;
+     for (ch=0; ch<stereo; ch++) {
+       double pe_temp=pe[gr][ch];
+       if (convert_psy) pe_temp=Max(pe[gr][0],pe[gr][1]);
+ 
+       /* extra bits based on PE > 700 */
+       add_bits[ch]=(pe_temp-750)/1.4;  /* 2.0; */
+ 
+       
+       /* short blocks need extra, no matter what the pe */
+       if (cod_info[ch]->block_type==2) 
+ 	if (add_bits[ch]<500) add_bits[ch]=500;
+       
+       if (add_bits[ch] < 0) add_bits[ch]=0;
+       bits += add_bits[ch];
+     }
+     for (ch=0; ch<stereo; ch++) {
+       if (bits > extra_bits) add_bits[ch] = (extra_bits*add_bits[ch])/bits;
+       targ_bits[ch] = targ_bits[ch] + add_bits[ch];
+     }
+     for (ch=0; ch<stereo; ch++) 
+       extra_bits -= add_bits[ch];
+   }
+ 
+   if (reduce_sidechannel) {
+     /*  ms_ener_ratio = 0:  allocate 66/33  mid/side  fac=.33  
+      *  ms_ener_ratio =.5:  allocate 50/50 mid/side   fac= 0 */
+     /* 75/25 split is fac=.5 */
+     /* float fac = .50*(.5-ms_ener_ratio[gr])/.5;*/
+     float fac = .33*(.5-ms_ener_ratio[gr])/.5;
+     if (fac<0) fac=0;
+ 
+     /* dont reduce side channel below 125 bits */
+     if (targ_bits[1]-targ_bits[1]*fac > 125) {
+       targ_bits[0] += targ_bits[1]*fac;
+       targ_bits[1] -= targ_bits[1]*fac;
+     }
+ 
+   
+     /* dont allow to many bits per channel */  
+     for (ch=0; ch<stereo; ch++) {
+       int max_bits = Min(4095,mean_bits/2 + 1200);
+       if (targ_bits[ch] > max_bits) {
+ 	extra_bits += (targ_bits[ch] - max_bits);
+ 	targ_bits[ch] = max_bits;
+       }
+     }
+   }  
+   
+   
+   /* BEGIN MAIN LOOP */
+   iteration = 0;
+   compute_stepsize=1;
+ 
+   while ( (notdone[0] || notdone[1])  ) {
+     int pre_just_turned_on[2];
+     iteration ++;
+ 
+     if (compute_stepsize) {
+       /* compute initial quantization step */
+       compute_stepsize=0;
+       for (ch=0 ; ch < stereo ; ch ++ )
+ 	if (notdone[ch]) {
+ 	  for(i=0;i<576;i++) 	    {
+ 	    temp=fabs(xr[gr][ch][i]);
+ 	    xrpow[gr][ch][i]=sqrt(sqrt(temp)*temp);
+ 	  }
+ 	  bits_found[ch]=bin_search_StepSize2(targ_bits[ch],-211.0,46,
+ 	      l3_enc[gr][ch],xr[gr][ch],xrpow[gr][ch],cod_info[ch]); 
+ 	}
+     }
+ 
+ 
+ 
+     /* inner_loop starts with the initial quantization step computed above
+      * and slowly increases until the bits < huff_bits.
+      * Thus is it important not to start with too large of an inital
+      * quantization step.  Too small is ok, but inner_loop will take longer 
+      */
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       if (notdone[ch]) {
+ 	//	cod_info[ch]->part2_length = part2_length( scalefac, fr_ps->header->version, cod_info[ch]);
+ 	huff_bits = targ_bits[ch] - cod_info[ch]->part2_length;
+ 	if (huff_bits < 0) {
+ 	  if (iteration==1) {
+ 	    fprintf(stderr,"ERROR: outer_loop(): huff_bits < 0. \n");
+ 	    exit(-5);
+ 	  }else{
+ 	    /* scale factors too large, not enough bits. use previous quantizaton */
+ 	    notdone[ch]=0;
+ 	    over[ch]=999;
+ 	  }
+ 	}else{
+ 	  /* if this is the first iteration, see if we can reuse the quantization
+ 	   * computed in bin_search_StepSize above */
+ 	  if (iteration==1) {
+ 	    if(bits_found[ch]>huff_bits) {
+ 	      cod_info[ch]->quantizerStepSize+=1.0;
+ 	      real_bits[ch] = inner_loop( xr, xrpow[gr][ch], l3_enc, huff_bits, cod_info[ch], gr, ch );
+ 	    } else real_bits[ch]=bits_found[ch];
+ 	  }
+ 	  else 
+ 	    real_bits[ch]=inner_loop( xr, xrpow[gr][ch], l3_enc, huff_bits, cod_info[ch], gr, ch );
+ 	}
+       }
+     }
+ 
+ 
+ 
+     /* compute the distortion in this quantization */
+     if (fast_mode) {
+       for (ch=0; ch<stereo; ch++)
+ 	over[ch]=0;
+     }else{
+       if (convert_psy) {
+ 	/* mid/side coefficiets, l/r thresholds */
+ 	calc_noise2( xr[gr], l3_enc[gr], cod_info, xfsf,
+           distort, l3_xmin,gr,stereo,over,over_noise,tot_noise,max_noise);
+       }	else {
+ 	  /* coefficients and thresholds both l/r (or both mid/side) */
+ 	  for (ch=0; ch<stereo; ch++)
+ 	    if (notdone[ch])
+ 	      over[ch]=calc_noise1( xr[gr][ch], l3_enc[gr][ch], cod_info[ch], 
+ 	    xfsf[ch],distort[ch], l3_xmin,gr,ch, &over_noise[ch], 
+             &tot_noise[ch], &max_noise[ch]);
+       }
+     }
+ 
+     /* check if this quantization is better the our saved quantization */
+     if (iteration == 1) 
+       for (ch=0; ch<stereo; ch++) better[ch]=1;
+     else quant_compare_dual(better,notdone,stereo,ms_ener_ratio[gr],
+         best_over,best_tot_noise,best_over_noise,best_max_noise,
+ 	over,tot_noise,over_noise,max_noise);
+ 
+  
+ 
+     /* save data so we can restore this quantization later */    
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       if (better[ch]) {
+ 	best_over[ch]=over[ch];
+ 	best_over_noise[ch]=over_noise[ch];
+ 	best_tot_noise[ch]=tot_noise[ch];
+ 	best_max_noise[ch]=max_noise[ch];
+ 	if (notdone[ch]) {
+ 	  for ( sfb = 0; sfb < CBLIMIT; sfb++ ) /* save scaling factors */
+ 	    scalesave_l[ch][sfb] = scalefac->l[gr][ch][sfb];
+ 	  
+ 	  for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
+ 	    for ( i = 0; i < 3; i++ )
+ 	      scalesave_s[ch][sfb][i] = scalefac->s[gr][ch][sfb][i];
+ 	  
+ 	  save_preflag[ch]  = cod_info[ch]->preflag;
+ 	  save_compress[ch] = cod_info[ch]->scalefac_compress;
+ 	  
+ 	  memcpy(save_l3_enc[ch],l3_enc[gr][ch],sizeof(l3_enc[gr][ch]));   
+ 	  memcpy(&save_cod_info[ch],cod_info[ch],sizeof(save_cod_info[ch]));
+ 	  save_real_bits[ch]=real_bits[ch];
+ 
+ #ifdef HAVEGTK
+ 	  if (gtkflag) {
+ 	    for ( i = 0; i < 3; i++ ) {
+ 	      for ( sfb = cod_info[ch]->sfb_smax; sfb < 12; sfb++ )  {
+ 		pinfo->xfsf_s[gr][ch][3*sfb+i] =  
+ 		  pinfo->thr_s[gr][ch][3*sfb+i]*xfsf[ch][i+1][sfb]/
+ 		  (1e-20+l3_xmin->s[gr][ch][sfb][i]);
+ 	      }
+ 	    }
+ 	    for ( sfb = 0; sfb < cod_info[ch]->sfb_lmax; sfb++ )   {
+ 	      pinfo->xfsf[gr][ch][sfb] =  
+ 		pinfo->thr[gr][ch][sfb]*xfsf[ch][0][sfb]/
+ 		(1e-20 + l3_xmin->l[gr][ch][sfb]);
+ 	    }
+ 	    pinfo->over[gr][ch]=over[ch];
+ 	    pinfo->over_noise[gr][ch]=over_noise[ch];
+ 	  }
+ #endif
+ 	  
+ 
+ 	}
+       }
+     }
+ 
+     /* if no bands with distortion, we are done */
+     for (ch=0 ; ch < stereo ; ch ++ ) 
+       if (notdone[ch]) {
+ 	if (convert_psy) 
+ 	  notdone[ch] = (over[0] || over[1]);
+ 	else
+ 	  notdone[ch] = over[ch];
+       }
+ 
+ 
+ 
+ 
+     /* see if we should apply preemphasis */
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       pre_just_turned_on[ch]=0;
+       if (notdone[ch] ) pre_just_turned_on[ch]=
+ 	 preemphasis( xr[gr][ch], xrpow[gr][ch], l3_xmin, 
+ 	       gr, ch, l3_side,	distort[ch]);
+     }
+     
+     
+     /* if we didn't just apply pre-emph, let us see if we should 
+      * amplify some scale factor bands */
+     for (ch=0 ; ch < stereo ; ch ++ ) 
+       if (notdone[ch] && (!pre_just_turned_on[ch]) ) {
+ 	  amp_scalefac_bands( xr[gr][ch], xrpow[gr][ch], l3_xmin,
+ 		l3_side, scalefac, gr, ch, iteration,distort[ch]);
+       }
+     
+ 
+     /* check to make sure we have not amplified too much */
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       if (notdone[ch]) {
+ 	if ( (status[ch] = loop_break(scalefac, cod_info[ch], gr, ch)) == 0 ) {
+ 	  if ( fr_ps->header->version == 1 ) {
+ 	    status[ch] = scale_bitcount( scalefac, cod_info[ch], gr, ch );
+ 	  }else{
+ 	    status[ch] = scale_bitcount_lsf( scalefac, cod_info[ch], gr, ch );
+ 	  }
+         }
+ 	notdone[ch] = !status[ch];
+       }
+     }
+   }    /* done with main iteration */
+   
+ 
+   
+   /* restore some data */
+   for (ch=0 ; ch < stereo ; ch ++ ) {
+     if (count[ch] ) {
+       cod_info[ch]->preflag = save_preflag[ch];
+       cod_info[ch]->scalefac_compress = save_compress[ch];
+       
+       for ( sfb = 0; sfb < CBLIMIT; sfb++ ) {
+ 	scalefac->l[gr][ch][sfb] = scalesave_l[ch][sfb];    
+       }
+       
+       for ( i = 0; i < 3; i++ )
+ 	for ( sfb = 0; sfb < SFB_SMAX; sfb++ ) {
+ 	  scalefac->s[gr][ch][sfb][i] = scalesave_s[ch][sfb][i];    
+ 	}
+ 
+       { 
+ 	real_bits[ch]=save_real_bits[ch];  
+ 	memcpy(l3_enc[gr][ch],save_l3_enc[ch],sizeof(l3_enc[gr][ch]));   
+ 	memcpy(cod_info[ch],&save_cod_info[ch],sizeof(save_cod_info[ch]));
+ 	
+ 	if ( fr_ps->header->version == 1 )
+ 	  status[ch] = scale_bitcount( scalefac, cod_info[ch], gr, ch );
+ 	else
+ 	  status[ch] = scale_bitcount_lsf( scalefac, cod_info[ch], gr, ch );
+ 	if (status[ch]) {
+ 	  fprintf(stderr,"Error recomputing scalefac_compress...this should not happen");
+ 	  exit(-10);
+ 	}
+       }
+       //      cod_info[ch]->part2_length   = part2_length( scalefac, fr_ps->header->version, cod_info[ch]);
+       cod_info[ch]->part2_3_length = cod_info[ch]->part2_length + real_bits[ch];
+ 
+ #ifdef HAVEGTK
+       if (gtkflag)
+ 	pinfo->LAMEmainbits[gr][ch]=cod_info[ch]->part2_3_length;
+ #endif
+     }      
+   }
+   
+   /* finish up */
+   for (ch=0 ; ch < stereo ; ch ++ ) {
+     if (!VBR) ResvAdjust( fr_ps, cod_info[ch], l3_side, mean_bits );
+     cod_info[ch]->global_gain = nint2( cod_info[ch]->quantizerStepSize + 210.0 );
+     assert( cod_info[ch]->global_gain < 256 );
+   }
+ }
+ 
+ 
+ /*************************************************************************/
+ /*            calc_noise2                                                */
+ /*************************************************************************/
+ /*   Improved version of calc_noise for dual channel.  This routine is */
+ /*   used when you are quantizaing mid and side channels using masking */
+ /*   thresholds from L and R channels.  mt 5/99 */
+ 
+ void calc_noise2( double xr[2][576], int ix[2][576], gr_info *cod_info[2],
+             double xfsf[2][4][CBLIMIT], double distort[2][4][CBLIMIT],
+             III_psy_xmin *l3_xmin,int gr,int stereo, int over[2], 
+             double over_noise[2], double tot_noise[2], double max_noise[2])
+ {
+     int start, end, sfb, l, i;
+     double sum[2],step_s[3][2],step[2],bw;
+ 
+     D192_3 *xr_s[2];
+     I192_3 *ix_s[2];
+ 
+     static double pow43[PRECALC_SIZE];
+     int ch;
+     static int init=0;
+     double diff[2];
+     double noise;
+     int index;
+     
+     if (init==0) {
+       init++;
+       for(i=0;i<PRECALC_SIZE;i++)
+         pow43[i] = pow((double)i, 4.0/3.0);
+     }
+     
+     
+ 
+     /* calc_noise2: we can assume block types of both channels must be the same
+ */
+     if (cod_info[0]->block_type != 2) {
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+       over[ch]=0;
+       over_noise[ch]=0;
+       tot_noise[ch]=0;
+       max_noise[ch]=-999;
+       step[ch] = pow( 2.0, (cod_info[ch]->quantizerStepSize) * 0.25 );
+     }
+     for ( sfb = 0; sfb < SFB_LMAX-1; sfb++ ) {
+       start = scalefac_band_long[ sfb ];
+       end   = scalefac_band_long[ sfb+1 ];
+       bw = end - start;
+ 
+       //      for (ch=0 ; ch < stereo ; ch ++ ) sum[ch]=0;
+       for ( sum[0]=0, sum[1]=0, l = start; l < end; l++ ) {
+           index=ix[0][l];
+           if (index==0) {
+             diff[0]=xr[0][l];
+           } else {
+             if (xr[0][l]<0) {
+               diff[0]=xr[0][l] + pow43[index] * step[0];
+             } else
+               diff[0]=xr[0][l] - pow43[index] * step[0];
+           }
+           index=ix[1][l];
+           if (index==0) {
+             diff[1]=xr[1][l];
+           } else {
+             if (xr[1][l]<0) {
+               diff[1]=xr[1][l] + pow43[index] * step[1];
+             } else
+               diff[1]=xr[1][l] - pow43[index] * step[1];
+           }
+         sum[0] += (diff[0]+diff[1])*(diff[0]+diff[1]);
+         sum[1] += (diff[0]-diff[1])*(diff[0]-diff[1]);
+       }      
+       sum[0] *= 0.5;
+       sum[1] *= 0.5;
+ 
+       for (ch=0 ; ch < stereo ; ch ++ ) {
+         xfsf[ch][0][sfb] = sum[ch] / bw;
+         noise = 10*log10(Max(.001,xfsf[ch][0][sfb]/l3_xmin->l[gr][ch][sfb]));
+         distort[ch][0][sfb] =  noise;
+         if (noise>0) {
+           over[ch]++;
+           //over_noise[ch] += xfsf[ch][0][sfb] - l3_xmin->l[gr][ch][sfb];
+           over_noise[ch] += noise;
+         }
+         tot_noise[ch] += noise;
+         max_noise[ch] = Max(max_noise[ch],noise);
+       }
+ 
+       /* if there is audible distortion in left or right channel, set flags
+        * to denote distortion in both mid and side channels */
+       for (ch=0 ; ch < stereo ; ch ++ ) {
+         distort[ch][0][sfb] = Max(distort[0][0][sfb],distort[1][0][sfb]);
+       }
+     }
+     }
+ 
+     /* calc_noise2: we can assume block types of both channels must be the same
+ */
+     if (cod_info[0]->block_type == 2) {
+     for (ch=0 ; ch < stereo ; ch ++ ) {
+ 
+       for (i=0;i<3;i++){
+         step_s[i][ch] = pow( 2.0, (cod_info[ch]->quantizerStepSize) * 0.25 );
+ /* subblock_gain ? */
+         if (cod_info[ch]->subblock_gain[i] )
+           step_s[i][ch] *= pow(2.0,-2.0*cod_info[ch]->subblock_gain[i]);
+       }
+ 
+       over[ch] = 0;
+       xr_s[ch] = (D192_3 *) xr[ch];
+       ix_s[ch] = (I192_3 *) ix[ch];
+     }
+ 
+     for ( sfb = 0 ; sfb < SFB_SMAX-1; sfb++ ) {
+       start = scalefac_band_short[ sfb ];
+       end   = scalefac_band_short[ sfb+1 ];
+       bw = end - start;
+       for ( i = 0; i < 3; i++ ) {           
+         for (ch=0 ; ch < stereo ; ch ++ ) sum[ch] = 0.0;
+         for ( l = start; l < end; l++ )           {
+             index=(*ix_s[0])[l][i];
+             if (index==0)
+               diff[0] = (*xr_s[0])[l][i];
+             else {
+               if ((*xr_s[0])[l][i] < 0) {
+                 diff[0] = (*xr_s[0])[l][i] + pow43[index] * step_s[i][0]; 
+               } else {
+                 diff[0] = (*xr_s[0])[l][i] - pow43[index] * step_s[i][0]; 
+               }
+             }
+             index=(*ix_s[1])[l][i];
+             if (index==0)
+               diff[1] = (*xr_s[1])[l][i];
+             else {
+               if ((*xr_s[1])[l][i] < 0) {
+                 diff[1] = (*xr_s[1])[l][i] + pow43[index] * step_s[i][1]; 
+               } else {
+                 diff[1] = (*xr_s[1])[l][i] - pow43[index] * step_s[i][1]; 
+               }
+             }     
+           sum[0] += (diff[0]+diff[1])*(diff[0]+diff[1])/(2.0);
+           sum[1] += (diff[0]-diff[1])*(diff[0]-diff[1])/(2.0);
+         }
+ 
+         for (ch=0 ; ch < stereo ; ch ++ ) {
+           xfsf[ch][i+1][sfb] = sum[ch] / bw;
+           noise =
+ 10*log10(Max(.001,xfsf[ch][i+1][sfb]/l3_xmin->s[gr][ch][sfb][i]));
+           distort[ch][i+1][sfb] = noise>0;
+           if (noise>0) {
+             over[ch]++;
+             //over_noise[ch] += xfsf[ch][i+1][sfb]-l3_xmin->s[gr][ch][sfb][i];
+             over_noise[ch] += noise;
+           }
+           tot_noise[ch] += noise;
+           max_noise[ch]=Max(max_noise[ch],noise);
+         }
+         /* if there is audible distortion in left or right channel, set flags
+          * to denote distortion in both mid and side channels */
+         for (ch=0 ; ch < stereo ; ch ++ ) 
+           distort[ch][i+1][sfb] = Max
+             (distort[0][i+1][sfb],distort[1][i+1][sfb]  );
+       }
+     }
+     }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/machine.h lame3.50/machine.h
*** encoder/machine.h	Wed Dec 31 17:00:00 1969
--- lame3.50/machine.h	Tue Oct 26 12:15:05 1999
***************
*** 0 ****
--- 1,66 ----
+ /*
+  *	Machine dependent defines/includes for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ 
+ #ifndef MACHINE_H_INCLUDED
+ #define MACHINE_H_INCLUDED
+ 
+ 
+ #include        <stdio.h>
+ #include        <string.h>
+ #include        <math.h>
+ #include        <stdlib.h>
+ #include		<ctype.h>
+ #include		<signal.h>
+ #include		<sys/types.h>
+ #include		<sys/stat.h>
+ #include		<fcntl.h>
+ #include		<errno.h>
+ 
+ /*
+ #ifndef OS_AMIGAOS
+ #include <memory.h>
+ #endif 
+ #include		<float.h>
+ */
+ 
+ #if ( defined(_MSC_VER) || defined(__BORLANDC__) )
+ 	#define WIN32_LEAN_AND_MEAN
+ 	#include <windows.h>
+ #else
+ 	typedef float FLOAT;
+ #endif
+ 
+ 
+ 
+ #ifdef _WIN32
+ 	# define M_PI       3.14159265358979323846
+ 	# define M_SQRT2	1.41421356237309504880
+ 	typedef unsigned long	u_long;
+ 	typedef unsigned int	u_int;
+ 	typedef unsigned short	u_short;
+ 	typedef unsigned char	u_char;
+ 
+ 	#include <fcntl.h>
+ 	#include <io.h>
+ #endif
+ 
+ 
+ #endif
diff -r -c -N encoder/main.c lame3.50/main.c
*** encoder/main.c	Wed Dec 31 17:00:00 1969
--- lame3.50/main.c	Tue Sep 28 21:57:13 1999
***************
*** 0 ****
--- 1,56 ----
+ #include "lame.h"
+ 
+ #ifdef HAVEGTK
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ #endif
+ 
+ char mp3buffer[LAME_MAXMP3BUFFER];
+ 
+ 
+ /**********************************************************************
+  * read one frame and encode it 
+  **********************************************************************/
+ int makeframe(void)
+ {
+   int iread;
+   static short int Buffer[2][1152];
+   iread=lame_readframe(Buffer);
+   /* even if iread=0, get_audio hit EOF and returned Buffer=all 0's.  call
+    * makeframe() one last time to flush all buffers */
+   lame_encode(Buffer,mp3buffer);
+   return iread;
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * main
+ *
+ * PURPOSE:  MPEG-1,2 Layer III encoder with GPSYCHO 
+ * psychoacoustic model.
+ *
+ ************************************************************************/
+ 
+ 
+ int main(int argc, char **argv)
+ {
+   lame_init(0);
+   if(argc==1) lame_usage(argv[0]);  /* no command-line args  */
+   lame_parse_args(argc, argv); 
+   lame_print_config();
+ 
+ #ifdef HAVEGTK
+   if (gtkflag) gtk_init (&argc, &argv);
+   if (gtkflag) gtkcontrol();
+   else 
+ #endif
+     while (makeframe());
+ 
+ 
+   lame_cleanup(mp3buffer);
+   return 0;
+ }
+ 
diff -r -c -N encoder/makefile.unix lame3.50/makefile.unix
*** encoder/makefile.unix	Wed Jan 22 02:43:23 1997
--- lame3.50/makefile.unix	Wed Dec 31 17:00:00 1969
***************
*** 1,77 ****
- ############################################################################
- ## ISO MPEG Audio Subgroup Software Simulation Group (1996)
- ## ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
- ##
- ## $Id: makefile.unix,v 1.1 1996/02/14 05:28:25 rowlands Exp $
- ##
- ## Makefile for encoder for vanilla UNIX platform using standard make.
- ##
- ## $Log: makefile.unix,v $
- ## Revision 1.1  1996/02/14 05:28:25  rowlands
- ## Initial revision
- ##
- ############################################################################
- 
- # MODE= -O -DUNIX
- MODE= -g -DUNIX
- #MODE= -DMSC60 -AH -Zi -Gt
- OBJ_SUFFIX=.o
- EXE_SUFFIX=
- 
- PROGRAM	= encode$(EXE_SUFFIX)
- 
- all: $(PROGRAM)
- 
- $(PROGRAM) : \
- 	common.c common.h encode.c encoder.h formatBitstream.c \
- 	formatBitstream.h huffman.c huffman.h ieeefloat.c ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.c l3bitstream.h l3psy.c l3psy.h \
- 	l3side.h loop-pvt.h loop.c loop.h mdct.c mdct.h musicin.c \
- 	portableio.c portableio.h psy.c reservoir.c reservoir.h subs.c tonal.c
- 
- HEDS =  \
- 	common.h encoder.h formatBitstream.h huffman.h ieeefloat.h \
- 	l3bitstream-pvt.h l3bitstream.h l3psy.h l3side.h loop-pvt.h loop.h \
- 	mdct.h portableio.h reservoir.h
- 
- OBJS = \
- 	common$(OBJ_SUFFIX) \
- 	encode$(OBJ_SUFFIX) \
- 	formatBitstream$(OBJ_SUFFIX) \
- 	huffman$(OBJ_SUFFIX) \
- 	ieeefloat$(OBJ_SUFFIX) \
- 	l3bitstream$(OBJ_SUFFIX) \
- 	l3psy$(OBJ_SUFFIX) \
- 	loop$(OBJ_SUFFIX) \
- 	mdct$(OBJ_SUFFIX) \
- 	musicin$(OBJ_SUFFIX) \
- 	portableio$(OBJ_SUFFIX) \
- 	psy$(OBJ_SUFFIX) \
- 	reservoir$(OBJ_SUFFIX) \
- 	subs$(OBJ_SUFFIX) \
- 	tonal$(OBJ_SUFFIX)
- 
- LFLAG = 
- 
- CC    = gcc
- LN    = gcc
- LNEXTRA=-lm
- #CC    = cl
- #LN    = cl
- 
- .c$(OBJ_SUFFIX): $(HEDS)
- 	$(CC) -c $(MODE) $*.c
- 
- all: $(PROGRAM)
- 
- default: all
- 
- 
- $(PROGRAM) : $(OBJS) $(HEDS)
- 	$(LN) -o $(PROGRAM) $(MODE) $(LFLAG) $(OBJS) $(LNEXTRA)
- 
- clean:
- 	rm -f $(OBJS)
- 
- veryclean:
- 	rm -f $(PROGRAM) $(OBJS)
--- 0 ----
diff -r -c -N encoder/mdct.c lame3.50/mdct.c
*** encoder/mdct.c	Wed Jan 22 02:43:17 1997
--- lame3.50/mdct.c	Wed Dec 31 17:00:00 1969
***************
*** 1,212 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: mdct.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: mdct.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #include "common.h"
- #include "l3side.h"
- #include "mdct.h"
- 
- double ca[8], cs[8];
- 
- /*
-   This is table B.9: coefficients for aliasing reduction
- */
- static double c[8] = { -0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142, -0.0037 };
- 
- void mdct_sub( L3SBS (*sb_sample), double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr )
- {
-     gr_info *cod_info;
-     double mdct_in[36];
-     int ch,gr,band,k,j;
-     double bu,bd;
-     static int init = 0;
-     int	block_type;
-     double (*mdct_enc)[2][32][18] = (double (*)[2][32][18]) mdct_freq;
-     
-     if ( init == 0 )
-     {
- 	/* prepare the aliasing reduction butterflies */
- 	for ( k = 0; k < 8; k++ )
- 	{
- 	    double sq;
- 	    sq = sqrt( 1.0 + c[k] * c[k] );
- 	    ca[k] = c[k] / sq;
- 	    cs[k] = 1.0 / sq;
- 	}
- 	init++;
-     }
-     
-     for ( gr = 0; gr < mode_gr; gr++ )
- 	for ( ch = 0; ch < stereo; ch++ )
- 	{
- 	    cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]) ;
- 	    block_type = cod_info->block_type;
- 	    
- 	    /*
- 	      Compensate for inversion in the analysis filter
- 	    */
- 	    for ( band = 0; band < 32; band++ )
- 		for ( k = 0; k < 18; k++ )
- 		    if ( (band & 1) && (k & 1) )
- 			(*sb_sample)[ch][gr+1][k][band] *= -1.0;
- 	    
- 	    /*
- 	      Perform imdct of 18 previous subband samples
- 	      + 18 current subband samples
- 	    */
- 	    for ( band = 0; band < 32; band++ )
- 	    {
- 		for ( k = 0; k < 18; k++ )
- 		{
- 		    mdct_in[k]    = (*sb_sample)[ch][ gr ][k][band];
- 		    mdct_in[k+18] = (*sb_sample)[ch][gr+1][k][band];
- 		}
- 		if ( cod_info->mixed_block_flag && (band < 2) )
- 		    block_type = 0;
- 		
- 		mdct( mdct_in, &mdct_enc[gr][ch][band][0], block_type );
- 	    }
- 	    
- 	    /*
- 	      Perform aliasing reduction butterfly
- 	      on long blocks
- 	    */
- 	    if ( block_type != 2 )
- 		for ( band = 0; band < 31; band++ )
- 		    for ( k = 0; k < 8; k++ )
- 		    {
- 			bu = mdct_enc[gr][ch][band][17-k] * cs[k] + mdct_enc[gr][ch][band+1][k] * ca[k];
- 			bd = mdct_enc[gr][ch][band+1][k] * cs[k] - mdct_enc[gr][ch][band][17-k] * ca[k];
- 			mdct_enc[gr][ch][band][17-k] = bu;
- 			mdct_enc[gr][ch][band+1][k]  = bd;
- 		    }
- 	    
- 	}
-     
-     /*
-       Save latest granule's subband samples to be used in
-       the next mdct call
-     */
-     for ( ch = 0; ch < stereo; ch++ )
- 	for ( j = 0; j < 18; j++ )
- 	    for ( band = 0; band < 32; band++ )
- 		(*sb_sample)[ch][0][j][band] = (*sb_sample)[ch][mode_gr][j][band];
- }
- 
- void mdct( double *in, double *out, int block_type )
- {
- /*-------------------------------------------------------------------*/
- /*                                                                   */
- /*   Function: Calculation of the MDCT                               */
- /*   In the case of long blocks ( block_type 0,1,3 ) there are       */
- /*   36 coefficents in the time domain and 18 in the frequency       */
- /*   domain.                                                         */
- /*   In the case of short blocks (block_type 2 ) there are 3         */
- /*   transformations with short length. This leads to 12 coefficents */
- /*   in the time and 6 in the frequency domain. In this case the     */
- /*   results are stored side by side in the vector out[].            */
- /*                                                                   */
- /*   New layer3                                                      */
- /*                                                                   */
- /*-------------------------------------------------------------------*/
- 
-   int l,k,i,m,N;
-   double sum;
-   static double win[4][36];
-   static int init = 0;
-   static double cos_s[6][12], cos_l[18][36];
- 
- 
-   if ( init == 0 )
-   {
-     /* type 0 */
-     for ( i = 0; i < 36; i++ )
-       win[0][i] = sin( PI/36 * (i + 0.5) );
-     /* type 1*/
-     for ( i = 0; i < 18; i++ ) 
-       win[1][i] = sin( PI/36 * (i + 0.5) );
-     for ( i = 18; i < 24; i++ )
-       win[1][i] = 1.0;
-     for ( i = 24; i < 30; i++ )
-       win[1][i] = sin( PI/12 * ( i + 0.5 - 18) );
-     for ( i = 30; i < 36; i++ )
-       win[1][i] = 0.0;
-     /* type 3*/
-     for ( i = 0; i < 6; i++ )
-       win[3][i] = 0.0;
-     for ( i = 6; i < 12; i++ ) 
-       win[3][i] = sin( PI/12 * (i + 0.5 - 6) );
-     for ( i = 12; i < 18; i++ )
-       win[3][i] = 1.0;
-     for ( i = 18; i < 36; i++ )
-       win[3][i] = sin( PI/36 * (i + 0.5) );
-     /* type 2*/
-     for ( i = 0; i < 12; i++ )
-     win[2][i] = sin( PI/12 * (i + 0.5) );
-     for ( i = 12; i < 36; i++ )
-       win[2][i] = 0.0;
- 
-     N = 12;
-     for ( m = 0; m < N / 2; m++ )
-       for ( k = 0; k < N; k++ )
-         cos_s[m][k] = cos( (PI /(2 * N)) * (2 * k + 1 + N / 2) *
-                      (2 * m + 1) ) / (N / 4);
- 
-     N = 36;
-     for ( m = 0; m < N / 2; m++ )
-       for ( k = 0; k < N; k++ )
-         cos_l[m][k] = cos( (PI / (2 * N)) * (2 * k + 1 + N / 2) *
-                      (2 * m + 1) ) / (N / 4);
- 
-     init++;
-   }
- 
-   if ( block_type == 2 )
-   {
-     N = 12;
-     for ( l = 0; l < 3; l++ )
-     {
-       for ( m = 0; m < N / 2; m++ )
-       {
-         for ( sum = 0.0, k = 0; k < N; k++ )
-           sum += win[block_type][k] * in[k + 6 * l + 6] * cos_s[m][k];
-         out[ 3 * m + l] = sum;
-       }
-     }
-   }
-   else
-   {
-     N = 36;
-     for ( m = 0; m < N / 2; m++ )
-     {
-       for ( sum = 0.0, k = 0; k < N; k++ )
-         sum += win[block_type][k] * in[k] * cos_l[m][k];
-       out[m] = sum;
-     }
-   }
- }
- 
- void
- delay( double (*xr)[2][576], int stereo )
- {
-     static double xr_buff[2][576];
-     double xr_buff2[2][576];
-     unsigned int i,j;
-     
-     for (i=0;i<stereo;i++)
-     {
- 	for (j=0;j<576;j++) xr_buff2[i][j] = xr_buff[i][j];
- 	for (j=0;j<576;j++) xr_buff[i][j]  = xr[1][i][j];
- 	for (j=0;j<576;j++) xr[1][i][j]    = xr[0][i][j];
- 	for (j=0;j<576;j++) xr[0][i][j]    = xr_buff2[i][j];
-     }
- }
--- 0 ----
diff -r -c -N encoder/mdct.h lame3.50/mdct.h
*** encoder/mdct.h	Wed Jan 22 02:43:17 1997
--- lame3.50/mdct.h	Wed Dec 31 17:00:00 1969
***************
*** 1,25 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: mdct.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: mdct.h,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- 
- #ifndef MDCT_DOT_H
- #define MDCT_DOT_H
- void mdct(double *in, double *out, int block_type);
- void inv_mdct(double *in, double *out, int block_type);
- 
- typedef double D32_18[SBLIMIT][18];
- typedef double L3SBS[2][3][18][SBLIMIT]; /* [gr][ch] */
- 
- void mdct_sub(L3SBS (*sb_sample), double (*mdct_freq)[2][576], int stereo, III_side_info_t *l3_side, int mode_gr );
- void mdct_sub_dec(double (*mdct_freq)[2][576], double inv_mdct_dec[3][2][18][32], int stereo, III_side_info_t *l3_side);
- void delay(double (*xr)[2][576], int stereo);
- #endif
--- 0 ----
diff -r -c -N encoder/mlame lame3.50/mlame
*** encoder/mlame	Wed Dec 31 17:00:00 1969
--- lame3.50/mlame	Fri Sep 10 09:52:07 1999
***************
*** 0 ****
--- 1,81 ----
+ #!/bin/bash 
+ #!/usr/local/bin/bash
+ ############################################################################
+ #   
+ #  Run the LAME encoder on multible files, with option to delete .wav files
+ #  after encoding.  "mlame -h" will give instructions.
+ #
+ #  Robert Hegemann <Robert.Hegemann@gmx.de>
+ #
+ ############################################################################
+ 
+ mp3coder="lame"
+ options="-h -m f -b 128"
+ rmsrc=false
+ 
+ helptext="\
+ \nThis script runs the LAME mp3 encoder on multiple files: \n\n\
+ $0 [options] <file 1> ... <file n>\n\
+ \n\
+   options:\n\
+     -h                  this help text\n\
+     -r                  remove files after encoding\n\
+     -o \"<lame options>\" overrides script default options \"${options}\"\n\
+ \n\
+   example:\n\
+     $0 -r -o \"-v -V 0 -b 112\" a*.wav z*.aif\n\
+     \n\
+ "
+ 
+ #   process command-line options
+ #   this could be extended to fake the 
+ #   commandline interface of the mp3encoder
+ 
+ while getopts ":o:r" optn; do
+     case $optn in
+     o ) options=$OPTARG # replace default options
+         ;; 
+     r ) rmsrc=true
+         ;;
+     \? ) printf "$helptext"
+         exit 1  
+         ;;
+     esac
+ done
+ shift $(($OPTIND - 1))
+ 
+ #   process input-files
+ 
+ for filename in "$@"; do
+     case $filename in
+     *[*?]*  )   # means shell couldn�t extend *.wav, etc.
+         echo "warning: no $filename file(s) found"
+         ;;
+     *[.][wW][aA][vV]  )
+         name=${filename%[.][wW][aA][vV]}
+         if $mp3coder $options $filename ${name}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     *[.][aA][iI][fF]  )
+         name=${filename%[.][aA][iI][fF]}
+         if $mp3coder $options $filename ${name}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     *   )
+         if $mp3coder $options $filename ${filename}.mp3 
+         then
+             if [ $rmsrc = true ]; then
+                 rm -f $filename
+             fi
+         fi
+         ;;
+     esac
+ done
diff -r -c -N encoder/mp3x.c lame3.50/mp3x.c
*** encoder/mp3x.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mp3x.c	Tue Sep 28 21:58:18 1999
***************
*** 0 ****
--- 1,33 ----
+ #include "lame.h"
+ 
+ #include "gtkanal.h"
+ #include <gtk/gtk.h>
+ 
+ 
+ 
+ 
+ /************************************************************************
+ *
+ * main
+ *
+ * PURPOSE:  MPEG-1,2 Layer III encoder with GPSYCHO 
+ * psychoacoustic model.
+ *
+ ************************************************************************/
+ int main(int argc, char **argv)
+ {
+   char mp3buffer[LAME_MAXMP3BUFFER];
+   lame_init(1);
+   
+   if(argc==1)  lame_usage(argv[0]);  /* no command-line args  */
+   else lame_parse_args(argc, argv); 
+   lame_print_config();
+ 
+   gtkflag=1;
+   gtk_init (&argc, &argv);
+   gtkcontrol();
+ 
+   lame_cleanup(mp3buffer);
+   return 0;
+ }
+ 
diff -r -c -N encoder/mpglib/Makefile lame3.50/mpglib/Makefile
*** encoder/mpglib/Makefile	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/Makefile	Fri Sep 10 09:51:56 1999
***************
*** 0 ****
--- 1,22 ----
+ 
+ CC=gcc
+ CFLAGS=-Wall -g
+ 
+ all: mpglib
+ 
+ 
+ *.o: mpg123.h mpglib.h
+ 
+ mpglib: common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	$(CC) -o mpglib common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o main.o -lm
+ 
+ lib:    common.o dct64_i386.o decode_i386.o layer3.o tabinit.o interface.o main.o
+ 	ar -svru libmpg123.a main.o common.o dct64_i386.o decode_i386.o layer3.o \
+ 		tabinit.o interface.o 
+ 
+ 
+ clean:
+ 	rm *.o mpglib
+ 
+ 
diff -r -c -N encoder/mpglib/README lame3.50/mpglib/README
*** encoder/mpglib/README	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/README	Fri Sep 10 09:51:56 1999
***************
*** 0 ****
--- 1,33 ----
+ MP3 library
+ -----------
+ Version 0.2
+ 
+ This decoder is a 'light' version (thrown out all unnecessay parts)
+ from the mpg123 package. I made this for a company.
+ 
+ Currently only Layer3 is enabled to save some space. Layer1,2 isn't
+ tested at all. The interface will not change significantly. 
+ A backport to the mpg123 package is planed.
+ 
+ comiled and tested only on Solaris 2.6
+ main.c contains a simple demo application for library.
+ 
+ COPYING: you may use this source under GPL terms!
+ 
+ PLEASE NOTE: This software may contain patented alogrithm (at least
+   patented in some countries). It may be not allowed to sell/use products
+   based on this source code in these countries. Check this out first!
+ 
+ COPYRIGHT of MP3 music:
+   Please note, that the duplicating of copyrighted music without explicit
+   permission violates the rights of the owner.
+ 
+ SENDING PATCHES:
+   Maybe I change the copyright policy (ie some kind of more free BSD licencse).
+   Please consider this when sending patches/changes.
+ 
+ FEEDBACK:
+   I'm interessted to here from you, when you use this package as part
+   of another project.
+ 
+ 
diff -r -c -N encoder/mpglib/TODO lame3.50/mpglib/TODO
*** encoder/mpglib/TODO	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/TODO	Fri Sep 10 09:51:56 1999
***************
*** 0 ****
--- 1,2 ----
+ 
+ apply 'VBR' bug 
diff -r -c -N encoder/mpglib/common.c lame3.50/mpglib/common.c
*** encoder/mpglib/common.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/common.c	Thu Sep 16 00:12:43 1999
***************
*** 0 ****
--- 1,262 ----
+ #include <ctype.h>
+ #include <stdlib.h>
+ #include <signal.h>
+ 
+ #include <sys/types.h>
+ #include <sys/stat.h>
+ #include <fcntl.h>
+ 
+ #include "mpg123.h"
+ 
+ struct parameter param = { 1 , 1 , 0 , 0 };
+ 
+ int tabsel_123[2][3][16] = {
+    { {0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,},
+      {0,32,48,56, 64, 80, 96,112,128,160,192,224,256,320,384,},
+      {0,32,40,48, 56, 64, 80, 96,112,128,160,192,224,256,320,} },
+ 
+    { {0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,},
+      {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,} }
+ };
+ 
+ long freqs[9] = { 44100, 48000, 32000,
+                   22050, 24000, 16000 ,
+                   11025 , 12000 , 8000 };
+ 
+ int bitindex;
+ unsigned char *wordpointer;
+ unsigned char *pcm_sample;
+ int pcm_point = 0;
+ 
+ 
+ #if 0
+ static void get_II_stuff(struct frame *fr)
+ {
+   static int translate[3][2][16] = 
+    { { { 0,2,2,2,2,2,2,0,0,0,1,1,1,1,1,0 } ,
+        { 0,2,2,0,0,0,1,1,1,1,1,1,1,1,1,0 } } ,
+      { { 0,2,2,2,2,2,2,0,0,0,0,0,0,0,0,0 } ,
+        { 0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0 } } ,
+      { { 0,3,3,3,3,3,3,0,0,0,1,1,1,1,1,0 } ,
+        { 0,3,3,0,0,0,1,1,1,1,1,1,1,1,1,0 } } };
+ 
+   int table,sblim;
+   static struct al_table *tables[5] = 
+        { alloc_0, alloc_1, alloc_2, alloc_3 , alloc_4 };
+   static int sblims[5] = { 27 , 30 , 8, 12 , 30 };
+ 
+   if(fr->lsf)
+     table = 4;
+   else
+     table = translate[fr->sampling_frequency][2-fr->stereo][fr->bitrate_index];
+   sblim = sblims[table];
+ 
+   fr->alloc = tables[table];
+   fr->II_sblimit = sblim;
+ }
+ #endif
+ 
+ #define HDRCMPMASK 0xfffffd00
+ 
+ #if 0
+ int head_check(unsigned long head)
+ {
+     if( (head & 0xffe00000) != 0xffe00000)
+ 	return FALSE;
+     if(!((head>>17)&3))
+ 	return FALSE;
+     if( ((head>>12)&0xf) == 0xf)
+ 	return FALSE;
+     if( ((head>>10)&0x3) == 0x3 )
+ 	return FALSE;
+     return TRUE;
+ }
+ #endif
+ 
+ /*
+  * the code a header and write the information
+  * into the frame structure
+  */
+ int decode_header(struct frame *fr,unsigned long newhead)
+ {
+ 
+ 
+     if( newhead & (1<<20) ) {
+       fr->lsf = (newhead & (1<<19)) ? 0x0 : 0x1;
+       fr->mpeg25 = 0;
+     }
+     else {
+       fr->lsf = 1;
+       fr->mpeg25 = 1;
+     }
+     
+     fr->lay = 4-((newhead>>17)&3);
+     if( ((newhead>>10)&0x3) == 0x3) {
+       fprintf(stderr,"Stream error\n");
+       exit(1);
+     }
+     if(fr->mpeg25) {
+       fr->sampling_frequency = 6 + ((newhead>>10)&0x3);
+     }
+     else
+       fr->sampling_frequency = ((newhead>>10)&0x3) + (fr->lsf*3);
+     fr->error_protection = ((newhead>>16)&0x1)^0x1;
+ 
+     if(fr->mpeg25) /* allow Bitrate change for 2.5 ... */
+       fr->bitrate_index = ((newhead>>12)&0xf);
+ 
+     fr->bitrate_index = ((newhead>>12)&0xf);
+     fr->padding   = ((newhead>>9)&0x1);
+     fr->extension = ((newhead>>8)&0x1);
+     fr->mode      = ((newhead>>6)&0x3);
+     fr->mode_ext  = ((newhead>>4)&0x3);
+     fr->copyright = ((newhead>>3)&0x1);
+     fr->original  = ((newhead>>2)&0x1);
+     fr->emphasis  = newhead & 0x3;
+ 
+     fr->stereo    = (fr->mode == MPG_MD_MONO) ? 1 : 2;
+ 
+     if(!fr->bitrate_index)
+     {
+       fprintf(stderr,"Free format not supported.\n");
+       return (0);
+     }
+ 
+     switch(fr->lay)
+     {
+       case 1:
+ #if 0
+ 		fr->do_layer = do_layer1;
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ? 
+                          (fr->mode_ext<<2)+4 : 32;
+         fr->framesize  = (long) tabsel_123[fr->lsf][0][fr->bitrate_index] * 12000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize  = ((fr->framesize+fr->padding)<<2)-4;
+ #else
+         fprintf(stderr,"Not supported!\n");
+ #endif
+         break;
+       case 2:
+ #if 0
+ 		fr->do_layer = do_layer2;
+         get_II_stuff(fr);
+         fr->jsbound = (fr->mode == MPG_MD_JOINT_STEREO) ?
+                          (fr->mode_ext<<2)+4 : fr->II_sblimit;
+         fr->framesize = (long) tabsel_123[fr->lsf][1][fr->bitrate_index] * 144000;
+         fr->framesize /= freqs[fr->sampling_frequency];
+         fr->framesize += fr->padding - 4;
+ #else
+         fprintf(stderr,"Not supported!\n");
+ #endif
+         break;
+       case 3:
+ #if 0
+         fr->do_layer = do_layer3;
+         if(fr->lsf)
+           ssize = (fr->stereo == 1) ? 9 : 17;
+         else
+           ssize = (fr->stereo == 1) ? 17 : 32;
+ #endif
+ 
+ #if 0
+         if(fr->error_protection)
+           ssize += 2;
+ #endif
+           fr->framesize  = (long) tabsel_123[fr->lsf][2][fr->bitrate_index] * 144000;
+           fr->framesize /= freqs[fr->sampling_frequency]<<(fr->lsf);
+           fr->framesize = fr->framesize + fr->padding - 4;
+         break; 
+       default:
+         fprintf(stderr,"Sorry, unknown layer type.\n"); 
+         return (0);
+     }
+ 
+     /*    print_header(fr); */
+ 
+     return 1;
+ }
+ 
+ 
+ #if 1
+ void print_header(struct frame *fr)
+ {
+ 	static char *modes[4] = { "Stereo", "Joint-Stereo", "Dual-Channel", "Single-Channel" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+ 
+ 	fprintf(stderr,"MPEG %s, Layer: %s, Freq: %ld, mode: %s, modext: %d, BPF : %d\n", 
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],freqs[fr->sampling_frequency],
+ 		modes[fr->mode],fr->mode_ext,fr->framesize+4);
+ 	fprintf(stderr,"Channels: %d, copyright: %s, original: %s, CRC: %s, emphasis: %d.\n",
+ 		fr->stereo,fr->copyright?"Yes":"No",
+ 		fr->original?"Yes":"No",fr->error_protection?"Yes":"No",
+ 		fr->emphasis);
+ 	fprintf(stderr,"Bitrate: %d Kbits/s, Extension value: %d\n",
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],fr->extension);
+ }
+ 
+ void print_header_compact(struct frame *fr)
+ {
+ 	static char *modes[4] = { "stereo", "joint-stereo", "dual-channel", "mono" };
+ 	static char *layers[4] = { "Unknown" , "I", "II", "III" };
+  
+ 	fprintf(stderr,"MPEG %s layer %s, %d kbit/s, %ld Hz %s\n",
+ 		fr->mpeg25 ? "2.5" : (fr->lsf ? "2.0" : "1.0"),
+ 		layers[fr->lay],
+ 		tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index],
+ 		freqs[fr->sampling_frequency], modes[fr->mode]);
+ }
+ 
+ #endif
+ 
+ unsigned int getbits(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   if(!number_of_bits)
+     return 0;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;
+     rval |= wordpointer[1];
+     rval <<= 8;
+     rval |= wordpointer[2];
+     rval <<= bitindex;
+     rval &= 0xffffff;
+ 
+     bitindex += number_of_bits;
+ 
+     rval >>= (24-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ unsigned int getbits_fast(int number_of_bits)
+ {
+   unsigned long rval;
+ 
+   {
+     rval = wordpointer[0];
+     rval <<= 8;	
+     rval |= wordpointer[1];
+     rval <<= bitindex;
+     rval &= 0xffff;
+     bitindex += number_of_bits;
+ 
+     rval >>= (16-number_of_bits);
+ 
+     wordpointer += (bitindex>>3);
+     bitindex &= 7;
+   }
+   return rval;
+ }
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/mpglib/dct64_i386.c lame3.50/mpglib/dct64_i386.c
*** encoder/mpglib/dct64_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/dct64_i386.c	Thu Sep 16 00:12:03 1999
***************
*** 0 ****
--- 1,315 ----
+ /*
+  * Discrete Cosine Tansform (DCT) for subband synthesis
+  * optimized for machines with no auto-increment. 
+  * The performance is highly compiler dependend. Maybe
+  * the dct64.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include "mpg123.h"
+ 
+ static void dct64_1(real *out0,real *out1,real *b1,real *b2,real *samples)
+ {
+ 
+  {
+   register real *costab = pnts[0];
+ 
+   b1[0x00] = samples[0x00] + samples[0x1F];
+   b1[0x1F] = (samples[0x00] - samples[0x1F]) * costab[0x0];
+ 
+   b1[0x01] = samples[0x01] + samples[0x1E];
+   b1[0x1E] = (samples[0x01] - samples[0x1E]) * costab[0x1];
+ 
+   b1[0x02] = samples[0x02] + samples[0x1D];
+   b1[0x1D] = (samples[0x02] - samples[0x1D]) * costab[0x2];
+ 
+   b1[0x03] = samples[0x03] + samples[0x1C];
+   b1[0x1C] = (samples[0x03] - samples[0x1C]) * costab[0x3];
+ 
+   b1[0x04] = samples[0x04] + samples[0x1B];
+   b1[0x1B] = (samples[0x04] - samples[0x1B]) * costab[0x4];
+ 
+   b1[0x05] = samples[0x05] + samples[0x1A];
+   b1[0x1A] = (samples[0x05] - samples[0x1A]) * costab[0x5];
+ 
+   b1[0x06] = samples[0x06] + samples[0x19];
+   b1[0x19] = (samples[0x06] - samples[0x19]) * costab[0x6];
+ 
+   b1[0x07] = samples[0x07] + samples[0x18];
+   b1[0x18] = (samples[0x07] - samples[0x18]) * costab[0x7];
+ 
+   b1[0x08] = samples[0x08] + samples[0x17];
+   b1[0x17] = (samples[0x08] - samples[0x17]) * costab[0x8];
+ 
+   b1[0x09] = samples[0x09] + samples[0x16];
+   b1[0x16] = (samples[0x09] - samples[0x16]) * costab[0x9];
+ 
+   b1[0x0A] = samples[0x0A] + samples[0x15];
+   b1[0x15] = (samples[0x0A] - samples[0x15]) * costab[0xA];
+ 
+   b1[0x0B] = samples[0x0B] + samples[0x14];
+   b1[0x14] = (samples[0x0B] - samples[0x14]) * costab[0xB];
+ 
+   b1[0x0C] = samples[0x0C] + samples[0x13];
+   b1[0x13] = (samples[0x0C] - samples[0x13]) * costab[0xC];
+ 
+   b1[0x0D] = samples[0x0D] + samples[0x12];
+   b1[0x12] = (samples[0x0D] - samples[0x12]) * costab[0xD];
+ 
+   b1[0x0E] = samples[0x0E] + samples[0x11];
+   b1[0x11] = (samples[0x0E] - samples[0x11]) * costab[0xE];
+ 
+   b1[0x0F] = samples[0x0F] + samples[0x10];
+   b1[0x10] = (samples[0x0F] - samples[0x10]) * costab[0xF];
+  }
+ 
+ 
+  {
+   register real *costab = pnts[1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x0F]; 
+   b2[0x0F] = (b1[0x00] - b1[0x0F]) * costab[0];
+   b2[0x01] = b1[0x01] + b1[0x0E]; 
+   b2[0x0E] = (b1[0x01] - b1[0x0E]) * costab[1];
+   b2[0x02] = b1[0x02] + b1[0x0D]; 
+   b2[0x0D] = (b1[0x02] - b1[0x0D]) * costab[2];
+   b2[0x03] = b1[0x03] + b1[0x0C]; 
+   b2[0x0C] = (b1[0x03] - b1[0x0C]) * costab[3];
+   b2[0x04] = b1[0x04] + b1[0x0B]; 
+   b2[0x0B] = (b1[0x04] - b1[0x0B]) * costab[4];
+   b2[0x05] = b1[0x05] + b1[0x0A]; 
+   b2[0x0A] = (b1[0x05] - b1[0x0A]) * costab[5];
+   b2[0x06] = b1[0x06] + b1[0x09]; 
+   b2[0x09] = (b1[0x06] - b1[0x09]) * costab[6];
+   b2[0x07] = b1[0x07] + b1[0x08]; 
+   b2[0x08] = (b1[0x07] - b1[0x08]) * costab[7];
+ 
+   b2[0x10] = b1[0x10] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x10]) * costab[0];
+   b2[0x11] = b1[0x11] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x11]) * costab[1];
+   b2[0x12] = b1[0x12] + b1[0x1D];
+   b2[0x1D] = (b1[0x1D] - b1[0x12]) * costab[2];
+   b2[0x13] = b1[0x13] + b1[0x1C];
+   b2[0x1C] = (b1[0x1C] - b1[0x13]) * costab[3];
+   b2[0x14] = b1[0x14] + b1[0x1B];
+   b2[0x1B] = (b1[0x1B] - b1[0x14]) * costab[4];
+   b2[0x15] = b1[0x15] + b1[0x1A];
+   b2[0x1A] = (b1[0x1A] - b1[0x15]) * costab[5];
+   b2[0x16] = b1[0x16] + b1[0x19];
+   b2[0x19] = (b1[0x19] - b1[0x16]) * costab[6];
+   b2[0x17] = b1[0x17] + b1[0x18];
+   b2[0x18] = (b1[0x18] - b1[0x17]) * costab[7];
+  }
+ 
+  {
+   register real *costab = pnts[2];
+ 
+   b1[0x00] = b2[0x00] + b2[0x07];
+   b1[0x07] = (b2[0x00] - b2[0x07]) * costab[0];
+   b1[0x01] = b2[0x01] + b2[0x06];
+   b1[0x06] = (b2[0x01] - b2[0x06]) * costab[1];
+   b1[0x02] = b2[0x02] + b2[0x05];
+   b1[0x05] = (b2[0x02] - b2[0x05]) * costab[2];
+   b1[0x03] = b2[0x03] + b2[0x04];
+   b1[0x04] = (b2[0x03] - b2[0x04]) * costab[3];
+ 
+   b1[0x08] = b2[0x08] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x08]) * costab[0];
+   b1[0x09] = b2[0x09] + b2[0x0E];
+   b1[0x0E] = (b2[0x0E] - b2[0x09]) * costab[1];
+   b1[0x0A] = b2[0x0A] + b2[0x0D];
+   b1[0x0D] = (b2[0x0D] - b2[0x0A]) * costab[2];
+   b1[0x0B] = b2[0x0B] + b2[0x0C];
+   b1[0x0C] = (b2[0x0C] - b2[0x0B]) * costab[3];
+ 
+   b1[0x10] = b2[0x10] + b2[0x17];
+   b1[0x17] = (b2[0x10] - b2[0x17]) * costab[0];
+   b1[0x11] = b2[0x11] + b2[0x16];
+   b1[0x16] = (b2[0x11] - b2[0x16]) * costab[1];
+   b1[0x12] = b2[0x12] + b2[0x15];
+   b1[0x15] = (b2[0x12] - b2[0x15]) * costab[2];
+   b1[0x13] = b2[0x13] + b2[0x14];
+   b1[0x14] = (b2[0x13] - b2[0x14]) * costab[3];
+ 
+   b1[0x18] = b2[0x18] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x18]) * costab[0];
+   b1[0x19] = b2[0x19] + b2[0x1E];
+   b1[0x1E] = (b2[0x1E] - b2[0x19]) * costab[1];
+   b1[0x1A] = b2[0x1A] + b2[0x1D];
+   b1[0x1D] = (b2[0x1D] - b2[0x1A]) * costab[2];
+   b1[0x1B] = b2[0x1B] + b2[0x1C];
+   b1[0x1C] = (b2[0x1C] - b2[0x1B]) * costab[3];
+  }
+ 
+  {
+   register real const cos0 = pnts[3][0];
+   register real const cos1 = pnts[3][1];
+ 
+   b2[0x00] = b1[0x00] + b1[0x03];
+   b2[0x03] = (b1[0x00] - b1[0x03]) * cos0;
+   b2[0x01] = b1[0x01] + b1[0x02];
+   b2[0x02] = (b1[0x01] - b1[0x02]) * cos1;
+ 
+   b2[0x04] = b1[0x04] + b1[0x07];
+   b2[0x07] = (b1[0x07] - b1[0x04]) * cos0;
+   b2[0x05] = b1[0x05] + b1[0x06];
+   b2[0x06] = (b1[0x06] - b1[0x05]) * cos1;
+ 
+   b2[0x08] = b1[0x08] + b1[0x0B];
+   b2[0x0B] = (b1[0x08] - b1[0x0B]) * cos0;
+   b2[0x09] = b1[0x09] + b1[0x0A];
+   b2[0x0A] = (b1[0x09] - b1[0x0A]) * cos1;
+   
+   b2[0x0C] = b1[0x0C] + b1[0x0F];
+   b2[0x0F] = (b1[0x0F] - b1[0x0C]) * cos0;
+   b2[0x0D] = b1[0x0D] + b1[0x0E];
+   b2[0x0E] = (b1[0x0E] - b1[0x0D]) * cos1;
+ 
+   b2[0x10] = b1[0x10] + b1[0x13];
+   b2[0x13] = (b1[0x10] - b1[0x13]) * cos0;
+   b2[0x11] = b1[0x11] + b1[0x12];
+   b2[0x12] = (b1[0x11] - b1[0x12]) * cos1;
+ 
+   b2[0x14] = b1[0x14] + b1[0x17];
+   b2[0x17] = (b1[0x17] - b1[0x14]) * cos0;
+   b2[0x15] = b1[0x15] + b1[0x16];
+   b2[0x16] = (b1[0x16] - b1[0x15]) * cos1;
+ 
+   b2[0x18] = b1[0x18] + b1[0x1B];
+   b2[0x1B] = (b1[0x18] - b1[0x1B]) * cos0;
+   b2[0x19] = b1[0x19] + b1[0x1A];
+   b2[0x1A] = (b1[0x19] - b1[0x1A]) * cos1;
+ 
+   b2[0x1C] = b1[0x1C] + b1[0x1F];
+   b2[0x1F] = (b1[0x1F] - b1[0x1C]) * cos0;
+   b2[0x1D] = b1[0x1D] + b1[0x1E];
+   b2[0x1E] = (b1[0x1E] - b1[0x1D]) * cos1;
+  }
+ 
+  {
+   register real const cos0 = pnts[4][0];
+ 
+   b1[0x00] = b2[0x00] + b2[0x01];
+   b1[0x01] = (b2[0x00] - b2[0x01]) * cos0;
+   b1[0x02] = b2[0x02] + b2[0x03];
+   b1[0x03] = (b2[0x03] - b2[0x02]) * cos0;
+   b1[0x02] += b1[0x03];
+ 
+   b1[0x04] = b2[0x04] + b2[0x05];
+   b1[0x05] = (b2[0x04] - b2[0x05]) * cos0;
+   b1[0x06] = b2[0x06] + b2[0x07];
+   b1[0x07] = (b2[0x07] - b2[0x06]) * cos0;
+   b1[0x06] += b1[0x07];
+   b1[0x04] += b1[0x06];
+   b1[0x06] += b1[0x05];
+   b1[0x05] += b1[0x07];
+ 
+   b1[0x08] = b2[0x08] + b2[0x09];
+   b1[0x09] = (b2[0x08] - b2[0x09]) * cos0;
+   b1[0x0A] = b2[0x0A] + b2[0x0B];
+   b1[0x0B] = (b2[0x0B] - b2[0x0A]) * cos0;
+   b1[0x0A] += b1[0x0B];
+ 
+   b1[0x0C] = b2[0x0C] + b2[0x0D];
+   b1[0x0D] = (b2[0x0C] - b2[0x0D]) * cos0;
+   b1[0x0E] = b2[0x0E] + b2[0x0F];
+   b1[0x0F] = (b2[0x0F] - b2[0x0E]) * cos0;
+   b1[0x0E] += b1[0x0F];
+   b1[0x0C] += b1[0x0E];
+   b1[0x0E] += b1[0x0D];
+   b1[0x0D] += b1[0x0F];
+ 
+   b1[0x10] = b2[0x10] + b2[0x11];
+   b1[0x11] = (b2[0x10] - b2[0x11]) * cos0;
+   b1[0x12] = b2[0x12] + b2[0x13];
+   b1[0x13] = (b2[0x13] - b2[0x12]) * cos0;
+   b1[0x12] += b1[0x13];
+ 
+   b1[0x14] = b2[0x14] + b2[0x15];
+   b1[0x15] = (b2[0x14] - b2[0x15]) * cos0;
+   b1[0x16] = b2[0x16] + b2[0x17];
+   b1[0x17] = (b2[0x17] - b2[0x16]) * cos0;
+   b1[0x16] += b1[0x17];
+   b1[0x14] += b1[0x16];
+   b1[0x16] += b1[0x15];
+   b1[0x15] += b1[0x17];
+ 
+   b1[0x18] = b2[0x18] + b2[0x19];
+   b1[0x19] = (b2[0x18] - b2[0x19]) * cos0;
+   b1[0x1A] = b2[0x1A] + b2[0x1B];
+   b1[0x1B] = (b2[0x1B] - b2[0x1A]) * cos0;
+   b1[0x1A] += b1[0x1B];
+ 
+   b1[0x1C] = b2[0x1C] + b2[0x1D];
+   b1[0x1D] = (b2[0x1C] - b2[0x1D]) * cos0;
+   b1[0x1E] = b2[0x1E] + b2[0x1F];
+   b1[0x1F] = (b2[0x1F] - b2[0x1E]) * cos0;
+   b1[0x1E] += b1[0x1F];
+   b1[0x1C] += b1[0x1E];
+   b1[0x1E] += b1[0x1D];
+   b1[0x1D] += b1[0x1F];
+  }
+ 
+  out0[0x10*16] = b1[0x00];
+  out0[0x10*12] = b1[0x04];
+  out0[0x10* 8] = b1[0x02];
+  out0[0x10* 4] = b1[0x06];
+  out0[0x10* 0] = b1[0x01];
+  out1[0x10* 0] = b1[0x01];
+  out1[0x10* 4] = b1[0x05];
+  out1[0x10* 8] = b1[0x03];
+  out1[0x10*12] = b1[0x07];
+ 
+  b1[0x08] += b1[0x0C];
+  out0[0x10*14] = b1[0x08];
+  b1[0x0C] += b1[0x0a];
+  out0[0x10*10] = b1[0x0C];
+  b1[0x0A] += b1[0x0E];
+  out0[0x10* 6] = b1[0x0A];
+  b1[0x0E] += b1[0x09];
+  out0[0x10* 2] = b1[0x0E];
+  b1[0x09] += b1[0x0D];
+  out1[0x10* 2] = b1[0x09];
+  b1[0x0D] += b1[0x0B];
+  out1[0x10* 6] = b1[0x0D];
+  b1[0x0B] += b1[0x0F];
+  out1[0x10*10] = b1[0x0B];
+  out1[0x10*14] = b1[0x0F];
+ 
+  b1[0x18] += b1[0x1C];
+  out0[0x10*15] = b1[0x10] + b1[0x18];
+  out0[0x10*13] = b1[0x18] + b1[0x14];
+  b1[0x1C] += b1[0x1a];
+  out0[0x10*11] = b1[0x14] + b1[0x1C];
+  out0[0x10* 9] = b1[0x1C] + b1[0x12];
+  b1[0x1A] += b1[0x1E];
+  out0[0x10* 7] = b1[0x12] + b1[0x1A];
+  out0[0x10* 5] = b1[0x1A] + b1[0x16];
+  b1[0x1E] += b1[0x19];
+  out0[0x10* 3] = b1[0x16] + b1[0x1E];
+  out0[0x10* 1] = b1[0x1E] + b1[0x11];
+  b1[0x19] += b1[0x1D];
+  out1[0x10* 1] = b1[0x11] + b1[0x19];
+  out1[0x10* 3] = b1[0x19] + b1[0x15];
+  b1[0x1D] += b1[0x1B];
+  out1[0x10* 5] = b1[0x15] + b1[0x1D];
+  out1[0x10* 7] = b1[0x1D] + b1[0x13];
+  b1[0x1B] += b1[0x1F];
+  out1[0x10* 9] = b1[0x13] + b1[0x1B];
+  out1[0x10*11] = b1[0x1B] + b1[0x17];
+  out1[0x10*13] = b1[0x17] + b1[0x1F];
+  out1[0x10*15] = b1[0x1F];
+ }
+ 
+ /*
+  * the call via dct64 is a trick to force GCC to use
+  * (new) registers for the b1,b2 pointer to the bufs[xx] field
+  */
+ void dct64(real *a,real *b,real *c)
+ {
+   real bufs[0x40];
+   dct64_1(a,b,bufs,bufs+0x20,c);
+ }
+ 
+ 
diff -r -c -N encoder/mpglib/decode_i386.c lame3.50/mpglib/decode_i386.c
*** encoder/mpglib/decode_i386.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/decode_i386.c	Thu Sep 16 00:12:15 1999
***************
*** 0 ****
--- 1,154 ----
+ /* 
+  * Mpeg Layer-1,2,3 audio decoder 
+  * ------------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp, All rights reserved.
+  * See also 'README'
+  *
+  * slighlty optimized for machines without autoincrement/decrement.
+  * The performance is highly compiler dependend. Maybe
+  * the decode.c version for 'normal' processor may be faster
+  * even for Intel processors.
+  */
+ 
+ #include <stdlib.h>
+ #include <math.h>
+ #include <string.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ extern struct mpstr *gmp;
+ 
+  /* old WRITE_SAMPLE */
+ #define WRITE_SAMPLE(samples,sum,clip) \
+   if( (sum) > 32767.0) { *(samples) = 0x7fff; (clip)++; } \
+   else if( (sum) < -32768.0) { *(samples) = -0x8000; (clip)++; } \
+   else { *(samples) = sum; }
+ 
+ int synth_1to1_mono(real *bandPtr,unsigned char *samples,int *pnt)
+ {
+   short samples_tmp[64];
+   short *tmp1 = samples_tmp;
+   int i,ret;
+   int pnt1 = 0;
+ 
+   ret = synth_1to1(bandPtr,0,(unsigned char *) samples_tmp,&pnt1);
+   samples += *pnt;
+ 
+   for(i=0;i<32;i++) {
+     *( (short *) samples) = *tmp1;
+     samples += 2;
+     tmp1 += 2;
+   }
+   *pnt += 64;
+ 
+   return ret;
+ }
+ 
+ 
+ int synth_1to1(real *bandPtr,int channel,unsigned char *out,int *pnt)
+ {
+   static const int step = 2;
+   int bo;
+   short *samples = (short *) (out + *pnt);
+ 
+   real *b0,(*buf)[0x110];
+   int clip = 0; 
+   int bo1;
+ 
+   bo = gmp->synth_bo;
+ 
+   if(!channel) {
+     bo--;
+     bo &= 0xf;
+     buf = gmp->synth_buffs[0];
+   }
+   else {
+     samples++;
+     buf = gmp->synth_buffs[1];
+   }
+ 
+   if(bo & 0x1) {
+     b0 = buf[0];
+     bo1 = bo;
+     dct64(buf[1]+((bo+1)&0xf),buf[0]+bo,bandPtr);
+   }
+   else {
+     b0 = buf[1];
+     bo1 = bo+1;
+     dct64(buf[0]+bo,buf[1]+bo+1,bandPtr);
+   }
+ 
+   gmp->synth_bo = bo;
+   
+   {
+     register int j;
+     real *window = decwin + 16 - bo1;
+ 
+     for (j=16;j;j--,b0+=0x10,window+=0x20,samples+=step)
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum -= window[0x1] * b0[0x1];
+       sum += window[0x2] * b0[0x2];
+       sum -= window[0x3] * b0[0x3];
+       sum += window[0x4] * b0[0x4];
+       sum -= window[0x5] * b0[0x5];
+       sum += window[0x6] * b0[0x6];
+       sum -= window[0x7] * b0[0x7];
+       sum += window[0x8] * b0[0x8];
+       sum -= window[0x9] * b0[0x9];
+       sum += window[0xA] * b0[0xA];
+       sum -= window[0xB] * b0[0xB];
+       sum += window[0xC] * b0[0xC];
+       sum -= window[0xD] * b0[0xD];
+       sum += window[0xE] * b0[0xE];
+       sum -= window[0xF] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+ 
+     {
+       real sum;
+       sum  = window[0x0] * b0[0x0];
+       sum += window[0x2] * b0[0x2];
+       sum += window[0x4] * b0[0x4];
+       sum += window[0x6] * b0[0x6];
+       sum += window[0x8] * b0[0x8];
+       sum += window[0xA] * b0[0xA];
+       sum += window[0xC] * b0[0xC];
+       sum += window[0xE] * b0[0xE];
+       WRITE_SAMPLE(samples,sum,clip);
+       b0-=0x10,window-=0x20,samples+=step;
+     }
+     window += bo1<<1;
+ 
+     for (j=15;j;j--,b0-=0x10,window-=0x20,samples+=step)
+     {
+       real sum;
+       sum = -window[-0x1] * b0[0x0];
+       sum -= window[-0x2] * b0[0x1];
+       sum -= window[-0x3] * b0[0x2];
+       sum -= window[-0x4] * b0[0x3];
+       sum -= window[-0x5] * b0[0x4];
+       sum -= window[-0x6] * b0[0x5];
+       sum -= window[-0x7] * b0[0x6];
+       sum -= window[-0x8] * b0[0x7];
+       sum -= window[-0x9] * b0[0x8];
+       sum -= window[-0xA] * b0[0x9];
+       sum -= window[-0xB] * b0[0xA];
+       sum -= window[-0xC] * b0[0xB];
+       sum -= window[-0xD] * b0[0xC];
+       sum -= window[-0xE] * b0[0xD];
+       sum -= window[-0xF] * b0[0xE];
+       sum -= window[-0x0] * b0[0xF];
+ 
+       WRITE_SAMPLE(samples,sum,clip);
+     }
+   }
+   *pnt += 128;
+ 
+   return clip;
+ }
+ 
+ 
diff -r -c -N encoder/mpglib/huffman.h lame3.50/mpglib/huffman.h
*** encoder/mpglib/huffman.h	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/huffman.h	Fri Sep 10 09:51:57 1999
***************
*** 0 ****
--- 1,332 ----
+ /*
+  * huffman tables ... recalcualted to work with my optimzed
+  * decoder scheme (MH)
+  * 
+  * probably we could save a few bytes of memory, because the 
+  * smaller tables are often the part of a bigger table
+  */
+ 
+ struct newhuff 
+ {
+   unsigned int linbits;
+   short *table;
+ };
+ 
+ static short tab0[] = 
+ { 
+    0
+ };
+ 
+ static short tab1[] =
+ {
+   -5,  -3,  -1,  17,   1,  16,   0
+ };
+ 
+ static short tab2[] =
+ {
+  -15, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  17,  -1,   1,
+   16,   0
+ };
+ 
+ static short tab3[] =
+ {
+  -13, -11,  -9,  -5,  -3,  -1,  34,   2,  18,  -1,  33,  32,  16,  17,  -1,
+    1,   0
+ };
+ 
+ static short tab5[] =
+ {
+  -29, -25, -23, -15,  -7,  -5,  -3,  -1,  51,  35,  50,  49,  -3,  -1,  19,
+    3,  -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab6[] =
+ {
+  -25, -19, -13,  -9,  -5,  -3,  -1,  51,   3,  35,  -1,  50,  48,  -1,  19,
+   49,  -3,  -1,  34,   2,  18,  -3,  -1,  33,  32,   1,  -1,  17,  -1,  16,
+    0
+ };
+ 
+ static short tab7[] =
+ {
+  -69, -65, -57, -39, -29, -17, -11,  -7,  -3,  -1,  85,  69,  -1,  84,  83,
+   -1,  53,  68,  -3,  -1,  37,  82,  21,  -5,  -1,  81,  -1,   5,  52,  -1,
+   80,  -1,  67,  51,  -5,  -3,  -1,  36,  66,  20,  -1,  65,  64, -11,  -7,
+   -3,  -1,   4,  35,  -1,  50,   3,  -1,  19,  49,  -3,  -1,  48,  34,  18,
+   -5,  -1,  33,  -1,   2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab8[] =
+ {
+  -65, -63, -59, -45, -31, -19, -13,  -7,  -5,  -3,  -1,  85,  84,  69,  83,
+   -3,  -1,  53,  68,  37,  -3,  -1,  82,   5,  21,  -5,  -1,  81,  -1,  52,
+   67,  -3,  -1,  80,  51,  36,  -5,  -3,  -1,  66,  20,  65,  -3,  -1,   4,
+   64,  -1,  35,  50,  -9,  -7,  -3,  -1,  19,  49,  -1,   3,  48,  34,  -1,
+    2,  32,  -1,  18,  33,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab9[] =
+ {
+  -63, -53, -41, -29, -19, -11,  -5,  -3,  -1,  85,  69,  53,  -1,  83,  -1,
+   84,   5,  -3,  -1,  68,  37,  -1,  82,  21,  -3,  -1,  81,  52,  -1,  67,
+   -1,  80,   4,  -7,  -3,  -1,  36,  66,  -1,  51,  64,  -1,  20,  65,  -5,
+   -3,  -1,  35,  50,  19,  -1,  49,  -1,   3,  48,  -5,  -3,  -1,  34,   2,
+   18,  -1,  33,  32,  -3,  -1,  17,   1,  -1,  16,   0
+ };
+ 
+ static short tab10[] =
+ {
+ -125,-121,-111, -83, -55, -35, -21, -13,  -7,  -3,  -1, 119, 103,  -1, 118,
+   87,  -3,  -1, 117, 102,  71,  -3,  -1, 116,  86,  -1, 101,  55,  -9,  -3,
+   -1, 115,  70,  -3,  -1,  85,  84,  99,  -1,  39, 114, -11,  -5,  -3,  -1,
+  100,   7, 112,  -1,  98,  -1,  69,  53,  -5,  -1,   6,  -1,  83,  68,  23,
+  -17,  -5,  -1, 113,  -1,  54,  38,  -5,  -3,  -1,  37,  82,  21,  -1,  81,
+   -1,  52,  67,  -3,  -1,  22,  97,  -1,  96,  -1,   5,  80, -19, -11,  -7,
+   -3,  -1,  36,  66,  -1,  51,   4,  -1,  20,  65,  -3,  -1,  64,  35,  -1,
+   50,   3,  -3,  -1,  19,  49,  -1,  48,  34,  -7,  -3,  -1,  18,  33,  -1,
+    2,  32,  17,  -1,   1,  16,   0
+ };
+ 
+ static short tab11[] =
+ {
+ -121,-113, -89, -59, -43, -27, -17,  -7,  -3,  -1, 119, 103,  -1, 118, 117,
+   -3,  -1, 102,  71,  -1, 116,  -1,  87,  85,  -5,  -3,  -1,  86, 101,  55,
+   -1, 115,  70,  -9,  -7,  -3,  -1,  69,  84,  -1,  53,  83,  39,  -1, 114,
+   -1, 100,   7,  -5,  -1, 113,  -1,  23, 112,  -3,  -1,  54,  99,  -1,  96,
+   -1,  68,  37, -13,  -7,  -5,  -3,  -1,  82,   5,  21,  98,  -3,  -1,  38,
+    6,  22,  -5,  -1,  97,  -1,  81,  52,  -5,  -1,  80,  -1,  67,  51,  -1,
+   36,  66, -15, -11,  -7,  -3,  -1,  20,  65,  -1,   4,  64,  -1,  35,  50,
+   -1,  19,  49,  -5,  -3,  -1,   3,  48,  34,  33,  -5,  -1,  18,  -1,   2,
+   32,  17,  -3,  -1,   1,  16,   0
+ };
+ 
+ static short tab12[] =
+ {
+ -115, -99, -73, -45, -27, -17,  -9,  -5,  -3,  -1, 119, 103, 118,  -1,  87,
+  117,  -3,  -1, 102,  71,  -1, 116, 101,  -3,  -1,  86,  55,  -3,  -1, 115,
+   85,  39,  -7,  -3,  -1, 114,  70,  -1, 100,  23,  -5,  -1, 113,  -1,   7,
+  112,  -1,  54,  99, -13,  -9,  -3,  -1,  69,  84,  -1,  68,  -1,   6,   5,
+   -1,  38,  98,  -5,  -1,  97,  -1,  22,  96,  -3,  -1,  53,  83,  -1,  37,
+   82, -17,  -7,  -3,  -1,  21,  81,  -1,  52,  67,  -5,  -3,  -1,  80,   4,
+   36,  -1,  66,  20,  -3,  -1,  51,  65,  -1,  35,  50, -11,  -7,  -5,  -3,
+   -1,  64,   3,  48,  19,  -1,  49,  34,  -1,  18,  33,  -7,  -5,  -3,  -1,
+    2,  32,   0,  17,  -1,   1,  16
+ };
+ 
+ static short tab13[] =
+ {
+ -509,-503,-475,-405,-333,-265,-205,-153,-115, -83, -53, -35, -21, -13,  -9,
+   -7,  -5,  -3,  -1, 254, 252, 253, 237, 255,  -1, 239, 223,  -3,  -1, 238,
+  207,  -1, 222, 191,  -9,  -3,  -1, 251, 206,  -1, 220,  -1, 175, 233,  -1,
+  236, 221,  -9,  -5,  -3,  -1, 250, 205, 190,  -1, 235, 159,  -3,  -1, 249,
+  234,  -1, 189, 219, -17,  -9,  -3,  -1, 143, 248,  -1, 204,  -1, 174, 158,
+   -5,  -1, 142,  -1, 127, 126, 247,  -5,  -1, 218,  -1, 173, 188,  -3,  -1,
+  203, 246, 111, -15,  -7,  -3,  -1, 232,  95,  -1, 157, 217,  -3,  -1, 245,
+  231,  -1, 172, 187,  -9,  -3,  -1,  79, 244,  -3,  -1, 202, 230, 243,  -1,
+   63,  -1, 141, 216, -21,  -9,  -3,  -1,  47, 242,  -3,  -1, 110, 156,  15,
+   -5,  -3,  -1, 201,  94, 171,  -3,  -1, 125, 215,  78, -11,  -5,  -3,  -1,
+  200, 214,  62,  -1, 185,  -1, 155, 170,  -1,  31, 241, -23, -13,  -5,  -1,
+  240,  -1, 186, 229,  -3,  -1, 228, 140,  -1, 109, 227,  -5,  -1, 226,  -1,
+   46,  14,  -1,  30, 225, -15,  -7,  -3,  -1, 224,  93,  -1, 213, 124,  -3,
+   -1, 199,  77,  -1, 139, 184,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -1,
+  198,  61, -37, -21,  -9,  -5,  -3,  -1, 211, 123,  45,  -1, 210,  29,  -5,
+   -1, 183,  -1,  92, 197,  -3,  -1, 153, 122, 195,  -7,  -5,  -3,  -1, 167,
+  151,  75, 209,  -3,  -1,  13, 208,  -1, 138, 168, -11,  -7,  -3,  -1,  76,
+  196,  -1, 107, 182,  -1,  60,  44,  -3,  -1, 194,  91,  -3,  -1, 181, 137,
+   28, -43, -23, -11,  -5,  -1, 193,  -1, 152,  12,  -1, 192,  -1, 180, 106,
+   -5,  -3,  -1, 166, 121,  59,  -1, 179,  -1, 136,  90, -11,  -5,  -1,  43,
+   -1, 165, 105,  -1, 164,  -1, 120, 135,  -5,  -1, 148,  -1, 119, 118, 178,
+  -11,  -3,  -1,  27, 177,  -3,  -1,  11, 176,  -1, 150,  74,  -7,  -3,  -1,
+   58, 163,  -1,  89, 149,  -1,  42, 162, -47, -23,  -9,  -3,  -1,  26, 161,
+   -3,  -1,  10, 104, 160,  -5,  -3,  -1, 134,  73, 147,  -3,  -1,  57,  88,
+   -1, 133, 103,  -9,  -3,  -1,  41, 146,  -3,  -1,  87, 117,  56,  -5,  -1,
+  131,  -1, 102,  71,  -3,  -1, 116,  86,  -1, 101, 115, -11,  -3,  -1,  25,
+  145,  -3,  -1,   9, 144,  -1,  72, 132,  -7,  -5,  -1, 114,  -1,  70, 100,
+   40,  -1, 130,  24, -41, -27, -11,  -5,  -3,  -1,  55,  39,  23,  -1, 113,
+   -1,  85,   7,  -7,  -3,  -1, 112,  54,  -1,  99,  69,  -3,  -1,  84,  38,
+   -1,  98,  53,  -5,  -1, 129,  -1,   8, 128,  -3,  -1,  22,  97,  -1,   6,
+   96, -13,  -9,  -5,  -3,  -1,  83,  68,  37,  -1,  82,   5,  -1,  21,  81,
+   -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20, -19, -11,
+   -5,  -1,  65,  -1,   4,  64,  -3,  -1,  35,  50,  19,  -3,  -1,  49,   3,
+   -1,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab15[] =
+ {
+ -495,-445,-355,-263,-183,-115, -77, -43, -27, -13,  -7,  -3,  -1, 255, 239,
+   -1, 254, 223,  -1, 238,  -1, 253, 207,  -7,  -3,  -1, 252, 222,  -1, 237,
+  191,  -1, 251,  -1, 206, 236,  -7,  -3,  -1, 221, 175,  -1, 250, 190,  -3,
+   -1, 235, 205,  -1, 220, 159, -15,  -7,  -3,  -1, 249, 234,  -1, 189, 219,
+   -3,  -1, 143, 248,  -1, 204, 158,  -7,  -3,  -1, 233, 127,  -1, 247, 173,
+   -3,  -1, 218, 188,  -1, 111,  -1, 174,  15, -19, -11,  -3,  -1, 203, 246,
+   -3,  -1, 142, 232,  -1,  95, 157,  -3,  -1, 245, 126,  -1, 231, 172,  -9,
+   -3,  -1, 202, 187,  -3,  -1, 217, 141,  79,  -3,  -1, 244,  63,  -1, 243,
+  216, -33, -17,  -9,  -3,  -1, 230,  47,  -1, 242,  -1, 110, 240,  -3,  -1,
+   31, 241,  -1, 156, 201,  -7,  -3,  -1,  94, 171,  -1, 186, 229,  -3,  -1,
+  125, 215,  -1,  78, 228, -15,  -7,  -3,  -1, 140, 200,  -1,  62, 109,  -3,
+   -1, 214, 227,  -1, 155, 185,  -7,  -3,  -1,  46, 170,  -1, 226,  30,  -5,
+   -1, 225,  -1,  14, 224,  -1,  93, 213, -45, -25, -13,  -7,  -3,  -1, 124,
+  199,  -1,  77, 139,  -1, 212,  -1, 184, 154,  -7,  -3,  -1, 169, 108,  -1,
+  198,  61,  -1, 211, 210,  -9,  -5,  -3,  -1,  45,  13,  29,  -1, 123, 183,
+   -5,  -1, 209,  -1,  92, 208,  -1, 197, 138, -17,  -7,  -3,  -1, 168,  76,
+   -1, 196, 107,  -5,  -1, 182,  -1, 153,  12,  -1,  60, 195,  -9,  -3,  -1,
+  122, 167,  -1, 166,  -1, 192,  11,  -1, 194,  -1,  44,  91, -55, -29, -15,
+   -7,  -3,  -1, 181,  28,  -1, 137, 152,  -3,  -1, 193,  75,  -1, 180, 106,
+   -5,  -3,  -1,  59, 121, 179,  -3,  -1, 151, 136,  -1,  43,  90, -11,  -5,
+   -1, 178,  -1, 165,  27,  -1, 177,  -1, 176, 105,  -7,  -3,  -1, 150,  74,
+   -1, 164, 120,  -3,  -1, 135,  58, 163, -17,  -7,  -3,  -1,  89, 149,  -1,
+   42, 162,  -3,  -1,  26, 161,  -3,  -1,  10, 160, 104,  -7,  -3,  -1, 134,
+   73,  -1, 148,  57,  -5,  -1, 147,  -1, 119,   9,  -1,  88, 133, -53, -29,
+  -13,  -7,  -3,  -1,  41, 103,  -1, 118, 146,  -1, 145,  -1,  25, 144,  -7,
+   -3,  -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  71,  -7,
+   -3,  -1,  40, 130,  -1,  24, 129,  -7,  -3,  -1, 116,   8,  -1, 128,  86,
+   -3,  -1, 101,  55,  -1, 115,  70, -17,  -7,  -3,  -1,  39, 114,  -1, 100,
+   23,  -3,  -1,  85, 113,  -3,  -1,   7, 112,  54,  -7,  -3,  -1,  99,  69,
+   -1,  84,  38,  -3,  -1,  98,  22,  -3,  -1,   6,  96,  53, -33, -19,  -9,
+   -5,  -1,  97,  -1,  83,  68,  -1,  37,  82,  -3,  -1,  21,  81,  -3,  -1,
+    5,  80,  52,  -7,  -3,  -1,  67,  36,  -1,  66,  51,  -1,  65,  -1,  20,
+    4,  -9,  -3,  -1,  35,  50,  -3,  -1,  64,   3,  19,  -3,  -1,  49,  48,
+   34,  -9,  -7,  -3,  -1,  18,  33,  -1,   2,  32,  17,  -3,  -1,   1,  16,
+    0
+ };
+ 
+ static short tab16[] =
+ {
+ -509,-503,-461,-323,-103, -37, -27, -15,  -7,  -3,  -1, 239, 254,  -1, 223,
+  253,  -3,  -1, 207, 252,  -1, 191, 251,  -5,  -1, 175,  -1, 250, 159,  -3,
+   -1, 249, 248, 143,  -7,  -3,  -1, 127, 247,  -1, 111, 246, 255,  -9,  -5,
+   -3,  -1,  95, 245,  79,  -1, 244, 243, -53,  -1, 240,  -1,  63, -29, -19,
+  -13,  -7,  -5,  -1, 206,  -1, 236, 221, 222,  -1, 233,  -1, 234, 217,  -1,
+  238,  -1, 237, 235,  -3,  -1, 190, 205,  -3,  -1, 220, 219, 174, -11,  -5,
+   -1, 204,  -1, 173, 218,  -3,  -1, 126, 172, 202,  -5,  -3,  -1, 201, 125,
+   94, 189, 242, -93,  -5,  -3,  -1,  47,  15,  31,  -1, 241, -49, -25, -13,
+   -5,  -1, 158,  -1, 188, 203,  -3,  -1, 142, 232,  -1, 157, 231,  -7,  -3,
+   -1, 187, 141,  -1, 216, 110,  -1, 230, 156, -13,  -7,  -3,  -1, 171, 186,
+   -1, 229, 215,  -1,  78,  -1, 228, 140,  -3,  -1, 200,  62,  -1, 109,  -1,
+  214, 155, -19, -11,  -5,  -3,  -1, 185, 170, 225,  -1, 212,  -1, 184, 169,
+   -5,  -1, 123,  -1, 183, 208, 227,  -7,  -3,  -1,  14, 224,  -1,  93, 213,
+   -3,  -1, 124, 199,  -1,  77, 139, -75, -45, -27, -13,  -7,  -3,  -1, 154,
+  108,  -1, 198,  61,  -3,  -1,  92, 197,  13,  -7,  -3,  -1, 138, 168,  -1,
+  153,  76,  -3,  -1, 182, 122,  60, -11,  -5,  -3,  -1,  91, 137,  28,  -1,
+  192,  -1, 152, 121,  -1, 226,  -1,  46,  30, -15,  -7,  -3,  -1, 211,  45,
+   -1, 210, 209,  -5,  -1,  59,  -1, 151, 136,  29,  -7,  -3,  -1, 196, 107,
+   -1, 195, 167,  -1,  44,  -1, 194, 181, -23, -13,  -7,  -3,  -1, 193,  12,
+   -1,  75, 180,  -3,  -1, 106, 166, 179,  -5,  -3,  -1,  90, 165,  43,  -1,
+  178,  27, -13,  -5,  -1, 177,  -1,  11, 176,  -3,  -1, 105, 150,  -1,  74,
+  164,  -5,  -3,  -1, 120, 135, 163,  -3,  -1,  58,  89,  42, -97, -57, -33,
+  -19, -11,  -5,  -3,  -1, 149, 104, 161,  -3,  -1, 134, 119, 148,  -5,  -3,
+   -1,  73,  87, 103, 162,  -5,  -1,  26,  -1,  10, 160,  -3,  -1,  57, 147,
+   -1,  88, 133,  -9,  -3,  -1,  41, 146,  -3,  -1, 118,   9,  25,  -5,  -1,
+  145,  -1, 144,  72,  -3,  -1, 132, 117,  -1,  56, 131, -21, -11,  -5,  -3,
+   -1, 102,  40, 130,  -3,  -1,  71, 116,  24,  -3,  -1, 129, 128,  -3,  -1,
+    8,  86,  55,  -9,  -5,  -1, 115,  -1, 101,  70,  -1,  39, 114,  -5,  -3,
+   -1, 100,  85,   7,  23, -23, -13,  -5,  -1, 113,  -1, 112,  54,  -3,  -1,
+   99,  69,  -1,  84,  38,  -3,  -1,  98,  22,  -1,  97,  -1,   6,  96,  -9,
+   -5,  -1,  83,  -1,  53,  68,  -1,  37,  82,  -1,  81,  -1,  21,   5, -33,
+  -23, -13,  -7,  -3,  -1,  52,  67,  -1,  80,  36,  -3,  -1,  66,  51,  20,
+   -5,  -1,  65,  -1,   4,  64,  -1,  35,  50,  -3,  -1,  19,  49,  -3,  -1,
+    3,  48,  34,  -3,  -1,  18,  33,  -1,   2,  32,  -3,  -1,  17,   1,  16,
+    0
+ };
+ 
+ static short tab24[] =
+ {
+ -451,-117, -43, -25, -15,  -7,  -3,  -1, 239, 254,  -1, 223, 253,  -3,  -1,
+  207, 252,  -1, 191, 251,  -5,  -1, 250,  -1, 175, 159,  -1, 249, 248,  -9,
+   -5,  -3,  -1, 143, 127, 247,  -1, 111, 246,  -3,  -1,  95, 245,  -1,  79,
+  244, -71,  -7,  -3,  -1,  63, 243,  -1,  47, 242,  -5,  -1, 241,  -1,  31,
+  240, -25,  -9,  -1,  15,  -3,  -1, 238, 222,  -1, 237, 206,  -7,  -3,  -1,
+  236, 221,  -1, 190, 235,  -3,  -1, 205, 220,  -1, 174, 234, -15,  -7,  -3,
+   -1, 189, 219,  -1, 204, 158,  -3,  -1, 233, 173,  -1, 218, 188,  -7,  -3,
+   -1, 203, 142,  -1, 232, 157,  -3,  -1, 217, 126,  -1, 231, 172, 255,-235,
+ -143, -77, -45, -25, -15,  -7,  -3,  -1, 202, 187,  -1, 141, 216,  -5,  -3,
+   -1,  14, 224,  13, 230,  -5,  -3,  -1, 110, 156, 201,  -1,  94, 186,  -9,
+   -5,  -1, 229,  -1, 171, 125,  -1, 215, 228,  -3,  -1, 140, 200,  -3,  -1,
+   78,  46,  62, -15,  -7,  -3,  -1, 109, 214,  -1, 227, 155,  -3,  -1, 185,
+  170,  -1, 226,  30,  -7,  -3,  -1, 225,  93,  -1, 213, 124,  -3,  -1, 199,
+   77,  -1, 139, 184, -31, -15,  -7,  -3,  -1, 212, 154,  -1, 169, 108,  -3,
+   -1, 198,  61,  -1, 211,  45,  -7,  -3,  -1, 210,  29,  -1, 123, 183,  -3,
+   -1, 209,  92,  -1, 197, 138, -17,  -7,  -3,  -1, 168, 153,  -1,  76, 196,
+   -3,  -1, 107, 182,  -3,  -1, 208,  12,  60,  -7,  -3,  -1, 195, 122,  -1,
+  167,  44,  -3,  -1, 194,  91,  -1, 181,  28, -57, -35, -19,  -7,  -3,  -1,
+  137, 152,  -1, 193,  75,  -5,  -3,  -1, 192,  11,  59,  -3,  -1, 176,  10,
+   26,  -5,  -1, 180,  -1, 106, 166,  -3,  -1, 121, 151,  -3,  -1, 160,   9,
+  144,  -9,  -3,  -1, 179, 136,  -3,  -1,  43,  90, 178,  -7,  -3,  -1, 165,
+   27,  -1, 177, 105,  -1, 150, 164, -17,  -9,  -5,  -3,  -1,  74, 120, 135,
+   -1,  58, 163,  -3,  -1,  89, 149,  -1,  42, 162,  -7,  -3,  -1, 161, 104,
+   -1, 134, 119,  -3,  -1,  73, 148,  -1,  57, 147, -63, -31, -15,  -7,  -3,
+   -1,  88, 133,  -1,  41, 103,  -3,  -1, 118, 146,  -1,  25, 145,  -7,  -3,
+   -1,  72, 132,  -1,  87, 117,  -3,  -1,  56, 131,  -1, 102,  40, -17,  -7,
+   -3,  -1, 130,  24,  -1,  71, 116,  -5,  -1, 129,  -1,   8, 128,  -1,  86,
+  101,  -7,  -5,  -1,  23,  -1,   7, 112, 115,  -3,  -1,  55,  39, 114, -15,
+   -7,  -3,  -1,  70, 100,  -1,  85, 113,  -3,  -1,  54,  99,  -1,  69,  84,
+   -7,  -3,  -1,  38,  98,  -1,  22,  97,  -5,  -3,  -1,   6,  96,  53,  -1,
+   83,  68, -51, -37, -23, -15,  -9,  -3,  -1,  37,  82,  -1,  21,  -1,   5,
+   80,  -1,  81,  -1,  52,  67,  -3,  -1,  36,  66,  -1,  51,  20,  -9,  -5,
+   -1,  65,  -1,   4,  64,  -1,  35,  50,  -1,  19,  49,  -7,  -5,  -3,  -1,
+    3,  48,  34,  18,  -1,  33,  -1,   2,  32,  -3,  -1,  17,   1,  -1,  16,
+    0
+ };
+ 
+ static short tab_c0[] =
+ {
+  -29, -21, -13,  -7,  -3,  -1,  11,  15,  -1,  13,  14,  -3,  -1,   7,   5,
+    9,  -3,  -1,   6,   3,  -1,  10,  12,  -3,  -1,   2,   1,  -1,   4,   8,
+    0
+ };
+ 
+ static short tab_c1[] =
+ {
+  -15,  -7,  -3,  -1,  15,  14,  -1,  13,  12,  -3,  -1,  11,  10,  -1,   9,
+    8,  -7,  -3,  -1,   7,   6,  -1,   5,   4,  -3,  -1,   3,   2,  -1,   1,
+    0
+ };
+ 
+ 
+ 
+ static struct newhuff ht[] = 
+ {
+  { /* 0 */ 0 , tab0  } ,
+  { /* 2 */ 0 , tab1  } ,
+  { /* 3 */ 0 , tab2  } ,
+  { /* 3 */ 0 , tab3  } ,
+  { /* 0 */ 0 , tab0  } ,
+  { /* 4 */ 0 , tab5  } ,
+  { /* 4 */ 0 , tab6  } ,
+  { /* 6 */ 0 , tab7  } ,
+  { /* 6 */ 0 , tab8  } ,
+  { /* 6 */ 0 , tab9  } ,
+  { /* 8 */ 0 , tab10 } ,
+  { /* 8 */ 0 , tab11 } ,
+  { /* 8 */ 0 , tab12 } ,
+  { /* 16 */ 0 , tab13 } ,
+  { /* 0  */ 0 , tab0  } ,
+  { /* 16 */ 0 , tab15 } ,
+ 
+  { /* 16 */ 1 , tab16 } ,
+  { /* 16 */ 2 , tab16 } ,
+  { /* 16 */ 3 , tab16 } ,
+  { /* 16 */ 4 , tab16 } ,
+  { /* 16 */ 6 , tab16 } ,
+  { /* 16 */ 8 , tab16 } ,
+  { /* 16 */ 10, tab16 } ,
+  { /* 16 */ 13, tab16 } ,
+  { /* 16 */ 4 , tab24 } ,
+  { /* 16 */ 5 , tab24 } ,
+  { /* 16 */ 6 , tab24 } ,
+  { /* 16 */ 7 , tab24 } ,
+  { /* 16 */ 8 , tab24 } ,
+  { /* 16 */ 9 , tab24 } ,
+  { /* 16 */ 11, tab24 } ,
+  { /* 16 */ 13, tab24 }
+ };
+ 
+ static struct newhuff htc[] = 
+ {
+  { /* 1 , 1 , */ 0 , tab_c0 } ,
+  { /* 1 , 1 , */ 0 , tab_c1 }
+ };
+ 
+ 
diff -r -c -N encoder/mpglib/interface.c lame3.50/mpglib/interface.c
*** encoder/mpglib/interface.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/interface.c	Tue Oct 12 10:46:30 1999
***************
*** 0 ****
--- 1,218 ----
+ #include <stdlib.h>
+ #include <stdio.h>
+ 
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ 
+ /* Global mp .. it's a hack */
+ struct mpstr *gmp;
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp) 
+ {
+ 	memset(mp,0,sizeof(struct mpstr));
+ 
+ 	mp->framesize = 0;
+ 	mp->fsizeold = -1;
+ 	mp->bsize = 0;
+ 	mp->head = mp->tail = NULL;
+ 	mp->fr.single = -1;
+ 	mp->bsnum = 0;
+ 	mp->synth_bo = 1;
+ 
+ 	make_decode_tables(32767);
+ 	init_layer3(SBLIMIT);
+ 
+ 	return !0;
+ }
+ 
+ void ExitMP3(struct mpstr *mp)
+ {
+ 	struct buf *b,*bn;
+ 	
+ 	b = mp->tail;
+ 	while(b) {
+ 		free(b->pnt);
+ 		bn = b->next;
+ 		free(b);
+ 		b = bn;
+ 	}
+ }
+ 
+ static struct buf *addbuf(struct mpstr *mp,char *buf,int size)
+ {
+ 	struct buf *nbuf;
+ 
+ 	nbuf = (struct buf*) malloc( sizeof(struct buf) );
+ 	if(!nbuf) {
+ 		fprintf(stderr,"Out of memory!\n");
+ 		return NULL;
+ 	}
+ 	nbuf->pnt = (unsigned char*) malloc(size);
+ 	if(!nbuf->pnt) {
+ 		free(nbuf);
+ 		return NULL;
+ 	}
+ 	nbuf->size = size;
+ 	memcpy(nbuf->pnt,buf,size);
+ 	nbuf->next = NULL;
+ 	nbuf->prev = mp->head;
+ 	nbuf->pos = 0;
+ 
+ 	if(!mp->tail) {
+ 		mp->tail = nbuf;
+ 	}
+ 	else {
+ 	  mp->head->next = nbuf;
+ 	}
+ 
+ 	mp->head = nbuf;
+ 	mp->bsize += size;
+ 
+ 	return nbuf;
+ }
+ 
+ static void remove_buf(struct mpstr *mp)
+ {
+   struct buf *buf = mp->tail;
+   
+   mp->tail = buf->next;
+   if(mp->tail)
+     mp->tail->prev = NULL;
+   else {
+     mp->tail = mp->head = NULL;
+   }
+   
+   free(buf->pnt);
+   free(buf);
+ 
+ }
+ 
+ static int read_buf_byte(struct mpstr *mp)
+ {
+ 	unsigned int b;
+ 
+ 	int pos;
+ 
+ 	pos = mp->tail->pos;
+ 	while(pos >= mp->tail->size) {
+ 		remove_buf(mp);
+ 		pos = mp->tail->pos;
+ 		if(!mp->tail) {
+ 			fprintf(stderr,"Fatal error!\n");
+ 			exit(1);
+ 		}
+ 	}
+ 
+ 	b = mp->tail->pnt[pos];
+ 	mp->bsize--;
+ 	mp->tail->pos++;
+ 	
+ 
+ 	return b;
+ }
+ 
+ static void read_head(struct mpstr *mp)
+ {
+ 	unsigned long head;
+ 
+ 	head = read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 	head <<= 8;
+ 	head |= read_buf_byte(mp);
+ 
+ 	mp->header = head;
+ }
+ 
+ int decodeMP3(struct mpstr *mp,char *in,int isize,char *out,
+ 		int osize,int *done)
+ {
+ 	int len;
+ 
+ 	gmp = mp;
+ 
+ 	if(osize < 4608) {
+ 		fprintf(stderr,"To less out space\n");
+ 		return MP3_ERR;
+ 	}
+ 
+ 	if(in) {
+ 		if(addbuf(mp,in,isize) == NULL) {
+ 			return MP3_ERR;
+ 		}
+ 	}
+ 
+ 
+ 	/* First decode header */
+ 	if(mp->framesize == 0) {
+ 		if(mp->bsize < 4) {
+ 			return MP3_NEED_MORE;
+ 		}
+ 		read_head(mp);
+ 		decode_header(&mp->fr,mp->header);
+ 		mp->framesize = mp->fr.framesize;
+ 	}
+ 
+ 	/*	  printf(" fr.framesize = %i \n",mp->fr.framesize);
+ 		  printf(" bsize        = %i \n",mp->bsize);
+ 	*/
+ 
+ 	if(mp->fr.framesize > mp->bsize) {
+ 	  return MP3_NEED_MORE;
+ 	}
+ 	wordpointer = mp->bsspace[mp->bsnum] + 512;
+ 	mp->bsnum = (mp->bsnum + 1) & 0x1;
+ 	bitindex = 0;
+ 
+ 	len = 0;
+ 	while(len < mp->framesize) {
+ 		int nlen;
+ 		int blen = mp->tail->size - mp->tail->pos;
+ 		if( (mp->framesize - len) <= blen) {
+                   nlen = mp->framesize-len;
+ 		}
+ 		else {
+                   nlen = blen;
+                 }
+ 		memcpy(wordpointer+len,mp->tail->pnt+mp->tail->pos,nlen);
+                 len += nlen;
+                 mp->tail->pos += nlen;
+ 		mp->bsize -= nlen;
+                 if(mp->tail->pos == mp->tail->size) {
+                    remove_buf(mp);
+                 }
+ 	}
+ 
+ 	*done = 0;
+ 	if(mp->fr.error_protection)
+            getbits(16);
+ 	do_layer3(&mp->fr,(unsigned char *) out,done);
+ 
+ 	mp->fsizeold = mp->framesize;
+ 	mp->framesize = 0;
+ 	return MP3_OK;
+ }
+ 
+ int set_pointer(long backstep)
+ {
+   unsigned char *bsbufold;
+   if(gmp->fsizeold < 0 && backstep > 0) {
+     fprintf(stderr,"Can't step back %ld!\n",backstep);
+     return MP3_ERR; 
+   }
+   bsbufold = gmp->bsspace[gmp->bsnum] + 512;
+   wordpointer -= backstep;
+   if (backstep)
+     memcpy(wordpointer,bsbufold+gmp->fsizeold-backstep,backstep);
+   bitindex = 0;
+   return MP3_OK;
+ }
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/mpglib/layer3.c lame3.50/mpglib/layer3.c
*** encoder/mpglib/layer3.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/layer3.c	Mon Oct 25 12:17:41 1999
***************
*** 0 ****
--- 1,1681 ----
+ /* 
+  * Mpeg Layer-3 audio decoder 
+  * --------------------------
+  * copyright (c) 1995,1996,1997 by Michael Hipp.
+  * All rights reserved. See also 'README'
+  */ 
+ 
+ #include <stdlib.h>
+ #include "mpg123.h"
+ #include "mpglib.h"
+ #include "huffman.h"
+ #ifdef OS_AMIGAOS
+ #include "/gtkanal.h"
+ #else
+ #include "../gtkanal.h"
+ #endif
+ 
+ 
+ extern struct mpstr *gmp;
+ 
+ #define MPEG1
+ 
+ 
+ static real ispow[8207];
+ static real aa_ca[8],aa_cs[8];
+ static real COS1[12][6];
+ static real win[4][36];
+ static real win1[4][36];
+ static real gainpow2[256+118+4];
+ static real COS9[9];
+ static real COS6_1,COS6_2;
+ static real tfcos36[9];
+ static real tfcos12[3];
+ 
+ struct bandInfoStruct {
+   short longIdx[23];
+   short longDiff[22];
+   short shortIdx[14];
+   short shortDiff[13];
+ };
+ 
+ int longLimit[9][23];
+ int shortLimit[9][14];
+ 
+ struct bandInfoStruct bandInfo[9] = { 
+ 
+ /* MPEG 1.0 */
+  { {0,4,8,12,16,20,24,30,36,44,52,62,74, 90,110,134,162,196,238,288,342,418,576},
+    {4,4,4,4,4,4,6,6,8, 8,10,12,16,20,24,28,34,42,50,54, 76,158},
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,40*3,52*3,66*3, 84*3,106*3,136*3,192*3},
+    {4,4,4,4,6,8,10,12,14,18,22,30,56} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,42,50,60,72, 88,106,128,156,190,230,276,330,384,576},
+    {4,4,4,4,4,4,6,6,6, 8,10,12,16,18,22,28,34,40,46,54, 54,192},
+    {0,4*3,8*3,12*3,16*3,22*3,28*3,38*3,50*3,64*3, 80*3,100*3,126*3,192*3},
+    {4,4,4,4,6,6,10,12,14,16,20,26,66} } ,
+ 
+  { {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576} ,
+    {4,4,4,4,4,4,6,6,8,10,12,16,20,24,30,38,46,56,68,84,102, 26} ,
+    {0,4*3,8*3,12*3,16*3,22*3,30*3,42*3,58*3,78*3,104*3,138*3,180*3,192*3} ,
+    {4,4,4,4,6,8,12,16,20,26,34,42,12} }  ,
+ 
+ /* MPEG 2.0 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 } ,
+    {0,4*3,8*3,12*3,18*3,24*3,32*3,42*3,56*3,74*3,100*3,132*3,174*3,192*3} ,
+    {4,4,4,6,6,8,10,14,18,26,32,42,18 } } ,
+ 
+  { {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,330,394,464,540,576},
+    {6,6,6,6,6,6,8,10,12,14,16,18,22,26,32,38,46,52,64,70,76,36 } ,
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,136*3,180*3,192*3} ,
+    {4,4,4,6,8,10,12,14,18,24,32,44,12 } } ,
+ 
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54 },
+    {0,4*3,8*3,12*3,18*3,26*3,36*3,48*3,62*3,80*3,104*3,134*3,174*3,192*3},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18 } } ,
+ /* MPEG 2.5 */
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576} ,
+    {6,6,6,6,6,6,8,10,12,14,16,20,24,28,32,38,46,52,60,68,58,54},
+    {0,12,24,36,54,78,108,144,186,240,312,402,522,576},
+    {4,4,4,6,8,10,12,14,18,24,30,40,18} },
+  { {0,12,24,36,48,60,72,88,108,132,160,192,232,280,336,400,476,566,568,570,572,574,576},
+    {12,12,12,12,12,12,16,20,24,28,32,40,48,56,64,76,90,2,2,2,2,2},
+    {0, 24, 48, 72,108,156,216,288,372,480,486,492,498,576},
+    {8,8,8,12,16,20,24,28,36,2,2,2,26} } ,
+ };
+ 
+ static int mapbuf0[9][152];
+ static int mapbuf1[9][156];
+ static int mapbuf2[9][44];
+ static int *map[9][3];
+ static int *mapend[9][3];
+ 
+ static unsigned int n_slen2[512]; /* MPEG 2.0 slen for 'normal' mode */
+ static unsigned int i_slen2[256]; /* MPEG 2.0 slen for intensity stereo */
+ 
+ static real tan1_1[16],tan2_1[16],tan1_2[16],tan2_2[16];
+ static real pow1_1[2][16],pow2_1[2][16],pow1_2[2][16],pow2_2[2][16];
+ 
+ static unsigned int get1bit(void)
+ {
+   unsigned char rval;
+   rval = *wordpointer << bitindex;
+ 
+   bitindex++;
+   wordpointer += (bitindex>>3);
+   bitindex &= 7;
+ 
+   return rval>>7;
+ }
+ 
+ 
+ 
+ 
+ /* 
+  * init tables for layer-3 
+  */
+ void init_layer3(int down_sample_sblimit)
+ {
+   int i,j,k,l;
+ 
+   for(i=-256;i<118+4;i++)
+     gainpow2[i+256] = pow((double)2.0,-0.25 * (double) (i+210) );
+ 
+   for(i=0;i<8207;i++)
+     ispow[i] = pow((double)i,(double)4.0/3.0);
+ 
+   for (i=0;i<8;i++)
+   {
+     static double Ci[8]={-0.6,-0.535,-0.33,-0.185,-0.095,-0.041,-0.0142,-0.0037};
+     double sq=sqrt(1.0+Ci[i]*Ci[i]);
+     aa_cs[i] = 1.0/sq;
+     aa_ca[i] = Ci[i]/sq;
+   }
+ 
+   for(i=0;i<18;i++)
+   {
+     win[0][i]    = win[1][i]    = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+0) +1) ) / cos ( M_PI * (double) (2*(i+0) +19) / 72.0 );
+     win[0][i+18] = win[3][i+18] = 0.5 * sin( M_PI / 72.0 * (double) (2*(i+18)+1) ) / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+   }
+   for(i=0;i<6;i++)
+   {
+     win[1][i+18] = 0.5 / cos ( M_PI * (double) (2*(i+18)+19) / 72.0 );
+     win[3][i+12] = 0.5 / cos ( M_PI * (double) (2*(i+12)+19) / 72.0 );
+     win[1][i+24] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+13) ) / cos ( M_PI * (double) (2*(i+24)+19) / 72.0 );
+     win[1][i+30] = win[3][i] = 0.0;
+     win[3][i+6 ] = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) )  / cos ( M_PI * (double) (2*(i+6 )+19) / 72.0 );
+   }
+ 
+   for(i=0;i<9;i++)
+     COS9[i] = cos( M_PI / 18.0 * (double) i);
+ 
+   for(i=0;i<9;i++)
+     tfcos36[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 36.0 );
+   for(i=0;i<3;i++)
+     tfcos12[i] = 0.5 / cos ( M_PI * (double) (i*2+1) / 12.0 );
+ 
+   COS6_1 = cos( M_PI / 6.0 * (double) 1);
+   COS6_2 = cos( M_PI / 6.0 * (double) 2);
+ 
+   for(i=0;i<12;i++)
+   {
+     win[2][i]  = 0.5 * sin( M_PI / 24.0 * (double) (2*i+1) ) / cos ( M_PI * (double) (2*i+7) / 24.0 );
+     for(j=0;j<6;j++)
+       COS1[i][j] = cos( M_PI / 24.0 * (double) ((2*i+7)*(2*j+1)) );
+   }
+ 
+   for(j=0;j<4;j++) {
+     static int len[4] = { 36,36,12,36 };
+     for(i=0;i<len[j];i+=2)
+       win1[j][i] = + win[j][i];
+     for(i=1;i<len[j];i+=2)
+       win1[j][i] = - win[j][i];
+   }
+ 
+   for(i=0;i<16;i++)
+   {
+     double t = tan( (double) i * M_PI / 12.0 );
+     tan1_1[i] = t / (1.0+t);
+     tan2_1[i] = 1.0 / (1.0 + t);
+     tan1_2[i] = M_SQRT2 * t / (1.0+t);
+     tan2_2[i] = M_SQRT2 / (1.0 + t);
+ 
+     for(j=0;j<2;j++) {
+       double base = pow(2.0,-0.25*(j+1.0));
+       double p1=1.0,p2=1.0;
+       if(i > 0) {
+         if( i & 1 )
+           p1 = pow(base,(i+1.0)*0.5);
+         else
+           p2 = pow(base,i*0.5);
+       }
+       pow1_1[j][i] = p1;
+       pow2_1[j][i] = p2;
+       pow1_2[j][i] = M_SQRT2 * p1;
+       pow2_2[j][i] = M_SQRT2 * p2;
+     }
+   }
+ 
+   for(j=0;j<9;j++)
+   {
+    struct bandInfoStruct *bi = &bandInfo[j];
+    int *mp;
+    int cb,lwin;
+    short *bdf;
+ 
+    mp = map[j][0] = mapbuf0[j];
+    bdf = bi->longDiff;
+    for(i=0,cb = 0; cb < 8 ; cb++,i+=*bdf++) {
+      *mp++ = (*bdf) >> 1;
+      *mp++ = i;
+      *mp++ = 3;
+      *mp++ = cb;
+    }
+    bdf = bi->shortDiff+3;
+    for(cb=3;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][0] = mp;
+ 
+    mp = map[j][1] = mapbuf1[j];
+    bdf = bi->shortDiff+0;
+    for(i=0,cb=0;cb<13;cb++) {
+      int l = (*bdf++) >> 1;
+      for(lwin=0;lwin<3;lwin++) {
+        *mp++ = l;
+        *mp++ = i + lwin;
+        *mp++ = lwin;
+        *mp++ = cb;
+      }
+      i += 6*l;
+    }
+    mapend[j][1] = mp;
+ 
+    mp = map[j][2] = mapbuf2[j];
+    bdf = bi->longDiff;
+    for(cb = 0; cb < 22 ; cb++) {
+      *mp++ = (*bdf++) >> 1;
+      *mp++ = cb;
+    }
+    mapend[j][2] = mp;
+ 
+   }
+ 
+   for(j=0;j<9;j++) {
+     for(i=0;i<23;i++) {
+       longLimit[j][i] = (bandInfo[j].longIdx[i] - 1 + 8) / 18 + 1;
+       if(longLimit[j][i] > (down_sample_sblimit) )
+         longLimit[j][i] = down_sample_sblimit;
+     }
+     for(i=0;i<14;i++) {
+       shortLimit[j][i] = (bandInfo[j].shortIdx[i] - 1) / 18 + 1;
+       if(shortLimit[j][i] > (down_sample_sblimit) )
+         shortLimit[j][i] = down_sample_sblimit;
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<6;j++) {
+       for(k=0;k<6;k++) {
+         int n = k + j * 6 + i * 36;
+         i_slen2[n] = i|(j<<3)|(k<<6)|(3<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<4;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 16;
+         i_slen2[n+180] = i|(j<<3)|(k<<6)|(4<<12);
+       }
+     }
+   }
+   for(i=0;i<4;i++) {
+     for(j=0;j<3;j++) {
+       int n = j + i * 3;
+       i_slen2[n+244] = i|(j<<3) | (5<<12);
+       n_slen2[n+500] = i|(j<<3) | (2<<12) | (1<<15);
+     }
+   }
+ 
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         for(l=0;l<4;l++) {
+           int n = l + k * 4 + j * 16 + i * 80;
+           n_slen2[n] = i|(j<<3)|(k<<6)|(l<<9)|(0<<12);
+         }
+       }
+     }
+   }
+   for(i=0;i<5;i++) {
+     for(j=0;j<5;j++) {
+       for(k=0;k<4;k++) {
+         int n = k + j * 4 + i * 20;
+         n_slen2[n+400] = i|(j<<3)|(k<<6)|(1<<12);
+       }
+     }
+   }
+ }
+ 
+ /*
+  * read additional side information
+  */
+ #ifdef MPEG1 
+ static void III_get_side_info_1(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch, gr;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(9);
+    if (stereo == 1)
+      si->private_bits = getbits_fast(5);
+    else 
+      si->private_bits = getbits_fast(3);
+ 
+    for (ch=0; ch<stereo; ch++) {
+        si->ch[ch].gr[0].scfsi = -1;
+        si->ch[ch].gr[1].scfsi = getbits_fast(4);
+    }
+ 
+    for (gr=0; gr<2; gr++) 
+    {
+      for (ch=0; ch<stereo; ch++) 
+      {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[gr]);
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+           fprintf(stderr,"big_values too large!\n");
+           gr_info->big_values = 288;
+        }
+        {
+ 	 unsigned int qss = getbits_fast(8);
+ 	 gr_info->pow2gain = gainpow2+256 - qss + powdiff;
+ #ifdef HAVEGTK
+ 	 if (gtkflag) 
+ 	   pinfo->qss[gr][ch]=qss;
+ #endif
+        }
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits_fast(4);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+ 
+ 
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+ 	   unsigned int sbg = (getbits_fast(3)<<3);
+            gr_info->full_gain[i] = gr_info->pow2gain + sbg;
+ #ifdef HAVEGTK
+ 	   if (gtkflag)
+ 	     pinfo->sub_gain[gr][ch][i]=sbg/8;
+ #endif
+ 	 }
+ 
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+          gr_info->region1start = 36>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->preflag = get1bit();
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        if (gtkflag)
+ 	 pinfo->scalefac_scale[gr][ch]=gr_info->scalefac_scale;
+ #endif
+      }
+    }
+ }
+ #endif
+ 
+ /*
+  * Side Info for MPEG 2.0 / LSF
+  */
+ static void III_get_side_info_2(struct III_sideinfo *si,int stereo,
+  int ms_stereo,long sfreq,int single)
+ {
+    int ch;
+    int powdiff = (single == 3) ? 4 : 0;
+ 
+    si->main_data_begin = getbits(8);
+    if (stereo == 1)
+      si->private_bits = get1bit();
+    else 
+      si->private_bits = getbits_fast(2);
+ 
+    for (ch=0; ch<stereo; ch++) 
+    {
+        register struct gr_info_s *gr_info = &(si->ch[ch].gr[0]);
+ 
+        gr_info->part2_3_length = getbits(12);
+        gr_info->big_values = getbits_fast(9);
+        if(gr_info->big_values > 288) {
+          fprintf(stderr,"big_values too large!\n");
+          gr_info->big_values = 288;
+        }
+        gr_info->pow2gain = gainpow2+256 - getbits_fast(8) + powdiff;
+        if(ms_stereo)
+          gr_info->pow2gain += 2;
+        gr_info->scalefac_compress = getbits(9);
+ /* window-switching flag == 1 for block_Type != 0 .. and block-type == 0 -> win-sw-flag = 0 */
+        if(get1bit()) 
+        {
+          int i;
+          gr_info->block_type = getbits_fast(2);
+          gr_info->mixed_block_flag = get1bit();
+          gr_info->table_select[0] = getbits_fast(5);
+          gr_info->table_select[1] = getbits_fast(5);
+          /*
+           * table_select[2] not needed, because there is no region2,
+           * but to satisfy some verifications tools we set it either.
+           */
+          gr_info->table_select[2] = 0;
+          for(i=0;i<3;i++) {
+            gr_info->full_gain[i] = gr_info->pow2gain + (getbits_fast(3)<<3);
+ 	 }
+ 
+          if(gr_info->block_type == 0) {
+            fprintf(stderr,"Blocktype == 0 and window-switching == 1 not allowed.\n");
+            exit(1);
+          }
+          /* region_count/start parameters are implicit in this case. */       
+ /* check this again! */
+          if(gr_info->block_type == 2)
+            gr_info->region1start = 36>>1;
+          else if(sfreq == 8)
+ /* check this for 2.5 and sfreq=8 */
+            gr_info->region1start = 108>>1;
+          else
+            gr_info->region1start = 54>>1;
+          gr_info->region2start = 576>>1;
+        }
+        else 
+        {
+          int i,r0c,r1c;
+          for (i=0; i<3; i++)
+            gr_info->table_select[i] = getbits_fast(5);
+          r0c = getbits_fast(4);
+          r1c = getbits_fast(3);
+          gr_info->region1start = bandInfo[sfreq].longIdx[r0c+1] >> 1 ;
+          gr_info->region2start = bandInfo[sfreq].longIdx[r0c+1+r1c+1] >> 1;
+          gr_info->block_type = 0;
+          gr_info->mixed_block_flag = 0;
+        }
+        gr_info->scalefac_scale = get1bit();
+        gr_info->count1table_select = get1bit();
+ #ifdef HAVEGTK
+        if (gtkflag)
+ 	 pinfo->scalefac_scale[0][ch]=gr_info->scalefac_scale;
+ #endif
+    }
+ }
+ 
+ /*
+  * read scalefactors
+  */
+ #ifdef MPEG1
+ static int III_get_scale_factors_1(int *scf,struct gr_info_s *gr_info)
+ {
+    static unsigned char slen[2][16] = {
+      {0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4},
+      {0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3}
+    };
+    int numbits;
+    int num0 = slen[0][gr_info->scalefac_compress];
+    int num1 = slen[1][gr_info->scalefac_compress];
+ 
+     if (gr_info->block_type == 2) 
+     {
+       int i=18;
+       numbits = (num0 + num1) * 18;
+ 
+       if (gr_info->mixed_block_flag) {
+          for (i=8;i;i--)
+            *scf++ = getbits_fast(num0);
+          i = 9;
+          numbits -= num0; /* num0 * 17 + num1 * 18 */
+       }
+ 
+       for (;i;i--)
+         *scf++ = getbits_fast(num0);
+       for (i = 18; i; i--)
+         *scf++ = getbits_fast(num1);
+       *scf++ = 0; *scf++ = 0; *scf++ = 0; /* short[13][0..2] = 0 */
+     }
+     else 
+     {
+       int i;
+       int scfsi = gr_info->scfsi;
+ 
+       if(scfsi < 0) { /* scfsi < 0 => granule == 0 */
+          for(i=11;i;i--)
+            *scf++ = getbits_fast(num0);
+          for(i=10;i;i--)
+            *scf++ = getbits_fast(num1);
+          numbits = (num0 + num1) * 10 + num0;
+       }
+       else {
+         numbits = 0;
+         if(!(scfsi & 0x8)) {
+           for (i=6;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 6;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x4)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num0);
+           numbits += num0 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x2)) {
+           for(i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+ 
+         if(!(scfsi & 0x1)) {
+           for (i=5;i;i--)
+             *scf++ = getbits_fast(num1);
+           numbits += num1 * 5;
+         }
+         else {
+           *scf++ = 0; *scf++ = 0; *scf++ = 0;  /* set to ZERO necessary? */
+           *scf++ = 0; *scf++ = 0;
+         }
+       }
+ 
+       *scf++ = 0;  /* no l[21] in original sources */
+     }
+     return numbits;
+ }
+ #endif
+ 
+ static int III_get_scale_factors_2(int *scf,struct gr_info_s *gr_info,int i_stereo)
+ {
+   unsigned char *pnt;
+   int i,j;
+   unsigned int slen;
+   int n = 0;
+   int numbits = 0;
+ 
+   static unsigned char stab[3][6][4] = {
+    { { 6, 5, 5,5 } , { 6, 5, 7,3 } , { 11,10,0,0} ,
+      { 7, 7, 7,0 } , { 6, 6, 6,3 } , {  8, 8,5,0} } ,
+    { { 9, 9, 9,9 } , { 9, 9,12,6 } , { 18,18,0,0} ,
+      {12,12,12,0 } , {12, 9, 9,6 } , { 15,12,9,0} } ,
+    { { 6, 9, 9,9 } , { 6, 9,12,6 } , { 15,18,0,0} ,
+      { 6,15,12,0 } , { 6,12, 9,6 } , {  6,18,9,0} } }; 
+ 
+   if(i_stereo) /* i_stereo AND second channel -> do_layer3() checks this */
+     slen = i_slen2[gr_info->scalefac_compress>>1];
+   else
+     slen = n_slen2[gr_info->scalefac_compress];
+ 
+   gr_info->preflag = (slen>>15) & 0x1;
+ 
+   n = 0;  
+   if( gr_info->block_type == 2 ) {
+     n++;
+     if(gr_info->mixed_block_flag)
+       n++;
+   }
+ 
+   pnt = stab[n][(slen>>12)&0x7];
+ 
+   for(i=0;i<4;i++) {
+     int num = slen & 0x7;
+     slen >>= 3;
+     if(num) {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = getbits_fast(num);
+       numbits += pnt[i] * num;
+     }
+     else {
+       for(j=0;j<(int)(pnt[i]);j++)
+         *scf++ = 0;
+     }
+   }
+   
+   n = (n << 1) + 1;
+   for(i=0;i<n;i++)
+     *scf++ = 0;
+ 
+   return numbits;
+ }
+ 
+ static int pretab1[22] = {0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,2,2,3,3,3,2,0};
+ static int pretab2[22] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+ 
+ /*
+  * don't forget to apply the same changes to III_dequantize_sample_ms() !!! 
+  */
+ static int III_dequantize_sample(real xr[SBLIMIT][SSLIMIT],int *scf,
+    struct gr_info_s *gr_info,int sfreq,int part2bits)
+ {
+   int shift = 1 + gr_info->scalefac_scale;
+   real *xrpnt = (real *) xr;
+   int l[3],l3;
+   int part2remain = gr_info->part2_3_length - part2bits;
+   int *me;
+ 
+   {
+     int bv       = gr_info->big_values;
+     int region1  = gr_info->region1start;
+     int region2  = gr_info->region2start;
+ 
+     l3 = ((576>>1)-bv)>>1;   
+ /*
+  * we may lose the 'odd' bit here !! 
+  * check this later again 
+  */
+     if(bv <= region1) {
+       l[0] = bv; l[1] = 0; l[2] = 0;
+     }
+     else {
+       l[0] = region1;
+       if(bv <= region2) {
+         l[1] = bv - l[0];  l[2] = 0;
+       }
+       else {
+         l[1] = region2 - l[0]; l[2] = bv - region2;
+       }
+     }
+   }
+  
+   if(gr_info->block_type == 2) {
+     /*
+      * decoding with short or mixed mode BandIndex table 
+      */
+     int i,max[4];
+     int step=0,lwin=0,cb=0;
+     register real v = 0.0;
+     register int *m,mc;
+ 
+     if(gr_info->mixed_block_flag) {
+       max[3] = -1;
+       max[0] = max[1] = max[2] = 2;
+       m = map[sfreq][0];
+       me = mapend[sfreq][0];
+     }
+     else {
+       max[0] = max[1] = max[2] = max[3] = -1;
+       /* max[3] not really needed in this case */
+       m = map[sfreq][1];
+       me = mapend[sfreq][1];
+     }
+ 
+     mc = 0;
+     for(i=0;i<2;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+       for(;lp;lp--,mc--) {
+         register int x,y;
+         if( (!mc) ) {
+           mc = *m++;
+           xrpnt = ((real *) xr) + (*m++);
+           lwin = *m++;
+           cb = *m++;
+           if(lwin == 3) {
+             v = gr_info->pow2gain[(*scf++) << shift];
+             step = 1;
+           }
+           else {
+             v = gr_info->full_gain[lwin][(*scf++) << shift];
+             step = 3;
+           }
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if(x == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+         }
+         else if(x) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[x] * v;
+           else
+             *xrpnt =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+         if(y == 15) {
+           max[lwin] = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+         }
+         else if(y) {
+           max[lwin] = cb;
+           if(get1bit())
+             *xrpnt = -ispow[y] * v;
+           else
+             *xrpnt =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             xrpnt = ((real *) xr) + (*m++);
+             lwin = *m++;
+             cb = *m++;
+             if(lwin == 3) {
+               v = gr_info->pow2gain[(*scf++) << shift];
+               step = 1;
+             }
+             else {
+               v = gr_info->full_gain[lwin][(*scf++) << shift];
+               step = 3;
+             }
+           }
+           mc--;
+         }
+         if( (a & (0x8>>i)) ) {
+           max[lwin] = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit()) 
+             *xrpnt = -v;
+           else
+             *xrpnt = v;
+         }
+         else
+           *xrpnt = 0.0;
+         xrpnt += step;
+       }
+     }
+  
+     while( m < me ) {
+       if(!mc) {
+         mc = *m++;
+         xrpnt = ((real *) xr) + *m++;
+         if( (*m++) == 3)
+           step = 1;
+         else
+           step = 3;
+         m++; /* cb */
+       }
+       mc--;
+       *xrpnt = 0.0;
+       xrpnt += step;
+       *xrpnt = 0.0;
+       xrpnt += step;
+ /* we could add a little opt. here:
+  * if we finished a band for window 3 or a long band
+  * further bands could copied in a simple loop without a
+  * special 'map' decoding
+  */
+     }
+ 
+     gr_info->maxband[0] = max[0]+1;
+     gr_info->maxband[1] = max[1]+1;
+     gr_info->maxband[2] = max[2]+1;
+     gr_info->maxbandl = max[3]+1;
+ 
+     {
+       int rmax = max[0] > max[1] ? max[0] : max[1];
+       rmax = (rmax > max[2] ? rmax : max[2]) + 1;
+       gr_info->maxb = rmax ? shortLimit[sfreq][rmax] : longLimit[sfreq][max[3]+1];
+     }
+ 
+   }
+   else {
+ 	/*
+      * decoding with 'long' BandIndex table (block_type != 2)
+      */
+     int *pretab = gr_info->preflag ? pretab1 : pretab2;
+     int i,max = -1;
+     int cb = 0;
+     register int *m = map[sfreq][2];
+     register real v = 0.0;
+     register int mc = 0;
+ #if 0
+     me = mapend[sfreq][2];
+ #endif
+ 
+ 	/*
+      * long hash table values
+      */
+     for(i=0;i<3;i++) {
+       int lp = l[i];
+       struct newhuff *h = ht+gr_info->table_select[i];
+ 
+       for(;lp;lp--,mc--) {
+         int x,y;
+ 
+         if(!mc) {
+           mc = *m++;
+           v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           cb = *m++;
+         }
+         {
+           register short *val = h->table;
+           while((y=*val++)<0) {
+             if (get1bit())
+               val -= y;
+             part2remain--;
+           }
+           x = y >> 4;
+           y &= 0xf;
+         }
+         if (x == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           x += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+         }
+         else if(x) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[x] * v;
+           else
+             *xrpnt++ =  ispow[x] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+ 
+         if (y == 15) {
+           max = cb;
+           part2remain -= h->linbits+1;
+           y += getbits(h->linbits);
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+         }
+         else if(y) {
+           max = cb;
+           if(get1bit())
+             *xrpnt++ = -ispow[y] * v;
+           else
+             *xrpnt++ =  ispow[y] * v;
+           part2remain--;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/*
+      * short (count1table) values
+      */
+     for(;l3 && (part2remain > 0);l3--) {
+       struct newhuff *h = htc+gr_info->count1table_select;
+       register short *val = h->table,a;
+ 
+       while((a=*val++)<0) {
+         part2remain--;
+         if(part2remain < 0) {
+           part2remain++;
+           a = 0;
+           break;
+         }
+         if (get1bit())
+           val -= a;
+       }
+       for(i=0;i<4;i++) {
+         if(!(i & 1)) {
+           if(!mc) {
+             mc = *m++;
+             cb = *m++;
+             v = gr_info->pow2gain[((*scf++) + (*pretab++)) << shift];
+           }
+           mc--;
+         }
+         if ( (a & (0x8>>i)) ) {
+           max = cb;
+           part2remain--;
+           if(part2remain < 0) {
+             part2remain++;
+             break;
+           }
+           if(get1bit())
+             *xrpnt++ = -v;
+           else
+             *xrpnt++ = v;
+         }
+         else
+           *xrpnt++ = 0.0;
+       }
+     }
+ 
+ 	/* 
+      * zero part
+      */
+     for(i=(&xr[SBLIMIT][0]-xrpnt)>>1;i;i--) {
+       *xrpnt++ = 0.0;
+       *xrpnt++ = 0.0;
+     }
+ 
+     gr_info->maxbandl = max+1;
+     gr_info->maxb = longLimit[sfreq][gr_info->maxbandl];
+   }
+ 
+   while( part2remain > 16 ) {
+     getbits(16); /* Dismiss stuffing Bits */
+     part2remain -= 16;
+   }
+   if(part2remain > 0)
+     getbits(part2remain);
+   else if(part2remain < 0) {
+     fprintf(stderr,"mpg123: Can't rewind stream by %d bits!\n",-part2remain);
+     return 1; /* -> error */
+   }
+   return 0;
+ }
+ 
+ 
+ /* 
+  * III_stereo: calculate real channel values for Joint-I-Stereo-mode
+  */
+ static void III_i_stereo(real xr_buf[2][SBLIMIT][SSLIMIT],int *scalefac,
+    struct gr_info_s *gr_info,int sfreq,int ms_stereo,int lsf)
+ {
+       real (*xr)[SBLIMIT*SSLIMIT] = (real (*)[SBLIMIT*SSLIMIT] ) xr_buf;
+       struct bandInfoStruct *bi = &bandInfo[sfreq];
+       real *tab1,*tab2;
+ 
+       if(lsf) {
+         int p = gr_info->scalefac_compress & 0x1;
+ 	    if(ms_stereo) {
+           tab1 = pow1_2[p]; tab2 = pow2_2[p];
+         }
+         else {
+           tab1 = pow1_1[p]; tab2 = pow2_1[p];
+         }
+       }
+       else {
+         if(ms_stereo) {
+           tab1 = tan1_2; tab2 = tan2_2;
+         }
+         else {
+           tab1 = tan1_1; tab2 = tan2_1;
+         }
+       }
+ 
+       if (gr_info->block_type == 2)
+       {
+          int lwin,do_l = 0;
+          if( gr_info->mixed_block_flag )
+            do_l = 1;
+ 
+          for (lwin=0;lwin<3;lwin++) /* process each window */
+          {
+              /* get first band with zero values */
+            int is_p,sb,idx,sfb = gr_info->maxband[lwin];  /* sfb is minimal 3 for mixed mode */
+            if(sfb > 3)
+              do_l = 0;
+ 
+            for(;sfb<12;sfb++)
+            {
+              is_p = scalefac[sfb*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */ 
+              if(is_p != 7) {
+                real t1,t2;
+                sb = bi->shortDiff[sfb];
+                idx = bi->shortIdx[sfb] + lwin;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for (; sb > 0; sb--,idx+=3)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+            }
+ 
+ #if 1
+ /* in the original: copy 10 to 11 , here: copy 11 to 12 
+ maybe still wrong??? (copy 12 to 13?) */
+            is_p = scalefac[11*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[12];
+            idx = bi->shortIdx[12] + lwin;
+ #else
+            is_p = scalefac[10*3+lwin-gr_info->mixed_block_flag]; /* scale: 0-15 */
+            sb = bi->shortDiff[11];
+            idx = bi->shortIdx[11] + lwin;
+ #endif
+            if(is_p != 7)
+            {
+              real t1,t2;
+              t1 = tab1[is_p]; t2 = tab2[is_p];
+              for ( ; sb > 0; sb--,idx+=3 )
+              {  
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+              }
+            }
+          } /* end for(lwin; .. ; . ) */
+ 
+          if (do_l)
+          {
+ /* also check l-part, if ALL bands in the three windows are 'empty'
+  * and mode = mixed_mode 
+  */
+            int sfb = gr_info->maxbandl;
+            int idx = bi->longIdx[sfb];
+ 
+            for ( ; sfb<8; sfb++ )
+            {
+              int sb = bi->longDiff[sfb];
+              int is_p = scalefac[sfb]; /* scale: 0-15 */
+              if(is_p != 7) {
+                real t1,t2;
+                t1 = tab1[is_p]; t2 = tab2[is_p];
+                for ( ; sb > 0; sb--,idx++)
+                {
+                  real v = xr[0][idx];
+                  xr[0][idx] = v * t1;
+                  xr[1][idx] = v * t2;
+                }
+              }
+              else 
+                idx += sb;
+            }
+          }     
+       } 
+       else /* ((gr_info->block_type != 2)) */
+       {
+         int sfb = gr_info->maxbandl;
+         int is_p,idx = bi->longIdx[sfb];
+         for ( ; sfb<21; sfb++)
+         {
+           int sb = bi->longDiff[sfb];
+           is_p = scalefac[sfb]; /* scale: 0-15 */
+           if(is_p != 7) {
+             real t1,t2;
+             t1 = tab1[is_p]; t2 = tab2[is_p];
+             for ( ; sb > 0; sb--,idx++)
+             {
+                real v = xr[0][idx];
+                xr[0][idx] = v * t1;
+                xr[1][idx] = v * t2;
+             }
+           }
+           else
+             idx += sb;
+         }
+ 
+         is_p = scalefac[20]; /* copy l-band 20 to l-band 21 */
+         if(is_p != 7)
+         {
+           int sb;
+           real t1 = tab1[is_p],t2 = tab2[is_p]; 
+ 
+           for ( sb = bi->longDiff[21]; sb > 0; sb--,idx++ )
+           {
+             real v = xr[0][idx];
+             xr[0][idx] = v * t1;
+             xr[1][idx] = v * t2;
+           }
+         }
+       } /* ... */
+ }
+ 
+ static void III_antialias(real xr[SBLIMIT][SSLIMIT],struct gr_info_s *gr_info)
+ {
+    int sblim;
+ 
+    if(gr_info->block_type == 2)
+    {
+       if(!gr_info->mixed_block_flag) 
+         return;
+       sblim = 1; 
+    }
+    else {
+      sblim = gr_info->maxb-1;
+    }
+ 
+    /* 31 alias-reduction operations between each pair of sub-bands */
+    /* with 8 butterflies between each pair                         */
+ 
+    {
+      int sb;
+      real *xr1=(real *) xr[1];
+ 
+      for(sb=sblim;sb;sb--,xr1+=10)
+      {
+        int ss;
+        real *cs=aa_cs,*ca=aa_ca;
+        real *xr2 = xr1;
+ 
+        for(ss=7;ss>=0;ss--)
+        {       /* upper and lower butterfly inputs */
+          register real bu = *--xr2,bd = *xr1;
+          *xr2   = (bu * (*cs)   ) - (bd * (*ca)   );
+          *xr1++ = (bd * (*cs++) ) + (bu * (*ca++) );
+        }
+      }
+   }
+ }
+ 
+ /*
+  DCT insipired by Jeff Tsay's DCT from the maplay package
+  this is an optimized version with manual unroll.
+ 
+  References:
+  [1] S. Winograd: "On Computing the Discrete Fourier Transform",
+      Mathematics of Computation, Volume 32, Number 141, January 1978,
+      Pages 175-199
+ */
+ 
+ static void dct36(real *inbuf,real *o1,real *o2,real *wintab,real *tsbuf)
+ {
+   {
+     register real *in = inbuf;
+ 
+     in[17]+=in[16]; in[16]+=in[15]; in[15]+=in[14];
+     in[14]+=in[13]; in[13]+=in[12]; in[12]+=in[11];
+     in[11]+=in[10]; in[10]+=in[9];  in[9] +=in[8];
+     in[8] +=in[7];  in[7] +=in[6];  in[6] +=in[5];
+     in[5] +=in[4];  in[4] +=in[3];  in[3] +=in[2];
+     in[2] +=in[1];  in[1] +=in[0];
+ 
+     in[17]+=in[15]; in[15]+=in[13]; in[13]+=in[11]; in[11]+=in[9];
+     in[9] +=in[7];  in[7] +=in[5];  in[5] +=in[3];  in[3] +=in[1];
+ 
+ 
+   {
+ 
+ #define MACRO0(v) { \
+     real tmp; \
+     out2[9+(v)] = (tmp = sum0 + sum1) * w[27+(v)]; \
+     out2[8-(v)] = tmp * w[26-(v)];  } \
+     sum0 -= sum1; \
+     ts[SBLIMIT*(8-(v))] = out1[8-(v)] + sum0 * w[8-(v)]; \
+     ts[SBLIMIT*(9+(v))] = out1[9+(v)] + sum0 * w[9+(v)]; 
+ #define MACRO1(v) { \
+ 	real sum0,sum1; \
+     sum0 = tmp1a + tmp2a; \
+ 	sum1 = (tmp1b + tmp2b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ #define MACRO2(v) { \
+     real sum0,sum1; \
+     sum0 = tmp2a - tmp1a; \
+     sum1 = (tmp2b - tmp1b) * tfcos36[(v)]; \
+ 	MACRO0(v); }
+ 
+     register const real *c = COS9;
+     register real *out2 = o2;
+ 	register real *w = wintab;
+ 	register real *out1 = o1;
+ 	register real *ts = tsbuf;
+ 
+     real ta33,ta66,tb33,tb66;
+ 
+     ta33 = in[2*3+0] * c[3];
+     ta66 = in[2*6+0] * c[6];
+     tb33 = in[2*3+1] * c[3];
+     tb66 = in[2*6+1] * c[6];
+ 
+     { 
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[1] + ta33 + in[2*5+0] * c[5] + in[2*7+0] * c[7];
+       tmp1b =             in[2*1+1] * c[1] + tb33 + in[2*5+1] * c[5] + in[2*7+1] * c[7];
+       tmp2a = in[2*0+0] + in[2*2+0] * c[2] + in[2*4+0] * c[4] + ta66 + in[2*8+0] * c[8];
+       tmp2b = in[2*0+1] + in[2*2+1] * c[2] + in[2*4+1] * c[4] + tb66 + in[2*8+1] * c[8];
+ 
+       MACRO1(0);
+       MACRO2(8);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a = ( in[2*1+0] - in[2*5+0] - in[2*7+0] ) * c[3];
+       tmp1b = ( in[2*1+1] - in[2*5+1] - in[2*7+1] ) * c[3];
+       tmp2a = ( in[2*2+0] - in[2*4+0] - in[2*8+0] ) * c[6] - in[2*6+0] + in[2*0+0];
+       tmp2b = ( in[2*2+1] - in[2*4+1] - in[2*8+1] ) * c[6] - in[2*6+1] + in[2*0+1];
+ 
+       MACRO1(1);
+       MACRO2(7);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[5] - ta33 - in[2*5+0] * c[7] + in[2*7+0] * c[1];
+       tmp1b =             in[2*1+1] * c[5] - tb33 - in[2*5+1] * c[7] + in[2*7+1] * c[1];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[8] - in[2*4+0] * c[2] + ta66 + in[2*8+0] * c[4];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[8] - in[2*4+1] * c[2] + tb66 + in[2*8+1] * c[4];
+ 
+       MACRO1(2);
+       MACRO2(6);
+     }
+ 
+     {
+       real tmp1a,tmp2a,tmp1b,tmp2b;
+       tmp1a =             in[2*1+0] * c[7] - ta33 + in[2*5+0] * c[1] - in[2*7+0] * c[5];
+       tmp1b =             in[2*1+1] * c[7] - tb33 + in[2*5+1] * c[1] - in[2*7+1] * c[5];
+       tmp2a = in[2*0+0] - in[2*2+0] * c[4] + in[2*4+0] * c[8] + ta66 - in[2*8+0] * c[2];
+       tmp2b = in[2*0+1] - in[2*2+1] * c[4] + in[2*4+1] * c[8] + tb66 - in[2*8+1] * c[2];
+ 
+       MACRO1(3);
+       MACRO2(5);
+     }
+ 
+ 	{
+ 		real sum0,sum1;
+     	sum0 =  in[2*0+0] - in[2*2+0] + in[2*4+0] - in[2*6+0] + in[2*8+0];
+     	sum1 = (in[2*0+1] - in[2*2+1] + in[2*4+1] - in[2*6+1] + in[2*8+1] ) * tfcos36[4];
+ 		MACRO0(4);
+ 	}
+   }
+ 
+   }
+ }
+ 
+ /*
+  * new DCT12
+  */
+ static void dct12(real *in,real *rawout1,real *rawout2,register real *wi,register real *ts)
+ {
+ #define DCT12_PART1 \
+              in5 = in[5*3];  \
+      in5 += (in4 = in[4*3]); \
+      in4 += (in3 = in[3*3]); \
+      in3 += (in2 = in[2*3]); \
+      in2 += (in1 = in[1*3]); \
+      in1 += (in0 = in[0*3]); \
+                              \
+      in5 += in3; in3 += in1; \
+                              \
+      in2 *= COS6_1; \
+      in3 *= COS6_1; \
+ 
+ #define DCT12_PART2 \
+      in0 += in4 * COS6_2; \
+                           \
+      in4 = in0 + in2;     \
+      in0 -= in2;          \
+                           \
+      in1 += in5 * COS6_2; \
+                           \
+      in5 = (in1 + in3) * tfcos12[0]; \
+      in1 = (in1 - in3) * tfcos12[2]; \
+                          \
+      in3 = in4 + in5;    \
+      in4 -= in5;         \
+                          \
+      in2 = in0 + in1;    \
+      in0 -= in1;
+ 
+ 
+    {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out1 = rawout1;
+      ts[SBLIMIT*0] = out1[0]; ts[SBLIMIT*1] = out1[1]; ts[SBLIMIT*2] = out1[2];
+      ts[SBLIMIT*3] = out1[3]; ts[SBLIMIT*4] = out1[4]; ts[SBLIMIT*5] = out1[5];
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        ts[(17-1)*SBLIMIT] = out1[17-1] + tmp0 * wi[11-1];
+        ts[(12+1)*SBLIMIT] = out1[12+1] + tmp0 * wi[6+1];
+        ts[(6 +1)*SBLIMIT] = out1[6 +1] + tmp1 * wi[1];
+        ts[(11-1)*SBLIMIT] = out1[11-1] + tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      ts[(17-0)*SBLIMIT] = out1[17-0] + in2 * wi[11-0];
+      ts[(12+0)*SBLIMIT] = out1[12+0] + in2 * wi[6+0];
+      ts[(12+2)*SBLIMIT] = out1[12+2] + in3 * wi[6+2];
+      ts[(17-2)*SBLIMIT] = out1[17-2] + in3 * wi[11-2];
+ 
+      ts[(6+0)*SBLIMIT]  = out1[6+0] + in0 * wi[0];
+      ts[(11-0)*SBLIMIT] = out1[11-0] + in0 * wi[5-0];
+      ts[(6+2)*SBLIMIT]  = out1[6+2] + in4 * wi[2];
+      ts[(11-2)*SBLIMIT] = out1[11-2] + in4 * wi[5-2];
+   }
+ 
+   in++;
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+  
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[5-1] = tmp0 * wi[11-1];
+        out2[0+1] = tmp0 * wi[6+1];
+        ts[(12+1)*SBLIMIT] += tmp1 * wi[1];
+        ts[(17-1)*SBLIMIT] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[5-0] = in2 * wi[11-0];
+      out2[0+0] = in2 * wi[6+0];
+      out2[0+2] = in3 * wi[6+2];
+      out2[5-2] = in3 * wi[11-2];
+ 
+      ts[(12+0)*SBLIMIT] += in0 * wi[0];
+      ts[(17-0)*SBLIMIT] += in0 * wi[5-0];
+      ts[(12+2)*SBLIMIT] += in4 * wi[2];
+      ts[(17-2)*SBLIMIT] += in4 * wi[5-2];
+   }
+ 
+   in++; 
+ 
+   {
+      real in0,in1,in2,in3,in4,in5;
+      register real *out2 = rawout2;
+      out2[12]=out2[13]=out2[14]=out2[15]=out2[16]=out2[17]=0.0;
+ 
+      DCT12_PART1
+ 
+      {
+        real tmp0,tmp1 = (in0 - in4);
+        {
+          real tmp2 = (in1 - in5) * tfcos12[1];
+          tmp0 = tmp1 + tmp2;
+          tmp1 -= tmp2;
+        }
+        out2[11-1] = tmp0 * wi[11-1];
+        out2[6 +1] = tmp0 * wi[6+1];
+        out2[0+1] += tmp1 * wi[1];
+        out2[5-1] += tmp1 * wi[5-1];
+      }
+ 
+      DCT12_PART2
+ 
+      out2[11-0] = in2 * wi[11-0];
+      out2[6 +0] = in2 * wi[6+0];
+      out2[6 +2] = in3 * wi[6+2];
+      out2[11-2] = in3 * wi[11-2];
+ 
+      out2[0+0] += in0 * wi[0];
+      out2[5-0] += in0 * wi[5-0];
+      out2[0+2] += in4 * wi[2];
+      out2[5-2] += in4 * wi[5-2];
+   }
+ }
+ 
+ /*
+  * III_hybrid
+  */
+ static void III_hybrid(real fsIn[SBLIMIT][SSLIMIT],real tsOut[SSLIMIT][SBLIMIT],
+    int ch,struct gr_info_s *gr_info)
+ {
+    real *tspnt = (real *) tsOut;
+    real (*block)[2][SBLIMIT*SSLIMIT] = gmp->hybrid_block;
+    int *blc = gmp->hybrid_blc;
+    real *rawout1,*rawout2;
+    int bt;
+    int sb = 0;
+ 
+    {
+      int b = blc[ch];
+      rawout1=block[b][ch];
+      b=-b+1;
+      rawout2=block[b][ch];
+      blc[ch] = b;
+    }
+ 
+   
+    if(gr_info->mixed_block_flag) {
+      sb = 2;
+      dct36(fsIn[0],rawout1,rawout2,win[0],tspnt);
+      dct36(fsIn[1],rawout1+18,rawout2+18,win1[0],tspnt+1);
+      rawout1 += 36; rawout2 += 36; tspnt += 2;
+    }
+  
+    bt = gr_info->block_type;
+    if(bt == 2) {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct12(fsIn[sb],rawout1,rawout2,win[2],tspnt);
+        dct12(fsIn[sb+1],rawout1+18,rawout2+18,win1[2],tspnt+1);
+      }
+    }
+    else {
+      for (; sb<gr_info->maxb; sb+=2,tspnt+=2,rawout1+=36,rawout2+=36) {
+        dct36(fsIn[sb],rawout1,rawout2,win[bt],tspnt);
+        dct36(fsIn[sb+1],rawout1+18,rawout2+18,win1[bt],tspnt+1);
+      }
+    }
+ 
+    for(;sb<SBLIMIT;sb++,tspnt++) {
+      int i;
+      for(i=0;i<SSLIMIT;i++) {
+        tspnt[i*SBLIMIT] = *rawout1++;
+        *rawout2++ = 0.0;
+      }
+    }
+ }
+ 
+ /*
+  * main layer3 handler
+  */
+ int do_layer3(struct frame *fr,unsigned char *pcm_sample,int *pcm_point)
+ {
+   int gr, ch, ss,clip=0;
+   int scalefacs[39]; /* max 39 for short[13][3] mode, mixed: 38, long: 22 */
+   struct III_sideinfo sideinfo;
+   int stereo = fr->stereo;
+   int single = fr->single;
+   int ms_stereo,i_stereo;
+   int sfreq = fr->sampling_frequency;
+   int stereo1,granules;
+ 
+ 
+ 
+   if(stereo == 1) { /* stream is mono */
+     stereo1 = 1;
+     single = 0;
+   }
+   else if(single >= 0) /* stream is stereo, but force to mono */
+     stereo1 = 1;
+   else
+     stereo1 = 2;
+ 
+   if(fr->mode == MPG_MD_JOINT_STEREO) {
+     ms_stereo = fr->mode_ext & 0x2;
+     i_stereo  = fr->mode_ext & 0x1;
+   }
+   else
+     ms_stereo = i_stereo = 0;
+ 
+ 
+   if(fr->lsf) {
+     granules = 1;
+     III_get_side_info_2(&sideinfo,stereo,ms_stereo,sfreq,single);
+   }
+   else {
+     granules = 2;
+ #ifdef MPEG1
+     III_get_side_info_1(&sideinfo,stereo,ms_stereo,sfreq,single);
+ #else
+     fprintf(stderr,"Not supported\n");
+ #endif
+   }
+ 
+   if(set_pointer(sideinfo.main_data_begin) == MP3_ERR)
+     return 0; 
+ 
+ 
+   for (gr=0;gr<granules;gr++) 
+   {
+     static real hybridIn[2][SBLIMIT][SSLIMIT];
+     static real hybridOut[2][SSLIMIT][SBLIMIT];
+ 
+     {
+       struct gr_info_s *gr_info = &(sideinfo.ch[0].gr[gr]);
+       long part2bits;
+       if(fr->lsf)
+         part2bits = III_get_scale_factors_2(scalefacs,gr_info,0);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs,gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+       if(III_dequantize_sample(hybridIn[0], scalefacs,gr_info,sfreq,part2bits))
+         return clip;
+     }
+     if(stereo == 2) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[1].gr[gr]);
+       long part2bits;
+       if(fr->lsf) 
+         part2bits = III_get_scale_factors_2(scalefacs,gr_info,i_stereo);
+       else {
+ #ifdef MPEG1
+         part2bits = III_get_scale_factors_1(scalefacs,gr_info);
+ #else
+ 	fprintf(stderr,"Not supported\n");
+ #endif
+       }
+ 
+       if(III_dequantize_sample(hybridIn[1],scalefacs,gr_info,sfreq,part2bits))
+           return clip;
+ 
+       if(ms_stereo) {
+         int i;
+         for(i=0;i<SBLIMIT*SSLIMIT;i++) {
+           real tmp0,tmp1;
+           tmp0 = ((real *) hybridIn[0])[i];
+           tmp1 = ((real *) hybridIn[1])[i];
+           ((real *) hybridIn[1])[i] = tmp0 - tmp1;  
+           ((real *) hybridIn[0])[i] = tmp0 + tmp1;
+         }
+       }
+ 
+       if(i_stereo)
+         III_i_stereo(hybridIn,scalefacs,gr_info,sfreq,ms_stereo,fr->lsf);
+ 
+       if(ms_stereo || i_stereo || (single == 3) ) {
+         if(gr_info->maxb > sideinfo.ch[0].gr[gr].maxb) 
+           sideinfo.ch[0].gr[gr].maxb = gr_info->maxb;
+         else
+           gr_info->maxb = sideinfo.ch[0].gr[gr].maxb;
+       }
+ 
+       switch(single) {
+         case 3:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++,in0++)
+               *in0 = (*in0 + *in1++); /* *0.5 done by pow-scale */ 
+           }
+           break;
+         case 1:
+           {
+             register int i;
+             register real *in0 = (real *) hybridIn[0],*in1 = (real *) hybridIn[1];
+             for(i=0;i<SSLIMIT*gr_info->maxb;i++)
+               *in0++ = *in1++;
+           }
+           break;
+       }
+     }
+ 
+ #ifdef HAVEGTK
+     if (gtkflag) {
+     extern int tabsel_123[2][3][16];
+     int sb;
+     
+     pinfo->bitrate = 
+       tabsel_123[fr->lsf][fr->lay-1][fr->bitrate_index];
+     pinfo->sampfreq = freqs[sfreq];
+     pinfo->emph = fr->emphasis;
+     pinfo->stereo = fr->stereo;
+     pinfo->js =   (fr->mode == MPG_MD_JOINT_STEREO);
+     pinfo->ms_stereo = ms_stereo;
+     pinfo->i_stereo = i_stereo;
+     pinfo->maindata = sideinfo.main_data_begin;
+     
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       pinfo->mixed[gr][ch] = gr_info->mixed_block_flag;
+       pinfo->mpg123blocktype[gr][ch]=gr_info->block_type;
+       pinfo->mainbits[gr][ch] = gr_info->part2_3_length;
+       pinfo->scfsi = gr_info->scfsi;
+     }
+     for(ch=0;ch<stereo1;ch++) { 
+       int j=0;
+       for (sb=0;sb<SBLIMIT;sb++)
+ 	for(ss=0;ss<SSLIMIT;ss++,j++) 
+ 	  pinfo->mpg123xr[gr][ch][j]=hybridIn[ch][sb][ss];
+     }
+   }
+ 
+ #endif
+ 
+     for(ch=0;ch<stereo1;ch++) {
+       struct gr_info_s *gr_info = &(sideinfo.ch[ch].gr[gr]);
+       III_antialias(hybridIn[ch],gr_info);
+       III_hybrid(hybridIn[ch], hybridOut[ch], ch,gr_info);
+     }
+ 
+     for(ss=0;ss<SSLIMIT;ss++) {
+       if(single >= 0) {
+         clip += synth_1to1_mono(hybridOut[0][ss],pcm_sample,pcm_point);
+       }
+       else {
+         int p1 = *pcm_point;
+         clip += synth_1to1(hybridOut[0][ss],0,pcm_sample,&p1);
+         clip += synth_1to1(hybridOut[1][ss],1,pcm_sample,pcm_point);
+       }
+     }
+   }
+   
+   return clip;
+ }
+ 
+ 
+ 
diff -r -c -N encoder/mpglib/main.c lame3.50/mpglib/main.c
*** encoder/mpglib/main.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/main.c	Mon Oct 25 12:24:07 1999
***************
*** 0 ****
--- 1,178 ----
+ #include "mpg123.h"
+ #include "mpglib.h"
+ 
+ #ifdef OS_AMIGAOS
+ #include "/lame.h"
+ #else
+ #include "../lame.h"
+ #endif /* OS_AMIGAOS */
+ 
+ #include <stdlib.h>
+ 
+ static char buf[16384];
+ #define FSIZE 8192  
+ static char out[FSIZE];
+ struct mpstr mp;
+ 
+ #if 0
+ void main(void)
+ {
+ 	int size;
+ 	char out[8192];
+ 	int len,ret;
+ 	
+ 
+ 	InitMP3(&mp);
+ 
+ 	while(1) {
+ 		len = read(0,buf,16384);
+ 		if(len <= 0)
+ 			break;
+ 		ret = decodeMP3(&mp,buf,len,out,8192,&size);
+ 		while(ret == MP3_OK) {
+ 			write(1,out,size);
+ 			ret = decodeMP3(&mp,NULL,0,out,8192,&size);
+ 		}
+ 	}
+ 
+ }
+ #endif
+ 
+ int is_syncword(char *header)
+ {
+ 
+ /*
+ unsigned int s0,s1;
+ s0 = (unsigned char) header[0];
+ s1 = (unsigned char) header[1] ;
+ printf(" syncword:  %2X   %2X   \n ",s0, s1);
+ */
+ 
+ /*
+ printf(" integer  %i \n",(int) ( header[0] == (char) 0xFF));
+ printf(" integer  %i \n",(int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ */
+ 
+ return 
+ ((int) ( header[0] == (char) 0xFF)) &&
+ ((int) ( (header[1] & (char) 0xF0) == (char) 0xF0));
+ 
+ 
+ }
+ 
+ 
+ int lame_decode_initfile(FILE *fd, int *stereo, int *samp, int *bitrate)
+ {
+   extern int tabsel_123[2][3][16];
+   int ret,size;
+   size_t len;
+   InitMP3(&mp);
+   memset(buf, 0, sizeof(buf));
+   
+   /* skip RIFF type proprietary headers  */
+   /* look for sync word  FFF */
+   while (!is_syncword(buf)) {
+     buf[0]=buf[1]; 
+     //    if (read(fd,&buf[1],1) <= 0) return -1;  /* failed */
+     if (fread(&buf[1],1,1,fd) <= 0) return -1;  /* failed */
+   }
+   ret = decodeMP3(&mp,buf,2,out,FSIZE,&size);
+ 
+   /* read the header */
+   //len = read(fd,buf,8); 
+   len = fread(buf,1,8,fd);
+   if (len <=0 ) return -1;
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+ 
+   *stereo = mp.fr.stereo;
+   *samp = freqs[mp.fr.sampling_frequency];
+   *bitrate = tabsel_123[mp.fr.lsf][mp.fr.lay-1][mp.fr.bitrate_index];
+ 
+ 
+   /*
+   printf("ret = %i NEED_MORE=%i \n",ret,MP3_NEED_MORE);
+   printf("stereo = %i \n",mp.fr.stereo);
+   printf("samp = %i  \n",(int)freqs[mp.fr.sampling_frequency]);
+   */
+ 
+   return 0;
+ }
+ 
+ 
+ 
+ int lame_decode_fromfile(FILE *fd, short pcm[][1152])
+ {
+   int size,stereo;
+   int outsize=0,j,i,ret;
+   size_t len;
+ 
+   size=0;
+   //len = read(fd,buf,64); 
+   len = fread(buf,1,64,fd);
+   if (len <=0 ) return 0;
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+ 
+   /* read more until we get a valid output frame */
+   while((ret == MP3_NEED_MORE) || !size) {
+     //    len = read(fd,buf,100);  
+     len = fread(buf,1,100,fd);
+     if (len <=0 ) return 0;
+     ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+     /* if (ret ==MP3_ERR) return 0;  lets ignore errors and keep reading... */
+     /*
+     printf("ret = %i size= %i  %i   %i  %i \n",ret,size,
+ 	   MP3_NEED_MORE,MP3_ERR,MP3_OK); 
+     */
+   }
+ 
+   stereo=mp.fr.stereo;
+ 
+   if (ret == MP3_OK) 
+   {
+     /*    write(1,out,size); */
+     outsize = size/(2*(stereo));
+     if ((outsize!=576) && (outsize!=1152)) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  Cant handle this... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	pcm[j][i] = ((short *) out)[stereo*i+j];
+   }
+   return outsize;
+ }
+ 
+ 
+ int lame_decode_init(void)
+ {
+   InitMP3(&mp);
+   memset(buf, 0, sizeof(buf));
+   return 0;
+ }
+ 
+ 
+ int lame_decode(char *buf,int len,short pcm[][1152])
+ {
+   int size;
+   int outsize=0,j,i,ret;
+ 
+   ret = decodeMP3(&mp,buf,len,out,FSIZE,&size);
+   if (ret==MP3_OK) {
+     /*    printf("mpg123 output one frame out=%i \n",size/4);  */
+     outsize = size/(2*mp.fr.stereo);
+     if (outsize > 1152) {
+       fprintf(stderr,"Opps: mpg123 returned more than one frame!  shouldn't happen... \n");
+       exit(-50);
+     }
+ 
+     for (j=0; j<mp.fr.stereo; j++)
+       for (i=0; i<outsize; i++) 
+ 	pcm[j][i] = ((short *) out)[mp.fr.stereo*i+j];
+   }
+   return outsize;
+ }
+ 
+ 
+ 
+ 
diff -r -c -N encoder/mpglib/mpg123.h lame3.50/mpglib/mpg123.h
*** encoder/mpglib/mpg123.h	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/mpg123.h	Tue Oct 12 10:45:52 1999
***************
*** 0 ****
--- 1,179 ----
+ #include        <stdio.h>
+ #include        <string.h>
+ #include        <signal.h>
+ 
+ 
+ #include        <math.h>
+ 
+ #ifdef _MSC_VER
+ 
+ # define M_PI       3.14159265358979323846
+ # define M_SQRT2	1.41421356237309504880
+ # define REAL_IS_FLOAT
+ # define NEW_DCT9
+ 
+ # define random rand
+ # define srandom srand
+ 
+ #endif
+ #ifdef __EMX__
+ #define M_PI       3.14159265358979323846
+ #define M_SQRT2    1.41421356237309504880
+ #endif
+ 
+ 
+ #ifdef REAL_IS_FLOAT
+ #  define real float
+ #elif defined(REAL_IS_LONG_DOUBLE)
+ #  define real long double
+ #else
+ #  define real double
+ #endif
+ 
+ #ifdef __GNUC__
+ #define INLINE inline
+ #else
+ #define INLINE
+ #endif
+ 
+ /* AUDIOBUFSIZE = n*64 with n=1,2,3 ...  */
+ #define		AUDIOBUFSIZE		16384
+ 
+ #define         FALSE                   0
+ #define         TRUE                    1
+ 
+ #define         SBLIMIT                 32
+ #define         SSLIMIT                 18
+ 
+ #define         MPG_MD_STEREO           0
+ #define         MPG_MD_JOINT_STEREO     1
+ #define         MPG_MD_DUAL_CHANNEL     2
+ #define         MPG_MD_MONO             3
+ 
+ #define MAXFRAMESIZE 1792
+ 
+ 
+ /* Pre Shift fo 16 to 8 bit converter table */
+ #define AUSHIFT (3)
+ 
+ struct frame {
+     int stereo;
+     int jsbound;
+     int single;
+     int lsf;
+     int mpeg25;
+     int header_change;
+     int lay;
+     int error_protection;
+     int bitrate_index;
+     int sampling_frequency;
+     int padding;
+     int extension;
+     int mode;
+     int mode_ext;
+     int copyright;
+     int original;
+     int emphasis;
+     int framesize; /* computed framesize */
+ };
+ 
+ struct parameter {
+ 	int quiet;	/* shut up! */
+ 	int tryresync;  /* resync stream after error */
+ 	int verbose;    /* verbose level */
+ 	int checkrange;
+ };
+ 
+ /* extern unsigned int   get1bit(void); */
+ extern unsigned int   getbits(int);
+ extern unsigned int   getbits_fast(int);
+ extern int set_pointer(long);
+ 
+ extern unsigned char *wordpointer;
+ extern int bitindex;
+ 
+ extern void make_decode_tables(long scaleval);
+ extern int do_layer3(struct frame *fr,unsigned char *,int *);
+ extern int decode_header(struct frame *fr,unsigned long newhead);
+ 
+ 
+ 
+ struct gr_info_s {
+       int scfsi;
+       unsigned part2_3_length;
+       unsigned big_values;
+       unsigned scalefac_compress;
+       unsigned block_type;
+       unsigned mixed_block_flag;
+       unsigned table_select[3];
+       unsigned subblock_gain[3];
+       unsigned maxband[3];
+       unsigned maxbandl;
+       unsigned maxb;
+       unsigned region1start;
+       unsigned region2start;
+       unsigned preflag;
+       unsigned scalefac_scale;
+       unsigned count1table_select;
+       real *full_gain[3];
+       real *pow2gain;
+ };
+ 
+ struct III_sideinfo
+ {
+   unsigned main_data_begin;
+   unsigned private_bits;
+   struct {
+     struct gr_info_s gr[2];
+   } ch[2];
+ };
+ 
+ extern int synth_1to1 (real *,int,unsigned char *,int *);
+ extern int synth_1to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_1to1_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_1to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_2to1 (real *,int,unsigned char *,int *);
+ extern int synth_2to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_2to1_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_2to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_4to1 (real *,int,unsigned char *,int *);
+ extern int synth_4to1_8bit (real *,int,unsigned char *,int *);
+ extern int synth_4to1_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_4to1_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern int synth_ntom (real *,int,unsigned char *,int *);
+ extern int synth_ntom_8bit (real *,int,unsigned char *,int *);
+ extern int synth_ntom_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_mono2stereo (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono (real *,unsigned char *,int *);
+ extern int synth_ntom_8bit_mono2stereo (real *,unsigned char *,int *);
+ 
+ extern void rewindNbits(int bits);
+ extern int  hsstell(void);
+ extern int get_songlen(struct frame *fr,int no);
+ 
+ extern void init_layer3(int);
+ extern void init_layer2(void);
+ extern void make_decode_tables(long scale);
+ extern void make_conv16to8_table(int);
+ extern void dct64(real *,real *,real *);
+ 
+ extern void synth_ntom_set_step(long,long);
+ 
+ extern unsigned char *conv16to8;
+ extern long freqs[9];
+ extern real muls[27][64];
+ extern real decwin[512+32];
+ extern real *pnts[5];
+ 
+ extern struct parameter param;
+ 
+ 
diff -r -c -N encoder/mpglib/mpglib.dsp lame3.50/mpglib/mpglib.dsp
*** encoder/mpglib/mpglib.dsp	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/mpglib.dsp	Sun Oct 24 21:49:54 1999
***************
*** 0 ****
--- 1,164 ----
+ # Microsoft Developer Studio Project File - Name="mpglib" - Package Owner=<4>
+ # Microsoft Developer Studio Generated Build File, Format Version 5.00
+ # ** DO NOT EDIT **
+ 
+ # TARGTYPE "Win32 (x86) Static Library" 0x0104
+ 
+ CFG=mpglib - Win32 Debug GTK
+ !MESSAGE This is not a valid makefile. To build this project using NMAKE,
+ !MESSAGE use the Export Makefile command and run
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak".
+ !MESSAGE 
+ !MESSAGE You can specify a configuration when running NMAKE
+ !MESSAGE by defining the macro CFG on the command line. For example:
+ !MESSAGE 
+ !MESSAGE NMAKE /f "mpglib.mak" CFG="mpglib - Win32 Debug GTK"
+ !MESSAGE 
+ !MESSAGE Possible choices for configuration are:
+ !MESSAGE 
+ !MESSAGE "mpglib - Win32 Release" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Debug" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Debug GTK" (based on "Win32 (x86) Static Library")
+ !MESSAGE "mpglib - Win32 Release GTK" (based on "Win32 (x86) Static Library")
+ !MESSAGE 
+ 
+ # Begin Project
+ # PROP Scc_ProjName ""
+ # PROP Scc_LocalPath ""
+ CPP=xicl.exe
+ 
+ !IF  "$(CFG)" == "mpglib - Win32 Release"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "Release"
+ # PROP BASE Intermediate_Dir "Release"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "ReleaseGTK"
+ # PROP Intermediate_Dir "ReleaseGTK"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Debug"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "Debug"
+ # PROP BASE Intermediate_Dir "Debug"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "DebugGTK"
+ # PROP Intermediate_Dir "DebugGTK"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Debug GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 1
+ # PROP BASE Output_Dir "mpglib__"
+ # PROP BASE Intermediate_Dir "mpglib__"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 1
+ # PROP Output_Dir "mpglib__"
+ # PROP Intermediate_Dir "mpglib__"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /Z7 /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "HAVEGTK" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ELSEIF  "$(CFG)" == "mpglib - Win32 Release GTK"
+ 
+ # PROP BASE Use_MFC 0
+ # PROP BASE Use_Debug_Libraries 0
+ # PROP BASE Output_Dir "mpglib_0"
+ # PROP BASE Intermediate_Dir "mpglib_0"
+ # PROP BASE Target_Dir ""
+ # PROP Use_MFC 0
+ # PROP Use_Debug_Libraries 0
+ # PROP Output_Dir "mpglib_0"
+ # PROP Intermediate_Dir "mpglib_0"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /YX /FD /c
+ # ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "HAVEGTK" /YX /FD /c
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LIB32=link.exe -lib
+ # ADD BASE LIB32 /nologo
+ # ADD LIB32 /nologo
+ 
+ !ENDIF 
+ 
+ # Begin Target
+ 
+ # Name "mpglib - Win32 Release"
+ # Name "mpglib - Win32 Debug"
+ # Name "mpglib - Win32 Debug GTK"
+ # Name "mpglib - Win32 Release GTK"
+ # Begin Source File
+ 
+ SOURCE=.\common.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\dct64_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\decode_i386.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\huffman.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\interface.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\layer3.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\main.c
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpg123.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\mpglib.h
+ # End Source File
+ # Begin Source File
+ 
+ SOURCE=.\tabinit.c
+ # End Source File
+ # End Target
+ # End Project
diff -r -c -N encoder/mpglib/mpglib.h lame3.50/mpglib/mpglib.h
*** encoder/mpglib/mpglib.h	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/mpglib.h	Fri Sep 10 09:51:57 1999
***************
*** 0 ****
--- 1,44 ----
+ 
+ struct buf {
+         unsigned char *pnt;
+ 	long size;
+ 	long pos;
+         struct buf *next;
+         struct buf *prev;
+ };
+ 
+ struct framebuf {
+ 	struct buf *buf;
+ 	long pos;
+ 	struct frame *next;
+ 	struct frame *prev;
+ };
+ 
+ struct mpstr {
+ 	struct buf *head,*tail;
+ 	int bsize;
+ 	int framesize;
+         int fsizeold;
+ 	struct frame fr;
+         unsigned char bsspace[2][MAXFRAMESIZE+512]; /* MAXFRAMESIZE */
+ 	real hybrid_block[2][2][SBLIMIT*SSLIMIT];
+ 	int hybrid_blc[2];
+ 	unsigned long header;
+ 	int bsnum;
+ 	real synth_buffs[2][2][0x110];
+         int  synth_bo;
+ 	
+ };
+ 
+ #define BOOL int
+ 
+ #define MP3_ERR -1
+ #define MP3_OK  0
+ #define MP3_NEED_MORE 1
+ 
+ 
+ BOOL InitMP3(struct mpstr *mp);
+ int decodeMP3(struct mpstr *mp,char *inmemory,int inmemsize,
+      char *outmemory,int outmemsize,int *done);
+ void ExitMP3(struct mpstr *mp);
+ 
diff -r -c -N encoder/mpglib/tabinit.c lame3.50/mpglib/tabinit.c
*** encoder/mpglib/tabinit.c	Wed Dec 31 17:00:00 1969
--- lame3.50/mpglib/tabinit.c	Thu Sep 16 00:12:46 1999
***************
*** 0 ****
--- 1,80 ----
+ #include <stdlib.h>
+ 
+ #include "mpg123.h"
+ 
+ real decwin[512+32];
+ static real cos64[16],cos32[8],cos16[4],cos8[2],cos4[1];
+ real *pnts[] = { cos64,cos32,cos16,cos8,cos4 };
+ 
+ #if 0
+ static unsigned char *conv16to8_buf = NULL;
+ unsigned char *conv16to8;
+ #endif
+ 
+ static long intwinbase[] = {
+      0,    -1,    -1,    -1,    -1,    -1,    -1,    -2,    -2,    -2,
+     -2,    -3,    -3,    -4,    -4,    -5,    -5,    -6,    -7,    -7,
+     -8,    -9,   -10,   -11,   -13,   -14,   -16,   -17,   -19,   -21,
+    -24,   -26,   -29,   -31,   -35,   -38,   -41,   -45,   -49,   -53,
+    -58,   -63,   -68,   -73,   -79,   -85,   -91,   -97,  -104,  -111,
+   -117,  -125,  -132,  -139,  -147,  -154,  -161,  -169,  -176,  -183,
+   -190,  -196,  -202,  -208,  -213,  -218,  -222,  -225,  -227,  -228,
+   -228,  -227,  -224,  -221,  -215,  -208,  -200,  -189,  -177,  -163,
+   -146,  -127,  -106,   -83,   -57,   -29,     2,    36,    72,   111,
+    153,   197,   244,   294,   347,   401,   459,   519,   581,   645,
+    711,   779,   848,   919,   991,  1064,  1137,  1210,  1283,  1356,
+   1428,  1498,  1567,  1634,  1698,  1759,  1817,  1870,  1919,  1962,
+   2001,  2032,  2057,  2075,  2085,  2087,  2080,  2063,  2037,  2000,
+   1952,  1893,  1822,  1739,  1644,  1535,  1414,  1280,  1131,   970,
+    794,   605,   402,   185,   -45,  -288,  -545,  -814, -1095, -1388,
+  -1692, -2006, -2330, -2663, -3004, -3351, -3705, -4063, -4425, -4788,
+  -5153, -5517, -5879, -6237, -6589, -6935, -7271, -7597, -7910, -8209,
+  -8491, -8755, -8998, -9219, -9416, -9585, -9727, -9838, -9916, -9959,
+  -9966, -9935, -9863, -9750, -9592, -9389, -9139, -8840, -8492, -8092,
+  -7640, -7134, -6574, -5959, -5288, -4561, -3776, -2935, -2037, -1082,
+    -70,   998,  2122,  3300,  4533,  5818,  7154,  8540,  9975, 11455,
+  12980, 14548, 16155, 17799, 19478, 21189, 22929, 24694, 26482, 28289,
+  30112, 31947, 33791, 35640, 37489, 39336, 41176, 43006, 44821, 46617,
+  48390, 50137, 51853, 53534, 55178, 56778, 58333, 59838, 61289, 62684,
+  64019, 65290, 66494, 67629, 68692, 69679, 70590, 71420, 72169, 72835,
+  73415, 73908, 74313, 74630, 74856, 74992, 75038 };
+ 
+ void make_decode_tables(long scaleval)
+ {
+   int i,j,k,kr,divv;
+   real *table,*costab;
+ 
+   
+   for(i=0;i<5;i++)
+   {
+     kr=0x10>>i; divv=0x40>>i;
+     costab = pnts[i];
+     for(k=0;k<kr;k++)
+       costab[k] = 1.0 / (2.0 * cos(M_PI * ((double) k * 2.0 + 1.0) / (double) divv));
+   }
+ 
+   table = decwin;
+   scaleval = -scaleval;
+   for(i=0,j=0;i<256;i++,j++,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ 
+   for( /* i=256 */ ;i<512;i++,j--,table+=32)
+   {
+     if(table < decwin+512+16)
+       table[16] = table[0] = (double) intwinbase[j] / 65536.0 * (double) scaleval;
+     if(i % 32 == 31)
+       table -= 1023;
+     if(i % 64 == 63)
+       scaleval = - scaleval;
+   }
+ }
+ 
+ 
+ 
diff -r -c -N encoder/musicin.c lame3.50/musicin.c
*** encoder/musicin.c	Wed Jan 22 02:43:17 1997
--- lame3.50/musicin.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1151 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: musicin.c,v 1.2 1997/01/19 22:28:29 rowlands Exp $
-  *
-  * $Log: musicin.c,v $
-  * Revision 1.2  1997/01/19 22:28:29  rowlands
-  * Layer 3 bug fixes from Seymour Shlien
-  *
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 3/01/91  Douglas Wong,       start of version 1.1 records          *
-  *          Davis Pan                                                 *
-  * 3/06/91  Douglas Wong,       rename: setup.h to endef.h            *
-  *                              removed extraneous variables          *
-  * 3/21/91  J.Georges Fritsch   introduction of the bit-stream        *
-  *                              package. This package allows you      *
-  *                              to generate the bit-stream in a       *
-  *                              binary or ascii format                *
-  * 3/31/91  Bill Aspromonte     replaced the read of the SB matrix    *
-  *                              by an "code generated" one            *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Incorporated Jean-Georges Fritsch's   *
-  *                              "bitstream.c" package.                *
-  *                              Modified to strictly adhere to        *
-  *                              encoded bitstream specs, including    *
-  *                              "Berlin changes".                     *
-  *                              Modified user interface dialog & code *
-  *                              to accept any input & output          *
-  *                              filenames desired.  Also added        *
-  *                              de-emphasis prompt and final bail-out *
-  *                              opportunity before encoding.          *
-  *                              Added AIFF PCM sound file reading     *
-  *                              capability.                           *
-  *                              Modified PCM sound file handling to   *
-  *                              process all incoming samples and fill *
-  *                              out last encoded frame with zeros     *
-  *                              (silence) if needed.                  *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 27jun91  dpwe (Aware Inc)    Used new frame_params struct.         *
-  *                              Clear all automatic arrays.           *
-  *                              Changed some variable names,          *
-  *                              simplified some code.                 *
-  *                              Track number of bits actually sent.   *
-  *                              Fixed padding slot, stereo bitrate    *
-  *                              Added joint-stereo : scales L+R.      *
-  * 6/12/91  Earle Jennings      added fix for MS_DOS in obtain_param  *
-  * 6/13/91  Earle Jennings      added stack length adjustment before  *
-  *                              main for MS_DOS                       *
-  * 7/10/91  Earle Jennings      conversion of all float to FLOAT      *
-  *                              port to MsDos from MacIntosh completed*
-  * 8/ 8/91  Jens Spille         Change for MS-C6.00                   *
-  * 8/22/91  Jens Spille         new obtain_parameters()               *
-  *10/ 1/91  S.I. Sudharsanan,   Ported to IBM AIX platform.           *
-  *          Don H. Lee,                                               *
-  *          Peter W. Farrett                                          *
-  *10/ 3/91  Don H. Lee          implemented CRC-16 error protection   *
-  *                              newly introduced functions are        *
-  *                              I_CRC_calc, II_CRC_calc and encode_CRC*
-  *                              Additions and revisions are marked    *
-  *                              with "dhl" for clarity                *
-  *11/11/91 Katherine Wang       Documentation of code.                *
-  *                                (variables in documentation are     *
-  *                                surround by the # symbol, and an '*'*
-  *                                denotes layer I or II versions)     *
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 2/25/92  Masahiro Iwadare    made code cleaner and more consistent *
-  * 8/07/92  Mike Coleman        make exit() codes return error status *
-  *                              made slight changes for portability   *
-  *19 aug 92 Soren H. Nielsen    Changed MS-DOS file name extensions.  *
-  * 8/25/92  Shaun Astarabadi    Replaced rint() function with explicit*
-  *                              rounding for portability with MSDOS.  *
-  * 9/22/92  jddevine@aware.com  Fixed _scale_factor_calc() calls.     *
-  *10/19/92  Masahiro Iwadare    added info->mode and info->mode_ext   *
-  *                              updates for AIFF format files         *
-  * 3/10/93  Kevin Peterson      In parse_args, only set non default   *
-  *                              bit rate if specified in arg list.    *
-  *                              Use return value from aiff_read_hdrs  *
-  *                              to fseek to start of sound data       *
-  * 7/26/93  Davis Pan           fixed bug in printing info->mode_ext  *
-  *                              value for joint stereo condition      *
-  * 8/27/93 Seymour Shlien,      Fixes in Unix and MSDOS ports,        *
-  *         Daniel Lauzon, and                                         *
-  *         Bill Truerniet                                             *
-  * 11/7/95 Soeren H. Nielsen    LSF added. Bug fix in MSDOS ext.      *
-  * 8/02/95 mc@fivebats.com      Changed default bitrate selection so  *
-  *                              it works with the new LSF stuff       *
-  *10/01/95 mc@fivebats.com      Added layer3                          *
-  **********************************************************************/
- 
- #ifdef MS_DOS
- #include <dos.h>
- #endif
- #include <stdlib.h>
- #include "common.h"
- #include "encoder.h"
- #include "l3psy.h"
- #include "mdct.h"
- #include "loop.h"
- #include "l3bitstream.h"
- #include <assert.h>
- 
- /* Global variable definitions for "musicin.c" */
- 
- FILE               *musicin;
- Bit_stream_struc   bs;
- char               *programName;
- 
- /* Implementations */
- 
- /************************************************************************
- *
- * obtain_parameters
- *
- * PURPOSE:  Prompts for and reads user input for encoding parameters
- *
- * SEMANTICS:  The parameters read are:
- * - input and output filenames
- * - sampling frequency (if AIFF file, will read from the AIFF file header)
- * - layer number
- * - mode (stereo, joint stereo, dual channel or mono)
- * - psychoacoustic model (I or II)
- * - total bitrate, irrespective of the mode
- * - de-emphasis, error protection, copyright and original or copy flags
- *
- ************************************************************************/
- 
- void
- obtain_parameters(fr_ps,psy,num_samples,original_file_name,encoded_file_name)
- frame_params    *fr_ps;
- int             *psy;
- unsigned long   *num_samples;
- char            original_file_name[MAX_NAME_SIZE];
- char            encoded_file_name[MAX_NAME_SIZE];
- {
-     int j;
-     long int freq;
-     int model, brt;
-     char t[50];
-     IFF_AIFF pcm_aiff_data;
-     layer *info = fr_ps->header;
-     long soundPosition;
- #ifdef  MS_DOS
-     char temp_str[MAX_NAME_SIZE];
- #endif 
- 
-     do  {
-        printf("Enter PCM input file name <required>: ");
-        gets(original_file_name);
-        if (original_file_name[0] == NULL_CHAR)
-        printf("PCM input file name is required.\n");
-     } while (original_file_name[0] == NULL_CHAR);
-     printf(">>> PCM input file name is: %s\n", original_file_name);
-  
-     if ((musicin = fopen(original_file_name, "rb")) == NULL) {
-        printf("Could not find \"%s\".\n", original_file_name);
-        exit(1);
-     }
- 
- #ifdef  MS_DOS
-     /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
-     new_ext(original_file_name, DFLT_EXT, temp_str);
-     printf("Enter MPEG encoded output file name <%s>: ",
-            temp_str);
- #else
-     printf("Enter MPEG encoded output file name <%s%s>: ",
-            original_file_name, DFLT_EXT);
- #endif
-  
-     gets(encoded_file_name);
-     
-     if (encoded_file_name[0] == NULL_CHAR) {
- #ifdef  MS_DOS
-   strcpy(encoded_file_name, temp_str);
- #else
-         strcat(strcpy(encoded_file_name, original_file_name), DFLT_EXT);
- #endif
-     }
-         
- 
-     printf(">>> MPEG encoded output file name is: %s\n", encoded_file_name);
-  
-     open_bit_stream_w(&bs, encoded_file_name, BUFFER_SIZE);
-  
-     if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
- 
-        printf(">>> Using Audio IFF sound file headers\n");
- 
-        aiff_check(original_file_name, &pcm_aiff_data, &info->version);
- 
-        if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
-           printf("Could not seek to PCM sound data in \"%s\".\n",
-                  original_file_name);
-           exit(1);
-        }
- 
-        info->sampling_frequency =
-       SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
-        printf(">>> %f Hz sampling frequency selected\n",
-               pcm_aiff_data.sampleRate);
- 
-        /* Determine number of samples in sound file */
- #ifndef MS_DOS
-        *num_samples = pcm_aiff_data.numChannels *
-                       pcm_aiff_data.numSampleFrames;
- #else
-        *num_samples = (long)(pcm_aiff_data.numChannels) *
-                       (long)(pcm_aiff_data.numSampleFrames);
- #endif
- 
-     }
-     else {    /* Not using Audio IFF sound file headers. */
- 
-        printf("What is the sampling frequency? <44100>[Hz]: ");
-        gets(t);
-        freq = atol(t);
-        switch (freq) {
-           case 48000 : info->sampling_frequency = 1;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 44100 : info->sampling_frequency = 0;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 32000 : info->sampling_frequency = 2;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 24000 : info->sampling_frequency = 1;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 22050 : info->sampling_frequency = 0;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           case 16000 : info->sampling_frequency = 2;
-         info->version = MPEG_PHASE2_LSF;
-               printf(">>> %ld Hz sampling freq selected\n", freq);
-               break;
-           default:    info->sampling_frequency = 0;
-               printf(">>> Default 44.1 kHz samp freq selected\n");
-        }
-        printf(">>> Encoding algorithm is %s\n", version_names[info->version]);
-        if (fseek(musicin, 0, SEEK_SET) != 0) {
-           printf("Could not seek to PCM sound data in \"%s\".\n",
-                   original_file_name);
-           exit(1);
-        }
-  
-        /* Declare sound file to have "infinite" number of samples. */
-        *num_samples = MAX_U_32_NUM;
- 
-     }
- 
-     printf("Which layer do you want to use?\n");
-     printf("Available: Layer (1), Layer (<2>), Layer (3): ");
-     gets(t);
-     switch(*t){
-        case '1': info->lay = 1; printf(">>> Using Layer %s\n",t); break;
-        case '2': info->lay = 2; printf(">>> Using Layer %s\n",t); break;
-      case '3': info->lay = 3; printf(">>> Using Layer %s\n",t); break;
-        default:  info->lay = 2; printf(">>> Using default Layer 2\n"); break;
-     }
- 
-     printf("Which mode do you want?\n");
-     printf("Available: (<s>)tereo, (j)oint stereo, ");
-     printf("(d)ual channel, s(i)ngle Channel: ");
-     gets(t);
-     switch(*t){
-        case 's':
-        case 'S':
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'j':
-        case 'J':
-           info->mode = MPG_MD_JOINT_STEREO;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'd':
-        case 'D':
-           info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        case 'i':
-        case 'I':
-           info->mode = MPG_MD_MONO; info->mode_ext = 0;
-           printf(">>> Using mode %s\n",t);
-           break;
-        default:
-           info->mode = MPG_MD_STEREO; info->mode_ext = 0;
-           printf(">>> Using default stereo mode\n");
-           break;
-     }
- 
-     printf("Which psychoacoustic model do you want to use? <1>: ");
-     gets(t);
-     model = atoi(t);
-     if (model > 2 || model < 1) {
-        printf(">>> Default model 1 selected\n");
-        *psy = 1;
-     }
-     else {
-        *psy = model;
-        printf(">>> Using psychoacoustic model %d\n", model);
-     }
-     
-     /* set default bitrate to highest allowed, which is index 14 */
-   brt = bitrate[info->version][info->lay-1][14];
-     printf( "What is the total bitrate? <%u>[kbps]: ", brt );
-     gets( t );
-     brt = atoi( t );
-     if ( brt == 0 )
-       j = 15;
-     else
-       j = 0;
-     while ( j < 15 )
-     {
-     if ( bitrate[info->version][info->lay-1][j] == brt )
-           break;
-     j++;
-     }
-     if ( j == 15 )
-     {
-     brt = bitrate[info->version][info->lay-1][14];
-         printf( ">>> Using default %u kbps\n", brt );
-         info->bitrate_index = 14;
-     }
-     else
-     {
-        info->bitrate_index = j;
-        printf( ">>> Bitrate = %d kbps\n", bitrate[info->version][info->lay-1][j] );
-     }
-  
-     printf("What type of de-emphasis should the decoder use?\n");
-     printf("Available: (<n>)one, (5)0/15 microseconds, (c)citt j.17: ");
-     gets(t);
-     if (*t != 'n' && *t != '5' && *t != 'c') {
-        printf(">>> Using default no de-emphasis\n");
-        info->emphasis = 0;
-     }
-     else {
-        if (*t == 'n')      info->emphasis = 0;
-        else if (*t == '5') info->emphasis = 1;
-        else if (*t == 'c') info->emphasis = 3;
-        printf(">>> Using de-emphasis %s\n",t);
-     }
-  
- /*  Start 2. Part changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want to set the private bit? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->extension = 1;
-     else                        info->extension = 0;
-     if(info->extension) printf(">>> Private bit set\n");
-     else                printf(">>> Private bit not set\n");
-  
- /*  End changes for CD Ver 3.2; jsp; 22-Aug-1991 */
-  
-     printf("Do you want error protection? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->error_protection = TRUE;
-     else                        info->error_protection = FALSE;
-     if(info->error_protection) printf(">>> Error protection used\n");
-     else printf(">>> Error protection not used\n");
-  
-     printf("Is the material copyrighted? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->copyright = 1;
-     else                        info->copyright = 0;
-     if(info->copyright) printf(">>> Copyrighted material\n");
-     else                printf(">>> Material not copyrighted\n");
-  
-     printf("Is this the original? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') info->original = 1;
-     else                        info->original = 0;
-     if(info->original) printf(">>> Original material\n");
-     else               printf(">>> Material not original\n");
-  
-     printf("Do you wish to exit (last chance before encoding)? (y/<n>): ");
-     gets(t);
-     if (*t == 'y' || *t == 'Y') exit(0);
- }
- 
- /************************************************************************
- *
- * parse_args
- *
- * PURPOSE:  Sets encoding parameters to the specifications of the
- * command line.  Default settings are used for parameters
- * not specified in the command line.
- *
- * SEMANTICS:  The command line is parsed according to the following
- * syntax:
- *
- * -l  is followed by the layer number
- * -m  is followed by the mode
- * -p  is followed by the psychoacoustic model number
- * -s  is followed by the sampling rate
- * -b  is followed by the total bitrate, irrespective of the mode
- * -d  is followed by the emphasis flag
- * -c  is followed by the copyright/no_copyright flag
- * -o  is followed by the original/not_original flag
- * -e  is followed by the error_protection on/off flag
- *
- * If the input file is in AIFF format, the sampling frequency is read
- * from the AIFF header.
- *
- * The input and output filenames are read into #inpath# and #outpath#.
- *
- ************************************************************************/
-  
- void
- parse_args(argc, argv, fr_ps, psy, num_samples, inPath, outPath)
- int     argc;
- char    **argv;
- frame_params  *fr_ps;
- int     *psy;
- unsigned long *num_samples;
- char    inPath[MAX_NAME_SIZE];
- char    outPath[MAX_NAME_SIZE];
- {
-    FLOAT srate;
-    int   brate;
-    layer *info = fr_ps->header;
-    int   err = 0, i = 0;
-    IFF_AIFF pcm_aiff_data;
-    long samplerate;
-    long soundPosition;
-  
-    /* preset defaults */
-    inPath[0] = '\0';   outPath[0] = '\0';
-    info->lay = DFLT_LAY;
-    switch(DFLT_MOD) {
-       case 's': info->mode = MPG_MD_STEREO; info->mode_ext = 0; break;
-       case 'd': info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; break;
-       case 'j': info->mode = MPG_MD_JOINT_STEREO; break;
-       case 'm': info->mode = MPG_MD_MONO; info->mode_ext = 0; break;
-       default:
-          fprintf(stderr, "%s: Bad mode dflt %c\n", programName, DFLT_MOD);
-          abort();
-    }
-    *psy = DFLT_PSY;
-    if((info->sampling_frequency = SmpFrqIndex((long)(1000*DFLT_SFQ), &info->version)) < 0) {
-       fprintf(stderr, "%s: bad sfrq default %.2f\n", programName, DFLT_SFQ);
-       abort();
-    }
-   info->bitrate_index = 14;
-   brate = 0;
-    switch(DFLT_EMP) {
-       case 'n': info->emphasis = 0; break;
-       case '5': info->emphasis = 1; break;
-       case 'c': info->emphasis = 3; break;
-       default: 
-          fprintf(stderr, "%s: Bad emph dflt %c\n", programName, DFLT_EMP);
-          abort();
-    }
-    info->copyright = 0; info->original = 0; info->error_protection = FALSE;
-  
-    /* process args */
-    while(++i<argc && err == 0) {
-       char c, *token, *arg, *nextArg;
-       int  argUsed;
-  
-       token = argv[i];
-       if(*token++ == '-') {
-          if(i+1 < argc) nextArg = argv[i+1];
-          else           nextArg = "";
-          argUsed = 0;
-          while( (c = *token++) ) {
-             if(*token /* NumericQ(token) */) arg = token;
-             else                             arg = nextArg;
-             switch(c) {
-                case 'l':        info->lay = atoi(arg); argUsed = 1;
-                   if(info->lay<1 || info->lay>3) {
-                      fprintf(stderr,"%s: -l layer must be 1, 2, or 3, not %s\n",
-                           programName, arg);
-                      err = 1;
-                   }
-                   break;
-                case 'm':        argUsed = 1;
-                   if (*arg == 's')
-                     { info->mode = MPG_MD_STEREO; info->mode_ext = 0; }
-                   else if (*arg == 'd')
-                     { info->mode = MPG_MD_DUAL_CHANNEL; info->mode_ext=0; }
-                   else if (*arg == 'j')
-                     { info->mode = MPG_MD_JOINT_STEREO; }
-                   else if (*arg == 'm')
-                     { info->mode = MPG_MD_MONO; info->mode_ext = 0; }
-                   else {
-                     fprintf(stderr,"%s: -m mode must be s/d/j/m not %s\n",
-                             programName, arg);
-                     err = 1;
-                   }
-                   break;
-                case 'p':        *psy = atoi(arg); argUsed = 1;
-                   if(*psy<1 || *psy>2) {
-                      fprintf(stderr,"%s: -p model must be 1 or 2, not %s\n",
-                              programName, arg);
-                      err = 1;
-                   }
-                   break;
- 
-                case 's':
-                   argUsed = 1;
-                   srate = atof( arg );
-                   /* samplerate = rint( 1000.0 * srate ); $A  */
-                   samplerate = (long) (( 1000.0 * srate ) + 0.5);
-                   if( (info->sampling_frequency =
-           SmpFrqIndex((long) samplerate, &info->version)) < 0 )
-                       err = 1;
-                   break;
-                   
-                case 'b':        
-         argUsed = 1;
-       brate = atoi(arg); 
-       break;
-                case 'd':        argUsed = 1;
-                   if (*arg == 'n')                    info->emphasis = 0;
-                   else if (*arg == '5')               info->emphasis = 1;
-                   else if (*arg == 'c')               info->emphasis = 3;
-                   else {
-                      fprintf(stderr,"%s: -d emp must be n/5/c not %s\n",
-                              programName, arg);
-                      err = 1;
-                   }
-                   break;
-                 case 'c':       info->copyright = 1; break;
-                 case 'o':       info->original  = 1; break;
-                 case 'e':       info->error_protection = TRUE; break;
-                 default:        fprintf(stderr,"%s: unrec option %c\n",
-                                         programName, c);
-                                 err = 1; break;
-             }
-             if(argUsed) {
-                if(arg == token)    token = "";   /* no more from token */
-                else                ++i;          /* skip arg we used */
-                arg = ""; argUsed = 0;
-             }
-          }
-       }
-       else {
-          if(inPath[0] == '\0')       strcpy(inPath, argv[i]);
-          else if(outPath[0] == '\0') strcpy(outPath, argv[i]);
-          else {
-             fprintf(stderr,"%s: excess arg %s\n", programName, argv[i]);
-             err = 1;
-          }
-       }
-    }
- 
-    if(err || inPath[0] == '\0') usage();  /* never returns */
-  
-    if(outPath[0] == '\0') {
- #ifdef MS_DOS
-       /* replace old extension with new one, 1992-08-19, 1995-06-12 shn */
-       new_ext(inPath, DFLT_EXT, outPath);
- #else
-       strcpy(outPath, inPath);
-       strcat(outPath, DFLT_EXT);
- #endif
-    }
- 
-    if ((musicin = fopen(inPath, "rb")) == NULL) {
-       printf("Could not find \"%s\".\n", inPath);
-       exit(1);
-    }
-  
-    open_bit_stream_w(&bs, outPath, BUFFER_SIZE);
- 
-    if ((soundPosition = aiff_read_headers(musicin, &pcm_aiff_data)) != -1) {
- 
-       printf(">>> Using Audio IFF sound file headers\n");
- 
-       aiff_check(inPath, &pcm_aiff_data, &info->version);
- 
-       if (fseek(musicin, soundPosition, SEEK_SET) != 0) {
-          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
-          exit(1);
-       }
- 
-       info->sampling_frequency = SmpFrqIndex((long)pcm_aiff_data.sampleRate, &info->version);
-       printf(">>> %f Hz sampling frequency selected\n",
-              pcm_aiff_data.sampleRate);
- 
-       /* Determine number of samples in sound file */
- #ifndef MS_DOS
-       *num_samples = pcm_aiff_data.numChannels *
-                      pcm_aiff_data.numSampleFrames;
- #else
-       *num_samples = (long)(pcm_aiff_data.numChannels) *
-                      (long)(pcm_aiff_data.numSampleFrames);
- #endif
-       if ( pcm_aiff_data.numChannels == 1 ) {
-         info->mode = MPG_MD_MONO;
-         info->mode_ext = 0;
-       }
-    }
-    else {    /* Not using Audio IFF sound file headers. */
- 
-       if (fseek(musicin, 0, SEEK_SET) != 0) {
-          printf("Could not seek to PCM sound data in \"%s\".\n", inPath);
-          exit(1);
-       }
-  
-       /* Declare sound file to have "infinite" number of samples. */
-       *num_samples = MAX_U_32_NUM;
- 
-    }
-    if ( brate == 0 )
-     brate = bitrate[info->version][info->lay-1][14];
-    if( (info->bitrate_index = BitrateIndex(info->lay, brate, info->version)) < 0) err=1;
-    if(err || inPath[0] == '\0') usage();  /* never returns */
- 
- }
- 
- /************************************************************************
- *
- * print_config
- *
- * PURPOSE:  Prints the encoding parameters used
- *
- ************************************************************************/
-  
- void print_config( frame_params *fr_ps, int *psy, char *inPath, char *outPath)
- {
-  layer *info = fr_ps->header;
-  
-    printf("Encoding configuration:\n");
-    printf("Algorithm=%s\n", version_names[info->version]);
-    if(info->mode != MPG_MD_JOINT_STEREO)
-       printf("Layer=%s   mode=%s   extn=%d   psy model=%d\n",
-              layer_names[info->lay-1], mode_names[info->mode],
-              info->mode_ext, *psy);
-    else printf("Layer=%s   mode=%s   extn=data dependant   psy model=%d\n",
-                layer_names[info->lay-1], mode_names[info->mode], *psy);
-    printf("samp frq=%.1f kHz   total bitrate=%d kbps\n",
-           s_freq[info->version][info->sampling_frequency],
-           bitrate[info->version][info->lay-1][info->bitrate_index]);
-    printf("de-emph=%d   c/right=%d   orig=%d   errprot=%s\n",
-           info->emphasis, info->copyright, info->original,
-           ((info->error_protection) ? "on" : "off"));
-    printf("input file: '%s'   output file: '%s'\n", inPath, outPath);
- }
- 
- 
- 
- 
-  
- /************************************************************************
- *
- * main
- *
- * PURPOSE:  MPEG I Encoder supporting layers 1 and 2, and 3, with
- * psychoacoustic models 1 (MUSICAM) and 2 (AT&T)
- *
- * SEMANTICS:  One overlapping frame of audio of up to 2 channels are
- * processed at a time in the following order:
- * (associated routines are in parentheses)
- *
- * 1.  Filter sliding window of data to get 32 subband
- * samples per channel.
- * (window_subband,filter_subband)
- *
- * 2.  If joint stereo mode, combine left and right channels
- * for subbands above #jsbound#.
- * (*_combine_LR)
- *
- * 3.  Calculate scalefactors for the frame, and if layer 2,
- * also calculate scalefactor select information.
- * (*_scale_factor_calc)
- *
- * 4.  Calculate psychoacoustic masking levels using selected
- * psychoacoustic model.
- * (*_Psycho_One, psycho_anal)
- *
- * 5.  Perform iterative bit allocation for subbands with low
- * mask_to_noise ratios using masking levels from step 4.
- * (*_main_bit_allocation)
- *
- * 6.  If error protection flag is active, add redundancy for
- * error protection.
- * (*_CRC_calc)
- *
- * 7.  Pack bit allocation, scalefactors, and scalefactor select
- * information (layer 2) onto bitstream.
- * (*_encode_bit_alloc,*_encode_scale,II_transmission_pattern)
- *
- * 8.  Quantize subbands and pack them into bitstream
- * (*_subband_quantization, *_sample_encoding)
- *
- ************************************************************************/
- 
- int frameNum=0;
- 
- void main(argc, argv)
- int     argc;
- char    **argv;
- {
-     typedef double SBS[2][3][SCALE_BLOCK][SBLIMIT];
-     SBS  FAR        *sb_sample;
-     L3SBS  FAR        *l3_sb_sample;
-     typedef double JSBS[3][SCALE_BLOCK][SBLIMIT];
-     JSBS FAR        *j_sample;
-     typedef double IN[2][HAN_SIZE];
-     IN   FAR        *win_que;
-     typedef unsigned int SUB[2][3][SCALE_BLOCK][SBLIMIT];
-     SUB  FAR        *subband;
-     
-     frame_params fr_ps;
-     layer info;
-     char original_file_name[MAX_NAME_SIZE];
-     char encoded_file_name[MAX_NAME_SIZE];
-     short FAR **win_buf;
-     static short FAR buffer[2][1152];
-     static unsigned int bit_alloc[2][SBLIMIT], scfsi[2][SBLIMIT];
-     static unsigned int scalar[2][3][SBLIMIT], j_scale[3][SBLIMIT];
-     static double FAR ltmin[2][SBLIMIT], lgmin[2][SBLIMIT], max_sc[2][SBLIMIT];
-     FLOAT snr32[32];
-     short sam[2][1344]; /* was [1056]; */
-     int whole_SpF, extra_slot = 0;
-     double avg_slots_per_frame, frac_SpF, slot_lag;
-     int model, stereo, error_protection;
-     static unsigned int crc;
-     int i, j, k, adb;
-     unsigned long bitsPerSlot, samplesPerFrame;
-     unsigned long frameBits, sentBits = 0;
-     unsigned long num_samples;
-     
- #ifdef  MACINTOSH
-     argc = ccommand( &argv );
- #endif
-     
- 
-     /* Most large variables are declared dynamically to ensure
-        compatibility with smaller machines */
-     
-     sb_sample = (SBS FAR *) mem_alloc(sizeof(SBS), "sb_sample");
-     l3_sb_sample = (L3SBS FAR *) mem_alloc(sizeof(SBS), "l3_sb_sample");
-     j_sample = (JSBS FAR *) mem_alloc(sizeof(JSBS), "j_sample");
-     win_que = (IN FAR *) mem_alloc(sizeof(IN), "Win_que");
-     subband = (SUB FAR *) mem_alloc(sizeof(SUB),"subband");
-     win_buf = (short FAR **) mem_alloc(sizeof(short *)*2, "win_buf");
-  
-     /* clear buffers */
-     memset((char *) buffer, 0, sizeof(buffer));
-     memset((char *) bit_alloc, 0, sizeof(bit_alloc));
-     memset((char *) scalar, 0, sizeof(scalar));
-     memset((char *) j_scale, 0, sizeof(j_scale));
-     memset((char *) scfsi, 0, sizeof(scfsi));
-     memset((char *) ltmin, 0, sizeof(ltmin));
-     memset((char *) lgmin, 0, sizeof(lgmin));
-     memset((char *) max_sc, 0, sizeof(max_sc));
-     memset((char *) snr32, 0, sizeof(snr32));
-     memset((char *) sam, 0, sizeof(sam));
-  
-     fr_ps.header = &info;
-     fr_ps.tab_num = -1;             /* no table loaded */
-     fr_ps.alloc = NULL;
-     info.version = MPEG_AUDIO_ID;   /* Default: MPEG-1 */
- 
-     programName = argv[0];
-     if(argc==1)     /* no command-line args */
-        obtain_parameters(&fr_ps, &model, &num_samples,
-                          original_file_name, encoded_file_name);
-     else
- 	parse_args(argc, argv, &fr_ps, &model, &num_samples,
- 		   original_file_name, encoded_file_name);
-     print_config(&fr_ps, &model,
-                  original_file_name, encoded_file_name);
-     
-     hdr_to_frps(&fr_ps);
-     stereo = fr_ps.stereo;
-     error_protection = info.error_protection;
-     
-     if (info.lay == 1)
-     { bitsPerSlot = 32; samplesPerFrame = 384;  }
-     else 
- 	if ( info.lay == 2 )
- 	{ bitsPerSlot = 8;  samplesPerFrame = 1152; }
- 	else	
- 	{  /* layer 3 */
- 	    bitsPerSlot = 8;
- 	    samplesPerFrame = info.version == 1 ? 1152 : 576;
- 	    
- 	    /* Apologize for missing features */
- 	    if ( info.mode == MPG_MD_JOINT_STEREO )
- 	    {
- 		fprintf( stderr, "Sorry, joint stereo not yet available for layer3\n" );
- 		exit( 1 );
- 	    }
- #if 0
- 	    if ( info.version != MPEG_AUDIO_ID )
- 	    {
- 		fprintf( stderr, "Sorry, MPEG2-LSF not yet available for layer3\n" );
- 		exit( 1 );
- 	    }
- #endif
- 	    if ( model != 2 )
- 	    {
- 		fprintf( stderr, "Sorry, psycho model 1 not available for layer3\n" );
- 		exit( 1 );
- 	    }
- 	}
-     /* Figure average number of 'slots' per frame. */
-     /* Bitrate means TOTAL for both channels, not per side. */
-     avg_slots_per_frame = ((double)samplesPerFrame /
-                            s_freq[info.version][info.sampling_frequency]) *
- 			   ((double)bitrate[info.version][info.lay-1][info.bitrate_index] /
- 			    (double)bitsPerSlot);
-     whole_SpF = (int) avg_slots_per_frame;
-     printf("slots/frame = %d\n",whole_SpF);
-     frac_SpF  = avg_slots_per_frame - (double)whole_SpF;
-     slot_lag  = -frac_SpF;
-     printf("frac SpF=%.3f, tot bitrate=%d kbps, s freq=%.1f kHz\n",
-            frac_SpF, bitrate[info.version][info.lay-1][info.bitrate_index],
-            s_freq[info.version][info.sampling_frequency]);
-     
-     if (frac_SpF != 0)
- 	printf("Fractional number of slots, padding required\n");
-     else info.padding = 0;
-     
-     while ( get_audio(musicin, buffer, num_samples, stereo, &info) > 0 )
-     {
- 	fprintf(stderr, "{%4lu}", frameNum++); fflush(stderr);
- 	win_buf[0] = &buffer[0][0];
- 	win_buf[1] = &buffer[1][0];
- 	if (frac_SpF != 0) {
- 	    if (slot_lag > (frac_SpF-1.0) ) {
- 		slot_lag -= frac_SpF;
- 		extra_slot = 0;
- 		info.padding = 0;
- 		/*  printf("No padding for this frame\n"); */
- 	    }
- 	    else {
- 		extra_slot = 1;
- 		info.padding = 1;
- 		slot_lag += (1-frac_SpF);
- 		/*  printf("Padding for this frame\n");    */
- 	    }
- 	}
- 	adb = (whole_SpF+extra_slot) * bitsPerSlot;
- 	
- 	switch (info.lay)
- 	{
- 	    
- /***************************** Layer I **********************************/
- 	    
-           case 1 :
- 	    for (j=0;j<SCALE_BLOCK;j++)
- 		for (k=0;k<stereo;k++) {
- 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
- 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][0][j][0]);
- 		}
- 	    
- 	    I_scale_factor_calc(*sb_sample, scalar, stereo);
- 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
-                 I_combine_LR(*sb_sample, *j_sample);
-                 I_scale_factor_calc(j_sample, &j_scale, 1);
- 	    }
- 	    
- 	    put_scale(scalar, &fr_ps, max_sc);
- 	    
- 	    if (model == 1) I_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
- 	    else {
-                 for (k=0;k<stereo;k++) {
- 		    psycho_anal(&buffer[k][0],&sam[k][0], k, info.lay, snr32,
- 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
- 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
-                 }
- 	    }
- 	    
- 	    I_main_bit_allocation(ltmin, bit_alloc, &adb, &fr_ps);
- 	    
- 	    if (error_protection) I_CRC_calc(&fr_ps, bit_alloc, &crc);
- 	    
- 	    encode_info(&fr_ps, &bs);
- 	    
- 	    if (error_protection) encode_CRC(crc, &bs);
- 	    
- 	    I_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
- 	    I_encode_scale(scalar, bit_alloc, &fr_ps, &bs);
- 	    I_subband_quantization(scalar, *sb_sample, j_scale, *j_sample,
- 				   bit_alloc, *subband, &fr_ps);
- 	    I_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
- 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
- 	    break;
- 	    
- /***************************** Layer 2 **********************************/
- 	    
-           case 2 :
- 	    for (i=0;i<3;i++) for (j=0;j<SCALE_BLOCK;j++)
-                 for (k=0;k<stereo;k++) {
- 		    window_subband(&win_buf[k], &(*win_que)[k][0], k);
- 		    filter_subband(&(*win_que)[k][0], &(*sb_sample)[k][i][j][0]);
-                 }
- 	    
- 	    II_scale_factor_calc(*sb_sample, scalar, stereo, fr_ps.sblimit);
- 	    pick_scale(scalar, &fr_ps, max_sc);
- 	    if(fr_ps.actual_mode == MPG_MD_JOINT_STEREO) {
- 		II_combine_LR(*sb_sample, *j_sample, fr_ps.sblimit);
- 		II_scale_factor_calc(j_sample, &j_scale, 1, fr_ps.sblimit);
- 	    }       /* this way we calculate more mono than we need */
- 	    /* but it is cheap */
- 	    
- 	    if (model == 1) II_Psycho_One(buffer, max_sc, ltmin, &fr_ps);
- 	    else {
- 		for (k=0;k<stereo;k++) {
- 		    psycho_anal(&buffer[k][0],&sam[k][0], k, 
- 				info.lay, snr32,
- 				(FLOAT)s_freq[info.version][info.sampling_frequency]*1000);
- 		    for (i=0;i<SBLIMIT;i++) ltmin[k][i] = (double) snr32[i];
- 		}
- 	    }
- 	    
- 	    II_transmission_pattern(scalar, scfsi, &fr_ps);
- 	    II_main_bit_allocation(ltmin, scfsi, bit_alloc, &adb, &fr_ps);
- 	    
- 	    if (error_protection)
- 		II_CRC_calc(&fr_ps, bit_alloc, scfsi, &crc);
- 	    
- 	    encode_info(&fr_ps, &bs);
- 	    
- 	    if (error_protection) encode_CRC(crc, &bs);
- 	    
- 	    II_encode_bit_alloc(bit_alloc, &fr_ps, &bs);
- 	    II_encode_scale(bit_alloc, scfsi, scalar, &fr_ps, &bs);
- 	    II_subband_quantization(scalar, *sb_sample, j_scale,
- 				    *j_sample, bit_alloc, *subband, &fr_ps);
- 	    II_sample_encoding(*subband, bit_alloc, &fr_ps, &bs);
- 	    for (i=0;i<adb;i++) put1bit(&bs, 0);
- 	    break;
- 	    
- /***************************** Layer 3 **********************************/
- 
- 	  case 3:
- 	  {
- 	      /*
- 		large "auto" vars are static due to the Macintosh linker
- 	      */ 
- 	      static double xr[2][2][576];
- 	      static double xr_dec[2][2][576];
- 	      static double pe[2][2];
- 	      static int l3_enc[2][2][576];
- 	      static III_psy_ratio ratio;
- 	      static III_side_info_t l3_side;
- 	      static III_scalefac_t  scalefac;
- 	      int gr, mode_gr, ch;
- 	      int mean_bits, sideinfo_len;
- 	      
- 	      int bitsPerFrame = 8 * whole_SpF + (info.padding * 8);
- 	      mode_gr = (info.version == 1) ? 2 : 1;
- 
- 	      /*
- 		determine the mean bitrate for main data
- 	      */
- 	      sideinfo_len = 32;
- 	      if ( info.version == 1 )
- 	      {   /* MPEG 1 */
- 		  if ( stereo == 1 )
- 		      sideinfo_len += 136;
- 		  else
- 		      sideinfo_len += 256;
- 	      }
- 	      else
- 	      {   /* MPEG 2 */
- 		  if ( stereo == 1 )
- 		      sideinfo_len += 72;
- 		  else
- 		      sideinfo_len += 136;
- 	      }
- 	      if ( info.error_protection )
- 		  sideinfo_len += 16;
- 	      mean_bits = (bitsPerFrame - sideinfo_len) / mode_gr;
- 
- 	      /*
- 		psychoacoustic model
- 	      */
- 	      for ( gr = 0; gr < mode_gr; gr++ )
- 		  for ( ch = 0; ch < stereo; ch++ )
- 		  {
- 		      L3psycho_anal( &buffer[ch][gr*576], &sam[ch][0], ch, info.lay,
- 				     snr32, s_freq[info.version][info.sampling_frequency] * 1000.0,
- 				     &ratio.l[gr][ch][0], &ratio.s[gr][ch][0],
- 				     &pe[gr][ch], &l3_side.gr[gr].ch[ch].tt );
- 		  }
- 
- 	      /*
- 		polyphase filtering
- 	      */
- 	      for( gr = 0; gr < mode_gr; gr++ )
- 		  for ( ch = 0; ch < stereo; ch++ )
- 		      for ( j = 0; j < 18; j++ )
- 		      {
- 			  window_subband( &win_buf[ch], &(*win_que)[ch][0], ch );
- 			  filter_subband( &(*win_que)[ch][0],  &(*l3_sb_sample)[ch][gr+1][j][0] );
- 		      }
- 
- 	      /*
- 		apply mdct to the polyphase outputs
- 	      */
- 	      mdct_sub( l3_sb_sample, xr, stereo, &l3_side, mode_gr );
- #if 0
- 	      delay( xr, stereo );
- #endif
- 	      /*
- 		bit and noise allocation
- 	      */
- 	      iteration_loop( pe, xr, &ratio, &l3_side, l3_enc, mean_bits,
- 			      stereo, xr_dec, &scalefac, &fr_ps, 0, bitsPerFrame );
- 
- 	      /*
- 		write the frame to the bitstream
- 	      */
- 	      III_format_bitstream( bitsPerFrame, &fr_ps, l3_enc, &l3_side, &scalefac, &bs,
- 				    xr, NULL, 0 );
- 	  }
- 	    break;  /* end of layer 3 */
- 	    
- 
- 	} /* end switch  */
- 	
- 	frameBits = sstell( &bs ) - sentBits;
- 	if ( frameBits % bitsPerSlot )   /* a program failure */
- 	    fprintf( stderr, "Sent %ld bits = %ld slots plus %ld\n",
- 		     frameBits, frameBits/bitsPerSlot,
- 		     frameBits%bitsPerSlot );
- 	sentBits += frameBits;
- 
-     }    
- 
-     if ( info.lay == 3 )
- 	III_FlushBitstream();
- 
-     close_bit_stream_w( &bs );
- 
-     printf("Avg slots/frame = %.3f; b/smp = %.2f; br = %.3f kbps\n",
-            (FLOAT) sentBits / (frameNum * bitsPerSlot),
-            (FLOAT) sentBits / (frameNum * samplesPerFrame),
-            (FLOAT) sentBits / (frameNum * samplesPerFrame) *
-            s_freq[info.version][info.sampling_frequency]);
- 
-     if (fclose(musicin) != 0){
- 	printf("Could not close \"%s\".\n", original_file_name);
- 	exit(2);
-     }
- 
- #ifdef  MACINTOSH
-     set_mac_file_attr( encoded_file_name, VOL_REF_NUM, CREATOR_ENCODE,
- 		       FILETYPE_ENCODE );
- #endif
- 
-     printf("Encoding of \"%s\" with psychoacoustic model %d is finished\n",
-            original_file_name, model);
-     printf("The MPEG encoded output file name is \"%s\"\n",
- 	   encoded_file_name);
-     exit(0);
- }
-  
- /************************************************************************
- *
- * usage
- *
- * PURPOSE:  Writes command line syntax to the file specified by #stderr#
- *
- ************************************************************************/
- 
- void usage()  /* print syntax & exit */
- {
-     fprintf(stderr,
-     "usage: %s                         queries for all arguments, or\n",
-             programName);
-     fprintf(stderr,
-     "       %s [-l lay][-m mode][-p psy][-s sfrq][-b br][-d emp]\n",
-             programName);
-     fprintf(stderr,
-     "          [-c][-o][-e] inputPCM [outBS]\n");
-     fprintf(stderr,"where\n");
-     fprintf(stderr," -l lay   use layer <lay> coding   (dflt %4u)\n",DFLT_LAY);
-     fprintf(stderr," -m mode  channel mode : s/d/j/m   (dflt %4c)\n",DFLT_MOD);
-     fprintf(stderr," -p psy   psychoacoustic model 1/2 (dflt %4u)\n",DFLT_PSY);
-     fprintf(stderr," -s sfrq  input smpl rate in kHz   (dflt %4.1f)\n",DFLT_SFQ);
-     fprintf(stderr," -b br    total bitrate in kbps    (dflt highest)\n");
-     fprintf(stderr," -d emp   de-emphasis n/5/c        (dflt %4c)\n",DFLT_EMP);
-     fprintf(stderr," -c       mark as copyright\n");
-     fprintf(stderr," -o       mark as original\n");
-     fprintf(stderr," -e       add error protection\n");
-     fprintf(stderr," inputPCM input PCM sound file (standard or AIFF)\n");
-     fprintf(stderr," outBS    output bit stream of encoded audio (dflt inName+%s)\n",
-             DFLT_EXT);
-     exit(1);
- }
- 
- /************************************************************************
- *
- * aiff_check
- *
- * PURPOSE:  Checks AIFF header information to make sure it is valid.
- *           Exits if not.
- *
- ************************************************************************/
- 
- void aiff_check( char *file_name, IFF_AIFF *pcm_aiff_data, int *version)
- {
-     if (pcm_aiff_data->sampleType != IFF_ID_SSND) {
-        printf("Sound data is not PCM in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if(SmpFrqIndex((long)pcm_aiff_data->sampleRate, version) < 0) {
-        printf("in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->sampleSize != sizeof(short) * BITS_IN_A_BYTE) {
-         printf("Sound data is not %d bits in \"%s\".\n",
-                sizeof(short) * BITS_IN_A_BYTE, file_name);
-         exit(1);
-     }
- 
-     if (pcm_aiff_data->numChannels != MONO &&
-         pcm_aiff_data->numChannels != STEREO) {
-        printf("Sound data is not mono or stereo in \"%s\".\n", file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->blkAlgn.blockSize != 0) {
-        printf("Block size is not %d bytes in \"%s\".\n", 0, file_name);
-        exit(1);
-     }
- 
-     if (pcm_aiff_data->blkAlgn.offset != 0) {
-        printf("Block offset is not %d bytes in \"%s\".\n", 0, file_name);
-        exit(1);
-     }
- }
--- 0 ----
diff -r -c -N encoder/portableio.c lame3.50/portableio.c
*** encoder/portableio.c	Wed Jan 22 02:43:12 1997
--- lame3.50/portableio.c	Mon Oct 11 14:28:20 1999
***************
*** 59,66 ****
  
  
  int
! ReadByte(fp)
! FILE *fp;
  {
  	int	result;
  
--- 59,65 ----
  
  
  int
! ReadByte(FILE *fp)
  {
  	int	result;
  
***************
*** 72,79 ****
  
  
  int
! Read16BitsLowHigh(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 71,77 ----
  
  
  int
! Read16BitsLowHigh(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 90,97 ****
  
  
  int
! Read16BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 88,94 ----
  
  
  int
! Read16BitsHighLow(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 108,125 ****
  
  
  void
! Write8Bits(fp, i)
! FILE *fp;
! int i;
  {
  	putc(i&0xff,fp);
  }
  
  
  void
! Write16BitsLowHigh(fp, i)
! FILE *fp;
! int i;
  {
  	putc(i&0xff,fp);
  	putc((i>>8)&0xff,fp);
--- 105,118 ----
  
  
  void
! Write8Bits(FILE *fp, int i)
  {
  	putc(i&0xff,fp);
  }
  
  
  void
! Write16BitsLowHigh(FILE *fp, int i)
  {
  	putc(i&0xff,fp);
  	putc((i>>8)&0xff,fp);
***************
*** 127,135 ****
  
  
  void
! Write16BitsHighLow(fp, i)
! FILE *fp;
! int i;
  {
  	putc((i>>8)&0xff,fp);
  	putc(i&0xff,fp);
--- 120,126 ----
  
  
  void
! Write16BitsHighLow(FILE *fp, int i)
  {
  	putc((i>>8)&0xff,fp);
  	putc(i&0xff,fp);
***************
*** 137,144 ****
  
  
  int
! Read24BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, third;
  	int	result;
--- 128,134 ----
  
  
  int
! Read24BitsHighLow(FILE *fp)
  {
  	int	first, second, third;
  	int	result;
***************
*** 157,164 ****
  
  
  int
! Read32Bits(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 147,153 ----
  
  
  int
! Read32Bits(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 175,182 ****
  
  
  int
! Read32BitsHighLow(fp)
! FILE *fp;
  {
  	int	first, second, result;
  
--- 164,170 ----
  
  
  int
! Read32BitsHighLow(FILE *fp)
  {
  	int	first, second, result;
  
***************
*** 193,201 ****
  
  
  void
! Write32Bits(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
--- 181,187 ----
  
  
  void
! Write32Bits(FILE *fp, int i)
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
***************
*** 203,211 ****
  
  
  void
! Write32BitsLowHigh(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
--- 189,195 ----
  
  
  void
! Write32BitsLowHigh(FILE *fp, int i)
  {
  	Write16BitsLowHigh(fp,(int)(i&0xffffL));
  	Write16BitsLowHigh(fp,(int)((i>>16)&0xffffL));
***************
*** 213,243 ****
  
  
  void
! Write32BitsHighLow(fp, i)
! FILE *fp;
! int i;
  {
  	Write16BitsHighLow(fp,(int)((i>>16)&0xffffL));
  	Write16BitsHighLow(fp,(int)(i&0xffffL));
  }
  
! void ReadBytes(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
! 	while (!feof(fp) & n-- > 0)
  		*p++ = getc(fp);
  }
  
! void ReadBytesSwapped(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & n-- > 0)
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
--- 197,219 ----
  
  
  void
! Write32BitsHighLow(FILE *fp, int i)
  {
  	Write16BitsHighLow(fp,(int)((i>>16)&0xffffL));
  	Write16BitsHighLow(fp,(int)(i&0xffffL));
  }
  
! void ReadBytes(FILE	*fp, char *p, int n)
  {
! 	while (!feof(fp) & (n-- > 0))
  		*p++ = getc(fp);
  }
  
! void ReadBytesSwapped(FILE *fp, char *p, int n)
  {
  	register char	*q = p;
  
! 	while (!feof(fp) & (n-- > 0))
  		*q++ = getc(fp);
  
  	for (q--; p < q; p++, q--){
***************
*** 247,265 ****
  	}
  }
  
! void WriteBytes(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	while (n-- > 0)
  		putc(*p++, fp);
  }
  
! void WriteBytesSwapped(fp, p, n)
! FILE	*fp;
! char	*p;
! int	n;
  {
  	p += n-1;
  	while (n-- > 0)
--- 223,235 ----
  	}
  }
  
! void WriteBytes(FILE *fp, char *p, int n)
  {
  	while (n-- > 0)
  		putc(*p++, fp);
  }
  
! void WriteBytesSwapped(FILE *fp, char *p, int n)
  {
  	p += n-1;
  	while (n-- > 0)
***************
*** 267,274 ****
  }
  
  defdouble
! ReadIeeeFloatHighLow(fp)
! FILE *fp;
  {
  	char	bits[kFloatLength];
  
--- 237,243 ----
  }
  
  defdouble
! ReadIeeeFloatHighLow(FILE *fp)
  {
  	char	bits[kFloatLength];
  
***************
*** 277,284 ****
  }
  
  defdouble
! ReadIeeeFloatLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kFloatLength];
  
--- 246,252 ----
  }
  
  defdouble
! ReadIeeeFloatLowHigh(FILE *fp)
  {
  	char	bits[kFloatLength];
  
***************
*** 287,294 ****
  }
  
  defdouble
! ReadIeeeDoubleHighLow(fp)
! FILE *fp;
  {
  	char	bits[kDoubleLength];
  
--- 255,261 ----
  }
  
  defdouble
! ReadIeeeDoubleHighLow(FILE *fp)
  {
  	char	bits[kDoubleLength];
  
***************
*** 297,304 ****
  }
  
  defdouble
! ReadIeeeDoubleLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kDoubleLength];
  
--- 264,270 ----
  }
  
  defdouble
! ReadIeeeDoubleLowHigh(FILE *fp)
  {
  	char	bits[kDoubleLength];
  
***************
*** 307,314 ****
  }
  
  defdouble
! ReadIeeeExtendedHighLow(fp)
! FILE *fp;
  {
  	char	bits[kExtendedLength];
  
--- 273,279 ----
  }
  
  defdouble
! ReadIeeeExtendedHighLow(FILE *fp)
  {
  	char	bits[kExtendedLength];
  
***************
*** 317,324 ****
  }
  
  defdouble
! ReadIeeeExtendedLowHigh(fp)
! FILE *fp;
  {
  	char	bits[kExtendedLength];
  
--- 282,288 ----
  }
  
  defdouble
! ReadIeeeExtendedLowHigh(FILE *fp)
  {
  	char	bits[kExtendedLength];
  
***************
*** 327,335 ****
  }
  
  void
! WriteIeeeFloatLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kFloatLength];
  
--- 291,297 ----
  }
  
  void
! WriteIeeeFloatLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kFloatLength];
  
***************
*** 338,346 ****
  }
  
  void
! WriteIeeeFloatHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kFloatLength];
  
--- 300,306 ----
  }
  
  void
! WriteIeeeFloatHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kFloatLength];
  
***************
*** 349,357 ****
  }
  
  void
! WriteIeeeDoubleLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kDoubleLength];
  
--- 309,315 ----
  }
  
  void
! WriteIeeeDoubleLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kDoubleLength];
  
***************
*** 360,368 ****
  }
  
  void
! WriteIeeeDoubleHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kDoubleLength];
  
--- 318,324 ----
  }
  
  void
! WriteIeeeDoubleHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kDoubleLength];
  
***************
*** 371,379 ****
  }
  
  void
! WriteIeeeExtendedLowHigh(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kExtendedLength];
  
--- 327,333 ----
  }
  
  void
! WriteIeeeExtendedLowHigh(FILE *fp, defdouble num)
  {
  	char	bits[kExtendedLength];
  
***************
*** 383,391 ****
  
  
  void
! WriteIeeeExtendedHighLow(fp, num)
! FILE *fp;
! defdouble num;
  {
  	char	bits[kExtendedLength];
  
--- 337,343 ----
  
  
  void
! WriteIeeeExtendedHighLow(FILE *fp, defdouble num)
  {
  	char	bits[kExtendedLength];
  
diff -r -c -N encoder/psy.c lame3.50/psy.c
*** encoder/psy.c	Wed Jan 22 02:43:18 1997
--- lame3.50/psy.c	Wed Dec 31 17:00:00 1969
***************
*** 1,454 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: psy.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: psy.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
-  *                              replace of floats with FLOAT          *
-  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
-  * 7/24/92  M. Iwadare          HANN window coefficients modified.    *
-  * 7/27/92  Masahiro Iwadare    Bug fix, FFT modification for Layer 3 *
-  * 7/27/92  Masahiro Iwadare    Bug fix, "new", "old", and "oldest"   *
-  *                              updates                               *
-  * 8/07/92  Mike Coleman        Bug fix, read_absthr()                *
-  * 95/3/21  Jon Rowlands        Removed extra debug statements        *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- FILE		*fpo;	/* file pointer */
- void psycho_anal(buffer,savebuf,chn,lay,snr32,sfreq)
- short int *buffer;
- short int savebuf[1056];
- int   chn, lay;
- FLOAT snr32[32];
- double sfreq;        /* to match prototype : float args are always double */
- {
-  unsigned int   i, j, k;
-  FLOAT          r_prime, phi_prime;
-  FLOAT          freq_mult, bval_lo, minthres, sum_energy;
-  double         tb, temp1, temp2, temp3;
- 
- /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
- /* to be remembered for the unpredictability measure.  For "r" and        */
- /* "phi_sav", the first index from the left is the channel select and     */
- /* the second index is the "age" of the data.                             */
- 
-  static int     new = 0, old = 1, oldest = 0;
-  static int     init = 0, flush, sync_flush, syncsize, sfreq_idx;
- 
- /* The following static variables are constants.                           */
- 
-  static double  nmt = 5.5;
- 
-  static FLOAT   crit_band[27] = {0,  100,  200, 300, 400, 510, 630,  770,
-                                920, 1080, 1270,1480,1720,2000,2320, 2700,
-                               3150, 3700, 4400,5300,6400,7700,9500,12000,
-                              15500,25000,30000};
- 
-  static FLOAT   bmax[27] = {20.0, 20.0, 20.0, 20.0, 20.0, 17.0, 15.0,
-                             10.0,  7.0,  4.4,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  4.5,  4.5,  4.5,  4.5,
-                              4.5,  4.5,  4.5,  3.5,  3.5,  3.5};
- 
- /* The following pointer variables point to large areas of memory         */
- /* dynamically allocated by the mem_alloc() function.  Dynamic memory     */
- /* allocation is used in order to avoid stack frame or data area          */
- /* overflow errors that otherwise would have occurred at compile time     */
- /* on the Macintosh computer.                                             */
- 
-  FLOAT          *grouped_c, *grouped_e, *nb, *cb, *ecb, *bc;
-  FLOAT          *wsamp_r, *wsamp_i, *phi, *energy;
-  FLOAT          *c, *fthr;
-  F32            *snrtmp;
- 
-  static int     *numlines;
-  static int     *partition;
-  static FLOAT   *cbval, *rnorm;
-  static FLOAT   *window;
-  static FLOAT   *absthr;
-  static double  *tmn;
-  static FCB     *s;
-  static FHBLK   *lthr;
-  static F2HBLK  *r, *phi_sav;
- 
- /* These dynamic memory allocations simulate "automatic" variables        */
- /* placed on the stack.  For each mem_alloc() call here, there must be    */
- /* a corresponding mem_free() call at the end of this function.           */
- 
-  grouped_c = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_c");
-  grouped_e = (FLOAT *) mem_alloc(sizeof(FCB), "grouped_e");
-  nb = (FLOAT *) mem_alloc(sizeof(FCB), "nb");
-  cb = (FLOAT *) mem_alloc(sizeof(FCB), "cb");
-  ecb = (FLOAT *) mem_alloc(sizeof(FCB), "ecb");
-  bc = (FLOAT *) mem_alloc(sizeof(FCB), "bc");
-  wsamp_r = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_r");
-  wsamp_i = (FLOAT *) mem_alloc(sizeof(FBLK), "wsamp_i");
-  phi = (FLOAT *) mem_alloc(sizeof(FBLK), "phi");
-  energy = (FLOAT *) mem_alloc(sizeof(FBLK), "energy");
-  c = (FLOAT *) mem_alloc(sizeof(FHBLK), "c");
-  fthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "fthr");
-  snrtmp = (F32 *) mem_alloc(sizeof(F2_32), "snrtmp");
- 
-  if(init==0){
- 
- /* These dynamic memory allocations simulate "static" variables placed    */
- /* in the data space.  Each mem_alloc() call here occurs only once at     */
- /* initialization time.  The mem_free() function must not be called.      */
- 
-      numlines = (int *) mem_alloc(sizeof(ICB), "numlines");
-      partition = (int *) mem_alloc(sizeof(IHBLK), "partition");
-      fpo = fopen("out.dat", "wb");
- 	if(fpo==NULL) {
- 		puts("\t The attempt to open the output file failed.\n");
- 		exit(-1);}
-      cbval = (FLOAT *) mem_alloc(sizeof(FCB), "cbval");
-      rnorm = (FLOAT *) mem_alloc(sizeof(FCB), "rnorm");
-      window = (FLOAT *) mem_alloc(sizeof(FBLK), "window");
-      absthr = (FLOAT *) mem_alloc(sizeof(FHBLK), "absthr");
-      tmn = (double *) mem_alloc(sizeof(DCB), "tmn");
-      s = (FCB *) mem_alloc(sizeof(FCBCB), "s");
-      lthr = (FHBLK *) mem_alloc(sizeof(F2HBLK), "lthr");
-      r = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "r");
-      phi_sav = (F2HBLK *) mem_alloc(sizeof(F22HBLK), "phi_sav");
- 
-      i = sfreq + 0.5;
-      switch(i){
-         case 32000: sfreq_idx = 0; break;
-         case 44100: sfreq_idx = 1; break;
-         case 48000: sfreq_idx = 2; break;
-         default:    printf("error, invalid sampling frequency: %d Hz\n",i);
-         exit(-1);
-      }
-      printf("absthr[][] sampling frequency index: %d\n",sfreq_idx);
-      read_absthr(absthr, sfreq_idx);
-      if(lay==1){
-         flush = 384;
-         syncsize = 1024;
-         sync_flush = 576;
-      }
-      else {
-         flush = 384*3.0/2.0;
-         syncsize = 1056;
-         sync_flush = syncsize - flush;
-      }
- /* calculate HANN window coefficients */
- /*   for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*i/(BLKSIZE-1.0))); */
-      for(i=0;i<BLKSIZE;i++)window[i]=0.5*(1-cos(2.0*PI*(i-0.5)/BLKSIZE));
- /* reset states used in unpredictability measure */
-      for(i=0;i<HBLKSIZE;i++){
-         r[0][0][i]=r[1][0][i]=r[0][1][i]=r[1][1][i]=0;
-         phi_sav[0][0][i]=phi_sav[1][0][i]=0;
-         phi_sav[0][1][i]=phi_sav[1][1][i]=0;
-         lthr[0][i] = 60802371420160.0;
-         lthr[1][i] = 60802371420160.0;
-      }
- /*****************************************************************************
-  * Initialization: Compute the following constants for use later             *
-  *    partition[HBLKSIZE] = the partition number associated with each        *
-  *                          frequency line                                   *
-  *    cbval[CBANDS]       = the center (average) bark value of each          *
-  *                          partition                                        *
-  *    numlines[CBANDS]    = the number of frequency lines in each partition  *
-  *    tmn[CBANDS]         = tone masking noise                               *
-  *****************************************************************************/
- /* compute fft frequency multiplicand */
-      freq_mult = sfreq/BLKSIZE;
-  
- /* calculate fft frequency, then bval of each line (use fthr[] as tmp storage)*/
-      for(i=0;i<HBLKSIZE;i++){
-         temp1 = i*freq_mult;
-         j = 1;
-         while(temp1>crit_band[j])j++;
-         fthr[i]=j-1+(temp1-crit_band[j-1])/(crit_band[j]-crit_band[j-1]);
-      }
-      partition[0] = 0;
- /* temp2 is the counter of the number of frequency lines in each partition */
-      temp2 = 1;
-      cbval[0]=fthr[0];
-      bval_lo=fthr[0];
-      for(i=1;i<HBLKSIZE;i++){
-         if((fthr[i]-bval_lo)>0.33){
-            partition[i]=partition[i-1]+1;
-            cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-            cbval[partition[i]] = fthr[i];
-            bval_lo = fthr[i];
-            numlines[partition[i-1]] = temp2;
-            temp2 = 1;
-         }
-         else {
-            partition[i]=partition[i-1];
-            cbval[partition[i]] += fthr[i];
-            temp2++;
-         }
-      }
-      numlines[partition[i-1]] = temp2;
-      cbval[partition[i-1]] = cbval[partition[i-1]]/temp2;
-  
- /************************************************************************
-  * Now compute the spreading function, s[j][i], the value of the spread-*
-  * ing function, centered at band j, for band i, store for later use    *
-  ************************************************************************/
-      for(j=0;j<CBANDS;j++){
-         for(i=0;i<CBANDS;i++){
-            temp1 = (cbval[i] - cbval[j])*1.05;
-            if(temp1>=0.5 && temp1<=2.5){
-               temp2 = temp1 - 0.5;
-               temp2 = 8.0 * (temp2*temp2 - 2.0 * temp2);
-            }
-            else temp2 = 0;
-            temp1 += 0.474;
-            temp3 = 15.811389+7.5*temp1-17.5*sqrt((double) (1.0+temp1*temp1));
-            if(temp3 <= -100) s[i][j] = 0;
-            else {
-               temp3 = (temp2 + temp3)*LN_TO_LOG10;
-               s[i][j] = exp(temp3);
-            }
-         }
-      }
- 
-   /* Calculate Tone Masking Noise values */
-      for(j=0;j<CBANDS;j++){
-         temp1 = 15.5 + cbval[j];
-         tmn[j] = (temp1>24.5) ? temp1 : 24.5;
-   /* Calculate normalization factors for the net spreading functions */
-         rnorm[j] = 0;
-         for(i=0;i<CBANDS;i++){
-            rnorm[j] += s[j][i];
-         }
-      }
-      init++;
-  }
-  
- /************************* End of Initialization *****************************/
-  switch(lay) {
-   case 1:
-   case 2:
-      for(i=0; i<lay; i++){
- /*****************************************************************************
-  * Net offset is 480 samples (1056-576) for layer 2; this is because one must*
-  * stagger input data by 256 samples to synchronize psychoacoustic model with*
-  * filter bank outputs, then stagger so that center of 1024 FFT window lines *
-  * up with center of 576 "new" audio samples.                                *
-  *                                                                           *
-  * For layer 1, the input data still needs to be staggered by 256 samples,   *
-  * then it must be staggered again so that the 384 "new" samples are centered*
-  * in the 1024 FFT window.  The net offset is then 576 and you need 448 "new"*
-  * samples for each iteration to keep the 384 samples of interest centered   *
-  *****************************************************************************/
-         for(j=0; j<syncsize; j++){
-            if(j<(sync_flush))savebuf[j] = savebuf[j+flush];
-            else savebuf[j] = *buffer++;
-            if(j<BLKSIZE){
- /**window data with HANN window***********************************************/
-               wsamp_r[j] = window[j]*((FLOAT) savebuf[j]);
-               wsamp_i[j] = 0;
-            }
-         }
- /**Compute FFT****************************************************************/
-         fft(wsamp_r,wsamp_i,energy,phi,1024);
- /*****************************************************************************
-  * calculate the unpredictability measure, given energy[f] and phi[f]        *
-  *****************************************************************************/
- /*only update data "age" pointers after you are done with both channels      */
- /*for layer 1 computations, for the layer 2 double computations, the pointers*/
- /*are reset automatically on the second pass                                 */
-          if(lay==2 || (lay==1 && chn==0) ){
-            if(new==0){new = 1; oldest = 1;}
-            else {new = 0; oldest = 0;}
-            if(old==0)old = 1; else old = 0;
-         }
-         for(j=0; j<HBLKSIZE; j++){
-            r_prime = 2.0 * r[chn][old][j] - r[chn][oldest][j];
-            phi_prime = 2.0 * phi_sav[chn][old][j] - phi_sav[chn][oldest][j];
-            r[chn][new][j] = sqrt((double) energy[j]);
-            phi_sav[chn][new][j] = phi[j];
- temp1=r[chn][new][j] * cos((double) phi[j]) - r_prime * cos((double) phi_prime);
- temp2=r[chn][new][j] * sin((double) phi[j]) - r_prime * sin((double) phi_prime);
-            temp3=r[chn][new][j] + fabs((double)r_prime);
-            if(temp3 != 0)c[j]=sqrt(temp1*temp1+temp2*temp2)/temp3;
-            else c[j] = 0;
-         }
- /*****************************************************************************
-  * Calculate the grouped, energy-weighted, unpredictability measure,         *
-  * grouped_c[], and the grouped energy. grouped_e[]                          *
-  *****************************************************************************/
-         for(j=1;j<CBANDS;j++){
-            grouped_e[j] = 0;
-            grouped_c[j] = 0;
-         }
-         grouped_e[0] = energy[0];
-         grouped_c[0] = energy[0]*c[0];
-         for(j=1;j<HBLKSIZE;j++){
-            grouped_e[partition[j]] += energy[j];
-            grouped_c[partition[j]] += energy[j]*c[j];
-         }
- 
- /*****************************************************************************
-  * convolve the grouped energy-weighted unpredictability measure             *
-  * and the grouped energy with the spreading function, s[j][k]               *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            ecb[j] = 0;
-            cb[j] = 0;
-            for(k=0;k<CBANDS;k++){
-               if(s[j][k] != 0.0){
-                  ecb[j] += s[j][k]*grouped_e[k];
-                  cb[j] += s[j][k]*grouped_c[k];
-               }
-            }
-            if(ecb[j] !=0)cb[j] = cb[j]/ecb[j];
-            else cb[j] = 0;
-         }
- 
- /*****************************************************************************
-  * Calculate the required SNR for each of the frequency partitions           *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++){
-            if(cb[j]<.05)cb[j]=0.05;
-            else if(cb[j]>.5)cb[j]=0.5;
-            tb = -0.434294482*log((double) cb[j])-0.301029996;
- 	   cb[j]=tb;
-            bc[j] = tmn[j]*tb + nmt*(1.0-tb);
-            k = cbval[j] + 0.5;
-            bc[j] = (bc[j] > bmax[k]) ? bc[j] : bmax[k];
-            bc[j] = exp((double) -bc[j]*LN_TO_LOG10);
-         }
- 
- /*****************************************************************************
-  * Calculate the permissible noise energy level in each of the frequency     *
-  * partitions. Include absolute threshold and pre-echo controls              *
-  *         this whole section can be accomplished by a table lookup          *
-  *****************************************************************************/
-         for(j=0;j<CBANDS;j++)
-            if(rnorm[j] && numlines[j])
-               nb[j] = ecb[j]*bc[j]/(rnorm[j]*numlines[j]);
-            else nb[j] = 0;
-         for(j=0;j<HBLKSIZE;j++){
- /*temp1 is the preliminary threshold */
-            temp1=nb[partition[j]];
-            temp1=(temp1>absthr[j])?temp1:absthr[j];
- /*do not use pre-echo control for layer 2 because it may do bad things to the*/
- /*  MUSICAM bit allocation algorithm                                         */
-            if(lay==1){
-               fthr[j] = (temp1 < lthr[chn][j]) ? temp1 : lthr[chn][j];
-               temp2 = temp1 * 0.00316;
-               fthr[j] = (temp2 > fthr[j]) ? temp2 : fthr[j];
-            }
-            else fthr[j] = temp1;
-            lthr[chn][j] = LXMIN*temp1;
-         }
- 
- /*****************************************************************************
-  * Translate the 512 threshold values to the 32 filter bands of the coder    *
-  *****************************************************************************/
-         for(j=0;j<193;j += 16){
-            minthres = 60802371420160.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               if(minthres>fthr[j+k])minthres = fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/(minthres * 17.0);
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
-         for(j=208;j<(HBLKSIZE-1);j += 16){
-            minthres = 0.0;
-            sum_energy = 0.0;
-            for(k=0;k<17;k++){
-               minthres += fthr[j+k];
-               sum_energy += energy[j+k];
-            }
-            snrtmp[i][j/16] = sum_energy/minthres;
-            snrtmp[i][j/16] = 4.342944819 * log((double)snrtmp[i][j/16]);
-         }
- /*****************************************************************************
-  * End of Psychoacuostic calculation loop                                    *
-  *****************************************************************************/
-      }
-      for(i=0; i<32; i++){
-         if(lay==2)
-            snr32[i]=(snrtmp[0][i]>snrtmp[1][i])?snrtmp[0][i]:snrtmp[1][i];
-         else snr32[i]=snrtmp[0][i];
-      }
-      break;
-   case 3:
-      printf("layer 3 is not currently supported\n");
-      break;
-   default:
-      printf("error, invalid MPEG/audio coding layer: %d\n",lay);
-  }
- 
- /* These mem_free() calls must correspond with the mem_alloc() calls     */
- /* used at the beginning of this function to simulate "automatic"        */
- /* variables placed on the stack.                                        */
- 
-  mem_free((void **) &grouped_c);
-  mem_free((void **) &grouped_e);
-  mem_free((void **) &nb);
-  mem_free((void **) &cb);
-  mem_free((void **) &ecb);
-  mem_free((void **) &bc);
-  mem_free((void **) &wsamp_r);
-  mem_free((void **) &wsamp_i);
-  mem_free((void **) &phi);
-  mem_free((void **) &energy);
-  mem_free((void **) &c);
-  mem_free((void **) &fthr);
-  mem_free((void **) &snrtmp);
- }
- 
- /******************************************************************************
- routine to read in absthr table from a file.
- ******************************************************************************/
- 
- void read_absthr(absthr, table)
- FLOAT *absthr;
- int table;
- {
-  FILE *fp;
-  long j,index;
-  float a;
-  char t[80];
-  char ta[16];
- 
-  strcpy( ta, "absthr_0" );
-  
-  switch(table){
-     case 0 : ta[7] = '0';
-              break;
-     case 1 : ta[7] = '1';
-              break;
-     case 2 : ta[7] = '2';
-              break;
-     default : printf("absthr table: Not valid table number\n");
-  }
-  if(!(fp = OpenTableFile(ta) ) ){
-     printf("Please check %s table\n", ta);
-     exit(1);
-  }
-  fgets(t, 150, fp);
-  sscanf(t, "table %ld", &index);
-  if(index != table){
-     printf("error in absthr table %s",ta);
-     exit(1);
-  }
-  for(j=0; j<HBLKSIZE; j++){
-     fgets(t,80,fp);
-     sscanf(t,"%f", &a);
-     absthr[j] =  a;
-  }
-  fclose(fp);
- }
--- 0 ----
diff -r -c -N encoder/psymodel.c lame3.50/psymodel.c
*** encoder/psymodel.c	Wed Dec 31 17:00:00 1969
--- lame3.50/psymodel.c	Mon Nov  1 18:19:12 1999
***************
*** 0 ****
--- 1,1176 ----
+ /**********************************************************************
+  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
+  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
+  *
+  * $Id: l3psy.c,v 1.2 1998/10/05 17:06:48 larsi Exp $
+  *
+  * $Log: l3psy.c,v $
+  * Revision 1.2  1998/10/05 17:06:48  larsi
+  * *** empty log message ***
+  *
+  * Revision 1.1.1.1  1998/10/05 14:47:18  larsi
+  *
+  * Revision 1.2  1997/01/19 22:28:29  rowlands
+  * Layer 3 bug fixes from Seymour Shlien
+  *
+  * Revision 1.1  1996/02/14 04:04:23  rowlands
+  * Initial revision
+  *
+  * Received from Mike Coleman
+  **********************************************************************/
+ /**********************************************************************
+  *   date   programmers         comment                               *
+  * 2/25/91  Davis Pan           start of version 1.0 records          *
+  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
+  * 7/10/91  Earle Jennings      Ported to MsDos.                      *
+  *                              replace of floats with FLOAT          *
+  * 2/11/92  W. Joseph Carter    Fixed mem_alloc() arg for "absthr".   *
+  * 3/16/92  Masahiro Iwadare	Modification for Layer III            *
+  * 17/4/93  Masahiro Iwadare    Updated for IS Modification           *
+  **********************************************************************/
+ 
+ #include "util.h"
+ #include "globalflags.h"
+ #include "encoder.h"
+ #include "psymodel.h"
+ #include "l3side.h"
+ #include <assert.h>
+ #include "gtkanal.h"
+ #include "tables.h"
+ #include "fft.h"
+ 
+ #ifdef M_LN10
+ #define		LN_TO_LOG10		(M_LN10/10)
+ #else
+ #define         LN_TO_LOG10             0.2302585093
+ #endif
+ 
+ #define maximum(x,y) ( (x>y) ? x : y )
+ #define minimum(x,y) ( (x<y) ? x : y )
+ 
+ /* some different types of adaptive window switching */
+ 
+ 
+ /* This mode will turn on short_blocks if there is a localized surge in energy */
+ #define ENER_AWS  
+ 
+ static int switch_pe=1800;
+ 
+ static double s3_l[CBANDS][CBANDS]; /* needed global static by sprdngfs */
+ 
+ void L3para_read( double sfreq, int numlines[CBANDS],int numlines_s[CBANDS], int partition_l[HBLKSIZE],
+ 		  double minval[CBANDS], double qthr_l[CBANDS], double norm_l[CBANDS],
+ 		  double s3_l[CBANDS][CBANDS],  double s3_s[CBANDS][CBANDS], 
+                   int partition_s[HBLKSIZE_s], double qthr_s[CBANDS],
+ 		  double norm_s[CBANDS], double SNR_s[CBANDS],
+ 		  int cbw_l[SBMAX_l], int bu_l[SBMAX_l], int bo_l[SBMAX_l],
+ 		  double w1_l[SBMAX_l], double w2_l[SBMAX_l],
+ 		  int cbw_s[SBMAX_s], int bu_s[SBMAX_s], int bo_s[SBMAX_s],
+ 		  double w1_s[SBMAX_s], double w2_s[SBMAX_s] );
+ 									
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ void L3psycho_energy( short int *buffer, 
+     FLOAT energy[HBLKSIZE],
+     FLOAT ax[HBLKSIZE], FLOAT bx[HBLKSIZE],
+     FLOAT energy_s[3][HBLKSIZE_s],
+     FLOAT ax_s[3][HBLKSIZE_s], FLOAT bx_s[3][HBLKSIZE_s],
+      int chn,int gr_out , layer * info)
+ {
+   static short int savebuffer[2][WINDELAY+576];
+   static int sync_flush,flush,syncsize;
+   static FLOAT scalefac;
+   static FLOAT window_s[BLKSIZE_s];
+   static FLOAT window[BLKSIZE];
+   static int firstcall=1;
+ 
+ #ifdef HAVEGTK
+   static FLOAT energy_save[4][HBLKSIZE];
+ #endif
+ 
+   int i,j,k,sblock;
+   
+   FLOAT wsamp_r[BLKSIZE];
+   FLOAT wsamp_rs[256];
+   
+   if(firstcall) {
+     firstcall=0;
+     memset((char *) savebuffer, 0, sizeof(savebuffer));    
+     sync_flush=WINDELAY; flush=576; syncsize=WINDELAY+576;
+     
+     scalefac=1.0;
+     if (force_ms) scalefac=SQRT2;
+     
+     /* calculate HANN window coefficients */
+     /* note: ISO DOCS use i-.5 because their i starts at 1, not 0 */
+     for(i=0;i<BLKSIZE;i++)  window[i]  =0.5*(1-cos(2.0*PI*(i+0.5)/BLKSIZE));
+     for(i=0;i<BLKSIZE_s;i++)window_s[i]=0.5*(1-cos(2.0*PI*(i+0.5)/BLKSIZE_s));
+ 
+   }
+ 
+   /**********************************************************************
+    *  compute FFTs
+    **********************************************************************/
+   if (chn<2) { /* the most common option */
+     for ( j = 0; j < sync_flush; j++ ) /* for long window samples */
+       savebuffer[chn][j] = savebuffer[chn][j+flush];
+     for ( j = sync_flush; j < syncsize; j++ )
+       savebuffer[chn][j] = buffer[j-sync_flush];
+ 
+     for ( j = 0; j < BLKSIZE; j++ ) 
+       wsamp_r[j] = window[j] * savebuffer[chn][j] * scalefac;
+ 
+   } else
+     if (chn==2) {
+       for ( j = 0; j < BLKSIZE; j++ )
+         wsamp_r[j] = window[j] * (savebuffer[0][j] + savebuffer[1][j] )/SQRT2;
+     } else /* if (chn==3)   */
+       {
+         for ( j = 0; j < BLKSIZE; j++ )
+           wsamp_r[j] = window[j] * (savebuffer[0][j] - savebuffer[1][j] )/SQRT2;
+       }
+ 
+   fft( wsamp_r, energy, ax, bx, 1024 );
+   /* mt 7/99
+     Note: fft_side() can be used to compute energy, ax & bx for the
+     mid and side channels (chn=2,3) without calling additional FFTs. 
+     But it requires wsamp_r to be saved from channels 0 and 1.  
+     My tests show that the FFT is so fast that this gives no savings.
+     Probably the extra memory hurts the cache performance.
+   */
+ 
+   
+ #ifdef HAVEGTK
+   if(gtkflag) {
+     for (j=0; j<HBLKSIZE ; j++) {
+       pinfo->energy[gr_out][chn][j]=energy_save[chn][j];
+       energy_save[chn][j]=energy[j];
+     }
+   }
+ #endif
+   for ( sblock = 0; sblock < 3; sblock++ ) {
+     int shlen = 192;
+     int shoff = 1;
+     if (chn<2) 
+       for ( j = 0, k = shlen * (shoff + sblock); j < 256; j++, k++ ) 
+         wsamp_rs[j] = window_s[j]* savebuffer[chn][k]*scalefac;
+     if (chn==2) 
+       for ( j = 0, k = shlen * (shoff + sblock); j < 256; j++, k++ ) 
+         wsamp_rs[j] = window_s[j] *
+ ((savebuffer[0][k]+savebuffer[1][k])/2)*SQRT2;
+     if (chn==3) 
+       for ( j = 0, k = shlen * (shoff + sblock); j < 256; j++, k++ ) 
+         wsamp_rs[j] = window_s[j] *
+ ((savebuffer[0][k]-savebuffer[1][k])/2)*SQRT2;
+ 
+     fft( wsamp_rs, energy_s[sblock], ax_s[sblock], bx_s[sblock], 256 );
+   }
+ 
+ 
+ }
+ 
+ 
+ 
+ 
+  
+ 
+ 
+ 
+  
+ 
+ void L3psycho_anal( short int *buffer[2], int stereo,
+ 		    int gr_out , layer * info,
+ 		    double sfreq, 
+ 		    int check_ms_stereo, double *ms_ener_ratio,
+ 		    double ratio_d[4][21], double ratio_ds[4][12][3],
+ 		    double percep_energy[4], int blocktype_d[2])
+ {
+   static double pe[4]={0,0,0,0};
+   static double ms_ratio_s_old=0,ms_ratio_l_old=0;
+ 
+   static double ratio[4][SBMAX_l];
+   static double ratio_s[4][SBMAX_s][3];
+ #ifdef HAVEGTK
+   static double pe_save[4];
+   static double ers_save[4];
+ #endif
+   static double thm_save[4][SBMAX_l];
+   static double en_save[4][SBMAX_l];
+   static double thm_s_save[4][SBMAX_s][3];
+   static double en_s_save[4][SBMAX_s][3];
+ 
+ 
+   int blocktype[2],uselongblock[2],chn;
+   int numchn;
+   unsigned int   b, i, j, k;
+   double ms_ratio_l=0,ms_ratio_s=0;
+   double estot[4][3];
+ 
+ 
+   double   thr[CBANDS];
+   FLOAT ax[HBLKSIZE], bx[HBLKSIZE];
+   FLOAT energy[HBLKSIZE];
+   FLOAT energy_s[3][HBLKSIZE_s];
+   FLOAT ax_s[3][HBLKSIZE_s], bx_s[3][HBLKSIZE_s]; /* 256 samples not 129. */
+ 
+   static float mld_l[SBMAX_l],mld_s[SBMAX_s];
+   
+ 
+   
+ 
+ /* The static variables "r", "phi_sav", "new", "old" and "oldest" have    */
+ /* to be remembered for the unpredictability measure.  For "r" and        */
+ /* "phi_sav", the first index from the left is the channel select and     */
+ /* the second index is the "age" of the data.                             */
+  static int     sfreq_idx;
+  static double 	cw[HBLKSIZE], eb[CBANDS];
+  static double 	ctb[CBANDS];
+  static double	SNR_l[CBANDS], SNR_s[CBANDS];
+  static double	minval[CBANDS],qthr_l[CBANDS],norm_l[CBANDS];
+  static double	qthr_s[CBANDS],norm_s[CBANDS];
+  static double	nb_1[4][CBANDS], nb_2[4][CBANDS];
+  static double  s3_s[CBANDS][CBANDS];
+ 
+ /* Scale Factor Bands */
+  static int	cbw_l[SBMAX_l],bu_l[SBMAX_l],bo_l[SBMAX_l] ;
+  static int	cbw_s[SBMAX_s],bu_s[SBMAX_s],bo_s[SBMAX_s] ;
+  static double	w1_l[SBMAX_l], w2_l[SBMAX_l];
+  static double	w1_s[SBMAX_s], w2_s[SBMAX_s];
+  static double	en[SBMAX_l],   thm[SBMAX_l] ;
+  static int	blocktype_old[2] ;
+  int	sb,sblock;
+  static int	partition_l[HBLKSIZE],partition_s[HBLKSIZE_s];
+  static int numCBANDS,numCBANDS_s;
+  static int num_part,num_part_s;
+ 
+  static int      s3ind[CBANDS][2];
+  static int      s3ind_s[CBANDS][2];
+ 
+ 
+  static FLOAT   nb[CBANDS], cb[CBANDS], ecb[CBANDS];
+  static	int	numlines_s[CBANDS] ;
+  static	int	numlines_l[CBANDS];
+  static FLOAT   ax_sav[4][2][HBLKSIZE], bx_sav[4][2][HBLKSIZE],rx_sav[4][2][HBLKSIZE];
+ 
+  if((frameNum==0) && (gr_out==0)){
+ 
+      i = sfreq + 0.5;
+      switch(i){
+         case 32000: sfreq_idx = 0; break;
+         case 44100: sfreq_idx = 1; break;
+         case 48000: sfreq_idx = 2; break;
+         case 16000: sfreq_idx = 3; break;
+         case 22050: sfreq_idx = 4; break;
+         case 24000: sfreq_idx = 5; break;
+         default:    fprintf(stderr,"error, invalid sampling frequency: %d Hz\n",i);
+ 	  exit(-1);
+      }
+ 
+ /* reset states used in unpredictability measure */
+ 	memset (rx_sav,0, sizeof(rx_sav));
+ 	memset (ax_sav,0, sizeof(ax_sav));
+ 	memset (bx_sav,0, sizeof(bx_sav));
+  
+ 
+ 
+     /* setup stereo demasking thresholds */
+     /* formula reverse enginerred from plot in paper */
+     for ( sb = 0; sb < SBMAX_s; sb++ ) {
+       double mld = 1.25*(1-cos(3.14159*sb/SBMAX_s))-2.5;
+       mld_s[sb] = pow(10.0,mld);
+     }
+     for ( sb = 0; sb < SBMAX_l; sb++ ) {
+       double mld = 1.25*(1-cos(3.14159*sb/SBMAX_l))-2.5;
+       mld_l[sb] = pow(10.0,mld);
+     }
+ 
+     for (i=0;i<HBLKSIZE;i++) partition_l[i]=-1;
+     for (i=0;i<HBLKSIZE_s;i++) partition_s[i]=-1;
+ 
+ 
+      L3para_read( sfreq,numlines_l,numlines_s,partition_l,minval,qthr_l,norm_l,s3_l,s3_s,
+ 		  partition_s,qthr_s,norm_s,SNR_s,
+ 		  cbw_l,bu_l,bo_l,w1_l,w2_l, cbw_s,bu_s,bo_s,w1_s,w2_s );
+ 
+ 
+      /* num_part   = number of partition bands before convolution */
+      /* numCBANDS  = number of partition bands after convolution */
+      num_part=0; num_part_s=0;
+      for (i=0;i<HBLKSIZE;i++) 
+        if (partition_l[i]>num_part) num_part=partition_l[i];
+      for (i=0;i<HBLKSIZE_s;i++) 
+        if (partition_s[i]>num_part_s) num_part_s=partition_s[i];
+      num_part++;
+      num_part_s++;
+ 
+      numCBANDS=bo_l[SBMAX_l-1]+1;
+      numCBANDS_s=bo_s[SBMAX_s-1]+1;
+ 
+      for (i=0; i<num_part; i++) {
+        for (j = 0; j < num_part; j++) {
+ 	 if (s3_l[i][j] != 0.0)
+ 	   break;
+        }
+        s3ind[i][0] = j;
+        
+        for (j = num_part; j > 0; j--) {
+ 	 if (s3_l[i][j] != 0.0)
+ 	   break;
+        }
+        s3ind[i][1] = j;
+      }
+ 
+ 
+      for (i=0; i<num_part_s; i++) {
+        for (j = 0; j < num_part_s; j++) {
+ 	 if (s3_s[i][j] != 0.0)
+ 	   break;
+        }
+        s3ind_s[i][0] = j;
+        
+        for (j = num_part_s; j > 0; j--) {
+ 	 if (s3_s[i][j] != 0.0)
+ 	   break;
+        }
+        s3ind_s[i][1] = j;
+      }
+      
+ #define NEWS3XX
+ #ifdef NEWS3     
+      // compute norm_l, norm_s instead of relying on table data 
+      for ( b = 0;b < numCBANDS; b++ ) {
+        double norm=0;
+        for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ ) {
+ 	 norm += s3_l[b][k];
+        }
+        norm_l[b] = 1/norm;
+        //printf("%i  norm=%f  norm_l=%f \n",b,1/norm,norm_l[b]);
+      }
+      for ( b = 0;b < numCBANDS_s; b++ ) {
+        double norm=0;
+        for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) {
+ 	 norm += s3_s[b][k];
+        }
+        norm_s[b] = 1/norm;
+        //printf("%i  norm=%f  norm_s=%f \n",b,1/norm,norm_l[b]);
+      }
+ #endif
+ 
+      /* MPEG1 SNR_s data is given in db, convert to energy */
+      if (info->version == MPEG_AUDIO_ID) {
+        for ( b = 0;b < numCBANDS_s; b++ ) {
+ 	 SNR_s[b]=exp( (double) SNR_s[b] * LN_TO_LOG10 );
+        }
+      }
+  }
+ /************************* End of Initialization *****************************/
+ 
+ 
+ 
+ 
+ 
+  numchn=stereo;
+  if (highq && (info->mode == MPG_MD_JOINT_STEREO)) numchn=4;
+  for (chn=0; chn<numchn; chn++) {
+  
+  for ( j = 0; j < 21; j++ )
+    ratio_d[chn][j] = ratio[chn][j];
+  for ( j = 0; j < 12; j++ )
+    for ( i = 0; i < 3; i++ )
+      ratio_ds[chn][j][i] = ratio_s[chn][j][i];
+  percep_energy[chn] = pe[chn]; 
+  
+ /**********************************************************************
+ *  compute FFTs
+ **********************************************************************/
+  L3psycho_energy( buffer[chn%2], energy, ax, bx, energy_s, ax_s, bx_s,
+ 		  chn,gr_out,info);
+ 
+ 
+ /**********************************************************************
+ *    compute unpredicatability of first six spectral lines            * 
+ **********************************************************************/
+  for ( j = 0; j < 6; j++ )
+    {	 /* calculate unpredictability measure cw */
+      double an, a1, a2;
+      double bn, b1, b2;
+      double rn, r1, r2;
+      double numre, numim, den;
+ 
+      a2 = ax_sav[chn][1][j];
+      b2 = bx_sav[chn][1][j];
+      r2 = rx_sav[chn][1][j];
+      a1 = ax_sav[chn][1][j] = ax_sav[chn][0][j];
+      b1 = bx_sav[chn][1][j] = bx_sav[chn][0][j];
+      r1 = rx_sav[chn][1][j] = rx_sav[chn][0][j];
+      an = ax_sav[chn][0][j] = ax[j];
+      bn = bx_sav[chn][0][j] = bx[j];
+      rn = rx_sav[chn][0][j] = sqrt(energy[j]);
+ 
+      { /* square (x1,y1) */
+        if( r1 != 0.0 ) {
+ 	 numre = (a1*b1);
+ 	 numim = (a1*a1-b1*b1)*0.5;
+ 	 den = r1*r1;
+        } else {
+ 	 numre = 1.0;
+ 	 numim = 0.0;
+ 	 den = 1.0;
+        }
+      }
+ 
+      { /* multiply by (x2,-y2) */
+        if( r2 != 0.0 ) {
+ 	 double tmp2 = (numim+numre)*(a2+b2)*0.5;
+ 	 double tmp1 = -a2*numre+tmp2;
+ 	 numre =       -b2*numim+tmp2;
+ 	 numim = tmp1;
+ 	 den *= r2;
+        } else {
+ 	 /* do nothing */
+        }
+      }
+ 
+      { /* r-prime factor */
+        double tmp = (2.0*r1-r2)/den;
+        numre *= tmp;
+        numim *= tmp;
+      }
+ 
+      if( (den=rn+fabs(2.0*r1-r2)) != 0.0 ) {
+        numre = (an+bn)/2.0-numre;
+        numim = (an-bn)/2.0-numim;
+        cw[j] = sqrt(numre*numre+numim*numim)/den;
+      } else {
+        cw[j] = 0.0;
+      }
+ 
+    }
+                                                                                   
+ /**********************************************************************
+ *     compute unpredicatibility of next 200 spectral lines            *
+ **********************************************************************/ 
+  for ( j = 6; j < 206; j += 4 )
+    {/* calculate unpredictability measure cw */
+      double rn, r1, r2;
+      double numre, numim, den;
+ 
+      k = (j+2) / 4; 
+ 
+      { /* square (x1,y1) */
+        r1 = sqrt((double)energy_s[0][k]);
+        if( r1 != 0.0 ) {
+ 	 double a1 = ax_s[0][k];
+ 	 double b1 = bx_s[0][k];
+ 	 numre = (a1*b1);
+ 	 numim = (a1*a1-b1*b1)*0.5;
+ 	 den = r1*r1;
+        } else {
+ 	 numre = 1.0;
+ 	 numim = 0.0;
+ 	 den = 1.0;
+        }
+      }
+ 
+ 
+      { /* multiply by (x2,-y2) */
+        r2 = sqrt((double)energy_s[2][k]);
+        if( r2 != 0.0 ) {
+ 	 double a2 = ax_s[2][k];
+ 	 double b2 = bx_s[2][k];
+ 
+ 	 double tmp2 = (numim+numre)*(a2+b2)*0.5;
+ 	 double tmp1 = -a2*numre+tmp2;
+ 	 numre =       -b2*numim+tmp2;
+ 	 numim = tmp1;
+ 
+ 	 den *= r2;
+        } else {
+ 	 /* do nothing */
+        }
+      }
+ 
+      { /* r-prime factor */
+        double tmp = (2.0*r1-r2)/den;
+        numre *= tmp;
+        numim *= tmp;
+      }
+ 
+      rn = sqrt((double)energy_s[1][k]);
+      if( (den=rn+fabs(2.0*r1-r2)) != 0.0 ) {
+        double an = ax_s[1][k];
+        double bn = bx_s[1][k];
+        numre = (an+bn)/2.0-numre;
+        numim = (an-bn)/2.0-numim;
+        cw[j] = sqrt(numre*numre+numim*numim)/den;
+      } else {
+        cw[j] = 0.0;
+      }
+ 
+      cw[j+1] = cw[j+2] = cw[j+3] = cw[j];
+    }
+ 
+  
+ 
+ 
+ 
+ /**********************************************************************
+ *    Set unpredicatiblility of remaining spectral lines to 0.4  206..513 *
+ **********************************************************************/
+  for ( j = 206; j < HBLKSIZE; j++ )
+    cw[j] = 0.4;
+ 	
+ 
+ 
+ #if 0
+  for ( j = 14; j < HBLKSIZE-4; j += 4 )
+    {/* calculate energy from short ffts */
+      double tot,ave;
+      k = (j+2) / 4; 
+      for (tot=0, sblock=0; sblock < 3; sblock++)
+        tot+=energy_s[sblock][k];
+      ave = energy[j+1]+ energy[j+2]+ energy[j+3]+ energy[j];
+      ave /= 4.;
+      /*
+        printf("energy / tot %i %5.2f   %e  %e\n",j,ave/(tot*16./3.),
+        ave,tot*16./3.);
+      */
+      energy[j+1] = energy[j+2] = energy[j+3] =  energy[j]=tot;
+    }
+ #endif
+  
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ /**********************************************************************
+ *    Calculate the energy and the unpredictability in the threshold   *
+ *    calculation partitions                                           *
+ **********************************************************************/
+  for ( b = 0; b < CBANDS; b++ )
+    {
+      eb[b] = 0.0;
+      cb[b] = 0.0;
+    }
+  for ( j = 0; j < HBLKSIZE; j++ )
+    {
+      int tp = partition_l[j];
+      if ( tp >= 0 )
+        {
+ 	 eb[tp] += energy[j];
+ 	 cb[tp] += cw[j] * energy[j];
+        }
+    }
+ 
+ 
+ /**********************************************************************
+ *      convolve the partitioned energy and unpredictability           *
+ *      with the spreading function, s3_l[b][k]                        *
+ ******************************************************************** */
+  for ( b = 0; b < CBANDS; b++ )
+    {
+      ecb[b] = 0.0;
+      ctb[b] = 0.0;
+    }
+    for ( b = 0;b < numCBANDS; b++ )
+        for ( k = s3ind[b][0]; k <= s3ind[b][1]; k++ )
+ 	 {
+ 	   ecb[b] += s3_l[b][k] * eb[k];	/* sprdngf for Layer III */
+ 	   ctb[b] += s3_l[b][k] * cb[k];
+ 	 }
+ 
+ 
+  /* calculate the tonality of each threshold calculation partition */
+  /* calculate the SNR in each threshhold calculation partition */
+ 
+  for ( b = 0; b < numCBANDS; b++ )
+    {
+      double cbb,tbb;
+      if (ecb[b] != 0.0 )
+        {
+ 	 cbb = ctb[b]/ecb[b];
+ 	 if (cbb <0.01) cbb = 0.01;
+ 	 cbb = log( cbb);
+        }
+      else
+        cbb = 0.0 ;
+      tbb = -0.299 - 0.43*cbb;  /* conv1=-0.299, conv2=-0.43 */
+      tbb = minimum( 1.0, maximum( 0.0, tbb) ) ;  /* 0<tbb<1 */
+      SNR_l[b] = maximum( minval[b], 29.0*tbb+6.0*(1.0-tbb) );
+ 
+ 
+    }	/* TMN=29.0,NMT=6.0 for all calculation partitions */
+  
+  for ( b = 0; b < numCBANDS; b++ ) /* calculate the threshold for each partition */
+    nb[b] = ecb[b] * norm_l[b] * exp( -SNR_l[b] * LN_TO_LOG10 );
+ 
+ 
+  
+  for ( b = 0; b < numCBANDS; b++ )
+    { /* pre-echo control */
+      double temp_1; /* BUG of IS */
+      int rpelev=2; int rpelev2=16; 
+      temp_1 = minimum( nb[b], minimum(rpelev*nb_1[chn][b],rpelev2*nb_2[chn][b]) );
+      thr[b] = maximum( qthr_l[b], temp_1 );/* rpelev=2.0, rpelev2=16.0 */
+      nb_2[chn][b] = nb_1[chn][b];
+      nb_1[chn][b] = nb[b];
+    }
+ 
+  /* note: all surges in PE are because of the above pre-echo formula
+   * for temp_1.  it this is not used, PE is always around 600
+   */
+ 
+  pe[chn] = 0.0;		/*  calculate percetual entropy */
+  for ( b = 0; b < numCBANDS; b++ )
+    {
+      double tp = log((thr[b]+1.0) / (eb[b]+1.0) );
+      tp = minimum( 0.0, tp ) ;  /*not log*/
+      pe[chn] -= numlines_l[b] * tp ;
+ 
+ 
+    }	/* thr[b] -> thr[b]+1.0 : for non sound portition */
+ 
+ 
+ 
+  /*************************************************************** 
+   * Check to see if we also need to compute long block thresholds
+   ***************************************************************/
+  if (voice_mode){
+    uselongblock[chn]=1;
+  } else {
+    double mn,mx;
+    uselongblock[chn] = (pe[chn] < switch_pe);
+ 
+    for (sblock=0; sblock < 3; sblock++)
+        estot[chn][sblock]=0;
+    for ( j = HBLKSIZE_s/2; j < HBLKSIZE_s; j ++)
+      for (sblock=0; sblock < 3; sblock++)
+        estot[chn][sblock]+=energy_s[sblock][j];
+    mn = minimum(estot[chn][0],estot[chn][1]);
+    mn = minimum(mn,estot[chn][2]);
+    mx = maximum(estot[chn][0],estot[chn][1]);
+    mx = maximum(mx,estot[chn][2]);
+ #ifdef HAVEGTK
+    if (gtkflag) {
+      pinfo->ers[gr_out][chn]=ers_save[chn];
+      ers_save[chn]=mx/(1e-12+mn);
+      pinfo->pe[gr_out][chn]=pe_save[chn];
+      pe_save[chn]=pe[chn];
+    }
+ #endif
+ #ifdef ENER_AWS
+    if (chn<2)  {
+      uselongblock[chn] = 1;
+      
+      /* tuned for t1.wav.  doesnt effect most other samples */
+      if (pe[chn] > 3000) uselongblock[chn]=0; 
+      
+      /* big surge of energy - always use short blocks */
+      if (  mx > 30*mn) uselongblock[chn] = 0;
+      
+      /* medium surge, medium pe - use short blocks */
+      if ((mx > 10*mn) && (pe[chn] > 1000))  uselongblock[chn] = 0; 
+ #endif
+    }
+  }
+  
+  
+  
+  /*************************************************************** 
+   * compute masking thresholds for both short and long blocks
+   ***************************************************************/
+  /* threshold calculation (part 2) */
+  for ( sb = 0; sb < SBMAX_l; sb++ )
+    {
+      en[sb] = w1_l[sb] * eb[bu_l[sb]] + w2_l[sb] * eb[bo_l[sb]];
+      thm[sb] = w1_l[sb] *thr[bu_l[sb]] + w2_l[sb] * thr[bo_l[sb]];
+      for ( b = bu_l[sb]+1; b < bo_l[sb]; b++ )
+        {
+ 	 en[sb]  += eb[b];
+ 	 thm[sb] += thr[b];
+        }
+      if ( en[sb] != 0.0 )
+        ratio[chn][sb] = thm[sb]/en[sb];
+      else
+        ratio[chn][sb] = 0.0;
+    }
+ #ifdef HAVEGTK
+  if (gtkflag) {
+    for (sb=0; sb< SBMAX_l; sb ++ ) {
+      pinfo->thr[gr_out][chn][sb]=thm_save[chn][sb];
+      pinfo->en[gr_out][chn][sb]=en_save[chn][sb];
+      thm_save[chn][sb]=thm[sb];
+      en_save[chn][sb]=en[sb];
+    }
+  }
+ #endif
+  for (sb=0; sb< SBMAX_l; sb ++ ) {
+    thm_save[chn][sb]=thm[sb];
+    en_save[chn][sb]=en[sb];
+  }
+  
+  /* threshold calculation for short blocks */
+  for ( sblock = 0; sblock < 3; sblock++ )    {
+    for ( b = 0; b < CBANDS; b++ )
+      {
+        eb[b] = 0.0;
+        ecb[b] = 0.0;
+      }
+    for ( j = 0; j < HBLKSIZE_s; j++ ) {
+      if (partition_s[j]>=0) eb[partition_s[j]] += energy_s[sblock][j];
+    }
+    for ( b = 0; b < numCBANDS_s; b++ )
+      for ( k = s3ind_s[b][0]; k <= s3ind_s[b][1]; k++ ) 
+           ecb[b] += s3_s[b][k] * eb[k];
+ 
+ 
+    for ( b = 0; b < numCBANDS_s; b++ )
+      {
+        //       nb[b] = ecb[b] * norm_s[b] * exp( (double) SNR_s[b] * LN_TO_LOG10 );
+        nb[b] = ecb[b] * norm_s[b] * SNR_s[b];
+        thr[b] = maximum (qthr_s[b],nb[b]);
+      }
+ 
+    for ( sb = 0; sb < SBMAX_s; sb++ )
+      {
+        en[sb] = w1_s[sb] * eb[bu_s[sb]] + w2_s[sb] * eb[bo_s[sb]];
+        thm[sb] = w1_s[sb] *thr[bu_s[sb]] + w2_s[sb] * thr[bo_s[sb]];
+        for ( b = bu_s[sb]+1; b < bo_s[sb]; b++ )
+ 	 {
+ 	   en[sb] += eb[b];
+ 	   thm[sb] += thr[b];
+ 	 }
+        if ( en[sb] != 0.0 ) 
+ 	 ratio_s[chn][sb][sblock] = thm[sb]/en[sb];
+        else
+ 	 ratio_s[chn][sb][sblock] = 0.0;
+ #ifdef HAVEGTK
+        if (gtkflag) {
+ 	 pinfo->thr_s[gr_out][chn][3*sb+sblock]=thm_s_save[chn][sb][sblock];
+ 	 pinfo->en_s[gr_out][chn][3*sb+sblock]=en_s_save[chn][sb][sblock];
+        }
+ #endif
+        thm_s_save[chn][sb][sblock]=thm[sb];
+        en_s_save[chn][sb][sblock]=en[sb];
+ 
+ 
+      }
+    
+  } 
+ 
+  
+  /* compute M/S thresholds from Johnston & Ferreira 1992 ICASSP paper */
+ #define JOHNSTON
+ #ifdef JOHNSTON
+  if ((force_ms && (chn==1)) || (chn==3)) {
+    double rside,rmid,mld;
+    int ch0,ch1; 
+    ch0=chn-1;
+    ch1=chn;
+    
+    for ( sb = 0; sb < SBMAX_l; sb++ ) {
+      /* use this fix if L & R masking differs by 2db or less */
+      /* if db = 10*log10(x2/x1) < 2 */
+      /* if (x2 < 1.58*x1) { */
+      if ((chn==1) || (ratio[0][sb] <= 1.58*ratio[1][sb]) ) {
+        mld = mld_l[sb];
+        rmid = Max(ratio[ch0][sb],Min(ratio[ch1][sb],mld));
+        rside = Max(ratio[ch1][sb],Min(ratio[ch0][sb],mld));
+        ratio[ch0][sb]=rmid;
+        ratio[ch1][sb]=rside;
+      }
+    }
+    for ( sblock = 0; sblock < 3; sblock++ ){
+      for ( sb = 0; sb < SBMAX_s; sb++ ) {
+        if ((chn==1) || (ratio_s[0][sb][sblock] <= 1.58*ratio_s[1][sb][sblock]) ) {
+ 	 mld = mld_s[sb];
+ 	 rmid = Max(ratio_s[ch0][sb][sblock],Min(ratio_s[ch1][sb][sblock],mld));
+ 	 rside = Max(ratio_s[ch1][sb][sblock],Min(ratio_s[ch0][sb][sblock],mld));
+ 	 ratio_s[ch0][sb][sblock]=rmid;
+ 	 ratio_s[ch1][sb][sblock]=rside;
+        }
+      }
+    }
+  }
+ #endif
+  } /* end loop over chn */
+ 
+ 
+ 
+  if (check_ms_stereo)  {
+  /* determin ms_ratio from masking thresholds*/
+  /* use ms_stereo (ms_ratio < .35) if average thresh. diff < 5 db */
+  { double db,x1,x2,sidetot=0,tot=0;
+  for (sb= SBMAX_l/4 ; sb< SBMAX_l; sb ++ ) {
+    x1 = minimum(thm_save[0][sb],thm_save[1][sb]);
+    x2 = maximum(thm_save[0][sb],thm_save[1][sb]);
+    /* thresholds difference in db */
+    if (x2 >= 1000*x1)  db=30;
+    else db = 10*log10(x2/x1);  
+    sidetot += db;
+    tot++;
+  }
+  ms_ratio_l= .35*(sidetot/tot)/5.0;
+  
+  sidetot=0; tot=0;
+  for ( sblock = 0; sblock < 3; sblock++ )
+    for ( sb = SBMAX_s/4; sb < SBMAX_s; sb++ ) {
+      x1 = minimum(thm_s_save[0][sb][sblock],thm_s_save[1][sb][sblock]);
+      x2 = maximum(thm_s_save[0][sb][sblock],thm_s_save[1][sb][sblock]);
+      /* thresholds difference in db */
+      if (x2 >= 1000*x1)  db=30;
+      else db = 10*log10(x2/x1);  
+      sidetot += db;
+      tot++;
+    }
+  ms_ratio_s = .35*(sidetot/tot)/5.0;
+  }
+  }
+ 
+ 
+ 
+  /*************************************************************** 
+   * determin final block type
+   ***************************************************************/
+  if (force_ms) {
+    /* Forced ms_stereo mode.  */
+    /* ch=0 (mid) blocktype determines ch=1 (side) blocktype */
+    uselongblock[1] = uselongblock[0];
+  }
+ 
+ 
+  for (chn=0; chn<stereo; chn++) {
+    blocktype[chn] = NORM_TYPE;
+  }
+ 
+  if (!allow_diff_short)
+  if (info->mode==MPG_MD_JOINT_STEREO) {
+    /* force both channels to use the same block type */
+    /* this is necessary if the frame is to be encoded in ms_stereo.  */
+    /* But even without ms_stereo, FhG  does this */
+    int bothlong= (uselongblock[0] && uselongblock[1]);
+    if (!bothlong) {
+      uselongblock[0]=0;
+      uselongblock[1]=0;
+    }
+  }
+ 
+ 
+ 
+ 
+  /* update the blocktype of the previous granule, since it depends on what
+   * happend in this granule */
+  for (chn=0; chn<stereo; chn++) {
+  if ( uselongblock[chn])
+    {				/* no attack : use long blocks */
+      switch( blocktype_old[chn] ) 
+        {
+        case NORM_TYPE:
+        case STOP_TYPE:
+ 	 blocktype[chn] = NORM_TYPE;
+ 	 break;
+        case SHORT_TYPE:
+ 	 blocktype[chn] = STOP_TYPE; 
+ 	 break;
+        case START_TYPE:
+ 	 fprintf( stderr, "Error in block selecting\n" );
+ 	 abort();
+ 	 break; /* problem */
+        }
+    } else   {
+      /* attack : use short blocks */
+      blocktype[chn] = SHORT_TYPE;
+      if ( blocktype_old[chn] == NORM_TYPE ) {
+        blocktype_old[chn] = START_TYPE;
+      }
+      if ( blocktype_old[chn] == STOP_TYPE ) {
+        blocktype_old[chn] = SHORT_TYPE ;
+      }
+    }
+ 
+  
+  blocktype_d[chn] = blocktype_old[chn];  /* value returned to calling program */
+  blocktype_old[chn] = blocktype[chn];    /* save for next call to l3psy_anal */
+  }
+ 
+  if (blocktype_d[0]==2)
+    *ms_ener_ratio = ms_ratio_s_old;
+  else
+    *ms_ener_ratio = ms_ratio_l_old;
+  ms_ratio_s_old = ms_ratio_s;
+  ms_ratio_l_old = ms_ratio_l;
+ 
+ 
+ 
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ void L3para_read(double sfreq, int *numlines_l,int *numlines_s, int *partition_l, double *minval,
+ double *qthr_l, double *norm_l, double (*s3_l)[63], double s3_s[CBANDS][CBANDS],
+ int *partition_s, double *qthr_s, double *norm_s, double *SNR, 
+ int *cbw_l, int *bu_l, int *bo_l, double *w1_l, double *w2_l, 
+ int *cbw_s, int *bu_s, int *bo_s, double *w1_s, double *w2_s)
+ {
+   double freq_tp;
+   static double bval_l[CBANDS], bval_s[CBANDS];
+   int   cbmax=0, cbmax_tp;
+   //  static double s3_s[CBANDS][CBANDS];
+   double *p = psy_data;
+ 
+   int  sbmax ;
+   int  i,j,k,k2,loop, part_max ;
+ 
+   /* Read long block data */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       cbmax_tp = (int) *p++;
+       cbmax_tp++;
+ 
+       if (sfreq == freq_tp )
+ 	{
+ 	  cbmax = cbmax_tp;
+ 	  for(i=0,k2=0;i<cbmax_tp;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      numlines_l[i] = (int) *p++;
+ 	      minval[i] = *p++;
+ 	      qthr_l[i] = *p++;
+ 	      norm_l[i] = *p++;
+ 	      bval_l[i] = *p++;
+ 	      if (j!=i)
+ 		{
+ 		  fprintf(stderr,"1. please check \"psy_data\"");
+ 		  exit(-1);
+ 		}
+ 	      for(k=0;k<numlines_l[i];k++)
+ 		partition_l[k2++] = i ;
+ 	    }
+ 	}
+       else
+ 	p += cbmax_tp * 6;
+     }
+ 
+ #define NEWBARKXX
+ #ifdef NEWBARK
+   /* compute bark values of each critical band */
+   for(i=0;i<cbmax;i++) {
+     for (j=0;(i != partition_l[j]);j++);
+     { double ji = j + (numlines_l[i]-1)/2.0;
+     double freq = sfreq*ji/1024000.0;
+     double bark = 13*atan(.76*freq) + 3.5*atan(freq*freq/(7.5*7.5));
+     printf("%i %i bval_l = %f  %f  %f \n",i,j,bval_l[i],freq,bark);
+     bval_l[i]=bark;
+     }
+   }
+ #endif
+ 
+   /************************************************************************
+    * Now compute the spreading function, s[j][i], the value of the spread-*
+    * ing function, centered at band j, for band i, store for later use    *
+    ************************************************************************/
+   part_max = cbmax ;
+   for(i=0;i<part_max;i++)
+     {
+       double tempx,x,tempy,temp;
+       for(j=0;j<part_max;j++)
+ 	{
+ 	  //tempx = (bval_l[i] - bval_l[j])*1.05;
+ 	  if (j>=i) tempx = (bval_l[i] - bval_l[j])*3.0;
+ 	  else    tempx = (bval_l[i] - bval_l[j])*1.5;
+ 	  /*             if (j>=i) tempx = (bval_l[j] - bval_l[i])*3.0;
+ 			 else    tempx = (bval_l[j] - bval_l[i])*1.5; */
+ 
+ 
+ 	  if(tempx>=0.5 && tempx<=2.5)
+ 	    {
+ 	      temp = tempx - 0.5;
+ 	      x = 8.0 * (temp*temp - 2.0 * temp);
+ 	    }
+ 	  else x = 0.0;
+ 	  tempx += 0.474;
+ 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
+ 
+ #ifdef NEWS3
+ 	  if (j>=i) tempy = (bval_l[j] - bval_l[i])*(-15);
+ 	  else    tempy = (bval_l[j] - bval_l[i])*25;
+ 	  x=0; 
+ #endif
+ 	  /*
+ 	  if ((i==part_max/2)  && (fabs(bval_l[j] - bval_l[i])) < 3) {
+ 	    printf("bark=%f   x+tempy = %f  \n",bval_l[j] - bval_l[i],x+tempy);
+ 	    //printf("i,j %i %i   bark=%f  %f \n",i,j,bval_l[j],j/(.001+bval_l[j]));
+ 	  }
+ 	  */
+ 
+ 	  if (tempy <= -60.0) s3_l[i][j] = 0.0;
+ 	  else                s3_l[i][j] = exp( (x + tempy)*LN_TO_LOG10 ); 
+ 	}
+     }
+ 
+   /* Read short block data */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       cbmax_tp = (int) *p++;
+       cbmax_tp++;
+ 
+       if (sfreq == freq_tp )
+ 	{
+ 	  cbmax = cbmax_tp;
+ 	  for(i=0,k2=0;i<cbmax_tp;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      numlines_s[i] = (int) *p++;
+ 	      qthr_s[i] = *p++;         
+ 	      norm_s[i] = *p++;         
+ 	      SNR[i] = *p++;            
+ 	      bval_s[i] = *p++;
+ 	      if (j!=i)
+ 		{
+ 		  fprintf(stderr,"3. please check \"psy_data\"");
+ 		  exit(-1);
+ 		}
+ 	      for(k=0;k<numlines_s[i];k++) 
+ 		partition_s[k2++] = i ;
+ 	    }
+ 	}
+       else
+ 	p += cbmax_tp * 6;
+     }
+ 
+ 
+ #ifdef NEWBARK
+   /* compute bark values of each critical band */
+   for(i=0;i<cbmax;i++) {
+     for (j=0;(i != partition_s[j]);j++);
+     { double ji = j + (numlines_s[i]-1)/2.0;
+     double freq = sfreq*ji/256000.0;
+     double bark = 13*atan(.76*freq) + 3.5*atan(freq*freq/(7.5*7.5));
+     printf("%i %i bval_s = %f  %f  %f \n",i,j,bval_s[i],freq,bark);
+     bval_s[i]=bark;
+     }
+   }
+ #endif
+ 
+ 
+ 
+   /************************************************************************
+    * Now compute the spreading function, s[j][i], the value of the spread-*
+    * ing function, centered at band j, for band i, store for later use    *
+    ************************************************************************/
+   part_max = cbmax ;
+   for(i=0;i<part_max;i++)
+     {
+       double tempx,x,tempy,temp;
+       for(j=0;j<part_max;j++)
+ 	{
+ 	  // tempx = (bval_s[i] - bval_s[j])*1.05;
+ 	  if (j>=i) tempx = (bval_s[i] - bval_s[j])*3.0;
+ 	  else    tempx = (bval_s[i] - bval_s[j])*1.5;
+ 	  if(tempx>=0.5 && tempx<=2.5)
+ 	    {
+ 	      temp = tempx - 0.5;
+ 	      x = 8.0 * (temp*temp - 2.0 * temp);
+ 	    }
+ 	  else x = 0.0;
+ 	  tempx += 0.474;
+ 	  tempy = 15.811389 + 7.5*tempx - 17.5*sqrt(1.0+tempx*tempx);
+ #ifdef NEWS3
+ 	  if (j>=i) tempy = (bval_s[j] - bval_s[i])*(-15);
+ 	  else    tempy = (bval_s[j] - bval_s[i])*25;
+ 	  x=0; 
+ #endif
+ 	  if (tempy <= -60.0) s3_s[i][j] = 0.0;
+ 	  else                s3_s[i][j] = exp( (x + tempy)*LN_TO_LOG10 );
+ 	}
+     }
+   /* Read long block data for converting threshold calculation 
+      partitions to scale factor bands */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       sbmax =  (int) *p++;
+       sbmax++;
+ 
+       if (sfreq == freq_tp)
+ 	{
+ 	  for(i=0;i<sbmax;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      cbw_l[i] = (int) *p++;
+ 	      bu_l[i] = (int) *p++;
+ 	      bo_l[i] = (int) *p++;
+ 	      w1_l[i] = (double) *p++;
+ 	      w2_l[i] = (double) *p++;
+ 	      if (j!=i)
+ 		{ fprintf(stderr,"30:please check \"psy_data\"\n");
+ 		exit(-1);
+ 		}
+ 
+ 	      if (i!=0)
+ 		if ( (bo_l[i] != (bu_l[i]+cbw_l[i])) ||
+ 		     (fabs(1.0-w1_l[i]-w2_l[i-1]) > 0.01 ) )
+ 		  {
+ 		    fprintf(stderr,"31l: please check \"psy_data.\"\n");
+ 		    exit(-1);
+ 		  }
+ 	    }
+ 	}
+       else
+ 	p += sbmax * 6;
+     }
+ 
+   /* Read short block data for converting threshold calculation 
+      partitions to scale factor bands */
+ 
+   for(loop=0;loop<6;loop++)
+     {
+       freq_tp = *p++;
+       sbmax = (int) *p++;
+       sbmax++;
+ 
+       if (sfreq == freq_tp)
+ 	{
+ 	  for(i=0;i<sbmax;i++)
+ 	    {
+ 	      j = (int) *p++;
+ 	      cbw_s[i] = (int) *p++;
+ 	      bu_s[i] = (int) *p++;
+ 	      bo_s[i] = (int) *p++;
+ 	      w1_s[i] = *p++;
+ 	      w2_s[i] = *p++;
+ 	      if (j!=i)
+ 		{ fprintf(stderr,"30:please check \"psy_data\"\n");
+ 		exit(-1);
+ 		}
+ 
+ 	      if (i!=0)
+ 		if ( (bo_s[i] != (bu_s[i]+cbw_s[i])) ||
+ 		     (fabs(1.0-w1_s[i]-w2_s[i-1]) > 0.01 ) )
+ 		  { fprintf(stderr,"31s: please check \"psy_data.\"\n");
+ 		  exit(-1);
+ 		  }
+ 	    }
+ 	}
+       else
+ 	p += sbmax * 6;
+     }
+ 
+ }
diff -r -c -N encoder/psymodel.h lame3.50/psymodel.h
*** encoder/psymodel.h	Wed Dec 31 17:00:00 1969
--- lame3.50/psymodel.h	Tue Oct  5 18:18:16 1999
***************
*** 0 ****
--- 1,24 ----
+ #ifndef L3PSY_DOT_H_
+ #define L3PSY_DOT_H_
+ #define BLKSIZE_s 256
+ #define HBLKSIZE_s 129
+ #define SBMAX_l 21
+ #define SBMAX_s 12
+ 
+ 
+ /* #define switch_pe        1800 */
+ #define NORM_TYPE       0
+ #define START_TYPE      1
+ #define SHORT_TYPE      2
+ #define STOP_TYPE       3
+ 
+ /* l3psy.c */
+ #include "l3side.h"
+ void L3psycho_anal( short int *buffer[2], int chn, 
+ 		    int gr , layer *info,
+ 		    double sfreq, 
+ 		    int check_ms, double *ms_ener_ratio, 
+ 		    double ratio_d[2][21], double ratio_ds[2][12][3],
+ 		    double pe[2], 
+                     int blocktype_d[2]); 
+ #endif
diff -r -c -N encoder/quantize-pvt.h lame3.50/quantize-pvt.h
*** encoder/quantize-pvt.h	Wed Dec 31 17:00:00 1969
--- lame3.50/quantize-pvt.h	Sun Oct  3 16:14:46 1999
***************
*** 0 ****
--- 1,178 ----
+ /**********************************************************************
+  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
+  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
+  *
+  * $Id: loop-pvt.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
+  *
+  * Private interface declarations for loop.c
+  *
+  * $Log: loop-pvt.h,v $
+  * Revision 1.1  1996/02/14 04:04:23  rowlands
+  * Initial revision
+  *
+  * Received from Mike Coleman
+  **********************************************************************/
+ 
+ #ifndef LOOP_PVT_H
+ #define LOOP_PVT_H
+ 
+ /*
+   Revision History:
+ 
+   Date        Programmer                Comment
+   ==========  ========================= ===============================
+   1995/10/01  mc@fivebats.com           created
+ 
+ */
+ 
+ void outer_loop( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
+                 int bits,
+ 		double noise[4],
+                 double targ_noise[4],    /* VBR target noise info */
+                 int sloppy,              /* 1=quit as soon as noise < targ_noise */
+                 III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
+                 int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
+ 		frame_params *fr_ps,
+                 III_scalefac_t *scalefac, /* scalefactors */
+                 int gr,
+                 int stereo,
+ 		III_side_info_t *l3_side,
+ 		III_psy_ratio *ratio, 
+ 		double ms_ratio,
+ 		int ch);
+ 
+ 
+ void outer_loop_dual( double xr[2][2][576],     /*vector of the magnitudees of the spectral values */
+ 		 double xr_org[2][2][576],
+                 int mean_bits,
+                 int VBRbits[2][2],
+                 int bit_rate,
+ 		int best_over[2],
+                 III_psy_xmin  *l3_xmin, /* the allowed distortion of the scalefactor */
+                 int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
+ 		frame_params *fr_ps,
+                 III_scalefac_t *scalefac, /* scalefactors */
+                 int gr,
+                 int ch,
+ 		III_side_info_t *l3_side,
+ 		III_psy_ratio *ratio, 
+ 		double pe[2][2],
+ 		double ms_ratio[2]);
+ 
+ 
+ 
+ int part2_length( III_scalefac_t *scalefac,
+ 		  int version, gr_info *cod_info);
+ 
+ int quantanf_init( double xr[576] );
+ 
+ int inner_loop( double xr[2][2][576], double xrpow[576],
+                 int l3_enc[2][2][576],
+                 int max_bits,
+                 gr_info *cod_info,
+                 int gr,
+                 int ch );
+ void calc_xmin( double xr[2][2][576],
+                III_psy_ratio *ratio,
+                gr_info *cod_info,
+                III_psy_xmin *l3_xmin,
+                int gr,
+                int ch );
+ double xr_max( double xr[576],
+                unsigned int begin,
+                unsigned int end );
+ 
+ void calc_scfsi( double  xr[576],
+                  III_side_info_t *l3_side,
+                  III_psy_xmin  *l3_xmin,
+                  int ch,
+                  int gr );
+ 
+ void gr_deco( gr_info *cod_info );
+ 
+ 
+ int count_bit( int ix[576], unsigned int start, unsigned int end, unsigned int table);
+ int bigv_bitcount( int ix[576], gr_info *cod_info );
+ int choose_table( int max);
+ void bigv_tab_select( int ix[576], gr_info *cod_info );
+ void subdivide( gr_info *cod_info );
+ int count1_bitcount( int ix[576], gr_info *cod_info );
+ void  calc_runlen( int ix[576],
+                    gr_info *cod_info );
+ int scale_bitcount( III_scalefac_t *scalefac,
+                     gr_info *cod_info,
+                     int gr,
+                     int ch );
+ int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info,
+                     int gr, int ch );
+ int calc_noise1( double xr[576],
+                  int ix[576],
+                  gr_info *cod_info,
+                  double xfsf[4][CBLIMIT], 
+ 		 double distort[4][CBLIMIT],
+                  III_psy_xmin  *l3_xmin,
+ 		 int gr, int ch, 
+                  double *noise, double *tot_noise, double *max_noise);
+ 
+ void calc_noise2( double xr[2][576],
+                  int ix[2][576],
+                  gr_info *cod_info[2],
+                  double xfsf[2][4][CBLIMIT], 
+ 		 double distort[2][4][CBLIMIT],
+                  III_psy_xmin  *l3_xmin,
+ 		 int gr, int ch, int over[2], 
+                  double noise[2], double tot_noise[2], double max_noise[2]);
+ 
+ 
+ int loop_break( III_scalefac_t *scalefac,
+                 gr_info *cod_info,
+                 int gr,
+                 int ch );
+ int preemphasis( double xr[576], double xrpow[576],
+                   III_psy_xmin  *l3_xmin,
+                   int gr,
+                   int ch,
+ 		  III_side_info_t *l3_side,
+                   double distort[4][CBLIMIT] );
+ int amp_scalefac_bands( double xr[576], double xrpow[576],
+                         III_psy_xmin  *l3_xmin,
+ 			III_side_info_t *l3_side,
+                         III_scalefac_t *scalefac,
+                         int gr,
+                         int ch,
+ 			int iteration,
+                         double distort[4][CBLIMIT]);
+ int quantize( double xr[576],
+                int  ix[576],
+                gr_info *cod_info );
+ void quantize_xrpow( double xr[576],
+                int  ix[576],
+                gr_info *cod_info );
+ int ix_max( int ix[576],
+             unsigned int begin,
+             unsigned int end );
+ 
+ 
+ int
+ new_choose_table( int ix[576],
+ 		  unsigned int begin,
+ 		  unsigned int end, int * s );
+ 
+ /* New SS 20-12-96 */
+ int bin_search_StepSize(int desired_rate, double start, int bot, int ix[576],
+            double xrs[576], double xrspow[576], gr_info * cod_info);
+ int bin_search_StepSize2(int desired_rate, double start, int bot, int ix[576],
+            double xrs[576], double xrspow[576], gr_info * cod_info);
+ int count_bits(int  *ix,gr_info *cod_info);
+ 
+ 
+ int quant_compare(
+ int best_over,double best_tot_noise,double best_over_noise,double best_max_over,
+ int over,double tot_noise, double over_noise,double max_noise);
+ 
+ int VBR_compare(
+ int best_over,double best_tot_noise,double best_over_noise,double best_max_over,
+ int over,double tot_noise, double over_noise,double max_noise);
+ 
+ 
+ #endif
diff -r -c -N encoder/quantize.c lame3.50/quantize.c
*** encoder/quantize.c	Wed Dec 31 17:00:00 1969
--- lame3.50/quantize.c	Fri Oct 29 00:06:26 1999
***************
*** 0 ****
--- 1,2046 ----
+ /*
+  *	MP3 quantization
+  *
+  *	Copyright (c) 1999 Mark Taylor
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ 
+ #include <assert.h>
+ #include "globalflags.h"
+ #include "util.h"
+ #include "l3side.h"
+ #include "quantize.h"
+ #include "l3bitstream.h"
+ #include "reservoir.h"
+ #include "quantize-pvt.h"
+ #include "gtkanal.h"
+ 
+ #define PRECALC_SIZE 8206 /* 8191+15. should never be outside this. see count_bits() */
+ 
+ static double masking_lower=1;
+ 
+ 
+ static int convert_mdct, convert_psy, reduce_sidechannel;
+ /*
+ mt 5/99.  These global flags denote 4 possibilities:
+                                                                 mode    l3_xmin
+ 1   MDCT input L/R, quantize L/R,   psy-model thresholds: L/R   -m s     either
+ 2   MDCT input L/R, quantize M/S,   psy-model thresholds: L/R   -m j     orig
+ 3   MDCT input M/S, quantize M/S,   psy-model thresholds: M/S   -m f     either
+ 4   MDCT input L/R, quantize M/S,   psy-model thresholds: M/S   -m j -h  m/s
+ 
+ 1:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=0          
+ 2:  convert_mdct = 1, convert_psy=1,  reduce_sidechannel=1
+ 3:  convert_mdct = 0, convert_psy=0,  reduce_sidechannel=1
+ 4:  convert_mdct = 1, convert_psy=0,  reduce_sidechannel=1
+ 
+ if (convert_mdct), then iteration_loop will quantize M/S data from
+ the L/R input MDCT coefficients.
+ 
+ if (convert_psy), then calc_noise will compute the noise for the L/R
+ channels from M/S MDCT data and L/R psy-model threshold information.
+ Distortion in ether L or R channel will be marked as distortion in
+ both Mid and Side channels.  
+ 
+ if (reduce_sidechannel) then outer_loop will allocate less bits
+ to the side channel and more bits to the mid channel based on relative 
+ energies.
+ */
+ 
+ 
+ 
+ 
+ /*
+   Here are MPEG1 Table B.8 and MPEG2 Table B.1
+   -- Layer III scalefactor bands.
+   Index into this using a method such as:
+     idx  = fr_ps->header->sampling_frequency
+            + (fr_ps->header->version * 3)
+ */
+ 
+ struct scalefac_struct sfBandIndex[6] =
+ {
+ 
+   { /* Table B.2.b: 22.05 kHz */
+     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+     {0,4,8,12,18,24,32,42,56,74,100,132,174,192}
+   },
+   { /* Table B.2.c: 24 kHz */
+     {0,6,12,18,24,30,36,44,54,66,80,96,114,136,162,194,232,278,332,394,464,540,576},
+     {0,4,8,12,18,26,36,48,62,80,104,136,180,192}
+   },
+   { /* Table B.2.a: 16 kHz */
+     {0,6,12,18,24,30,36,44,54,66,80,96,116,140,168,200,238,284,336,396,464,522,576},
+     {0,4,8,12,18,26,36,48,62,80,104,134,174,192}
+   },
+   { /* Table B.8.b: 44.1 kHz */
+     {0,4,8,12,16,20,24,30,36,44,52,62,74,90,110,134,162,196,238,288,342,418,576},
+     {0,4,8,12,16,22,30,40,52,66,84,106,136,192}
+   },
+   { /* Table B.8.c: 48 kHz */
+     {0,4,8,12,16,20,24,30,36,42,50,60,72,88,106,128,156,190,230,276,330,384,576},
+     {0,4,8,12,16,22,28,38,50,64,80,100,126,192}
+   },
+   { /* Table B.8.a: 32 kHz */
+     {0,4,8,12,16,20,24,30,36,44,54,66,82,102,126,156,194,240,296,364,448,550,576},
+     {0,4,8,12,16,22,30,42,58,78,104,138,180,192}
+   }
+ };
+ 
+ /*
+   The following table is used to implement the scalefactor
+   partitioning for MPEG2 as described in section
+   2.4.3.2 of the IS. The indexing corresponds to the
+   way the tables are presented in the IS:
+ 
+   [table_number][row_in_table][column of nr_of_sfb]
+ */
+ static unsigned nr_of_sfb_block[6][3][4] =
+ {
+   {
+     {6, 5, 5, 5},
+     {9, 9, 9, 9},
+     {6, 9, 9, 9}
+   },
+   {
+     {6, 5, 7, 3},
+     {9, 9, 12, 6},
+     {6, 9, 12, 6}
+   },
+   {
+     {11, 10, 0, 0},
+     {18, 18, 0, 0},
+     {15,18,0,0}
+   },
+   {
+     {7, 7, 7, 0},
+     {12, 12, 12, 0},
+     {6, 15, 12, 0}
+   },
+   {
+     {6, 6, 6, 3},
+     {12, 9, 9, 6},
+     {6, 12, 9, 6}
+   },
+   {
+     {8, 8, 5, 0},
+     {15,12,9,0},
+     {6,18,9,0}
+   }
+ };
+ 
+ /*
+   table of largest scalefactors for MPEG2
+ */
+ static unsigned max_sfac_tab[6][4] =
+ {
+     {4, 4, 3, 3},
+     {4, 4, 3, 0},
+     {3, 2, 0, 0},
+     {4, 5, 5, 0},
+     {3, 3, 3, 0},
+     {2, 2, 0, 0}
+ };
+ 
+ /* Table B.6: layer3 preemphasis */
+ int  pretab[21] =
+ {
+     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+     1, 1, 1, 1, 2, 2, 3, 3, 3, 2
+ };
+ 
+ /* This is the scfsi_band table from 2.4.2.7 of the IS */
+ int scfsi_band_long[5] = { 0, 6, 11, 16, 21 };
+ 
+ int *scalefac_band_long  = &sfBandIndex[3].l[0];
+ int *scalefac_band_short = &sfBandIndex[3].s[0];
+ 
+ 
+ 
+ /* 
+ compute the ATH for each scalefactor band 
+ cd range:  0..96db
+ 
+ Input:  3.3kHz signal  32767 amplitude  (3.3kHz is where ATH is smallest = -5db)
+ longblocks:  sfb=12   en0/bw=-11db    max_en0 = 1.3db
+ shortblocks: sfb=5           -9db              0db
+ 
+ Input:  1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated)
+ longblocks:  amp=1      sfb=12   en0/bw=-103 db      max_en0 = -92db
+             amp=32767   sfb=12           -12 db                 -1.4db 
+ 
+ Input:  1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated)
+ shortblocks: amp=1      sfb=5   en0/bw= -99                    -86 
+             amp=32767   sfb=5           -9  db                  4db 
+ 
+ 
+ MAX energy of largest wave at 3.3kHz = 1db
+ AVE energy of largest wave at 3.3kHz = -11db
+ Let's take AVE:  -11db = maximum signal in sfb=12.  
+ Dynamic range of CD: 96db.  Therefor energy of smallest audible wave 
+ in sfb=12  = -11  - 96 = -107db = ATH at 3.3kHz.  
+ 
+ ATH formula for this wave: -5db.  To adjust to LAME scaling, we need
+ ATH = ATH_formula  - 103  (db)
+ ATH = ATH * 2.5e-10      (ener)
+ 
+ */
+ static double ATH_l[CBLIMIT];
+ static double ATH_s[CBLIMIT];
+ 
+ double ATHformula(double f)
+ {
+   double ath;
+   f  = Max(0.02, f);
+   /* from Painter & Spanias, 1997 */
+   /* minimum: (i=77) 3.3kHz = -5db */
+   ath=(3.640 * pow(f,-0.8)
+        -  6.500 * exp(-0.6*pow(f-3.3,2.0))
+        +  0.001 * pow(f,4.0));
+   
+   /* convert to energy */
+   ath -= 114;    /* MDCT scaling.  From tests by macik and MUS420 code */
+   //ath -= 200; /* disabled */
+   ath = pow( 10.0, ath/10.0 );
+   return ath;
+ }
+  
+ 
+ void compute_ath(layer *info,double ATH_l[CBLIMIT],double ATH_s[CBLIMIT])
+ {
+   int sfb,i,start,end;
+   double ATH_f;
+   double samp_freq = s_freq[info->version][info->sampling_frequency];
+ 
+   /* last sfb is not used */
+   for ( sfb = 0; sfb < SFB_LMAX-1; sfb++ ) {
+     start = scalefac_band_long[ sfb ];
+     end   = scalefac_band_long[ sfb+1 ];
+     ATH_l[sfb]=1e99;
+     for (i=start ; i < end; i++) {
+       ATH_f = ATHformula(samp_freq*i/(2*576)); /* freq in kHz */
+       ATH_l[sfb]=Min(ATH_l[sfb],ATH_f);
+     }
+     /*
+     printf("sfb=%i %f  ATH=%f %f  %f   \n",sfb,samp_freq*start/(2*576),
+ 10*log10(ATH_l[sfb]),
+ 10*log10( ATHformula(samp_freq*start/(2*576)))  ,
+ 10*log10(ATHformula(samp_freq*end/(2*576))));
+     */
+   }
+ 
+   for ( sfb = 0; sfb < SFB_SMAX - 1; sfb++ ){
+     start = scalefac_band_short[ sfb ];
+     end   = scalefac_band_short[ sfb+1 ];
+     ATH_s[sfb]=1e99;
+     for (i=start ; i < end; i++) {
+       ATH_f = ATHformula(samp_freq*i/(2*192));     /* freq in kHz */
+       ATH_s[sfb]=Min(ATH_s[sfb],ATH_f);
+     }
+   }
+ }
+ 
+ 
+ 
+ 
+ 
+ /* convert from L/R <-> Mid/Side */
+ void ms_convert(double xr[2][576],double xr_org[2][576])
+ {
+   int i;
+   for ( i = 0; i < 576; i++ ) {
+     xr[0][i] = (xr_org[0][i]+xr_org[1][i])/SQRT2;
+     xr[1][i] = (xr_org[0][i]-xr_org[1][i])/SQRT2;
+   }
+ }
+ 
+ 
+ 
+ /************************************************************************
+  * allocate bits among 2 channels based on PE
+  * mt 6/99
+  ************************************************************************/
+ void on_pe(double pe[2][2],III_side_info_t *l3_side,
+ int targ_bits[2],int mean_bits,int stereo, int gr)
+ {
+   gr_info *cod_info;
+   int extra_bits,tbits,bits;
+   int add_bits[2]; 
+   int ch;
+ 
+   /* allocate targ_bits for granule */
+   ResvMaxBits2( mean_bits, &tbits, &extra_bits, gr);
+     
+ 
+   for (ch=0 ; ch < stereo ; ch ++) {
+     /******************************************************************
+      * allocate bits for each channel 
+      ******************************************************************/
+     cod_info = &l3_side->gr[gr].ch[ch].tt;
+     
+     targ_bits[ch]=tbits/stereo;
+     
+     // allocate extra bits from reservoir based on PE 
+     bits=0;
+     
+     /* extra bits based on PE > 700 */
+     add_bits[ch]=(pe[gr][ch]-750)/1.4;  /* 2.0; */
+     
+     /* short blocks need extra, no matter what the pe */
+     if (cod_info->block_type==2) 
+       if (add_bits[ch]<500) add_bits[ch]=500;
+     
+     if (add_bits[ch] < 0) add_bits[ch]=0;
+     bits += add_bits[ch];
+     
+     if (bits > extra_bits) add_bits[ch] = (extra_bits*add_bits[ch])/bits;
+     if ((targ_bits[ch]+add_bits[ch]) > 4095) 
+       add_bits[ch]=4095-targ_bits[ch];
+ 
+     targ_bits[ch] = targ_bits[ch] + add_bits[ch];
+     extra_bits -= add_bits[ch];
+   }
+ }
+ 
+ void reduce_side(int targ_bits[2],double ms_ener_ratio,int mean_bits)
+ {
+ int ch;
+ int stereo=2;
+     /*  ms_ener_ratio = 0:  allocate 66/33  mid/side  fac=.33  
+      *  ms_ener_ratio =.5:  allocate 50/50 mid/side   fac= 0 */
+     /* 75/25 split is fac=.5 */
+     /* float fac = .50*(.5-ms_ener_ratio[gr])/.5;*/
+     float fac = .33*(.5-ms_ener_ratio)/.5;
+     if (fac<0) fac=0;
+     
+     if (targ_bits[1] >= 125) {
+       /* dont reduce side channel below 125 bits */
+       if (targ_bits[1]-targ_bits[1]*fac > 125) {
+ 	targ_bits[0] += targ_bits[1]*fac;
+ 	targ_bits[1] -= targ_bits[1]*fac;
+       } else {
+ 	targ_bits[0] += targ_bits[1] - 125;
+ 	targ_bits[1] = 125;
+       }
+     }
+     
+     /* dont allow to many bits per channel */  
+     for (ch=0; ch<stereo; ch++) {
+       int max_bits = Min(4095,mean_bits/2 + 1200);
+       if (targ_bits[ch] > max_bits) {
+ 	targ_bits[ch] = max_bits;
+       }
+     }
+ 
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************/
+ /*  initialization for iteration_loop */
+ /************************************************************************/
+ void
+ iteration_init( double xr_org[2][2][576], 
+ 		III_side_info_t *l3_side, int l3_enc[2][2][576],
+ 		frame_params *fr_ps, III_psy_xmin *l3_xmin)
+ {
+   gr_info *cod_info;
+   layer *info  = fr_ps->header;
+   int stereo = fr_ps->stereo;
+   int ch, gr, i, mode_gr;
+   //  int bit_rate,samp_freq;
+ 
+ 
+   if ( frameNum==0 ) {
+     l3_side->main_data_begin = 0;
+     memset((char *) &l3_xmin, 0, sizeof(l3_xmin));
+     compute_ath(info,ATH_l,ATH_s);
+   }
+ 
+   l3_side->resvDrain = 0;
+   mode_gr = (info->version == 1) ? 2 : 1;
+   //bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
+   //samp_freq = s_freq[info->version][info->sampling_frequency]*1000 +.5;
+ 
+   scalefac_band_long  = &sfBandIndex[info->sampling_frequency + (info->version * 3)].l[0];
+   scalefac_band_short = &sfBandIndex[info->sampling_frequency + (info->version * 3)].s[0];
+   
+ 
+   convert_mdct=0;
+   convert_psy=0;
+   reduce_sidechannel=0;
+   if (info->mode_ext==MPG_MD_MS_LR) {
+     if (highq) {
+       convert_mdct = 1;
+       convert_psy = 0;
+       reduce_sidechannel=1;
+     }else{
+       convert_mdct = 1;
+       convert_psy = 1;
+       reduce_sidechannel=1;
+     }
+   }
+   if (force_ms) {
+     convert_mdct = 0;
+     convert_psy = 0;
+     reduce_sidechannel=1;
+   }
+   if (convert_psy) memset(l3_enc,0,sizeof(int)*2*2*576);
+ 
+ 
+   /* voice mode disables short blocks */  
+   if (voice_mode) {
+     for ( gr = 0; gr < mode_gr; gr++ ) {
+       for (ch =0 ; ch < stereo ; ch++) {
+ 		int start = scalefac_band_long[ SFB_LMAX-3 ];
+ 		  for ( i = start; i < 576; i++ )
+ 			  xr_org[gr][ch][i]=0;
+       }
+       for (ch =0 ; ch < stereo ; ch++) {
+ 		for ( i = 0; i < 2; i++ )
+ 			  xr_org[gr][ch][i]=0;
+       }
+     }
+   }
+ 
+   if (sfb21) {
+     for ( gr = 0; gr < mode_gr; gr++ ) {
+       for (ch =0 ; ch < stereo ; ch++) {
+ 	int shortblock = (l3_side->gr[gr].ch[0].tt.block_type==2);
+ 	if (shortblock) {
+ 	  int j;
+ 	  for (j=0; j<3; j++) {
+ 	    int start = scalefac_band_short[ SFB_SMAX-1 ];
+ 	    for ( i = start; i < 192; i++ ) {
+ 	      int i0 = 3*i+j; 
+ 	      xr_org[gr][ch][i0]=0;
+ 	    }
+ 	  }
+ 	}else{
+ 	  int start = scalefac_band_long[ SFB_LMAX-1 ];
+ 	  for ( i = start; i < 576; i++ ) xr_org[gr][ch][i]=0;
+ 	}
+       }
+     }
+   }
+   
+   
+   
+   /* some intializations. */
+   for ( gr = 0; gr < mode_gr; gr++ ){
+     for ( ch = 0; ch < stereo; ch++ ){
+       cod_info = (gr_info *) &(l3_side->gr[gr].ch[ch]);
+       gr_deco(cod_info);
+     }
+   }
+ 
+ 
+   /* dont bother with scfsi. */
+   for ( ch = 0; ch < stereo; ch++ )
+     for ( i = 0; i < 4; i++ )
+       l3_side->scfsi[ch][i] = 0;
+ 
+ 
+   
+ 
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************/
+ /*  iteration_loop()                                                    */
+ /************************************************************************/
+ void
+ iteration_loop( double pe[2][2], double ms_ener_ratio[2],
+ 		double xr_org[2][2][576], III_psy_ratio *ratio,
+ 		III_side_info_t *l3_side, int l3_enc[2][2][576],
+ 		III_scalefac_t *scalefac, frame_params *fr_ps)
+ {
+   III_psy_xmin l3_xmin;
+   gr_info *cod_info;
+   layer *info;
+   int VBRbits[2][2];
+   int over[2];
+   double noise[4]; /* over,max_noise,over_noise,tot_noise; */
+   double targ_noise[4]; /* over,max_noise,over_noise,tot_noise; */
+   int bitsPerFrame;
+   int mean_bits;
+   int stereo = fr_ps->stereo;
+   int ch, gr, i, mode_gr, bit_rate;
+   double xr[2][2][576];
+ 
+ 
+   iteration_init(xr_org,l3_side,l3_enc,fr_ps,&l3_xmin);
+   info = fr_ps->header;
+   mode_gr = (info->version == 1) ? 2 : 1;
+   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
+ 
+ 
+   getframebits(info,stereo,&bitsPerFrame,&mean_bits);
+   ResvFrameBegin( fr_ps, l3_side, mean_bits, bitsPerFrame );
+ 
+   /* quantize! */
+ 
+   for ( gr = 0; gr < mode_gr; gr++ ) {
+     if (convert_psy) {
+       /* dual channel version can quantize Mid/Side channels with L/R
+        * maskings (by constantly reconstructing L/R data).  Used before we
+        * we had proper mid/side maskings. */
+       outer_loop_dual( xr, xr_org, mean_bits, VBRbits, bit_rate, over,
+ 	       &l3_xmin,l3_enc, fr_ps, 
+ 	       scalefac,gr,stereo, l3_side, ratio, pe, ms_ener_ratio);
+     } else {
+       int targ_bits[2];
+       /* copy data to be quantized into xr */
+       if (convert_mdct) ms_convert(xr[gr],xr_org[gr]);
+       else memcpy(xr[gr],xr_org[gr],sizeof(double)*2*576);   
+       
+       for (ch=0 ; ch < stereo ; ch ++) targ_bits[ch]=VBRbits[gr][ch];
+       on_pe(pe,l3_side,targ_bits,mean_bits,stereo,gr);
+       if (reduce_sidechannel) 
+ 	reduce_side(targ_bits,ms_ener_ratio[gr],mean_bits);
+       
+       for (ch=0 ; ch < stereo ; ch ++) {
+ 	outer_loop( xr, targ_bits[ch], noise, targ_noise, 0, &l3_xmin,l3_enc, 
+ 	    fr_ps, scalefac,gr,stereo, l3_side, ratio, ms_ener_ratio[gr],ch);
+ 	cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 	ResvAdjust( fr_ps, cod_info, l3_side, mean_bits );
+       }
+     }
+   }
+ 
+   
+   /* set the sign of l3_enc */
+   for ( gr = 0; gr < mode_gr; gr++ ) {
+     for ( ch =  0; ch < stereo; ch++ ) {
+       int *pi = &l3_enc[gr][ch][0];
+       for ( i = 0; i < 576; i++) 	    {
+ 	double pr = xr[gr][ch][i];
+ 	if ( (pr < 0) && (pi[i] > 0) )   pi[i] *= -1;
+       }
+     }
+   }
+   ResvFrameEnd( fr_ps, l3_side, mean_bits );
+ }
+ 
+       
+ /************************************************************************
+  *
+  * VBR_iteration_loop()   
+  *
+  * tries to find out how many bits are needed for each granule and channel
+  * to get an acceptable quantization. An appropriate bitrate will then be
+  * choosed for quantization.  rh 8/99                                                
+  *
+  ************************************************************************/
+ void
+ VBR_iteration_loop (double pe[2][2], double ms_ener_ratio[2],
+                 double xr_org[2][2][576], III_psy_ratio * ratio,
+                 III_side_info_t * l3_side, int l3_enc[2][2][576],
+                 III_scalefac_t * scalefac, frame_params * fr_ps)
+ {
+   III_psy_xmin l3_xmin;
+   gr_info  *cod_info = NULL;
+   layer    *info;
+   int       save_bits[2][2];
+   double    noise[4];      /* over,max_noise,over_noise,tot_noise; */
+   double    targ_noise[4]; /* over,max_noise,over_noise,tot_noise; */
+   int       this_bits, dbits;
+   int       used_bits=0;
+   int       min_bits,max_bits,min_mean_bits=0;
+   int       frameBits[15];
+   int       bitsPerFrame;
+   int       bits;
+   int       mean_bits;
+   int       stereo = fr_ps->stereo;
+   int       i,ch, gr, mode_gr;
+   double    xr[2][2][576];
+   double xr_save[576];
+   double masking_lower_db;
+ 
+   iteration_init(xr_org,l3_side,l3_enc,fr_ps,&l3_xmin);
+   info = fr_ps->header;
+   mode_gr = (info->version == 1) ? 2 : 1;
+ 
+ 
+   /*******************************************************************
+    * how many bits are available for each bitrate?
+    *******************************************************************/
+   for( info->bitrate_index = VBR_min_bitrate;
+        info->bitrate_index <= VBR_max_bitrate;
+        info->bitrate_index++    ) {
+     getframebits (info, stereo, &bitsPerFrame, &mean_bits);
+     if (info->bitrate_index == VBR_min_bitrate) {
+       /* always use at least this many bits per granule per channel */
+       min_mean_bits=mean_bits/stereo;
+     }
+     frameBits[info->bitrate_index]=
+       ResvFrameBegin (fr_ps, l3_side, mean_bits, bitsPerFrame);
+     //printf("framebits = %i \n",frameBits[info->bitrate_index]);
+   }
+ 
+   info->bitrate_index=VBR_max_bitrate;
+ 
+   
+   /*******************************************************************
+    * how many bits would we use of it?
+    *******************************************************************/
+   for (gr = 0; gr < mode_gr; gr++) {
+     int num_chan=stereo;
+     /* determine quality based on mid channel only */
+     if (reduce_sidechannel) num_chan=1;  
+ 
+     /* copy data to be quantized into xr */
+     if (convert_mdct) ms_convert(xr[gr],xr_org[gr]);
+     else memcpy(xr[gr],xr_org[gr],sizeof(double)*2*576);   
+ 
+     
+ 
+ 
+ 
+     for (ch = 0; ch < num_chan; ch++) { 
+       /******************************************************************
+        * find smallest number of bits for an allowable quantization
+        ******************************************************************/
+       memcpy(xr_save,xr[gr][ch],sizeof(double)*576);   
+       cod_info = &l3_side->gr[gr].ch[ch].tt;
+       min_bits = Max(125,min_mean_bits);
+       if (cod_info->block_type ==2) {
+ 	min_bits += Max(1100,pe[gr][ch]);
+ 	min_bits=Min(min_bits,1800);
+       }
+ 
+       max_bits = 1200 + frameBits[VBR_max_bitrate]/(stereo*mode_gr);
+       max_bits=Min(max_bits,2500);
+       max_bits=Max(max_bits,min_bits);
+ 
+ 
+       /** in the case we will not find any better, we allocate max_bits
+        ****************************************************************/
+       save_bits[gr][ch] = max_bits;
+ 
+       dbits = (max_bits-min_bits)/4;
+       this_bits = (max_bits+min_bits)/2;  
+       /* bin search to within +/- 10 bits of optimal */
+       do {
+ 	int better;
+ 	double fac;
+ 	assert(this_bits>=min_bits);
+ 	assert(this_bits<=max_bits);
+ 
+ 	/* quality setting */
+ 	/* Adjust allowed masking based on quality setting */
+ 	/* db_lower varies from -10 to +8 db */
+ 	masking_lower_db = -10 + 2*VBR_q;
+ 	/* adjust by -6(min)..0(max) depending on bitrate */
+ 	fac=(double)(this_bits-125)/(double)(2500-125);
+ 	fac = 6*(fac-1);
+ 	//fac = 3*(fac-1);
+ 
+ 	masking_lower_db += fac;
+ 	masking_lower = pow(10.0,masking_lower_db/10);
+ 
+ 
+ 	
+ 
+ 	/* VBR will look for a quantization which has better values
+ 	 * then those specified below.*/
+ 	targ_noise[0]=0;          /* over */
+ 	targ_noise[1]=0;          /* max_noise */
+ 	targ_noise[2]=0;          /* over_noise */
+ 	targ_noise[3]=-2;          /* tot_noise */
+ 	
+ 	targ_noise[0]=Max(0,targ_noise[0]);
+ 	targ_noise[2]=Max(0,targ_noise[2]);
+ 
+ 
+ 	/* restore xr */
+ 	memcpy(xr[gr][ch],xr_save,sizeof(double)*576);   
+ 	outer_loop( xr, this_bits, noise, targ_noise, 1,&l3_xmin,l3_enc, fr_ps, 
+ 	    scalefac,gr,stereo, l3_side, ratio, ms_ener_ratio[gr], ch);
+ 
+ 	/* is quantization as good as we are looking for ? */
+ 	better=VBR_compare((int)targ_noise[0],targ_noise[3],targ_noise[2],
+             targ_noise[1],(int)noise[0],noise[3],noise[2],noise[1]);
+ 
+        if (better) {
+ 	  save_bits[gr][ch] = this_bits;
+           this_bits -= dbits;
+         } else {
+           this_bits += dbits;
+         }
+         dbits /= 2;
+       } while (dbits>10) ;
+       used_bits += save_bits[gr][ch];
+       
+     } /* for */
+   } /* for */
+ 
+ 
+   if (reduce_sidechannel) {
+     /* number of bits needed was found for MID channel above.  Use formula
+      * (fixed bitrate code) to set the side channel bits */
+     for (gr = 0; gr < mode_gr; gr++) {
+       double fac = .33*(.5-ms_ener_ratio[gr])/.5;
+       save_bits[gr][1]=((1-fac)/(1+fac))*save_bits[gr][0];
+       used_bits += save_bits[gr][1];
+     }
+   }
+ 
+   
+   /******************************************************************
+    * find lowest bitrate able to hold used bits
+    ******************************************************************/
+   for( info->bitrate_index = VBR_min_bitrate;
+        info->bitrate_index < VBR_max_bitrate;
+        info->bitrate_index++    )
+     if( used_bits <= frameBits[info->bitrate_index] ) break;
+ 
+ 
+   /*******************************************************************
+    * calculate quantization for this bitrate
+    *******************************************************************/  
+   getframebits (info, stereo, &bitsPerFrame, &mean_bits);
+   bits=ResvFrameBegin (fr_ps, l3_side, mean_bits, bitsPerFrame);
+ 
+   /* repartion available bits in same proportion */
+   if (used_bits > bits ) {
+     for( gr = 0; gr < mode_gr; gr++) {
+       for(ch = 0; ch < stereo; ch++) {
+ 	save_bits[gr][ch]=(save_bits[gr][ch]*frameBits[info->bitrate_index])/used_bits;
+       }
+     }
+     used_bits=0;
+     for( gr = 0; gr < mode_gr; gr++) {
+       for(ch = 0; ch < stereo; ch++) {
+ 	used_bits += save_bits[gr][ch];
+       }
+     }
+   }
+   assert(used_bits <= bits);
+ 
+   for(gr = 0; gr < mode_gr; gr++) {
+     /* copy data to be quantized into xr */
+     if (convert_mdct) ms_convert(xr[gr],xr_org[gr]);
+     else memcpy(xr[gr],xr_org[gr],sizeof(double)*2*576);   
+     for(ch = 0; ch < stereo; ch++) {
+       outer_loop( xr, save_bits[gr][ch], noise,targ_noise,0,
+ 		  &l3_xmin,l3_enc, fr_ps, 
+ 		  scalefac,gr,stereo, l3_side, ratio, ms_ener_ratio[gr], ch);
+     }
+   }
+ 
+   /*******************************************************************
+    * update reservoir status after FINAL quantization/bitrate 
+    *******************************************************************/
+   for (gr = 0; gr < mode_gr; gr++)
+     for (ch = 0; ch < stereo; ch++) {
+       cod_info = &l3_side->gr[gr].ch[ch].tt;
+       ResvAdjust (fr_ps, cod_info, l3_side, mean_bits);
+     }
+ 
+   /*******************************************************************
+    * set the sign of l3_enc 
+    *******************************************************************/
+   for (gr = 0; gr < mode_gr; gr++)
+     for (ch = 0; ch < stereo; ch++) {
+       int      *pi = &l3_enc[gr][ch][0];
+ 
+       for (i = 0; i < 576; i++) {
+         double    pr = xr[gr][ch][i];
+ 
+         if ((pr < 0) && (pi[i] > 0))
+           pi[i] *= -1;
+       }
+     }
+ 
+   ResvFrameEnd (fr_ps, l3_side, mean_bits);
+ }
+ 
+ 
+ 
+ 
+ /************************************************************************/
+ /*  init_outer_loop  mt 6/99                                            */
+ /************************************************************************/
+ void init_outer_loop(
+     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
+     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
+     III_scalefac_t *scalefac, /* scalefactors */
+     int gr, int stereo, III_side_info_t *l3_side,
+     III_psy_ratio *ratio, int ch)
+ {
+   int sfb,i;
+   gr_info *cod_info;  
+   cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 
+   /* compute max allowed distortion */
+   calc_xmin( xr, ratio, cod_info, l3_xmin, gr, ch );
+ 
+   /* if ( info->version == 1 )
+      calc_scfsi( xr[gr][ch], l3_side, &l3_xmin, ch, gr ); 
+   */
+   
+     
+   /* reset of iteration variables */
+     
+   for ( sfb = 0; sfb < SFB_LMAX; sfb++ )
+     scalefac->l[gr][ch][sfb] = 0;
+   for ( sfb = 0; sfb < SFB_SMAX; sfb++ )
+     for ( i = 0; i < 3; i++ )
+       scalefac->s[gr][ch][sfb][i] = 0;
+   
+   for ( i = 0; i < 4; i++ )
+     cod_info->slen[i] = 0;
+   cod_info->sfb_partition_table = &nr_of_sfb_block[0][0][0];
+   
+   cod_info->part2_3_length    = 0;
+   cod_info->big_values        = ((cod_info->block_type==2)?288:0);
+   cod_info->count1            = 0;
+   cod_info->scalefac_compress = 0;
+   cod_info->table_select[0]   = 0;
+   cod_info->table_select[1]   = 0;
+   cod_info->table_select[2]   = 0;
+   cod_info->subblock_gain[0]  = 0;
+   cod_info->subblock_gain[1]  = 0;
+   cod_info->subblock_gain[2]  = 0;
+   cod_info->region0_count     = 0;
+   cod_info->region1_count     = 0;
+   cod_info->part2_length      = 0;
+   cod_info->preflag           = 0;
+   cod_info->scalefac_scale    = 0;
+   cod_info->quantizerStepSize = 0.0;
+   cod_info->count1table_select= 0;
+   cod_info->address1          = 0;
+   cod_info->address2          = 0;
+   cod_info->address3          = 0;
+   
+   
+   if (experimentalZ) {
+     /* compute subblock gains */
+     int j,b;  double en[3],mx;
+     if ((cod_info->block_type ==2) ) {
+       /* estimate energy within each subblock */
+       for (b=0; b<3; b++) en[b]=0;
+       for ( i=0,j = 0; j < 192; j++ ) {
+ 	for (b=0; b<3; b++) {
+ 	  en[b]+=xr[gr][ch][i]*xr[gr][ch][i];
+ 	  i++;
+ 	}
+       }
+       mx = 1e-12;
+       for (b=0; b<3; b++) mx=Max(mx,en[b]);
+       for (b=0; b<3; b++) en[b] = Max(en[b],1e-12)/mx;
+       //	printf("ener = %4.2f  %4.2f  %4.2f  \n",en[0],en[1],en[2]);
+       /* pick gain so that 2^(2gain)*en[0] = 1  */
+       /* gain = .5* log( 1/en[0] )/log(2) = -.5*log(en[])/log(2) */
+       for (b=0; b<3; b++) {
+ 	cod_info->subblock_gain[b]=nint2(-.5*log(en[b])/log(2.0));
+ 	if (cod_info->subblock_gain[b] > 2) 
+ 	  cod_info->subblock_gain[b]=2;
+ 	if (cod_info->subblock_gain[b] < 0) 
+ 	  cod_info->subblock_gain[b]=0;
+       }
+     }
+   }
+ }
+ 
+ 
+ /* old outer_loop routines which will eventually be removed are in: */
+ #include "loopold.c"    
+ 
+ 
+ /************************************************************************/
+ /*  outer_loop                                                         */
+ /************************************************************************/
+ /*  Function: The outer iteration loop controls the masking conditions  */
+ /*  of all scalefactorbands. It computes the best scalefac and          */
+ /*  global gain. This module calls the inner iteration loop             
+  * 
+  *  mt 5/99 completely rewritten to allow for bit reservoir control,   
+  *  mid/side channels with L/R or mid/side masking thresholds, 
+  *  and chooses best quantization instead of last quantization when 
+  *  no distortion free quantization can be found.  
+  *  
+  *  added VBR support mt 5/99
+  ************************************************************************/
+ void outer_loop(
+     double xr[2][2][576],        /*  could be L/R OR MID/SIDE */
+     int targ_bits,
+     double best_noise[4],
+     double targ_noise[4],
+     int sloppy,
+     III_psy_xmin  *l3_xmin,   /* the allowed distortion of the scalefactor */
+     int l3_enc[2][2][576],    /* vector of quantized values ix(0..575) */
+     frame_params *fr_ps,
+     III_scalefac_t *scalefac, /* scalefactors */
+     int gr, int stereo, III_side_info_t *l3_side,
+     III_psy_ratio *ratio, double ms_ener_ratio,
+     int ch)
+ {
+ 
+   int i, iteration;
+   int status,count=0,bits_found=0;
+   int real_bits=0;
+   int scalesave_l[CBLIMIT], scalesave_s[CBLIMIT][3];
+   int sfb, huff_bits;
+   double xfsf[4][CBLIMIT];
+   double xrpow[576],temp;
+   double distort[4][CBLIMIT];
+   int save_l3_enc[576];  
+   int save_real_bits=0;
+   int save_preflag=0, save_compress=0;
+   int better;
+   int over=0;
+   double max_noise;
+   double over_noise;
+   double tot_noise;
+   int best_over=0;
+   double best_max_noise=0;
+   double best_over_noise=0;
+   double best_tot_noise=0;
+   gr_info save_cod_info;
+   gr_info *cod_info;  
+   double xr_save[576];
+ 
+   int compute_stepsize=1;
+   int pre_just_turned_on;
+   int notdone=1;
+ 
+ 
+   
+ 
+   if (experimentalY) memcpy(xr_save,xr[gr][ch],sizeof(double)*576);   
+   cod_info = &l3_side->gr[gr].ch[ch].tt;
+   init_outer_loop(xr,l3_xmin,scalefac,gr,stereo,l3_side,ratio,ch);  
+   best_over = 100;
+   count=0;
+   for (i=0; i<576; i++) {
+     if ( fabs(xr[gr][ch][i]) > 0 ) count++; 
+   }
+   if (count==0) {
+     best_over=0;
+     notdone = 0;
+   }
+   
+ 
+   
+   /* BEGIN MAIN LOOP */
+   iteration = 0;
+   while ( notdone  ) {
+     int try_scale=0;
+     iteration ++;
+     
+     if (compute_stepsize) {
+       /* init and compute initial quantization step */
+       compute_stepsize=0;
+       for(i=0;i<576;i++) 	    {
+ 	temp=fabs(xr[gr][ch][i]);
+ 	xrpow[i]=sqrt(sqrt(temp)*temp);
+       }
+       bits_found=bin_search_StepSize2(targ_bits,-211.0,46,
+ 		  l3_enc[gr][ch],xr[gr][ch],xrpow,cod_info); 
+     }
+     
+     
+     
+     /* inner_loop starts with the initial quantization step computed above
+      * and slowly increases until the bits < huff_bits.
+      * Thus is it important not to start with too large of an inital
+      * quantization step.  Too small is ok, but inner_loop will take longer 
+      */
+     huff_bits = targ_bits - cod_info->part2_length;
+     if (huff_bits < 0) {
+       if (iteration==1) {
+ 	fprintf(stderr,"ERROR: outer_loop(): huff_bits < 0. \n");
+ 	exit(-5);
+       }else{
+ 	/* scale factors too large, not enough bits. use previous quantizaton */
+ 	notdone=0;
+       }
+     }else{
+       /* if this is the first iteration, see if we can reuse the quantization
+        * computed in bin_search_StepSize above */
+       if (iteration==1) {
+ 	if(bits_found>huff_bits) {
+ 	  cod_info->quantizerStepSize+=1.0;
+ 	  real_bits = inner_loop( xr, xrpow, l3_enc, huff_bits, cod_info, gr, ch );
+ 	} else real_bits=bits_found;
+       }
+       else 
+ 	real_bits=inner_loop( xr, xrpow, l3_enc, huff_bits, cod_info, gr, ch );
+     }
+     
+     
+     if (notdone) {
+       /* compute the distortion in this quantization */
+       if (fast_mode) {
+       	over=0;
+       }else{
+ 	/* coefficients and thresholds both l/r (or both mid/side) */
+ 	over=calc_noise1( xr[gr][ch], l3_enc[gr][ch], cod_info, 
+ 			  xfsf,distort, l3_xmin,gr,ch, &over_noise, 
+ 			  &tot_noise, &max_noise);
+       }
+             
+       /* check if this quantization is better the our saved quantization */
+       if (iteration == 1) better=1;
+       else 
+ 	better=quant_compare(
+ 	     best_over,best_tot_noise,best_over_noise,best_max_noise,
+                   over,     tot_noise,     over_noise,     max_noise);
+       
+       
+       /* save data so we can restore this quantization later */    
+       if (better) {
+ 	best_over=over;
+ 	best_max_noise=max_noise;
+ 	best_over_noise=over_noise;
+ 	best_tot_noise=tot_noise;
+ 	
+         /* we need not save the quantization when in sloppy mode, so skip
+          */ 
+         if (!sloppy) {
+ 	for ( sfb = 0; sfb < SFB_LMAX-1; sfb++ ) /* save scaling factors */
+ 	  scalesave_l[sfb] = scalefac->l[gr][ch][sfb];
+ 	
+ 	for ( sfb = 0; sfb < SFB_SMAX-1; sfb++ )
+ 	  for ( i = 0; i < 3; i++ )
+ 	    scalesave_s[sfb][i] = scalefac->s[gr][ch][sfb][i];
+ 	
+ 	save_preflag  = cod_info->preflag;
+ 	save_compress = cod_info->scalefac_compress;
+ 	
+ 	memcpy(save_l3_enc,l3_enc[gr][ch],sizeof(l3_enc[gr][ch]));   
+ 	memcpy(&save_cod_info,cod_info,sizeof(save_cod_info));
+ 	save_real_bits=real_bits;
+ 	
+ #ifdef HAVEGTK
+ 	if (gtkflag) {
+ 	  int l,start,end,bw;
+ 	  double en0;
+ 	  D192_3 *xr_s = (D192_3 *)xr[gr][ch];
+ 
+ 	  for ( i = 0; i < 3; i++ ) {
+ 	    for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )  {
+ 	      start = scalefac_band_short[ sfb ];
+ 	      end   = scalefac_band_short[ sfb + 1 ];
+ 	      bw = end - start;
+ 	      for ( en0 = 0.0, l = start; l < end; l++ ) 
+ 		en0 += (*xr_s)[l][i] * (*xr_s)[l][i];
+ 	      en0=Max(en0/bw,1e-20);
+ 	      /*
+ 	      pinfo->xfsf_s[gr][ch][3*sfb+i] =  
+ 		pinfo->thr_s[gr][ch][3*sfb+i]*xfsf[i+1][sfb]/
+ 		l3_xmin->s[gr][ch][sfb][i];
+ 	      */
+ 	      pinfo->xfsf_s[gr][ch][3*sfb+i] =  
+ 		pinfo->en_s[gr][ch][3*sfb+i]*xfsf[i+1][sfb]/en0;
+ 	      pinfo->thr_s[gr][ch][3*sfb+i] =  
+ 		pinfo->en_s[gr][ch][3*sfb+i]*l3_xmin->s[gr][ch][sfb][i]/en0;
+ 
+ 	    }
+ 	  }
+ 	  for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )   {
+ 	    start = scalefac_band_long[ sfb ];
+ 	    end   = scalefac_band_long[ sfb+1 ];
+ 	    bw = end - start;
+ 	    for ( en0 = 0.0, l = start; l < end; l++ ) 
+ 	      en0 += xr[gr][ch][l] * xr[gr][ch][l];
+ 	    en0=Max(en0/bw,1e-20);
+ 	    /* 
+ 	    pinfo->xfsf[gr][ch][sfb] =  
+ 	      pinfo->thr[gr][ch][sfb]*xfsf[0][sfb]/
+ 	      l3_xmin->l[gr][ch][sfb];
+ 	    */
+ 	    pinfo->xfsf[gr][ch][sfb] =  
+ 	      pinfo->en[gr][ch][sfb]*xfsf[0][sfb]/en0;
+ 	    pinfo->thr[gr][ch][sfb] =  
+ 	      pinfo->en[gr][ch][sfb]*l3_xmin->l[gr][ch][sfb]/en0;
+ 
+ 
+ 	  }
+ 	  pinfo->over[gr][ch]=over;
+ 	  pinfo->max_noise[gr][ch]=max_noise;
+ 	  pinfo->tot_noise[gr][ch]=tot_noise;
+ 	  pinfo->over_noise[gr][ch]=over_noise;
+ 	}
+ #endif
+         } /* end of sloppy skipping */
+       }
+     }
+ 
+     /* if no bands with distortion, we are done */
+     if (experimentalX==0)
+       if (over==0) notdone=0;
+ 
+     /* in sloppy mode, as soon as we know we can do better than targ_noise,
+        quit.  This is used for the inital VBR bin search.  Turn it off for
+        final (optimal) quantization */
+     if (sloppy && notdone) notdone = 
+         !VBR_compare((int)targ_noise[0],targ_noise[3],targ_noise[2],
+          targ_noise[1],over,tot_noise,over_noise,max_noise);
+ 
+ 
+ 
+     
+     
+     if (notdone) {
+       /* see if we should apply preemphasis */
+       pre_just_turned_on=
+ 	preemphasis(xr[gr][ch],xrpow,l3_xmin,gr,ch,l3_side,distort);
+ 
+       /* if we didn't just apply pre-emph, let us see if we should 
+        * amplify some scale factor bands */
+       if (!pre_just_turned_on) {
+ 	notdone = amp_scalefac_bands( xr[gr][ch], xrpow, l3_xmin,
+ 			     l3_side, scalefac, gr, ch, iteration,distort);
+       }
+     }
+       
+       
+     if (notdone) {            
+       /* check to make sure we have not amplified too much */
+       if ( (status = loop_break(scalefac, cod_info, gr, ch)) == 0 ) {
+ 	if ( fr_ps->header->version == 1 ) {
+ 	  status = scale_bitcount( scalefac, cod_info, gr, ch );
+ 	  if (status && (cod_info->scalefac_scale==0)) try_scale=1; 
+ 	}else{
+ 	  status = scale_bitcount_lsf( scalefac, cod_info, gr, ch );
+ 	  if (status && (cod_info->scalefac_scale==0)) try_scale=1; 
+ 	}
+       }
+       notdone = !status;
+     }    
+     
+ 
+     
+     if (try_scale && experimentalY) {
+       memcpy(xr[gr][ch],xr_save,sizeof(double)*576);   
+       init_outer_loop(xr,l3_xmin,scalefac,gr,stereo,l3_side,ratio,ch);  
+       compute_stepsize=1;  /* compute a new global gain */
+       notdone=1;
+       cod_info->scalefac_scale=1;
+     }
+   }    /* done with main iteration */
+   
+   
+   /* in sloppy mode we don�t need to restore the quantization, 
+    * cos we didn�t saved it and we don�t need it, as we only want
+    * to know if we can do better
+    */
+   if (!sloppy)
+   /* restore some data */
+   if (count ) {
+     cod_info->preflag = save_preflag;
+     cod_info->scalefac_compress = save_compress;
+     
+     for ( sfb = 0; sfb < SFB_LMAX-1; sfb++ ) {
+       scalefac->l[gr][ch][sfb] = scalesave_l[sfb];    
+     }
+     
+     for ( i = 0; i < 3; i++ )
+       for ( sfb = 0; sfb < SFB_SMAX-1; sfb++ ) {
+ 	scalefac->s[gr][ch][sfb][i] = scalesave_s[sfb][i];    
+       }
+     
+     { 
+       real_bits=save_real_bits;  
+       memcpy(l3_enc[gr][ch],save_l3_enc,sizeof(l3_enc[gr][ch]));   
+       memcpy(cod_info,&save_cod_info,sizeof(save_cod_info));
+       
+       if ( fr_ps->header->version == 1 ) {
+ 	status = scale_bitcount( scalefac, cod_info, gr, ch );
+       } else {
+ 	status = scale_bitcount_lsf( scalefac, cod_info, gr, ch );
+       }
+       if (status) {
+ 	fprintf(stderr,"Error recomputing scalefac_compress...this should not happen");
+ 	exit(-10);
+       }
+     }
+     cod_info->part2_3_length = cod_info->part2_length + real_bits;
+     
+ #ifdef HAVEGTK
+     if (gtkflag)
+       pinfo->LAMEmainbits[gr][ch]=cod_info->part2_3_length;
+ #endif
+   }      
+   
+   
+   /* finish up */
+   cod_info->global_gain = nint2( cod_info->quantizerStepSize + 210.0 );
+   assert( cod_info->global_gain < 256 );
+ 
+   best_noise[0]=best_over;
+   best_noise[1]=best_max_noise;
+   best_noise[2]=best_over_noise;
+   best_noise[3]=best_tot_noise;
+ }
+ 
+ 
+ 
+ 
+ 
+   
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************** 
+  *         inner_loop                                                      * 
+  *************************************************************************** 
+  * The code selects the best quantizerStepSize for a particular set
+  * of scalefacs                                                            */
+  
+ int
+ inner_loop( double xr[2][2][576], double xrpow[576],
+ 	    int l3_enc[2][2][576], int max_bits,
+ 	    gr_info *cod_info, int gr, int ch )
+ {
+     int bits;
+     assert( max_bits >= 0 );
+     cod_info->quantizerStepSize -= 1.0;;
+     do
+     {
+       cod_info->quantizerStepSize += 1.0;
+       quantize_xrpow( xrpow, l3_enc[gr][ch], cod_info );
+       bits = count_bits(l3_enc[gr][ch],cod_info);  
+     }
+     while ( bits > max_bits );
+     return bits;
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            scale_bitcount                                             */
+ /*************************************************************************/
+ 
+ /* Also calculates the number of bits necessary to code the scalefactors. */
+ 
+ int scale_bitcount( III_scalefac_t *scalefac, gr_info *cod_info,
+ 		int gr, int ch )
+ {
+     int i, k, sfb, max_slen1 = 0, max_slen2 = 0, /*a, b, */ ep = 2;
+ 
+     //    static int slen1[16] = { 0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 };
+     //    static int slen2[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3 };
+     static int slen1[16] = { 1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8,16,16 };
+     static int slen2[16] = { 1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8 };
+ 
+     static int slen1_tab[16] = {0,
+ 	18, 36, 54, 54, 36, 54, 72, 54, 72, 90, 72, 90,108,108,126
+     };
+     static int slen2_tab[16] = {0,
+ 	10, 20, 30, 33, 21, 31, 41, 32, 42, 52, 43, 53, 63, 64, 74
+     };
+     int *tab;
+ 
+ 
+     if ( cod_info->block_type == 2 )
+     {
+             tab = slen1_tab;
+             /* a = 18; b = 18;  */
+             for ( i = 0; i < 3; i++ )
+             {
+                 for ( sfb = 0; sfb < 6; sfb++ )
+                     if ( scalefac->s[gr][ch][sfb][i] > max_slen1 )
+                         max_slen1 = scalefac->s[gr][ch][sfb][i];
+                 for (sfb = 6; sfb < 12; sfb++ )
+                     if ( scalefac->s[gr][ch][sfb][i] > max_slen2 )
+                         max_slen2 = scalefac->s[gr][ch][sfb][i];
+             }
+     }
+     else
+     { /* block_type == 1,2,or 3 */
+         tab = slen2_tab;
+         /* a = 11; b = 10;   */
+         for ( sfb = 0; sfb < 11; sfb++ )
+             if ( scalefac->l[gr][ch][sfb] > max_slen1 )
+                 max_slen1 = scalefac->l[gr][ch][sfb];
+         for ( sfb = 11; sfb < 21; sfb++ )
+             if ( scalefac->l[gr][ch][sfb] > max_slen2 )
+                 max_slen2 = scalefac->l[gr][ch][sfb];
+     }
+ 
+ 
+ 
+     /* from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99
+      * loop over *all* posible values of scalefac_compress to find the
+      * one which uses the smallest number of bits.  ISO would stop
+      * at first valid index */
+     cod_info->part2_length=10000;
+     for ( k = 0; k < 16; k++ )
+     {
+         if ( (max_slen1 < slen1[k]) && (max_slen2 < slen2[k]) &&
+              (cod_info->part2_length > tab[k])) {
+ 	  cod_info->part2_length=tab[k];
+ 	  cod_info->scalefac_compress=k;
+ 	  ep=0;  /* we found a suitable scalefac_compress */
+ 	  //break;  
+ 	}
+     }
+ 
+     //    if ( ep == 0 )  cod_info->scalefac_compress = k;
+     return ep;
+ }
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            scale_bitcount_lsf                                         */
+ /*************************************************************************/
+ 
+ /* Also counts the number of bits to encode the scalefacs but for MPEG 2 */ 
+ /* Lower sampling frequencies  (24, 22.05 and 16 kHz.)                   */
+  
+ /*  This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,     */
+ /* "Audio Decoding Layer III"                                            */
+ 
+ int scale_bitcount_lsf( III_scalefac_t *scalefac, gr_info *cod_info,
+ 		    int gr, int ch )
+ {
+     int table_number, row_in_table, partition, nr_sfb, window, over;
+     int i, sfb, max_sfac[ 4 ];
+     unsigned *partition_table;
+ 
+     /*
+       Set partition table. Note that should try to use table one,
+       but do not yet...
+     */
+     if ( cod_info->preflag )
+ 	table_number = 2;
+     else
+ 	table_number = 0;
+ 
+     for ( i = 0; i < 4; i++ )
+ 	max_sfac[i] = 0;
+ 
+     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
+     {
+ 	    row_in_table = 1;
+ 	    partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	    for ( sfb = 0, partition = 0; partition < 4; partition++ )
+ 	    {
+ 		nr_sfb = partition_table[ partition ] / 3;
+ 		for ( i = 0; i < nr_sfb; i++, sfb++ )
+ 		    for ( window = 0; window < 3; window++ )
+ 			if ( scalefac->s[gr][ch][sfb][window] > max_sfac[partition] )
+ 			    max_sfac[partition] = scalefac->s[gr][ch][sfb][window];
+ 	    }
+     }
+     else
+     {
+ 	row_in_table = 0;
+ 	partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	for ( sfb = 0, partition = 0; partition < 4; partition++ )
+ 	{
+ 	    nr_sfb = partition_table[ partition ];
+ 	    for ( i = 0; i < nr_sfb; i++, sfb++ )
+ 		if ( scalefac->l[gr][ch][sfb] > max_sfac[partition] )
+ 		    max_sfac[partition] = scalefac->l[gr][ch][sfb];
+ 	}
+     }
+ 
+     for ( over = 0, partition = 0; partition < 4; partition++ )
+     {
+ 	if ( max_sfac[partition] > max_sfac_tab[table_number][partition] )
+ 	    over++;
+     }
+     if ( !over )
+     {
+ 	/*
+ 	  Since no bands have been over-amplified, we can set scalefac_compress
+ 	  and slen[] for the formatter
+ 	*/
+ 	static int log2tab[] = { 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4 };
+ 
+ 	unsigned slen1, slen2, slen3, slen4;
+ 
+         cod_info->sfb_partition_table = &nr_of_sfb_block[table_number][row_in_table][0];
+ 	for ( partition = 0; partition < 4; partition++ )
+ 	    cod_info->slen[partition] = log2tab[max_sfac[partition]];
+ 
+ 	/* set scalefac_compress */
+ 	slen1 = cod_info->slen[ 0 ];
+ 	slen2 = cod_info->slen[ 1 ];
+ 	slen3 = cod_info->slen[ 2 ];
+ 	slen4 = cod_info->slen[ 3 ];
+ 
+ 	switch ( table_number )
+ 	{
+ 	  case 0:
+ 	    cod_info->scalefac_compress = (((slen1 * 5) + slen2) << 4)
+ 		+ (slen3 << 2)
+ 		+ slen4;
+ 	    break;
+ 
+ 	  case 1:
+ 	    cod_info->scalefac_compress = 400
+ 		+ (((slen1 * 5) + slen2) << 2)
+ 		+ slen3;
+ 	    break;
+ 
+ 	  case 2:
+ 	    cod_info->scalefac_compress = 500 + (slen1 * 3) + slen2;
+ 	    break;
+ 
+ 	  default:
+ 	    fprintf( stderr, "intensity stereo not implemented yet\n" );
+ 	    exit( EXIT_FAILURE );
+ 	    break;
+ 	}
+     }
+ #ifdef DEBUG
+     if ( over ) 
+         printf( "---WARNING !! Amplification of some bands over limits\n" );
+ #endif
+     if (!over) {
+       assert( cod_info->sfb_partition_table );     
+       cod_info->part2_length=0;
+       for ( partition = 0; partition < 4; partition++ )
+ 	cod_info->part2_length += cod_info->slen[partition] * cod_info->sfb_partition_table[partition];
+     }
+     return over;
+ }
+ 
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            calc_noise                                                 */
+ /*************************************************************************/
+ /*  mt 5/99:  Function: Improved calc_noise for a single channel   */
+ int calc_noise1( double xr[576], int ix[576], gr_info *cod_info,
+             double xfsf[4][CBLIMIT], double distort[4][CBLIMIT],
+             III_psy_xmin *l3_xmin,int gr, int ch, double *over_noise,
+             double *tot_noise, double *max_noise)
+ 
+ {
+     int start, end, sfb, l, i, over=0;
+     double sum,step,bw;
+ 
+     D192_3 *xr_s;
+     I192_3 *ix_s;
+ 
+     static double pow43[PRECALC_SIZE];
+     static int init=0;
+     int count=0;
+     double noise;
+     *over_noise=0;
+     *tot_noise=0;
+     *max_noise=-999;
+ 
+     if (init==0) {
+       init++;
+       for(i=0;i<PRECALC_SIZE;i++)
+         pow43[i] = pow((double)i, 4.0/3.0);
+     }
+       
+     xr_s = (D192_3 *) xr;
+     ix_s = (I192_3 *) ix;
+ 
+     step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 );
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+     {
+         start = scalefac_band_long[ sfb ];
+         end   = scalefac_band_long[ sfb+1 ];
+         bw = end - start;
+ 
+         for ( sum = 0.0, l = start; l < end; l++ )
+         {
+             double temp;
+             temp = fabs(xr[l]) - pow43[ix[l]] * step;
+             sum += temp * temp;
+         }
+         xfsf[0][sfb] = sum / bw;
+ 	// max -30db noise below threshold 
+ 	noise = 10*log10(Max(.001,xfsf[0][sfb] / l3_xmin->l[gr][ch][sfb]));
+         distort[0][sfb] = noise;
+         if (noise>0) {
+ 	  over++;
+           //*over_noise += xfsf[0][sfb] - l3_xmin->l[gr][ch][sfb];
+ 	  *over_noise += noise;
+ 	}
+ 	*tot_noise += noise;
+ 	*max_noise=Max(*max_noise,noise);
+ 	count++;
+ 
+     }
+ 
+ 
+     for ( i = 0; i < 3; i++ )
+     {
+         step = pow( 2.0, (cod_info->quantizerStepSize) * 0.25 ); /*
+ subblock_gain ? */
+         if (cod_info->subblock_gain[i] )
+           step *= pow(2.0,-2.0*cod_info->subblock_gain[i]);
+ 
+         for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
+         {
+             start = scalefac_band_short[ sfb ];
+             end   = scalefac_band_short[ sfb+1 ];
+             bw = end - start;
+             
+             for ( sum = 0.0, l = start; l < end; l++ )
+             {
+                 double temp;
+                 temp = fabs((*xr_s)[l][i]) - pow43[(*ix_s)[l][i]] * step;
+                 sum += temp * temp;
+             }       
+             xfsf[i+1][sfb] = sum / bw;
+ 	    // max -30db noise below threshold 
+ 	    noise = 10*log10(Max(.001,xfsf[i+1][sfb] / l3_xmin->s[gr][ch][sfb][i] ));
+             distort[i+1][sfb] = noise;
+             if (noise > 0) {
+ 	      over++;
+ 	      //*over_noise +=xfsf[i+1][sfb]-l3_xmin->s[gr][ch][sfb][i];
+ 	      *over_noise += noise;
+ 	    }
+ 	    *tot_noise += noise;
+ 	    *max_noise=Max(*max_noise,noise);
+ 	    count++;	    
+         }
+     }
+ 
+ 	if (count>1) *tot_noise /= count;
+ 	if (over>1) *over_noise /= over;
+ 	return over;
+ }
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            calc_xmin                                                  */
+ /*************************************************************************/
+ 
+ /*
+   Calculate the allowed distortion for each scalefactor band,
+   as determined by the psychoacoustic model.
+   xmin(sb) = ratio(sb) * en(sb) / bw(sb)
+ */
+ void calc_xmin( double xr[2][2][576], III_psy_ratio *ratio,
+ 	   gr_info *cod_info, III_psy_xmin *l3_xmin,
+ 	   int gr, int ch )
+ {
+     int start, end, sfb, l, b;
+     double en0, bw, ener;
+ 
+     D192_3 *xr_s;
+     xr_s = (D192_3 *) xr[gr][ch] ;
+ 
+     if (ATHonly) {    
+       for ( sfb = cod_info->sfb_smax; sfb < SFB_SMAX - 1; sfb++ )
+ 	  for ( b = 0; b < 3; b++ )
+ 	      l3_xmin->s[gr][ch][sfb][b]=ATH_s[sfb];
+       for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+ 	  l3_xmin->l[gr][ch][sfb]=ATH_l[sfb];
+       
+     }else{
+ 
+       for ( sfb = cod_info->sfb_smax; sfb < SFB_SMAX - 1; sfb++ ){
+ 	start = scalefac_band_short[ sfb ];
+         end   = scalefac_band_short[ sfb + 1 ];
+ 	bw = end - start;
+         for ( b = 0; b < 3; b++ ) {
+ 	  for ( en0 = 0.0, l = start; l < end; l++ ) {
+ 	    ener = (*xr_s)[l][b] * (*xr_s)[l][b];
+ 	    en0 += ener;
+ 	  }
+ 	  l3_xmin->s[gr][ch][sfb][b] = masking_lower*ratio->s[gr][ch][sfb][b] * en0/bw;
+ 	  l3_xmin->s[gr][ch][sfb][b]=Max(ATH_s[sfb],l3_xmin->s[gr][ch][sfb][b]);
+ 	}
+       }
+       
+       
+       for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ ){
+ 	start = scalefac_band_long[ sfb ];
+ 	end   = scalefac_band_long[ sfb+1 ];
+ 	bw = end - start;
+ 	
+         for ( en0 = 0.0, l = start; l < end; l++ ) {
+ 	  ener = xr[gr][ch][l] * xr[gr][ch][l];
+ 	  en0 += ener;
+ 	}
+ 	
+         l3_xmin->l[gr][ch][sfb] =masking_lower*ratio->l[gr][ch][sfb] * en0/bw;
+ 	l3_xmin->l[gr][ch][sfb]=Max(ATH_l[sfb],l3_xmin->l[gr][ch][sfb]);
+       }
+     }
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            loop_break                                                 */
+ /*************************************************************************/
+ 
+ /*  Function: Returns zero if there is a scalefac which has not been
+     amplified. Otherwise it returns one. 
+ */
+ 
+ int loop_break( III_scalefac_t *scalefac, gr_info *cod_info,
+ 	    int gr, int ch )
+ {
+     int i, sfb;
+ 
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+         if ( scalefac->l[gr][ch][sfb] == 0 )
+ 	    return 0;
+ 
+     for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ )
+         for ( i = 0; i < 3; i++ )
+             if ( scalefac->s[gr][ch][sfb][i] == 0 )
+ 		return 0;
+ 
+     return 1;
+ }
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            preemphasis                                                */
+ /*************************************************************************/
+ 
+ /*
+   See ISO 11172-3  section  C.1.5.4.3.4
+ */
+ int preemphasis( double xr[576], double xrpow[576], 
+      III_psy_xmin  *l3_xmin,
+      int gr, int ch, III_side_info_t *l3_side, double distort[4][CBLIMIT] )
+ {
+     int i, sfb, start, end, over;
+     double ifqstep;
+     gr_info *cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 
+ 
+     /*
+       Preemphasis is switched on if in all the upper four scalefactor
+       bands the actual distortion exceeds the threshold after the
+       first call of the inner loop
+     */
+     over = 0;
+     if ( cod_info->block_type != 2 && cod_info->preflag == 0 )
+     {	
+ 	for ( sfb = 17; sfb < 21; sfb++ )
+ 	    if ( distort[0][sfb]>0 ) over++;
+ 
+ 	if (over == 4 )
+ 	{
+ 	    double t,t34;
+ 	    cod_info->preflag = 1;
+ 	    ifqstep = ( cod_info->scalefac_scale == 0 ) ? SQRT2 : 2.0;
+ 	    for ( sfb = 11; sfb < cod_info->sfb_lmax; sfb++ )
+ 	    {
+ 		t=pow( ifqstep, (double) pretab[sfb] );
+ 		t34=sqrt(sqrt(t)*t);
+ 		l3_xmin->l[gr][ch][sfb] *= t*t;
+ 		start = scalefac_band_long[ sfb ];
+ 		end   = scalefac_band_long[ sfb+1 ];
+ 		for( i = start; i < end; i++ ) xr[i]*=t;
+ 		for( i = start; i < end; i++ ) xrpow[i]*=t34;
+ 	    }
+ 	}
+     }
+     return (over == 4);
+ }
+ 
+ 
+ 
+ 
+ /*************************************************************************/
+ /*            amp_scalefac_bands                                         */
+ /*************************************************************************/
+ 
+ /* 
+   Amplify the scalefactor bands that violate the masking threshold.
+   See ISO 11172-3 Section C.1.5.4.3.5
+ */
+ int amp_scalefac_bands( double xr[576], double xrpow[576], 
+ 		    III_psy_xmin *l3_xmin, III_side_info_t *l3_side,
+ 		    III_scalefac_t *scalefac,
+ 		    int gr, int ch, int iteration, double distort[4][CBLIMIT])
+ {
+     int start, end, l, sfb, i, over = 0;
+     double ifqstep, ifqstep2, ifqstep34;
+     double distort_thresh;
+     D192_3 *xr_s;
+     D192_3 *xrpow_s;
+     gr_info *cod_info;
+     cod_info = &l3_side->gr[gr].ch[ch].tt;
+ 
+     xr_s = (D192_3 *) xr;
+     xrpow_s = (D192_3 *) xrpow;
+ 
+ 
+     if ( cod_info->scalefac_scale == 0 )
+ 	ifqstep = SQRT2;
+     else
+ 	ifqstep = 2.0;
+ 
+ 
+     ifqstep2 = ifqstep * ifqstep;
+     ifqstep34=sqrt(sqrt(ifqstep)*ifqstep);
+ 
+     /* distort_thresh = 0, unless all bands have distortion 
+      * less than masking.  In that case, just amplify bands with distortion
+      * within 95% of largest distortion/masking ratio */
+     distort_thresh = -900;
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+       distort_thresh = Max(1.05*distort[0][sfb],distort_thresh);
+     distort_thresh=Min(distort_thresh,0.0);
+ 
+ 
+     for ( sfb = 0; sfb < cod_info->sfb_lmax; sfb++ )
+     {
+ 	if ( distort[0][sfb]>distort_thresh  ) 
+ 	{
+ 	    over++;
+ 	    l3_xmin->l[gr][ch][sfb] *= ifqstep2;
+ 	    scalefac->l[gr][ch][sfb]++;
+ 	    start = scalefac_band_long[sfb];
+ 	    end   = scalefac_band_long[sfb+1];
+ 	    for ( l = start; l < end; l++ ) xr[l] *= ifqstep;
+ 	    for ( l = start; l < end; l++ ) xrpow[l] *= ifqstep34;
+ 	}
+     }
+ 
+ 
+ 
+     /*
+       Note that scfsi is not enabled for frames containing
+       short blocks
+     */
+ 
+     distort_thresh = -900;
+     for ( i = 0; i < 3; i++ )
+       for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ ) {
+ 	  distort_thresh = Max(1.05*distort[i+1][sfb],distort_thresh);
+       }
+     distort_thresh=Min(distort_thresh,0.0);
+ 
+ 
+     for ( i = 0; i < 3; i++ )
+       for ( sfb = cod_info->sfb_smax; sfb < 12; sfb++ ) {
+             if ( distort[i+1][sfb]>distort_thresh)
+             {
+                 over++;
+                 l3_xmin->s[gr][ch][sfb][i] *= ifqstep2;
+                 scalefac->s[gr][ch][sfb][i]++;
+                 start = scalefac_band_short[sfb];
+                 end   = scalefac_band_short[sfb+1];
+                 for ( l = start; l < end; l++ ) (*xr_s)[l][i] *= ifqstep;
+ 		for ( l = start; l < end; l++ ) (*xrpow_s)[l][i] *= ifqstep34;
+             }
+       }
+     return over;
+ }
+ 
+ 
+ 
+ 
+ #ifdef _MSC_VER
+ #define MSVC_XRPOW_ASM
+ #ifdef MSVC_XRPOW_ASM
+ # define MSVC_FTOL(src, dest) do { \
+     double src_ = (src); \
+     int dest_; \
+     { \
+       __asm fld src_ \
+       __asm fistp dest_ \
+     } \
+     (dest) = dest_; \
+   } while (0)
+ # endif
+ #endif
+ 
+ void quantize_xrpow( double xr[576], int ix[576], gr_info *cod_info )
+ {
+   /* quantize on xr^(3/4) instead of xr */
+   register int j;
+   double quantizerStepSize;
+   double istep_l,istep0,istep1,istep2;
+ #if defined(__GNUC__) && defined(__i386__) 
+ #elif defined(MSVC_XRPOW_ASM)
+ #else
+   double compareval0;
+ #endif
+ 
+   quantizerStepSize = cod_info->quantizerStepSize;
+   
+   istep_l = pow ( 2.0, quantizerStepSize * -0.1875 );
+   
+   if ((cod_info->block_type==2))
+     {
+       istep0 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[0]);
+       istep1 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[1]);
+       istep2 = istep_l * pow(2.0,1.5* (double) cod_info->subblock_gain[2]);
+       for (j=192;j>0;j--) 
+         {
+ #if defined(__GNUC__) && defined(__i386__)
+           asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep0*(*(xr++)) - 0.0946): "st");
+           asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep1*(*(xr++)) - 0.0946): "st");
+           asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep2*(*(xr++)) - 0.0946): "st");
+ #elif defined(MSVC_XRPOW_ASM)
+           MSVC_FTOL((istep0*(*(xr++)) - 0.0946), *(ix++));
+           MSVC_FTOL((istep1*(*(xr++)) - 0.0946), *(ix++));
+           MSVC_FTOL((istep2*(*(xr++)) - 0.0946), *(ix++));
+ #else
+           *(ix++) = (int)( istep0*(*(xr++))  + 0.4054);
+           *(ix++) = (int)( istep1*(*(xr++))  + 0.4054);
+           *(ix++) = (int)( istep2*(*(xr++))  + 0.4054);
+ #endif
+         }
+     }
+   else
+     {
+ #if defined(__GNUC__) && defined(__i386__) 
+       for (j=576;j>0;j--) 
+           asm ("fistpl %0 ": "=m"(*(ix++)): "t"(istep_l*(*(xr++)) - 0.0946): "st");
+ #elif defined(MSVC_XRPOW_ASM)
+       for (j=576;j>0;j--) {
+         MSVC_FTOL((istep_l*(*(xr++)) - 0.0946), *(ix++));
+       }
+ #else
+       compareval0 = (1.0 - 0.4054)/istep_l;
+       /* depending on architecture, it may be worth calculating a few more compareval's.
+          eg.  compareval1 = (2.0 - 0.4054/istep_l); 
+               .. and then after the first compare do this ...
+               if compareval1>*xr then ix = 1;
+          On a pentium166, it's only worth doing the one compare (as done here), as the second
+          compare becomes more expensive than just calculating the value. Architectures with 
+          slow FP operations may want to add some more comparevals. try it and send your diffs 
+          statistically speaking
+          73% of all xr*istep_l values give ix=0
+          16% will give 1
+          4%  will give 2
+       */
+       for (j=576;j>0;j--) 
+         {
+           if (compareval0 > *xr) {
+             *(ix++) = 0;
+             xr++;
+           } else
+             *(ix++) = (int)( istep_l*(*(xr++))  + 0.4054);
+         }
+ #endif
+     }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ /*
+   Seymour's comment:  Jan 8 1995
+   When mixed_block_flag is set, the low subbands 0-1 undergo the long
+   window transform and are each split into 18 frequency lines, while
+   the remaining 30 subbands undergo the short window transform and are
+   each split into 6 frequency lines. A problem now arises, as neither
+   the short or long scale factor bands apply to this mixed spectrum.
+   The standard resolves this situation by using the first 8 long scale
+   factor bands for the low spectrum and the short scale factor bands
+   in the range of 3 to 11 (inclusive) for the remaining frequency lines.
+   These scale factor bands do not match exactly to the 0-1 subbands
+   for all sampling frequencies (32,44.1 and 48 kHz); however they
+   were designed so that there would not be a frequency gap or overlap
+   at the switch over point. (Note multiply short frequency lines by 3
+   to account for wider frequency line.) 
+   */
+ 
+ /* mt 4/99:  ISO code cannot produces mixed blocks,
+  * Fhg Code also never seems to use them, so no need to add them
+  * to this code 
+  */
+ /*************************************************************************/
+ /*            gr_deco                                                    */
+ /*************************************************************************/
+ 
+ void gr_deco( gr_info *cod_info )
+ {
+     if ( cod_info->window_switching_flag != 0 && cod_info->block_type == 2 )
+         {
+             cod_info->sfb_lmax = 0; /* No sb*/
+             cod_info->sfb_smax = 0;
+         }
+     else
+     {
+       /* MPEG 1 doesnt use last scalefactor band? */
+         cod_info->sfb_lmax = SFB_LMAX - 1;
+         cod_info->sfb_smax = SFB_SMAX - 1;    /* No sb */
+     }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ static int OldValue = -30; /* guess it or so. */
+ 
+ typedef enum {
+     BINSEARCH_NONE,
+     BINSEARCH_UP, 
+     BINSEARCH_DOWN
+ } binsearchDirection_t;
+ 
+ /*-------------------------------------------------------------------------*/
+ int 
+ bin_search_StepSize2(int      desired_rate, 
+ 		    double   start, 
+ 		    int      bot, 
+ 		    int     *ix,
+ 		    double   xrs[576], 
+ 		    double   xrspow[576], 
+ 		    gr_info *cod_info)
+ /*-------------------------------------------------------------------------*/
+ {
+     int flag_GoneOver = 0;
+     int CurrentStep = 4;
+     int nBits;
+     int StepSize = OldValue;
+     binsearchDirection_t Direction = BINSEARCH_NONE;
+     do
+     {
+ 	cod_info->quantizerStepSize = StepSize;
+ 	quantize_xrpow(xrspow, ix, cod_info);
+ 	nBits = count_bits(ix,cod_info);  
+ 
+ 	if (CurrentStep == 1 )
+         {
+ 	    break; /* nothing to adjust anymore */
+ 	}
+ 	if (flag_GoneOver)
+ 	{
+ 	    CurrentStep /= 2;
+ 	}
+ 	if (nBits > desired_rate)  /* increase Quantize_StepSize */
+ 	{
+ 	    if (Direction == BINSEARCH_DOWN && !flag_GoneOver)
+ 	    {
+ 		flag_GoneOver = 1;
+ 		CurrentStep /= 2; /* late adjust */
+ 	    }
+ 	    Direction = BINSEARCH_UP;
+ 	    StepSize += CurrentStep;
+ 	}
+ 	else if (nBits < desired_rate)
+ 	{
+ 	    if (Direction == BINSEARCH_UP && !flag_GoneOver)
+ 	    {
+ 		flag_GoneOver = 1;
+ 		CurrentStep /= 2; /* late adjust */
+ 	    }
+ 	    Direction = BINSEARCH_DOWN;
+ 	    StepSize -= CurrentStep;
+ 	}
+ 	else break; /* nBits == desired_rate;; most unlikely to happen.
+ */
+     } while (1); /* For-ever, break is adjusted. */
+     OldValue = StepSize;
+     return nBits;
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ 
+ int quant_compare(
+ int best_over,double best_tot_noise,double best_over_noise,double best_max_noise,
+ int over,double tot_noise, double over_noise, double max_noise)
+ {
+   /*
+     noise is given in decibals (db) relative to masking thesholds.
+ 
+     over_noise:  sum of quantization noise > masking
+     tot_noise:   sum of all quantization noise
+     max_noise:   max quantization noise 
+ 
+    */
+   int better=0;
+ 
+   if (experimentalX==0) {
+     better = ((over < best_over) ||
+ 	    ((over==best_over) && (over_noise<best_over_noise)) ) ;
+   }
+ 
+   if (experimentalX==1) 
+     better = max_noise < best_max_noise;
+ 
+   if (experimentalX==2) {
+     better = tot_noise < best_tot_noise;
+   }
+   if (experimentalX==3) {
+     better = (tot_noise < best_tot_noise) &&
+       (max_noise < best_max_noise + 2);
+   }
+   if (experimentalX==4) {
+     better = ( ( (0>=max_noise) && (best_max_noise>2)) ||
+      ( (0>=max_noise) && (best_max_noise<0) && ((best_max_noise+2)>max_noise) && (tot_noise<best_tot_noise) ) ||
+      ( (0>=max_noise) && (best_max_noise>0) && ((best_max_noise+2)>max_noise) && (tot_noise<(best_tot_noise+best_over_noise)) ) ||
+      ( (0<max_noise) && (best_max_noise>-0.5) && ((best_max_noise+1)>max_noise) && ((tot_noise+over_noise)<(best_tot_noise+best_over_noise)) ) ||
+      ( (0<max_noise) && (best_max_noise>-1) && ((best_max_noise+1.5)>max_noise) && ((tot_noise+over_noise+over_noise)<(best_tot_noise+best_over_noise+best_over_noise)) ) );
+   }
+   if (experimentalX==5) {
+     better =   (over_noise <  best_over_noise)
+       || ((over_noise == best_over_noise)&&(tot_noise < best_tot_noise));
+   }
+ 
+   return better;
+ }
+ 
+ 
+ int VBR_compare(
+ int best_over,double best_tot_noise,double best_over_noise,double best_max_noise,
+ int over,double tot_noise, double over_noise, double max_noise)
+ {
+   /*
+     noise is given in decibals (db) relative to masking thesholds.
+ 
+     over_noise:  sum of quantization noise > masking
+     tot_noise:   sum of all quantization noise
+     max_noise:   max quantization noise 
+ 
+    */
+   int better=0;
+ 
+   better = ((over <= best_over) &&
+ 	    (over_noise<=best_over_noise) &&
+ 	    (tot_noise<=best_tot_noise) &&
+ 	    (max_noise<=best_max_noise));
+   return better;
+ }
+   
+ 
+ 
+ 
+ 
+ 
+ 
+ 
diff -r -c -N encoder/quantize.h lame3.50/quantize.h
*** encoder/quantize.h	Wed Dec 31 17:00:00 1969
--- lame3.50/quantize.h	Tue Oct 12 14:55:53 1999
***************
*** 0 ****
--- 1,65 ----
+ /**********************************************************************
+  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
+  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
+  *
+  * $Id: loop.h,v 1.1 1996/02/14 04:04:23 rowlands Exp $
+  *
+  * $Log: loop.h,v $
+  * Revision 1.1  1996/02/14 04:04:23  rowlands
+  * Initial revision
+  *
+  * Received from Mike Coleman
+  **********************************************************************/
+ 
+ #ifndef LOOP_DOT_H
+ #define LOOP_DOT_H
+ #include "util.h"
+ #include "l3side.h"
+ 
+ /**********************************************************************
+  *   date   programmers                comment                        *
+  * 25. 6.92  Toshiyuki Ishino          Ver 1.0                        *
+  * 29.10.92  Masahiro Iwadare          Ver 2.0                        *
+  * 17. 4.93  Masahiro Iwadare          Updated for IS Modification    *
+  *                                                                    *
+  *********************************************************************/
+ 
+ extern int cont_flag;
+ 
+ #define CBLIMIT       21
+ 
+ #define SFB_LMAX 22
+ #define SFB_SMAX 13
+ 
+ extern int pretab[];
+ 
+ struct scalefac_struct
+ {
+    int l[23];
+    int s[14];
+ };
+ 
+ extern struct scalefac_struct sfBandIndex[];  /* Table B.8 -- in loop.c */
+ 
+ 
+ void iteration_loop( double pe[2][2], double ms_ratio[2], 
+ 		     double xr_org[2][2][576], III_psy_ratio *ratio,
+ 		     III_side_info_t *l3_side, int l3_enc[2][2][576], 
+ 		     III_scalefac_t *scalefac, frame_params *fr_ps);
+ 
+ void VBR_iteration_loop( double pe[2][2], double ms_ratio[2], 
+ 		     double xr_org[2][2][576], III_psy_ratio *ratio,
+ 		     III_side_info_t *l3_side, int l3_enc[2][2][576], 
+ 		     III_scalefac_t *scalefac, frame_params *fr_ps);
+ 
+ 
+ 
+ 
+ #define maximum(A,B) ( (A) > (B) ? (A) : (B) )
+ #define minimum(A,B) ( (A) < (B) ? (A) : (B) )
+ #define signum( A ) ( (A) > 0 ? 1 : -1 )
+ 
+ 
+ extern int bit_buffer[50000];
+ 
+ #endif
diff -r -c -N encoder/reservoir.c lame3.50/reservoir.c
*** encoder/reservoir.c	Wed Jan 22 02:43:18 1997
--- lame3.50/reservoir.c	Mon Oct 25 12:12:22 1999
***************
*** 23,32 ****
  #include <math.h>
  #include <assert.h>
  #include "l3side.h"
! #include "loop.h"
  #include "huffman.h"
  #include "l3bitstream.h"
  #include "reservoir.h"
  
  /*
    Layer3 bit reservoir:
--- 23,34 ----
  #include <math.h>
  #include <assert.h>
  #include "l3side.h"
! #include "quantize.h"
  #include "huffman.h"
  #include "l3bitstream.h"
  #include "reservoir.h"
+ #include "gtkanal.h"
+ #include "globalflags.h"
  
  /*
    Layer3 bit reservoir:
***************
*** 36,48 ****
  static int ResvSize = 0; /* in bits */
  static int ResvMax  = 0; /* in bits */
  
  /*
    ResvFrameBegin:
    Called at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! void
  ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
      layer *info;
--- 38,56 ----
  static int ResvSize = 0; /* in bits */
  static int ResvMax  = 0; /* in bits */
  
+ void InitReservoir(void)
+ {
+ 	ResvSize = 0;
+ 	ResvMax  = 0;
+ }
+ 
  /*
    ResvFrameBegin:
    Called at the beginning of a frame. Updates the maximum
    size of the reservoir, and checks to make sure main_data_begin
    was set properly by the formatter
  */
! int
  ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength )
  {
      layer *info;
***************
*** 71,78 ****
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
      assert( expectedResvSize == ResvSize );
! 
!     fullFrameBits = mean_bits * mode_gr;
  
      /*
        determine maximum size of reservoir:
--- 79,85 ----
      fprintf( stderr, ">>> ResvSize = %d\n", ResvSize );
  #endif
      assert( expectedResvSize == ResvSize );
!     fullFrameBits = mean_bits * mode_gr + ResvSize;
  
      /*
        determine maximum size of reservoir:
***************
*** 90,136 ****
        */
      if ( ResvMax > resvLimit )
  	ResvMax = resvLimit;
  }
  
  /*
!   ResvMaxBits:
!   Called at the beginning of each granule to get the max bit
!   allowance for the current granule based on reservoir size
!   and perceptual entropy.
  */
! int
! ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits )
  {
!     int more_bits, max_bits, add_bits, over_bits;
! 
!     mean_bits /= fr_ps->stereo;
!     max_bits = mean_bits;
  
-     if ( max_bits > 4095 )
- 	max_bits = 4095;
  
!     if ( ResvMax == 0 )
! 	return max_bits;
  
!     more_bits = *pe * 3.1 - mean_bits;
!     add_bits = 0;
!     if ( more_bits > 100 )
!     {
! 	int frac = (ResvSize * 6) / 10;
! 
! 	if ( frac < more_bits )
! 	    add_bits = frac;
! 	else
! 	    add_bits = more_bits;
!     }
!     over_bits = ResvSize - ((ResvMax * 8) / 10) - add_bits;
!     if ( over_bits > 0 )
! 	add_bits += over_bits;
! 
!     max_bits += add_bits;
!     if ( max_bits > 4095 )
! 	max_bits = 4095;
!     return max_bits;
  }
  
  /*
--- 97,146 ----
        */
      if ( ResvMax > resvLimit )
  	ResvMax = resvLimit;
+ 
+ #ifdef HAVEGTK
+   if (gtkflag){
+     pinfo->mean_bits=mean_bits/2;  /* expected bits per channel per granule */
+     pinfo->resvsize=ResvSize;
+   }
+ #endif
+ 
+     return fullFrameBits;
  }
  
+ 
  /*
!   ResvMaxBits2:
!   As above, but now it *really* is bits per granule (both channels).  
!   Mark Taylor 4/99
  */
! void ResvMaxBits2(int mean_bits, int *targ_bits, int *extra_bits, int gr)
  {
!   int add_bits;
  
  
!   *targ_bits = mean_bits ;
!   /* extra bits if the reservoir is almost full */
!   if (ResvSize > ((ResvMax * 9) / 10)) {
!     add_bits= ResvSize-((ResvMax * 9) / 10);
!     *targ_bits += add_bits;
!   }else {
!     add_bits =0 ;
!     /* build up reservoir.  this builds the reservoir a little slower
!      * than FhG.  It could simple be mean_bits/15, but this was rigged
!      * to always produce 100 (the old value) at 128kbs */
!     *targ_bits -= (int) (mean_bits/15.2);
!   }
! 
!   
!   /* amount from the reservoir we are allowed to use. ISO says 6/10 */
!   *extra_bits =    
!     (ResvSize  < (ResvMax*6)/10  ? ResvSize : (ResvMax*6)/10);
!   *extra_bits -= add_bits;
!   
!   if (*extra_bits < 0) *extra_bits=0;
  
!   
  }
  
  /*
***************
*** 144,149 ****
--- 154,160 ----
      ResvSize += (mean_bits / fr_ps->stereo) - gi->part2_3_length;
  }
  
+ 
  /*
    ResvFrameEnd:
    Called after all granules in a frame have been allocated. Makes sure
***************
*** 155,168 ****
  void
  ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits )
  {
!     layer *info;
!     gr_info *gi;
!     int mode_gr, gr, ch, stereo, ancillary_pad, stuffingBits;
      int over_bits;
  
-     info   = fr_ps->header;
      stereo = fr_ps->stereo;
-     mode_gr = (info->version == 1) ? 2 : 1;
      ancillary_pad = 0;
  
  #if 1
--- 166,175 ----
  void
  ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits )
  {
!     int stereo, ancillary_pad, stuffingBits;
      int over_bits;
  
      stereo = fr_ps->stereo;
      ancillary_pad = 0;
  
  #if 1
***************
*** 185,228 ****
  	ResvSize -= over_bits;
      }
  
!     if ( stuffingBits )
!     {
! 	/*
! 	  plan a: put all into the first granule
! 	  This was preferred by someone designing a
! 	  real-time decoder...
! 	*/
! 	gi = (gr_info *) &(l3_side->gr[0].ch[0]);	
! 	
! 	if ( gi->part2_3_length + stuffingBits < 4095 )
! 	    gi->part2_3_length += stuffingBits;
! 	else
! 	{
! 	    /* plan b: distribute throughout the granules */
! 	    for (gr = 0; gr < mode_gr; gr++ )
! 		for (ch = 0; ch < stereo; ch++ )
! 		{
! 		    int extraBits, bitsThisGr;
! 		    gr_info *gi = (gr_info *) &(l3_side->gr[gr].ch[ch]);
! 		    if ( stuffingBits == 0 )
! 			break;
! 		    extraBits = 4095 - gi->part2_3_length;
! 		    bitsThisGr = extraBits < stuffingBits ? extraBits : stuffingBits;
! 		    gi->part2_3_length += bitsThisGr;
! 		    stuffingBits -= bitsThisGr;
! 		}
! 	    /*
! 	      If any stuffing bits remain, we elect to spill them
! 	      into ancillary data. The bitstream formatter will do this if
! 	      l3side->resvDrain is set
! 	    */
! #ifdef DEBUG
! 	    if ( stuffingBits )
! 		fprintf( stderr, "spilling %d stuffing bits into ancillary data\n", stuffingBits );
! #endif
! 	    l3_side->resvDrain = stuffingBits;
! 	}
!     }
  }
  
  
--- 192,201 ----
  	ResvSize -= over_bits;
      }
  
! 
!     l3_side->resvDrain = stuffingBits;
!     return;
! 
  }
  
  
diff -r -c -N encoder/reservoir.h lame3.50/reservoir.h
*** encoder/reservoir.h	Wed Jan 22 02:43:18 1997
--- lame3.50/reservoir.h	Tue Oct  5 09:36:52 1999
***************
*** 22,30 ****
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! void ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength );
! int  ResvMaxBits( frame_params *fr_ps, III_side_info_t *l3_side, double *pe, int mean_bits );
  void ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits );
  void ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits );
  
  #endif
--- 22,31 ----
  #ifndef RESERVOIR_H
  #define RESERVOIR_H
  
! int ResvFrameBegin( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits, int frameLength );
! void ResvMaxBits2( int mean_bits, int *targ_bits, int *max_bits, int gr);
  void ResvAdjust( frame_params *fr_ps, gr_info *gi, III_side_info_t *l3_side, int mean_bits );
  void ResvFrameEnd( frame_params *fr_ps, III_side_info_t *l3_side, int mean_bits );
+ void InitReservoir(void);
  
  #endif
diff -r -c -N encoder/subs.c lame3.50/subs.c
*** encoder/subs.c	Wed Jan 22 02:43:18 1997
--- lame3.50/subs.c	Wed Dec 31 17:00:00 1969
***************
*** 1,163 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: subs.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: subs.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Davis Pan           start of version 1.0 records          *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  * 7/10/91  Earle Jennings      Ported to MsDos from Macintosh        *
-  *                              Replacement of one float with FLOAT   *
-  * 2/11/92  W. Joseph Carter    Added type casting to memset() args.  *
-  * 4/27/92  Masahiro Iwadare    Added 256 point version for Layer III *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- 
- /*****************************************************************************
-  ************************** Start of Subroutines *****************************
-  *****************************************************************************/
- 
- /*****************************************************************************
-  * FFT computes fast fourier transform of BLKSIZE samples of data            *
-  *   uses decimation-in-frequency algorithm described in "Digital            *
-  *   Signal Processing" by Oppenheim and Schafer, refer to pages 304         *
-  *   (flow graph) and 330-332 (Fortran program in problem 5)                 *
-  *   to get the inverse fft, change line 20 from                             *
-  *                 w_imag[L] = -sin(PI/le1);                                 *
-  *                          to                                               *
-  *                 w_imag[L] = sin(PI/le1);                                  *
-  *                                                                           *
-  *   required constants:                                                     *
-  *         #define      PI          3.14159265358979                         *
-  *         #define      BLKSIZE     1024                                     *
-  *         #define      LOGBLKSIZE  10                                       *
-  *         #define      BLKSIZE_S   256                                      *
-  *         #define      LOGBLKSIZE_S 8                                       *
-  *                                                                           *
-  *****************************************************************************/
- #define      BLKSIZE_S   256
- #define      LOGBLKSIZE_S 8
- 
- void fft(x_real,x_imag, energy, phi, N)
- FLOAT x_real[BLKSIZE], x_imag[BLKSIZE], energy[BLKSIZE], phi[BLKSIZE];
- int	N;
- {
-  int     M,MM1;
-  static int     init=0;
-  int     NV2, NM1, MP;
-  static double  w_real[2][LOGBLKSIZE], w_imag[2][LOGBLKSIZE];
-  int            i,j,k,L;
-  int            ip, le,le1;
-  double         t_real, t_imag, u_real, u_imag;
- 
-  if(init==0) {
-     memset((char *) w_real, 0, sizeof(w_real));  /* preset statics to 0 */
-     memset((char *) w_imag, 0, sizeof(w_imag));  /* preset statics to 0 */
-     M = LOGBLKSIZE;
-     for(L=0; L<M; L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_real[0][L] = cos(PI/le1);
-        w_imag[0][L] = -sin(PI/le1);
-     }          
-     M = LOGBLKSIZE_S;
-     for(L=0; L<M; L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_real[1][L] = cos(PI/le1);
-        w_imag[1][L] = -sin(PI/le1);
-     }          
-     init++;
-  }
-  switch(N) {
- 	case BLKSIZE:
- 			M = LOGBLKSIZE;
- 			MP = 0;
- 			break;
- 	case BLKSIZE_S:
- 			M = LOGBLKSIZE_S;
- 			MP = 1;
- 			break;
- 	default:	printf("Error: Bad FFT Size in subs.c\n");
- 			exit(-1);
-  }
-  MM1 = M-1;
-  NV2 = N >> 1;
-  NM1 = N - 1;
-  for(L=0; L<MM1; L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_real = 1;
-     u_imag = 0;
-     for(j=0; j<le1; j++){
-        for(i=j; i<N; i+=le){
-           ip = i + le1;
-           t_real = x_real[i] + x_real[ip];
-           t_imag = x_imag[i] + x_imag[ip];
-           x_real[ip] = x_real[i] - x_real[ip];
-           x_imag[ip] = x_imag[i] - x_imag[ip];
-           x_real[i] = t_real;
-           x_imag[i] = t_imag;
-           t_real = x_real[ip];
-           x_real[ip] = x_real[ip]*u_real - x_imag[ip]*u_imag;
-           x_imag[ip] = x_imag[ip]*u_real + t_real*u_imag;
-        }
-        t_real = u_real;
-        u_real = u_real*w_real[MP][L] - u_imag*w_imag[MP][L];
-        u_imag = u_imag*w_real[MP][L] + t_real*w_imag[MP][L];
-     }
-  }
-  /* special case: L = M-1; all Wn = 1 */
-  for(i=0; i<N; i+=2){
-     ip = i + 1;
-     t_real = x_real[i] + x_real[ip];
-     t_imag = x_imag[i] + x_imag[ip];
-     x_real[ip] = x_real[i] - x_real[ip];
-     x_imag[ip] = x_imag[i] - x_imag[ip];
-     x_real[i] = t_real;
-     x_imag[i] = t_imag;
-     energy[i] = x_real[i]*x_real[i] + x_imag[i]*x_imag[i];
-     if(energy[i] <= 0.0005){phi[i] = 0;energy[i] = 0.0005;}
-     else phi[i] = atan2((double) x_imag[i],(double) x_real[i]);
-     energy[ip] = x_real[ip]*x_real[ip] + x_imag[ip]*x_imag[ip];
-     if(energy[ip] == 0)phi[ip] = 0;
-     else phi[ip] = atan2((double) x_imag[ip],(double) x_real[ip]);
-  }
-  /* this section reorders the data to the correct ordering */
-  j = 0;
-  for(i=0; i<NM1; i++){
-     if(i<j){
- /* use this section only if you need the FFT in complex number form *
-  * (and in the correct ordering)                                    */
-        t_real = x_real[j];
-        t_imag = x_imag[j];
-        x_real[j] = x_real[i];
-        x_imag[j] = x_imag[i];
-        x_real[i] = t_real;
-        x_imag[i] = t_imag;
- /* reorder the energy and phase, phi                                        */
-        t_real = energy[j];
-        energy[j] = energy[i];
-        energy[i] = t_real;
-        t_real = phi[j];
-        phi[j] = phi[i];
-        phi[i] = t_real;
-     }
-     k=NV2;
-     while(k<=j){
-        j = j-k;
-        k = k >> 1;
-     }
-     j = j+k;
-  }
- }
--- 0 ----
diff -r -c -N encoder/tables.c lame3.50/tables.c
*** encoder/tables.c	Wed Dec 31 17:00:00 1969
--- lame3.50/tables.c	Tue Oct 12 14:53:14 1999
***************
*** 0 ****
--- 1,1091 ----
+ #include "util.h"
+ #include "huffman.h"
+ 
+ 
+ 
+ unsigned int hs = sizeof(HUFFBITS)*8;
+ 
+ static HUFFBITS      t1HB[]   = {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  1, 0}; 
+ static HUFFBITS      t2HB[]   = {1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+  3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0};
+ static HUFFBITS      t3HB[]   = {3, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 0};
+ static HUFFBITS      t5HB[]   = {1, 2, 6, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, 7, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 1, 1, 0};
+ static HUFFBITS      t6HB[]   = {7, 3, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 2, 0};
+ static HUFFBITS      t7HB[]   = {1, 2, 10, 19, 16, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 7, 10, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 13, 17, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 11, 18, 15, 11, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 9, 14, 3, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 5, 3, 2, 0};
+ static HUFFBITS      t8HB[]   = {3, 4, 6, 18, 12, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 1, 2, 16, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 3, 5, 14, 7, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 19, 17, 15, 13, 10, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13, 5, 8, 11, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 4, 4, 1, 1, 0};
+ static HUFFBITS      t9HB[]   = {7, 5, 9, 14, 15, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 5, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 8, 8, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15, 6, 9, 10, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11, 7, 9, 6, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14, 4, 6, 2, 6, 0};
+ static HUFFBITS      t10HB[]   = {1, 2, 10, 23, 35, 30, 12, 17, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 8, 12, 18, 21, 12, 7, 0, 0, 0, 0, 0, 0, 0, 0, 11, 9, 15, 21, 32, 40, 19, 6, 0, 0, 0, 0, 0, 0, 0, 0, 14, 13, 22, 34, 46, 23, 18, 7, 0, 0, 0, 0, 0, 0, 0, 0, 20, 19, 33, 47, 27, 22, 9, 3, 0, 0, 0, 0, 0, 0, 0, 0, 31, 22, 41, 26, 21, 20, 5, 3, 0, 0, 0, 0, 0, 0, 0, 0, 14, 13, 10, 11, 16, 6, 5, 1, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 7, 8, 4 , 4, 2, 0};
+ static HUFFBITS      t11HB[]   = {3, 4, 10, 24, 34, 33, 21, 15, 0, 0, 0, 0, 0, 0, 0, 0, 5, 3, 4, 10, 32, 17, 11, 10, 0, 0, 0, 0, 0, 0, 0, 0, 11, 7, 13, 18, 30, 31, 20, 5, 0, 0, 0, 0, 0, 0, 0, 0, 25, 11, 19, 59, 27, 18, 12, 5, 0, 0, 0, 0, 0, 0, 0, 0, 35, 33, 31, 58, 30, 16, 7, 5, 0, 0, 0, 0, 0, 0, 0, 0, 28, 26, 32, 19, 17, 15, 8, 14, 0, 0, 0, 0, 0, 0, 0, 0, 14, 12, 9, 13, 14, 9, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 11, 4, 6, 6, 6, 3, 2, 0};
+ static HUFFBITS      t12HB[]   = {9, 6, 16, 33, 41, 39, 38, 26, 0, 0, 0, 0, 0, 0, 0, 0, 7, 5, 6, 9, 23, 16, 26, 11, 0, 0, 0, 0, 0, 0, 0, 0, 17, 7, 11, 14, 21, 30, 10, 7, 0, 0, 0, 0, 0, 0, 0, 0, 17, 10, 15, 12, 18, 28, 14, 5, 0, 0, 0, 0, 0, 0, 0, 0, 32, 13, 22, 19, 18, 16, 9, 5, 0, 0, 0, 0, 0, 0, 0, 0, 40, 17, 31, 29, 17, 13, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 27, 12, 11, 15, 10, 7, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 27, 12, 8, 12 , 6, 3, 1, 0}; 
+ static HUFFBITS      t13HB[]   = {1, 5, 14, 21, 34, 51, 46, 71, 42, 52, 68, 52, 67, 44, 43, 19, 3, 4, 12, 19, 31, 26, 44, 33, 31, 24, 32, 24, 31, 35, 22, 14, 15, 13, 23, 36, 59, 49, 77, 65, 29, 40, 30, 40, 27, 33, 42, 16, 22,
+                                  20, 37, 61, 56, 79, 73, 64, 43, 76, 56, 37, 26, 31, 25, 14, 35, 16, 60, 57, 97, 75, 114, 91, 54, 73, 55, 41, 48, 53, 23, 24, 58, 27, 50, 96, 76, 70, 93, 84, 77, 58, 79, 29, 74, 49, 41, 17, 47, 
+                                  45, 78, 74, 115, 94, 90, 79, 69, 83, 71, 50, 59, 38, 36, 15, 72, 34, 56, 95, 92, 85, 91, 90, 86, 73, 77, 65, 51, 44, 43, 42, 43, 20, 30, 44, 55, 78, 72, 87, 78, 61, 46, 54, 37, 30, 20, 16, 53, 
+                                  25, 41, 37, 44, 59, 54, 81, 66, 76, 57, 54, 37, 18, 39, 11, 35, 33, 31, 57, 42, 82, 72, 80, 47, 58, 55, 21, 22, 26, 38, 22, 53, 25, 23, 38, 70, 60, 51, 36, 55, 26, 34, 23, 27, 14, 9, 7, 34, 32, 
+                                  28, 39, 49, 75, 30, 52, 48, 40, 52, 28, 18, 17, 9, 5, 45, 21, 34, 64, 56, 50, 49, 45, 31, 19, 12, 15, 10, 7, 6, 3, 48, 23, 20, 39, 36, 35, 53, 21, 16, 23, 13, 10, 6, 1, 4, 2, 16, 15, 17, 27, 25, 
+                                  20, 29, 11, 17, 12, 16, 8, 1, 1, 0, 1};
+ static HUFFBITS      t15HB[]   = {7, 12, 18, 53, 47, 76, 124, 108, 89, 123, 108, 119, 107, 81, 122, 63, 13, 5, 16, 27, 46, 36, 61, 51, 42, 70, 52, 83, 65, 41, 59, 36, 19, 17, 15, 24, 41, 34, 59, 48, 40, 64, 50, 78, 62, 80, 56, 
+                                   33, 29, 28, 25, 43, 39, 63, 55, 93, 76, 59, 93, 72, 54, 75, 50, 29, 52, 22, 42, 40, 67, 57, 95, 79, 72, 57, 89, 69, 49, 66, 46, 27, 77, 37, 35, 66, 58, 52, 91, 74, 62, 48, 79, 63, 90, 62, 40, 38,
+                                   125, 32, 60, 56, 50, 92, 78, 65, 55, 87, 71, 51, 73, 51, 70, 30, 109, 53, 49, 94, 88, 75, 66, 122, 91, 73, 56, 42, 64, 44, 21, 25, 90, 43, 41, 77, 73, 63, 56, 92, 77, 66, 47, 67, 48, 53, 36, 20,
+                                   71, 34, 67, 60, 58, 49, 88, 76, 67, 106, 71, 54, 38, 39, 23, 15, 109, 53, 51, 47, 90, 82, 58, 57, 48, 72, 57, 41, 23, 27, 62, 9, 86, 42, 40, 37, 70, 64, 52, 43, 70, 55, 42, 25, 29, 18, 11, 11, 
+                                   118, 68, 30, 55, 50, 46, 74, 65, 49, 39, 24, 16, 22, 13, 14, 7, 91, 44, 39, 38, 34, 63, 52, 45, 31, 52, 28, 19, 14, 8, 9, 3, 123, 60, 58, 53, 47, 43, 32, 22, 37, 24, 17, 12, 15, 10, 2, 1, 71, 
+                                   37, 34, 30, 28, 20, 17, 26, 21, 16, 10, 6, 8, 6, 2, 0};
+ static HUFFBITS      t16HB[]   = {1, 5, 14, 44, 74, 63, 110, 93, 172, 149, 138, 242, 225, 195, 376, 17, 3, 4, 12, 20, 35, 62, 53, 47, 83, 75, 68, 119, 201, 107, 207, 9, 15, 13, 23, 38, 67, 58, 103, 90, 161, 72, 127, 117, 
+                                   110, 209, 206, 16, 45, 21, 39, 69, 64, 114, 99, 87, 158, 140, 252, 212, 199, 387, 365, 26, 75, 36, 68, 65, 115, 101, 179, 164, 155, 264, 246, 226, 395, 382, 362, 9, 66, 30, 59, 56, 102,
+                                   185, 173, 265, 142, 253, 232, 400, 388, 378, 445, 16, 111, 54, 52, 100, 184, 178, 160, 133, 257, 244, 228, 217, 385, 366, 715, 10, 98, 48, 91, 88, 165, 157, 148, 261, 248, 407, 397, 372,
+                                   380, 889, 884, 8, 85, 84, 81, 159, 156, 143, 260, 249, 427, 401, 392, 383, 727, 713, 708, 7, 154, 76, 73, 141, 131, 256, 245, 426, 406, 394, 384, 735, 359, 710, 352, 11, 139, 129, 67, 125,
+                                   247, 233, 229, 219, 393, 743, 737, 720, 885, 882, 439, 4, 243, 120, 118, 115, 227, 223, 396, 746, 742, 736, 721, 712, 706, 223, 436, 6, 202, 224, 222, 218, 216, 389, 386, 381, 364, 888, 
+                                   443, 707, 440, 437, 1728, 4, 747, 211, 210, 208, 370, 379, 734, 723, 714, 1735, 883, 877, 876, 3459, 865, 2, 377, 369, 102, 187, 726, 722, 358, 711, 709, 866, 1734, 871, 3458, 870, 434, 
+                                   0, 12, 10, 7, 11, 10, 17, 11, 9, 13, 12, 10, 7, 5, 3, 1, 3};
+ static HUFFBITS      t24HB[]   = {15, 13, 46, 80, 146, 262, 248, 434, 426, 669, 653, 649, 621, 517, 1032, 88, 14, 12, 21, 38, 71, 130, 122, 216, 209, 198, 327, 345, 319, 297, 279, 42, 47, 22, 41, 74, 68, 128, 120, 221,
+                                   207, 194, 182, 340, 315, 295, 541, 18, 81, 39, 75, 70, 134, 125, 116, 220, 204, 190, 178, 325, 311, 293, 271, 16, 147, 72, 69, 135, 127, 118, 112, 210, 200, 188, 352, 323, 306, 285, 
+                                   540, 14, 263, 66, 129, 126, 119, 114, 214, 202, 192, 180, 341, 317, 301, 281, 262, 12, 249, 123, 121, 117, 113, 215, 206, 195, 185, 347, 330, 308, 291, 272, 520, 10, 435, 115, 111,
+                                   109, 211, 203, 196, 187, 353, 332, 313, 298, 283, 531, 381, 17, 427, 212, 208, 205, 201, 193, 186, 177, 169, 320, 303, 286, 268, 514, 377, 16, 335, 199, 197, 191, 189, 181, 174, 333, 
+                                   321, 305, 289, 275, 521, 379, 371, 11, 668, 184, 183, 179, 175, 344, 331, 314, 304, 290, 277, 530, 383, 373, 366, 10, 652, 346, 171, 168, 164, 318, 309, 299, 287, 276, 263, 513, 375, 
+                                   368, 362, 6, 648, 322, 316, 312, 307, 302, 292, 284, 269, 261, 512, 376, 370, 364, 359, 4, 620, 300, 296, 294, 288, 282, 273, 266, 515, 380, 374, 369, 365, 361, 357, 2, 1033, 280, 278,
+                                   274, 267, 264, 259, 382, 378, 372, 367, 363, 360, 358, 356, 0, 43, 20, 19, 17, 15, 13, 11, 9, 7, 6, 4, 7, 5, 3, 1, 3};
+ static HUFFBITS      t32HB[]   = {1, 5, 4, 5, 6, 5, 4, 4, 7, 3, 6, 0, 7, 2, 3, 1};
+ static HUFFBITS      t33HB[]   = {15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
+ 
+ static unsigned char t1l[]  = {1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3}; 
+ static unsigned char t2l[]  = {1, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6}; 
+ static unsigned char t3l[]  = {2, 2, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6}; 
+ static unsigned char t5l[]  = {1, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 8}; 
+ static unsigned char t6l[]  = {3, 3, 5, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 7}; 
+ static unsigned char t7l[]  = {1, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 7, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10}; 
+ static unsigned char t8l[]  = {2, 3, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 2, 4, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 6, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 9, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 9, 9, 11, 11}; 
+ static unsigned char t9l[]  = {3, 3, 5, 6, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 5, 6, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 8, 9, 9}; 
+ static unsigned char t10l[]  = {1, 3, 6, 8, 9, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 6, 7, 8, 9, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 7, 8, 9, 10, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 9, 10, 10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 9, 10, 10, 11, 11, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 10, 11, 11, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 9, 10, 10, 11, 11, 11}; 
+ static unsigned char t11l[]  = {2, 3, 5, 7, 8, 9, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 6, 8, 8, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 5, 6, 7, 8, 9, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 9, 8, 10, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 8, 9, 9, 10, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 8, 9, 10, 10, 11, 10, 11, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 7, 8, 9, 10, 10, 10, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 9, 10, 10, 10, 10}; 
+ static unsigned char t12l[]  = {4, 3, 5, 7, 8, 9, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 4, 5, 7, 7, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 5, 6, 7, 8, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 6, 5, 6, 6, 7, 8, 8, 8, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 7, 7, 8, 8, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 8, 8, 8, 9, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 8, 7, 7, 8, 8, 9, 9, 10, 0, 0, 0, 0, 0, 0, 0, 0, 9, 8, 8, 9, 9, 9, 9, 10}; 
+ static unsigned char t13l[]  = {1, 4, 6, 7, 8, 9, 9, 10, 9, 10, 11, 11, 12, 12, 13, 13, 3, 4, 6, 7, 8, 8, 9, 9, 9, 9, 10, 10, 11, 12, 12, 12, 6, 6, 7, 8, 9, 9, 10, 10, 9, 10, 10, 11, 11, 12, 13, 13, 7, 7, 8, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 13, 
+ 8, 7, 9, 9, 10, 10, 11, 11, 10, 11, 11, 12, 12, 13, 13, 14, 9, 8, 9, 10, 10, 10, 11, 11, 11, 11, 12, 11, 13, 13, 14, 14, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 13, 13, 14, 14, 10, 9, 10, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 14, 16, 16, 9, 8, 9, 10,
+ 10, 11, 11, 12, 12, 12, 12, 13, 13, 14, 15, 15, 10, 9, 10, 10, 11, 11, 11, 13, 12, 13, 13, 14, 14, 14, 16, 15, 10, 10, 10, 11, 11, 12, 12, 13, 12, 13, 14, 13, 14, 15, 16, 17, 11, 10, 10, 11, 12, 12, 12, 12, 13, 13, 13, 14, 15, 15, 15, 16, 11, 11, 11, 12, 12, 
+ 13, 12, 13, 14, 14, 15, 15, 15, 16, 16, 16, 12, 11, 12, 13, 13, 13, 14, 14, 14, 14, 14, 15, 16, 15, 16, 16, 13, 12, 12, 13, 13, 13, 15, 14, 14, 17, 15, 15, 15, 17, 16, 16, 12, 12, 13, 14, 14, 14, 15, 14, 15, 15, 16, 16, 19, 18, 19, 16}; 
+ static unsigned char t15l[]  = {3, 4, 5, 7, 7, 8, 9, 9, 9, 10, 10, 11, 11, 11, 12, 13, 4, 3, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 10, 11, 11, 5, 5, 5, 6, 7, 7, 8, 8, 8, 9, 9, 10, 10, 11, 11, 11, 6, 6, 6, 7, 7, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 7, 6, 7,
+  7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 8, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 11, 11, 11, 12, 9, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 12, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 12, 9, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11,
+  12, 12, 12, 9, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 10, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 12, 13, 12, 10, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 13, 11, 10, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 12, 12, 13, 13, 
+ 11, 10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 12, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 12, 13, 12, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13}; 
+ static unsigned char t16l[]  = {1, 4, 6, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 9, 3, 4, 6, 7, 8, 9, 9, 9, 10, 10, 10, 11, 12, 11, 12, 8, 6, 6, 7, 8, 9, 9, 10, 10, 11, 10, 11, 11, 11, 12, 12, 9, 8, 7, 8, 9, 9, 10, 10, 10, 11, 11, 12, 12, 12, 13, 13,
+  10, 9, 8, 9, 9, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 9, 9, 8, 9, 9, 10, 11, 11, 12, 11, 12, 12, 13, 13, 13, 14, 10, 10, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 14, 10, 10, 9, 10, 10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 15, 15, 10, 10, 10,
+  10, 11, 11, 11, 12, 12, 13, 13, 13, 13, 14, 14, 14, 10, 11, 10, 10, 11, 11, 12, 12, 13, 13, 13, 13, 14, 13, 14, 13, 11, 11, 11, 10, 11, 12, 12, 12, 12, 13, 14, 14, 14, 15, 15, 14, 10, 12, 11, 11, 11, 12, 12, 13, 14, 14, 14, 14, 14, 14, 13, 14, 11, 12, 12,
+  12, 12, 12, 13, 13, 13, 13, 15, 14, 14, 14, 14, 16, 11, 14, 12, 12, 12, 13, 13, 14, 14, 14, 16, 15, 15, 15, 17, 15, 11, 13, 13, 11, 12, 14, 14, 13, 14, 14, 15, 16, 15, 17, 15, 14, 11, 9, 8, 8, 9, 9, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8}; 
+ static unsigned char t24l[]  = {4, 4, 6, 7, 8, 9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 9, 4, 4, 5, 6, 7, 8, 8, 9, 9, 9, 10, 10, 10, 10, 10, 8, 6, 5, 6, 7, 7, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 7, 7, 6, 7, 7, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 7, 8, 7, 7, 8,
+  8, 8, 8, 9, 9, 9, 10, 10, 10, 10, 11, 7, 9, 7, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 7, 9, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 7, 10, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 8, 10, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 
+ 8, 10, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 8, 11, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 9, 9, 9, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 8, 11, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 11, 10, 10,
+  10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 8, 12, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 8, 8, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4}; 
+ static unsigned char t32l[]  = {1, 4, 4, 5, 4, 6, 5, 6, 4, 5, 5, 6, 5, 6, 6, 6}; 
+ static unsigned char t33l[]  = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4}; 
+ 
+ #define NOREF -1
+ struct huffcodetab ht[HTN] =
+ {
+ { 0, 0, 0,   0,NULL,NULL},
+ { 2,16, 0,   0,t1HB, t1l},
+ { 3,16, 0,   0,t2HB, t2l},
+ { 3,16, 0,   0,t3HB, t3l},
+ { 0, 0, 0,   0,NULL,NULL},/* Apparently not used */
+ { 4,16, 0,   0,t5HB, t5l},
+ { 4,16, 0,   0,t6HB, t6l},
+ { 6,16, 0,   0,t7HB, t7l},
+ { 6,16, 0,   0,t8HB, t8l},
+ { 6,16, 0,   0,t9HB, t9l},
+ { 8,16, 0,   0,t10HB, t10l},
+ { 8,16, 0,   0,t11HB, t11l},
+ { 8,16, 0,   0,t12HB, t12l},
+ {16,16, 0,   0,t13HB, t13l},
+ { 0, 0, 0,   0,NULL,NULL},/* Apparently not used */
+ {16,16, 0,   0,t15HB, t15l},
+ {16,16, 1,   1,t16HB, t16l},
+ {16,16, 2,   3,t16HB, t16l},
+ {16,16, 3,   7,t16HB, t16l},
+ {16,16, 4,  15,t16HB, t16l},
+ {16,16, 6,  63,t16HB, t16l},
+ {16,16, 8, 255,t16HB, t16l},
+ {16,16,10,1023,t16HB, t16l},
+ {16,16,13,8191,t16HB, t16l},
+ {16,16, 4,  15,t24HB, t24l},
+ {16,16, 5,  31,t24HB, t24l},
+ {16,16, 6,  63,t24HB, t24l},
+ {16,16, 7, 127,t24HB, t24l},
+ {16,16, 8, 255,t24HB, t24l},
+ {16,16, 9, 511,t24HB, t24l},
+ {16,16,11,2047,t24HB, t24l},
+ {16,16,13,8191,t24HB, t24l},
+ { 1,16, 0,   0,t32HB, t32l},
+ { 1,16, 0,   0,t33HB, t33l},
+ };	
+ 
+ 
+ 
+ 
+ 
+ double psy_data[] =
+ {48000.0, 61,
+  0, 1, 24.5, 4.532, 0.970, 0.000,
+  1, 1, 24.5, 4.532, 0.755, 0.469,
+  2, 1, 24.5, 4.532, 0.738, 0.938,
+  3, 1, 24.5, 0.904, 0.730, 1.406,
+  4, 1, 24.5, 0.904, 0.724, 1.875,
+  5, 1, 20.0, 0.090, 0.723, 2.344,
+  6, 1, 20.0, 0.090, 0.723, 2.813,
+  7, 1, 20.0, 0.029, 0.723, 3.281,
+  8, 1, 20.0, 0.029, 0.718, 3.750,
+  9, 1, 20.0, 0.009, 0.690, 4.199,
+  10, 1, 20.0, 0.009, 0.660, 4.625,
+  11, 1, 18.0, 0.009, 0.641, 5.047,
+  12, 1, 18.0, 0.009, 0.600, 5.438,
+  13, 1, 18.0, 0.009, 0.584, 5.828,
+  14, 1, 12.0, 0.009, 0.532, 6.188,
+  15, 1, 12.0, 0.009, 0.537, 6.522,
+  16, 2, 6.0, 0.018, 0.857, 7.174,
+  17, 2, 6.0, 0.018, 0.858, 7.801,
+  18, 2, 3.0, 0.018, 0.853, 8.402,
+  19, 2, 3.0, 0.018, 0.824, 8.966,
+  20, 2, 3.0, 0.018, 0.778, 9.484,
+  21, 2, 3.0, 0.018, 0.740, 9.966,
+  22, 2, 0.0, 0.018, 0.709, 10.426,
+  23, 2, 0.0, 0.018, 0.676, 10.866,
+  24, 2, 0.0, 0.018, 0.632, 11.279,
+  25, 2, 0.0, 0.018, 0.592, 11.669,
+  26, 2, 0.0, 0.018, 0.553, 12.042,
+  27, 2, 0.0, 0.018, 0.510, 12.386,
+  28, 2, 0.0, 0.018, 0.513, 12.721,
+  29, 3, 0.0, 0.027, 0.608, 13.115,
+  30, 3, 0.0, 0.027, 0.673, 13.562,
+  31, 3, 0.0, 0.027, 0.637, 13.984,
+  32, 3, 0.0, 0.027, 0.586, 14.371,
+  33, 3, 0.0, 0.027, 0.571, 14.741,
+  34, 4, 0.0, 0.036, 0.616, 15.140,
+  35, 4, 0.0, 0.036, 0.640, 15.563,
+  36, 4, 0.0, 0.036, 0.598, 15.962,
+  37, 4, 0.0, 0.036, 0.538, 16.324,
+  38, 4, 0.0, 0.036, 0.512, 16.665,
+  39, 5, 0.0, 0.045, 0.528, 17.020,
+  40, 5, 0.0, 0.045, 0.517, 17.373,
+  41, 5, 0.0, 0.045, 0.493, 17.708,
+  42, 6, 0.0, 0.054, 0.499, 18.045,
+  43, 7, 0.0, 0.063, 0.525, 18.398,
+  44, 7, 0.0, 0.063, 0.541, 18.762,
+  45, 8, 0.0, 0.072, 0.528, 19.120,
+  46, 8, 0.0, 0.072, 0.510, 19.466,
+  47, 8, 0.0, 0.072, 0.506, 19.807,
+  48, 10, 0.0, 0.180, 0.525, 20.159,
+  49, 10, 0.0, 0.180, 0.536, 20.522,
+  50, 10, 0.0, 0.180, 0.518, 20.874,
+  51, 13, 0.0, 0.372, 0.501, 21.214,
+  52, 13, 0.0, 0.372, 0.497, 21.553,
+  53, 14, 0.0, 0.400, 0.497, 21.892,
+  54, 18, 0.0, 1.627, 0.495, 22.231,
+  55, 18, 0.0, 1.627, 0.494, 22.569,
+  56, 20, 0.0, 1.808, 0.497, 22.909,
+  57, 25, 0.0, 22.607, 0.494, 23.248,
+  58, 25, 0.0, 22.607, 0.487, 23.583,
+  59, 35, 0.0, 31.650, 0.483, 23.915,
+  60, 67, 0.0, 605.867, 0.482, 24.246,
+  61, 67, 0.0, 605.867, 0.524, 24.576,
+  44100.0, 62,
+  0, 1, 24.5, 4.532, 0.951, 0.000,
+  1, 1, 24.5, 4.532, 0.700, 0.431,
+  2, 1, 24.5, 4.532, 0.681, 0.861,
+  3, 1, 24.5, 0.904, 0.675, 1.292,
+  4, 1, 24.5, 0.904, 0.667, 1.723,
+  5, 1, 20.0, 0.090, 0.665, 2.153,
+  6, 1, 20.0, 0.090, 0.664, 2.584,
+  7, 1, 20.0, 0.029, 0.664, 3.015,
+  8, 1, 20.0, 0.029, 0.664, 3.445,
+  9, 1, 20.0, 0.029, 0.655, 3.876,
+  10, 1, 20.0, 0.009, 0.616, 4.279,
+  11, 1, 20.0, 0.009, 0.597, 4.670,
+  12, 1, 18.0, 0.009, 0.578, 5.057,
+  13, 1, 18.0, 0.009, 0.541, 5.416,
+  14, 1, 18.0, 0.009, 0.575, 5.774,
+  15, 2, 12.0, 0.018, 0.856, 6.422,
+  16, 2, 6.0, 0.018, 0.846, 7.026,
+  17, 2, 6.0, 0.018, 0.840, 7.609,
+  18, 2, 3.0, 0.018, 0.822, 8.168,
+  19, 2, 3.0, 0.018, 0.800, 8.710,
+  20, 2, 3.0, 0.018, 0.753, 9.207,
+  21, 2, 3.0, 0.018, 0.704, 9.662,
+  22, 2, 0.0, 0.018, 0.674, 10.099,
+  23, 2, 0.0, 0.018, 0.640, 10.515,
+  24, 2, 0.0, 0.018, 0.609, 10.917,
+  25, 2, 0.0, 0.018, 0.566, 11.293,
+  26, 2, 0.0, 0.018, 0.535, 11.652,
+  27, 2, 0.0, 0.018, 0.531, 11.997,
+  28, 3, 0.0, 0.027, 0.615, 12.394,
+  29, 3, 0.0, 0.027, 0.686, 12.850,
+  30, 3, 0.0, 0.027, 0.650, 13.277,
+  31, 3, 0.0, 0.027, 0.612, 13.681,
+  32, 3, 0.0, 0.027, 0.567, 14.062,
+  33, 3, 0.0, 0.027, 0.520, 14.411,
+  34, 3, 0.0, 0.027, 0.513, 14.751,
+  35, 4, 0.0, 0.036, 0.557, 15.119,
+  36, 4, 0.0, 0.036, 0.584, 15.508,
+  37, 4, 0.0, 0.036, 0.570, 15.883,
+  38, 5, 0.0, 0.045, 0.579, 16.263,
+  39, 5, 0.0, 0.045, 0.585, 16.654,
+  40, 5, 0.0, 0.045, 0.548, 17.020,
+  41, 6, 0.0, 0.054, 0.536, 17.374,
+  42, 6, 0.0, 0.054, 0.550, 17.744,
+  43, 7, 0.0, 0.063, 0.532, 18.104,
+  44, 7, 0.0, 0.063, 0.504, 18.447,
+  45, 7, 0.0, 0.063, 0.496, 18.782,
+  46, 9, 0.0, 0.081, 0.517, 19.130,
+  47, 9, 0.0, 0.081, 0.527, 19.487,
+  48, 9, 0.0, 0.081, 0.516, 19.838,
+  49, 10, 0.0, 0.180, 0.497, 20.179,
+  50, 10, 0.0, 0.180, 0.489, 20.510,
+  51, 11, 0.0, 0.198, 0.502, 20.852,
+  52, 14, 0.0, 0.400, 0.501, 21.196,
+  53, 14, 0.0, 0.400, 0.491, 21.531,
+  54, 15, 0.0, 0.429, 0.497, 21.870,
+  55, 20, 0.0, 1.808, 0.504, 22.214,
+  56, 20, 0.0, 1.808, 0.504, 22.558,
+  57, 21, 0.0, 1.898, 0.495, 22.898,
+  58, 27, 0.0, 24.416, 0.486, 23.232,
+  59, 27, 0.0, 24.416, 0.484, 23.564,
+  60, 36, 0.0, 32.554, 0.483, 23.897,
+  61, 73, 0.0, 660.124, 0.475, 24.229,
+  62, 18, 0.0, 162.770, 0.515, 24.442,
+  32000.0, 58,
+  0, 2, 24.5, 4.532, 0.997, 0.313,
+  1, 2, 24.5, 4.532, 0.893, 0.938,
+  2, 2, 24.5, 1.809, 0.881, 1.563,
+  3, 2, 20.0, 0.181, 0.873, 2.188,
+  4, 2, 20.0, 0.181, 0.872, 2.813,
+  5, 2, 20.0, 0.057, 0.871, 3.438,
+  6, 2, 20.0, 0.018, 0.860, 4.045,
+  7, 2, 20.0, 0.018, 0.839, 4.625,
+  8, 2, 18.0, 0.018, 0.812, 5.173,
+  9, 2, 18.0, 0.018, 0.784, 5.698,
+  10, 2, 12.0, 0.018, 0.741, 6.185,
+  11, 2, 12.0, 0.018, 0.697, 6.634,
+  12, 2, 6.0, 0.018, 0.674, 7.070,
+  13, 2, 6.0, 0.018, 0.651, 7.492,
+  14, 2, 6.0, 0.018, 0.633, 7.905,
+  15, 2, 3.0, 0.018, 0.611, 8.305,
+  16, 2, 3.0, 0.018, 0.589, 8.695,
+  17, 2, 3.0, 0.018, 0.575, 9.064,
+  18, 3, 3.0, 0.027, 0.654, 9.484,
+  19, 3, 3.0, 0.027, 0.724, 9.966,
+  20, 3, 0.0, 0.027, 0.701, 10.426,
+  21, 3, 0.0, 0.027, 0.673, 10.866,
+  22, 3, 0.0, 0.027, 0.631, 11.279,
+  23, 3, 0.0, 0.027, 0.592, 11.669,
+  24, 3, 0.0, 0.027, 0.553, 12.042,
+  25, 3, 0.0, 0.027, 0.510, 12.386,
+  26, 3, 0.0, 0.027, 0.506, 12.721,
+  27, 4, 0.0, 0.036, 0.562, 13.091,
+  28, 4, 0.0, 0.036, 0.598, 13.488,
+  29, 4, 0.0, 0.036, 0.589, 13.873,
+  30, 5, 0.0, 0.045, 0.607, 14.268,
+  31, 5, 0.0, 0.045, 0.620, 14.679,
+  32, 5, 0.0, 0.045, 0.580, 15.067,
+  33, 5, 0.0, 0.045, 0.532, 15.424,
+  34, 5, 0.0, 0.045, 0.517, 15.771,
+  35, 6, 0.0, 0.054, 0.517, 16.120,
+  36, 6, 0.0, 0.054, 0.509, 16.466,
+  37, 6, 0.0, 0.054, 0.506, 16.807,
+  38, 8, 0.0, 0.072, 0.522, 17.158,
+  39, 8, 0.0, 0.072, 0.531, 17.518,
+  40, 8, 0.0, 0.072, 0.519, 17.869,
+  41, 10, 0.0, 0.090, 0.512, 18.215,
+  42, 10, 0.0, 0.090, 0.509, 18.563,
+  43, 10, 0.0, 0.090, 0.498, 18.902,
+  44, 12, 0.0, 0.109, 0.494, 19.239,
+  45, 12, 0.0, 0.109, 0.501, 19.580,
+  46, 13, 0.0, 0.118, 0.508, 19.925,
+  47, 14, 0.0, 0.252, 0.502, 20.269,
+  48, 14, 0.0, 0.252, 0.493, 20.606,
+  49, 16, 0.0, 0.288, 0.497, 20.944,
+  50, 20, 0.0, 0.572, 0.506, 21.288,
+  51, 20, 0.0, 0.572, 0.510, 21.635,
+  52, 23, 0.0, 0.658, 0.504, 21.980,
+  53, 27, 0.0, 2.441, 0.496, 22.319,
+  54, 27, 0.0, 2.441, 0.493, 22.656,
+  55, 32, 0.0, 2.893, 0.490, 22.993,
+  56, 37, 0.0, 33.458, 0.482, 23.326,
+  57, 37, 0.0, 33.458, 0.458, 23.656,
+  58, 12, 0.0, 10.851, 0.500, 23.937,
+  24000, 59,
+  0, 2, 15, 17.8250179, 0.697374165, 0.236874461,
+  1, 2, 15, 17.8250179, 0.455024809, 0.71016103,
+  2, 2, 15, 1.78250182, 0.431440443, 1.18193281,
+  3, 2, 15, 1.78250182, 0.42391625, 1.65102732,
+  4, 2, 13, 0.178250194, 0.418206781, 2.11632562,
+  5, 2, 13, 0.178250194, 0.41158545, 2.57676744,
+  6, 2, 13, 0.0563676581, 0.405409157, 3.03136396,
+  7, 2, 13, 0.0563676581, 0.399695486, 3.47920918,
+  8, 2, 13, 0.0563676581, 0.393753231, 3.91948748,
+  9, 2, 12, 0.0178250186, 0.387357473, 4.35147953,
+  10, 2, 12, 0.0178250186, 0.38045457, 4.77456427,
+  11, 2, 10, 0.0178250186, 0.373053908, 5.18822002,
+  12, 2, 10, 0.0178250186, 0.365188122, 5.59202194,
+  13, 2, 10, 0.0178250186, 0.356897771, 5.98564005,
+  14, 2, 9, 0.0178250186, 0.348700613, 6.36883163,
+  15, 2, 9, 0.0178250186, 0.340260029, 6.74143791,
+  16, 2, 6, 0.0178250186, 0.332341045, 7.10337448,
+  17, 2, 6, 0.0178250186, 0.330462843, 7.45462418,
+  18, 2, 6, 0.0178250186, 0.345568359, 7.79523182,
+  19, 3, 3, 0.0267375279, 0.377859652, 8.20455742,
+  20, 3, 3, 0.0267375279, 0.396689415, 8.67640114,
+  21, 3, 3, 0.0267375279, 0.391237885, 9.12561035,
+  22, 3, 3, 0.0267375279, 0.37761277, 9.55298138,
+  23, 3, 3, 0.0267375279, 0.362836808, 9.95940971,
+  24, 3, 0, 0.0267375279, 0.349010617, 10.3458519,
+  25, 3, 0, 0.0267375279, 0.339673489, 10.7132998,
+  26, 3, 0, 0.0267375279, 0.343845725, 11.0627575,
+  27, 4, 0, 0.0356500372, 0.355822682, 11.447506,
+  28, 4, 0, 0.0356500372, 0.358104348, 11.8627586,
+  29, 4, 0, 0.0356500372, 0.34745428, 12.2520256,
+  30, 4, 0, 0.0356500372, 0.334927917, 12.6173973,
+  31, 4, 0, 0.0356500372, 0.331643254, 12.9608269,
+  32, 5, 0, 0.0445625484, 0.333368897, 13.3219252,
+  33, 5, 0, 0.0445625484, 0.332313001, 13.6976833,
+  34, 5, 0, 0.0445625484, 0.3314417, 14.047802,
+  35, 6, 0, 0.0534750558, 0.330947191, 14.405302,
+  36, 6, 0, 0.0534750558, 0.332477689, 14.7684803,
+  37, 7, 0, 0.062387567, 0.332647532, 15.1315956,
+  38, 7, 0, 0.062387567, 0.330841452, 15.4940481,
+  39, 8, 0, 0.0713000745, 0.327769846, 15.8516159,
+  40, 8, 0, 0.0713000745, 0.324572712, 16.204628,
+  41, 9, 0, 0.0802125856, 0.323825002, 16.5502281,
+  42, 10, 0, 0.0891250968, 0.321414798, 16.9067478,
+  43, 10, 0, 0.0891250968, 0.318189293, 17.2537231,
+  44, 11, 0, 0.0980376005, 0.315934151, 17.5901108,
+  45, 12, 0, 0.106950112, 0.315639287, 17.931406,
+  46, 13, 0, 0.115862623, 0.316569835, 18.2750721,
+  47, 14, 0, 0.124775134, 0.31656, 18.6191597,
+  48, 15, 0, 0.133687645, 0.315465957, 18.9621754,
+  49, 16, 0, 0.142600149, 0.313576341, 19.3029613,
+  50, 17, 0, 0.151512653, 0.311635971, 19.6405869,
+  51, 18, 0, 0.160425171, 0.311066717, 19.9742699,
+  52, 20, 0, 0.355655879, 0.311465651, 20.3115921,
+  53, 21, 0, 0.373438686, 0.311872005, 20.6507797,
+  54, 23, 0, 0.409004271, 0.311015964, 20.9890823,
+  55, 24, 0, 0.676411927, 0.309207708, 21.3251152,
+  56, 26, 0, 0.732779562, 0.3081128, 21.6565971,
+  57, 28, 0, 0.789147198, 0.310006589, 21.9881554,
+  58, 31, 0, 2.76287794, 0.327113092, 22.3222847,
+  59, 34, 0, 3.03025317, 0.416082352, 22.6605186,
+  22050, 59,
+  0, 2, 15, 17.8250179, 0.658683598, 0.217637643,
+  1, 2, 15, 17.8250179, 0.432554901, 0.652563453,
+  2, 2, 15, 1.78250182, 0.405113578, 1.08633137,
+  3, 2, 15, 1.78250182, 0.397231787, 1.51803517,
+  4, 2, 15, 1.78250182, 0.392088681, 1.94679713,
+  5, 2, 13, 0.178250194, 0.386788279, 2.37177849,
+  6, 2, 13, 0.178250194, 0.380574644, 2.79218864,
+  7, 2, 13, 0.0563676581, 0.375309765, 3.20729256,
+  8, 2, 13, 0.0563676581, 0.370087624, 3.61641645,
+  9, 2, 12, 0.0178250186, 0.364568561, 4.01895428,
+  10, 2, 12, 0.0178250186, 0.358959526, 4.4143672,
+  11, 2, 12, 0.0178250186, 0.352938265, 4.80218887,
+  12, 2, 10, 0.0178250186, 0.3465029, 5.18202305,
+  13, 2, 10, 0.0178250186, 0.33968094, 5.55354261,
+  14, 2, 10, 0.0178250186, 0.332571507, 5.91648674,
+  15, 2, 9, 0.0178250186, 0.326015651, 6.27065945,
+  16, 2, 9, 0.0178250186, 0.325442046, 6.61592293,
+  17, 2, 9, 0.0178250186, 0.341315031, 6.95219517,
+  18, 3, 6, 0.0267375279, 0.374984443, 7.3584404,
+  19, 3, 6, 0.0267375279, 0.396138102, 7.8290925,
+  20, 3, 3, 0.0267375279, 0.39271906, 8.27975655,
+  21, 3, 3, 0.0267375279, 0.380755007, 8.71083069,
+  22, 3, 3, 0.0267375279, 0.367386311, 9.12284088,
+  23, 3, 3, 0.0267375279, 0.354351997, 9.51640987,
+  24, 3, 3, 0.0267375279, 0.341508389, 9.89222908,
+  25, 3, 0, 0.0267375279, 0.333577901, 10.2510386,
+  26, 3, 0, 0.0267375279, 0.338108748, 10.5936022,
+  27, 4, 0, 0.0356500372, 0.350744486, 10.9723492,
+  28, 4, 0, 0.0356500372, 0.354519457, 11.38272,
+  29, 4, 0, 0.0356500372, 0.345274031, 11.7689981,
+  30, 4, 0, 0.0356500372, 0.333828837, 12.1329184,
+  31, 4, 0, 0.0356500372, 0.331436664, 12.4761295,
+  32, 5, 0, 0.0445625484, 0.334172577, 12.8381901,
+  33, 5, 0, 0.0445625484, 0.334024847, 13.2160273,
+  34, 5, 0, 0.0445625484, 0.33392629, 13.5690479,
+  35, 6, 0, 0.0534750558, 0.334218502, 13.9303951,
+  36, 6, 0, 0.0534750558, 0.336405039, 14.298193,
+  37, 7, 0, 0.062387567, 0.337080389, 14.666563,
+  38, 7, 0, 0.062387567, 0.335603535, 15.0346909,
+  39, 8, 0, 0.0713000745, 0.332515866, 15.398139,
+  40, 8, 0, 0.0713000745, 0.327727586, 15.7570457,
+  41, 9, 0, 0.0802125856, 0.322346836, 16.1083431,
+  42, 9, 0, 0.0802125856, 0.317575186, 16.4528522,
+  43, 10, 0, 0.0891250968, 0.31632933, 16.7886105,
+  44, 11, 0, 0.0980376005, 0.317602783, 17.132,
+  45, 12, 0, 0.106950112, 0.319945186, 17.4796028,
+  46, 13, 0, 0.115862623, 0.320881754, 17.8287659,
+  47, 14, 0, 0.124775134, 0.320346534, 18.1774921,
+  48, 15, 0, 0.133687645, 0.318628669, 18.5243168,
+  49, 16, 0, 0.142600149, 0.316125751, 18.8681736,
+  50, 17, 0, 0.151512653, 0.313746184, 19.2082729,
+  51, 18, 0, 0.160425171, 0.312971771, 19.5440025,
+  52, 20, 0, 0.178250194, 0.313278913, 19.8831882,
+  53, 21, 0, 0.373438686, 0.313735574, 20.224247,
+  54, 23, 0, 0.409004271, 0.31308493, 20.5646286,
+  55, 24, 0, 0.426787049, 0.31156227, 20.903141,
+  56, 26, 0, 0.732779562, 0.310435742, 21.2376747,
+  57, 28, 0, 0.789147198, 0.31132248, 21.5730591,
+  58, 30, 0, 0.845514894, 0.32730341, 21.9066811,
+  59, 33, 0, 2.94112802, 0.414659739, 22.2411156,
+  16000, 55,
+  0, 3, 15, 26.7375278, 0.697374165, 0.236874461,
+  1, 3, 15, 26.7375278, 0.455024809, 0.71016103,
+  2, 3, 15, 2.67375278, 0.431440443, 1.18193281,
+  3, 3, 15, 2.67375278, 0.42391625, 1.65102732,
+  4, 3, 13, 0.26737529, 0.418206781, 2.11632562,
+  5, 3, 13, 0.26737529, 0.41158545, 2.57676744,
+  6, 3, 13, 0.0845514908, 0.405409157, 3.03136396,
+  7, 3, 13, 0.0845514908, 0.399695486, 3.47920918,
+  8, 3, 13, 0.0845514908, 0.393753231, 3.91948748,
+  9, 3, 12, 0.0267375279, 0.387357473, 4.35147953,
+  10, 3, 12, 0.0267375279, 0.38045457, 4.77456427,
+  11, 3, 10, 0.0267375279, 0.373053908, 5.18822002,
+  12, 3, 10, 0.0267375279, 0.365188122, 5.59202194,
+  13, 3, 10, 0.0267375279, 0.356897742, 5.98564005,
+  14, 3, 9, 0.0267375279, 0.34869957, 6.36883163,
+  15, 3, 9, 0.0267375279, 0.340241522, 6.74143791,
+  16, 3, 6, 0.0267375279, 0.332089454, 7.10337448,
+  17, 3, 6, 0.0267375279, 0.328292668, 7.45462418,
+  18, 3, 6, 0.0267375279, 0.336574793, 7.79523182,
+  19, 4, 3, 0.0356500372, 0.354600489, 8.17827797,
+  20, 4, 3, 0.0356500372, 0.364343345, 8.59994984,
+  21, 4, 3, 0.0356500372, 0.359369367, 9.00363636,
+  22, 4, 3, 0.0356500372, 0.347775847, 9.38988018,
+  23, 4, 3, 0.0356500372, 0.335562587, 9.7592926,
+  24, 4, 0, 0.0356500372, 0.326988578, 10.1125278,
+  25, 4, 0, 0.0356500372, 0.327966213, 10.4502735,
+  26, 5, 0, 0.0445625484, 0.334450752, 10.811614,
+  27, 5, 0, 0.0445625484, 0.335228145, 11.1935263,
+  28, 5, 0, 0.0445625484, 0.329595625, 11.5549288,
+  29, 5, 0, 0.0445625484, 0.326683223, 11.8971443,
+  30, 6, 0, 0.0534750558, 0.326986551, 12.2520256,
+  31, 6, 0, 0.0534750558, 0.325072199, 12.6173973,
+  32, 6, 0, 0.0534750558, 0.323560268, 12.9608269,
+  33, 7, 0, 0.062387567, 0.322494298, 13.3093863,
+  34, 7, 0, 0.062387567, 0.323403448, 13.6617231,
+  35, 8, 0, 0.0713000745, 0.323232353, 14.0134668,
+  36, 8, 0, 0.0713000745, 0.322662383, 14.3639784,
+  37, 9, 0, 0.0802125856, 0.324054241, 14.7098465,
+  38, 10, 0, 0.0891250968, 0.323228806, 15.0686541,
+  39, 10, 0, 0.0891250968, 0.320751846, 15.4191036,
+  40, 11, 0, 0.0980376005, 0.318823338, 15.7594051,
+  41, 12, 0, 0.106950112, 0.318418682, 16.104557,
+  42, 13, 0, 0.115862623, 0.318762124, 16.451416,
+  43, 14, 0, 0.124775134, 0.317806393, 16.7975388,
+  44, 15, 0, 0.133687645, 0.315653771, 17.1411018,
+  45, 16, 0, 0.142600149, 0.313369036, 17.4808159,
+  46, 17, 0, 0.151512653, 0.312513858, 17.8158207,
+  47, 19, 0, 0.169337675, 0.312785119, 18.1543369,
+  48, 20, 0, 0.178250194, 0.31343773, 18.4948578,
+  49, 22, 0, 0.196075201, 0.313258767, 18.8350143,
+  50, 23, 0, 0.20498772, 0.312570423, 19.1740704,
+  51, 25, 0, 0.222812727, 0.312572777, 19.5104179,
+  52, 27, 0, 0.240637749, 0.313047856, 19.8497677,
+  53, 29, 0, 0.515701056, 0.315029174, 20.1900635,
+  54, 31, 0, 0.551266611, 0.330613613, 20.5294952,
+  55, 33, 0, 0.586832225, 0.41819948, 20.8664398,
+  48000.0, 37,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.989, -8.240, 1.875,
+  2, 1, 0.029, 0.989, -8.240, 3.750,
+  3, 1, 0.009, 0.981, -8.240, 5.438,
+  4, 1, 0.009, 0.985, -8.240, 6.857,
+  5, 1, 0.009, 0.984, -8.240, 8.109,
+  6, 1, 0.009, 0.980, -8.240, 9.237,
+  7, 1, 0.009, 0.968, -8.240, 10.202,
+  8, 1, 0.009, 0.954, -8.240, 11.083,
+  9, 1, 0.009, 0.929, -8.240, 11.865,
+  10, 1, 0.009, 0.906, -7.447, 12.554,
+  11, 1, 0.009, 0.883, -7.447, 13.195,
+  12, 1, 0.009, 0.844, -7.447, 13.781,
+  13, 1, 0.009, 0.792, -7.447, 14.309,
+  14, 1, 0.009, 0.747, -7.447, 14.803,
+  15, 1, 0.009, 0.689, -7.447, 15.250,
+  16, 1, 0.009, 0.644, -7.447, 15.667,
+  17, 1, 0.009, 0.592, -7.447, 16.068,
+  18, 1, 0.009, 0.553, -7.447, 16.409,
+  19, 2, 0.018, 0.850, -7.447, 17.045,
+  20, 2, 0.018, 0.811, -6.990, 17.607,
+  21, 2, 0.018, 0.736, -6.990, 18.097,
+  22, 2, 0.018, 0.665, -6.990, 18.528,
+  23, 2, 0.018, 0.610, -6.990, 18.931,
+  24, 2, 0.018, 0.544, -6.990, 19.295,
+  25, 2, 0.018, 0.528, -6.990, 19.636,
+  26, 3, 0.054, 0.621, -6.990, 20.038,
+  27, 3, 0.054, 0.673, -6.990, 20.486,
+  28, 3, 0.054, 0.635, -6.990, 20.900,
+  29, 4, 0.114, 0.626, -6.990, 21.306,
+  30, 4, 0.114, 0.636, -6.020, 21.722,
+  31, 5, 0.452, 0.615, -6.020, 22.128,
+  32, 5, 0.452, 0.579, -6.020, 22.513,
+  33, 5, 0.452, 0.551, -6.020, 22.877,
+  34, 7, 6.330, 0.552, -5.229, 23.241,
+  35, 7, 6.330, 0.559, -5.229, 23.616,
+  36, 11, 9.947, 0.528, -5.229, 23.974,
+  37, 17, 153.727, 0.479, -5.229, 24.313,
+  44100.0, 38,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.983, -8.240, 1.723,
+  2, 1, 0.029, 0.983, -8.240, 3.445,
+  3, 1, 0.009, 0.982, -8.240, 5.057,
+  4, 1, 0.009, 0.985, -8.240, 6.422,
+  5, 1, 0.009, 0.983, -8.240, 7.609,
+  6, 1, 0.009, 0.978, -8.240, 8.710,
+  7, 1, 0.009, 0.967, -8.240, 9.662,
+  8, 1, 0.009, 0.948, -8.240, 10.515,
+  9, 1, 0.009, 0.930, -8.240, 11.293,
+  10, 1, 0.009, 0.914, -7.447, 12.009,
+  11, 1, 0.009, 0.870, -7.447, 12.625,
+  12, 1, 0.009, 0.845, -7.447, 13.210,
+  13, 1, 0.009, 0.800, -7.447, 13.748,
+  14, 1, 0.009, 0.749, -7.447, 14.241,
+  15, 1, 0.009, 0.701, -7.447, 14.695,
+  16, 1, 0.009, 0.653, -7.447, 15.125,
+  17, 1, 0.009, 0.590, -7.447, 15.508,
+  18, 1, 0.009, 0.616, -7.447, 15.891,
+  19, 2, 0.018, 0.860, -7.447, 16.537,
+  20, 2, 0.018, 0.823, -6.990, 17.112,
+  21, 2, 0.018, 0.762, -6.990, 17.621,
+  22, 2, 0.018, 0.688, -6.990, 18.073,
+  23, 2, 0.018, 0.612, -6.990, 18.470,
+  24, 2, 0.018, 0.594, -6.990, 18.849,
+  25, 3, 0.027, 0.658, -6.990, 19.271,
+  26, 3, 0.027, 0.706, -6.990, 19.741,
+  27, 3, 0.054, 0.660, -6.990, 20.177,
+  28, 3, 0.054, 0.606, -6.990, 20.576,
+  29, 3, 0.054, 0.565, -6.990, 20.950,
+  30, 4, 0.114, 0.560, -6.020, 21.316,
+  31, 4, 0.114, 0.579, -6.020, 21.699,
+  32, 5, 0.452, 0.567, -6.020, 22.078,
+  33, 5, 0.452, 0.534, -6.020, 22.438,
+  34, 5, 0.452, 0.514, -5.229, 22.782,
+  35, 7, 6.330, 0.520, -5.229, 23.133,
+  36, 7, 6.330, 0.518, -5.229, 23.484,
+  37, 7, 6.330, 0.507, -5.229, 23.828,
+  38, 19, 171.813, 0.447, -4.559, 24.173,
+  32000.0, 41,
+  0, 1, 4.532, 1.000, -8.240, 0.000,
+  1, 1, 0.904, 0.985, -8.240, 1.250,
+  2, 1, 0.090, 0.983, -8.240, 2.500,
+  3, 1, 0.029, 0.983, -8.240, 3.750,
+  4, 1, 0.009, 0.981, -8.240, 4.909,
+  5, 1, 0.009, 0.975, -8.240, 5.958,
+  6, 1, 0.009, 0.959, -8.240, 6.857,
+  7, 1, 0.009, 0.944, -8.240, 7.700,
+  8, 1, 0.009, 0.933, -8.240, 8.500,
+  9, 1, 0.009, 0.920, -8.240, 9.237,
+  10, 1, 0.009, 0.892, -7.447, 9.895,
+  11, 1, 0.009, 0.863, -7.447, 10.500,
+  12, 1, 0.009, 0.839, -7.447, 11.083,
+  13, 1, 0.009, 0.786, -7.447, 11.604,
+  14, 1, 0.009, 0.755, -7.447, 12.107,
+  15, 1, 0.009, 0.698, -7.447, 12.554,
+  16, 1, 0.009, 0.673, -7.447, 13.000,
+  17, 1, 0.009, 0.605, -7.447, 13.391,
+  18, 1, 0.009, 0.629, -7.447, 13.781,
+  19, 2, 0.018, 0.883, -7.447, 14.474,
+  20, 2, 0.018, 0.858, -6.990, 15.096,
+  21, 2, 0.018, 0.829, -6.990, 15.667,
+  22, 2, 0.018, 0.767, -6.990, 16.177,
+  23, 2, 0.018, 0.705, -6.990, 16.636,
+  24, 2, 0.018, 0.637, -6.990, 17.057,
+  25, 2, 0.018, 0.564, -6.990, 17.429,
+  26, 2, 0.018, 0.550, -6.990, 17.786,
+  27, 3, 0.027, 0.603, -6.990, 18.177,
+  28, 3, 0.027, 0.635, -6.990, 18.597,
+  29, 3, 0.027, 0.592, -6.990, 18.994,
+  30, 3, 0.027, 0.533, -6.020, 19.352,
+  31, 3, 0.027, 0.518, -6.020, 19.693,
+  32, 4, 0.072, 0.568, -6.020, 20.066,
+  33, 4, 0.072, 0.594, -6.020, 20.462,
+  34, 4, 0.072, 0.568, -5.229, 20.841,
+  35, 5, 0.143, 0.536, -5.229, 21.201,
+  36, 5, 0.143, 0.522, -5.229, 21.549,
+  37, 6, 0.172, 0.542, -5.229, 21.911,
+  38, 7, 0.633, 0.539, -4.559, 22.275,
+  39, 7, 0.633, 0.519, -4.559, 22.625,
+  40, 8, 0.723, 0.514, -3.980, 22.971,
+  41, 10, 9.043, 0.518, -3.980, 23.321,
+  24000, 44,
+  0, 1, 8.91250896, 0.971850038, 0.150000006, 0,
+  1, 1, 8.91250896, 0.874727964, 0.150000006, 0.946573138,
+  2, 1, 0.891250908, 0.85779953, 0.150000006, 1.88476217,
+  3, 1, 0.0891250968, 0.839743853, 0.150000006, 2.8056457,
+  4, 1, 0.028183829, 0.82260257, 0.150000006, 3.70133615,
+  5, 1, 0.00891250931, 0.80018574, 0.150000006, 4.56532001,
+  6, 1, 0.00891250931, 0.771475196, 0.150000006, 5.39263105,
+  7, 1, 0.00891250931, 0.737389982, 0.150000006, 6.17986727,
+  8, 1, 0.00891250931, 0.701111019, 0.150000006, 6.92507982,
+  9, 1, 0.00891250931, 0.65977633, 0.150000006, 7.62757969,
+  10, 1, 0.00891250931, 0.615037441, 0.150000006, 8.28770351,
+  11, 1, 0.00891250931, 0.568658054, 0.150000006, 8.90657234,
+  12, 1, 0.00891250931, 0.522260666, 0.180000007, 9.48587132,
+  13, 1, 0.00891250931, 0.478903115, 0.180000007, 10.0276566,
+  14, 1, 0.00891250931, 0.43808648, 0.180000007, 10.5341988,
+  15, 1, 0.00891250931, 0.412505627, 0.180000007, 11.0078659,
+  16, 1, 0.00891250931, 0.39070797, 0.180000007, 11.4510288,
+  17, 1, 0.00891250931, 0.371887118, 0.180000007, 11.866004,
+  18, 1, 0.00891250931, 0.367617637, 0.180000007, 12.2550087,
+  19, 1, 0.00891250931, 0.422220588, 0.180000007, 12.6201363,
+  20, 2, 0.0178250186, 0.564990044, 0.180000007, 13.2772083,
+  21, 2, 0.0178250186, 0.519700944, 0.180000007, 13.871047,
+  22, 2, 0.0178250186, 0.455360681, 0.200000003, 14.4024391,
+  23, 2, 0.0178250186, 0.408867925, 0.200000003, 14.8811684,
+  24, 2, 0.0178250186, 0.381538749, 0.200000003, 15.3153324,
+  25, 2, 0.0178250186, 0.362357527, 0.200000003, 15.7116165,
+  26, 2, 0.0178250186, 0.365735918, 0.200000003, 16.0755405,
+  27, 3, 0.0267375279, 0.38064, 0.200000003, 16.4882088,
+  28, 3, 0.0267375279, 0.379183382, 0.200000003, 16.9410992,
+  29, 3, 0.0267375279, 0.360672712, 0.200000003, 17.3513336,
+  30, 3, 0.0267375279, 0.343065977, 0.200000003, 17.7264423,
+  31, 3, 0.0267375279, 0.339290261, 0.200000003, 18.0722466,
+  32, 4, 0.0356500372, 0.342963994, 0.200000003, 18.4426575,
+  33, 4, 0.0356500372, 0.343128443, 0.200000003, 18.8344078,
+  34, 4, 0.0356500372, 0.343988508, 0.25, 19.1955795,
+  35, 5, 0.0445625484, 0.343928397, 0.25, 19.5697021,
+  36, 5, 0.0445625484, 0.339527696, 0.25, 19.9551182,
+  37, 5, 0.0889139697, 0.336541563, 0.280000001, 20.3115921,
+  38, 6, 0.106696762, 0.334955156, 0.280000001, 20.6737747,
+  39, 6, 0.169102982, 0.335601568, 0.300000012, 21.0404968,
+  40, 7, 0.1972868, 0.334716886, 0.300000012, 21.4060211,
+  41, 7, 0.1972868, 0.331676662, 0.300000012, 21.7696877,
+  42, 8, 0.713000774, 0.328550965, 0.400000006, 22.1267223,
+  43, 8, 0.713000774, 0.339241952, 0.400000006, 22.4769249,
+  44, 9, 0.802125871, 0.425207615, 0.400000006, 22.8164864,
+  22050, 44,
+  0, 1, 8.91250896, 0.954045713, 0.150000006, 0,
+  1, 1, 8.91250896, 0.833381653, 0.150000006, 0.869851649,
+  2, 1, 0.891250908, 0.815945923, 0.150000006, 1.73325908,
+  3, 1, 0.0891250968, 0.794244766, 0.150000006, 2.58322191,
+  4, 1, 0.028183829, 0.776486695, 0.150000006, 3.4134295,
+  5, 1, 0.00891250931, 0.755260408, 0.150000006, 4.21850443,
+  6, 1, 0.00891250931, 0.731070817, 0.150000006, 4.99414825,
+  7, 1, 0.00891250931, 0.701775849, 0.150000006, 5.73718691,
+  8, 1, 0.00891250931, 0.667876124, 0.150000006, 6.44553185,
+  9, 1, 0.00891250931, 0.630284071, 0.150000006, 7.11807632,
+  10, 1, 0.00891250931, 0.590170324, 0.150000006, 7.75455618,
+  11, 1, 0.00891250931, 0.548788548, 0.150000006, 8.3553915,
+  12, 1, 0.00891250931, 0.507795513, 0.150000006, 8.92152882,
+  13, 1, 0.00891250931, 0.469515711, 0.180000007, 9.45430183,
+  14, 1, 0.00891250931, 0.432291716, 0.180000007, 9.95530319,
+  15, 1, 0.00891250931, 0.411131173, 0.180000007, 10.4262848,
+  16, 1, 0.00891250931, 0.390771538, 0.180000007, 10.8690758,
+  17, 1, 0.00891250931, 0.373318017, 0.180000007, 11.2855215,
+  18, 1, 0.00891250931, 0.36956048, 0.180000007, 11.6774378,
+  19, 1, 0.00891250931, 0.42595759, 0.180000007, 12.0465794,
+  20, 2, 0.0178250186, 0.576900065, 0.180000007, 12.7141209,
+  21, 2, 0.0178250186, 0.533114731, 0.180000007, 13.3197365,
+  22, 2, 0.0178250186, 0.469967514, 0.180000007, 13.8634901,
+  23, 2, 0.0178250186, 0.417268544, 0.200000003, 14.3544445,
+  24, 2, 0.0178250186, 0.389299124, 0.200000003, 14.8002586,
+  25, 2, 0.0178250186, 0.362824857, 0.200000003, 15.2073727,
+  26, 2, 0.0178250186, 0.346801281, 0.200000003, 15.5811834,
+  27, 2, 0.0178250186, 0.349400043, 0.200000003, 15.926218,
+  28, 3, 0.0267375279, 0.364026934, 0.200000003, 16.3194923,
+  29, 3, 0.0267375279, 0.36560446, 0.200000003, 16.752903,
+  30, 3, 0.0267375279, 0.354275256, 0.200000003, 17.1470814,
+  31, 3, 0.0267375279, 0.351219416, 0.200000003, 17.5086212,
+  32, 4, 0.0356500372, 0.354364097, 0.200000003, 17.8938141,
+  33, 4, 0.0356500372, 0.348915905, 0.200000003, 18.2992878,
+  34, 4, 0.0356500372, 0.337649345, 0.200000003, 18.6713982,
+  35, 4, 0.0356500372, 0.332076877, 0.25, 19.015646,
+  36, 5, 0.0445625484, 0.330793113, 0.25, 19.3734016,
+  37, 5, 0.0445625484, 0.327528268, 0.25, 19.7430382,
+  38, 5, 0.0889139697, 0.32551071, 0.280000001, 20.0859604,
+  39, 6, 0.106696762, 0.324436843, 0.280000001, 20.4354992,
+  40, 6, 0.106696762, 0.325835049, 0.280000001, 20.7905579,
+  41, 7, 0.1972868, 0.326221824, 0.300000012, 21.1458054,
+  42, 7, 0.1972868, 0.325960994, 0.300000012, 21.5005951,
+  43, 8, 0.225470632, 0.339019388, 0.300000012, 21.8504524,
+  44, 8, 0.713000774, 0.426850349, 0.400000006, 22.1951065,
+  16000, 45,
+  0, 1, 8.91250896, 0.834739447, 0.150000006, 0,
+  1, 1, 8.91250896, 0.623757005, 0.150000006, 0.631518543,
+  2, 1, 0.891250908, 0.60420388, 0.150000006, 1.2606914,
+  3, 1, 0.891250908, 0.591974258, 0.150000006, 1.88476217,
+  4, 1, 0.0891250968, 0.575301588, 0.150000006, 2.50111985,
+  5, 1, 0.028183829, 0.561547697, 0.150000006, 3.1073606,
+  6, 1, 0.028183829, 0.546665847, 0.150000006, 3.70133615,
+  7, 1, 0.00891250931, 0.52986443, 0.150000006, 4.28118753,
+  8, 1, 0.00891250931, 0.511183441, 0.150000006, 4.84536505,
+  9, 1, 0.00891250931, 0.490902334, 0.150000006, 5.39263105,
+  10, 1, 0.00891250931, 0.46938166, 0.150000006, 5.92205667,
+  11, 1, 0.00891250931, 0.447003782, 0.150000006, 6.43299866,
+  12, 1, 0.00891250931, 0.428170592, 0.150000006, 6.92507982,
+  13, 1, 0.00891250931, 0.414536625, 0.150000006, 7.39815664,
+  14, 1, 0.00891250931, 0.401033074, 0.150000006, 7.85228777,
+  15, 1, 0.00891250931, 0.38779071, 0.150000006, 8.28770351,
+  16, 1, 0.00891250931, 0.374230444, 0.150000006, 8.704772,
+  17, 1, 0.00891250931, 0.360547513, 0.180000007, 9.10397339,
+  18, 1, 0.00891250931, 0.348256677, 0.180000007, 9.48587132,
+  19, 1, 0.00891250931, 0.350327015, 0.180000007, 9.85109234,
+  20, 1, 0.00891250931, 0.406330824, 0.180000007, 10.200304,
+  21, 2, 0.0178250186, 0.554098248, 0.180000007, 10.846529,
+  22, 2, 0.0178250186, 0.528312504, 0.180000007, 11.4447651,
+  23, 2, 0.0178250186, 0.476527005, 0.180000007, 11.9928398,
+  24, 2, 0.0178250186, 0.428205669, 0.180000007, 12.495945,
+  25, 2, 0.0178250186, 0.402271926, 0.180000007, 12.9588718,
+  26, 2, 0.0178250186, 0.378024429, 0.180000007, 13.3859692,
+  27, 2, 0.0178250186, 0.36254698, 0.180000007, 13.7811394,
+  28, 2, 0.0178250186, 0.368058592, 0.200000003, 14.1478529,
+  29, 3, 0.0267375279, 0.385963261, 0.200000003, 14.5674343,
+  30, 3, 0.0267375279, 0.38640517, 0.200000003, 15.0304852,
+  31, 3, 0.0267375279, 0.367834061, 0.200000003, 15.4513416,
+  32, 3, 0.0267375279, 0.349686563, 0.200000003, 15.836277,
+  33, 3, 0.0267375279, 0.345709383, 0.200000003, 16.1904697,
+  34, 4, 0.0356500372, 0.34871915, 0.200000003, 16.5683517,
+  35, 4, 0.0356500372, 0.347054332, 0.200000003, 16.9660263,
+  36, 4, 0.0356500372, 0.346329987, 0.200000003, 17.3304482,
+  37, 5, 0.0445625484, 0.344658494, 0.200000003, 17.7055588,
+  38, 5, 0.0445625484, 0.338779271, 0.200000003, 18.0899811,
+  39, 5, 0.0445625484, 0.334878683, 0.200000003, 18.4440536,
+  40, 6, 0.0534750558, 0.332811534, 0.200000003, 18.8030052,
+  41, 6, 0.0534750558, 0.333717585, 0.25, 19.1665268,
+  42, 7, 0.062387567, 0.333986402, 0.25, 19.5299358,
+  43, 7, 0.062387567, 0.334142625, 0.25, 19.8934898,
+  44, 8, 0.142262354, 0.34677428, 0.280000001, 20.2535706,
+  45, 8, 0.142262354, 0.436254472, 0.280000001, 20.610569,
+  48000.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.639,
+  5, 2, 17, 19, 0.361, 0.417,
+  6, 3, 19, 22, 0.583, 0.083,
+  7, 2, 22, 24, 0.917, 0.750,
+  8, 3, 24, 27, 0.250, 0.417,
+  9, 3, 27, 30, 0.583, 0.648,
+  10, 3, 30, 33, 0.352, 0.611,
+  11, 3, 33, 36, 0.389, 0.625,
+  12, 4, 36, 40, 0.375, 0.144,
+  13, 3, 40, 43, 0.856, 0.389,
+  14, 3, 43, 46, 0.611, 0.160,
+  15, 3, 46, 49, 0.840, 0.217,
+  16, 3, 49, 52, 0.783, 0.184,
+  17, 2, 52, 54, 0.816, 0.886,
+  18, 3, 54, 57, 0.114, 0.313,
+  19, 2, 57, 59, 0.687, 0.452,
+  20, 1, 59, 60, 0.548, 0.908,
+  44100.0, 20,
+  0, 3, 0, 4, 1.000, 0.056,
+  1, 3, 4, 7, 0.944, 0.611,
+  2, 4, 7, 11, 0.389, 0.167,
+  3, 3, 11, 14, 0.833, 0.722,
+  4, 3, 14, 17, 0.278, 0.139,
+  5, 1, 17, 18, 0.861, 0.917,
+  6, 3, 18, 21, 0.083, 0.583,
+  7, 3, 21, 24, 0.417, 0.250,
+  8, 3, 24, 27, 0.750, 0.805,
+  9, 3, 27, 30, 0.194, 0.574,
+  10, 3, 30, 33, 0.426, 0.537,
+  11, 3, 33, 36, 0.463, 0.819,
+  12, 4, 36, 40, 0.180, 0.100,
+  13, 3, 40, 43, 0.900, 0.468,
+  14, 3, 43, 46, 0.532, 0.623,
+  15, 3, 46, 49, 0.376, 0.450,
+  16, 3, 49, 52, 0.550, 0.552,
+  17, 3, 52, 55, 0.448, 0.403,
+  18, 2, 55, 57, 0.597, 0.643,
+  19, 2, 57, 59, 0.357, 0.722,
+  20, 2, 59, 61, 0.278, 0.960,
+  32000, 20,
+  0, 1, 0, 2, 1.000, 0.528,
+  1, 2, 2, 4, 0.472, 0.305,
+  2, 2, 4, 6, 0.694, 0.083,
+  3, 1, 6, 7, 0.917, 0.861,
+  4, 2, 7, 9, 0.139, 0.639,
+  5, 2, 9, 11, 0.361, 0.417,
+  6, 3, 11, 14, 0.583, 0.083,
+  7, 2, 14, 16, 0.917, 0.750,
+  8, 3, 16, 19, 0.250, 0.870,
+  9, 3, 19, 22, 0.130, 0.833,
+  10, 4, 22, 26, 0.167, 0.389,
+  11, 4, 26, 30, 0.611, 0.478,
+  12, 4, 30, 34, 0.522, 0.033,
+  13, 3, 34, 37, 0.967, 0.917,
+  14, 4, 37, 41, 0.083, 0.617,
+  15, 3, 41, 44, 0.383, 0.995,
+  16, 4, 44, 48, 0.005, 0.274,
+  17, 3, 48, 51, 0.726, 0.480,
+  18, 3, 51, 54, 0.519, 0.261,
+  19, 2, 54, 56, 0.739, 0.884,
+  20, 2, 56, 58, 0.116, 1.000,
+  24000, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.537036896,
+  7, 3, 20, 23, 0.462963104, 0.5,
+  8, 4, 23, 27, 0.5, 0.0555559993,
+  9, 3, 27, 30, 0.944444001, 0.402778625,
+  10, 3, 30, 33, 0.597221375, 0.766667187,
+  11, 3, 33, 36, 0.233332828, 0.805555999,
+  12, 3, 36, 39, 0.194444016, 0.769841909,
+  13, 3, 39, 42, 0.23015812, 0.611111104,
+  14, 3, 42, 45, 0.388888896, 0.449494779,
+  15, 3, 45, 48, 0.550505221, 0.194444954,
+  16, 2, 48, 50, 0.805555046, 0.913194656,
+  17, 3, 50, 53, 0.0868053436, 0.580555737,
+  18, 3, 53, 56, 0.419444263, 0.113426208,
+  19, 2, 56, 58, 0.886573792, 0.533730626,
+  20, 2, 58, 60, 0.466269344, 0.691176474,
+  22050, 20,
+  0, 2, 0, 3, 1, 0.916666746,
+  1, 3, 3, 6, 0.0833332539, 0.583333492,
+  2, 3, 6, 9, 0.416666508, 0.25,
+  3, 2, 9, 11, 0.75, 0.916666985,
+  4, 3, 11, 14, 0.0833330154, 0.583333969,
+  5, 3, 14, 17, 0.416666031, 0.25,
+  6, 3, 17, 20, 0.75, 0.203703582,
+  7, 3, 20, 23, 0.796296418, 0.166666687,
+  8, 3, 23, 26, 0.833333313, 0.722222686,
+  9, 4, 26, 30, 0.277777344, 0.152778625,
+  10, 3, 30, 33, 0.847221375, 0.566667199,
+  11, 3, 33, 36, 0.433332831, 0.93518573,
+  12, 4, 36, 40, 0.0648142472, 0.118056297,
+  13, 3, 40, 43, 0.881943703, 0.0925937295,
+  14, 2, 43, 45, 0.907406271, 0.934344172,
+  15, 3, 45, 48, 0.0656557977, 0.575398028,
+  16, 3, 48, 51, 0.424601972, 0.232026935,
+  17, 2, 51, 53, 0.767973065, 0.758334339,
+  18, 3, 53, 56, 0.241665646, 0.187501252,
+  19, 2, 56, 58, 0.812498748, 0.533731699,
+  20, 2, 58, 60, 0.466268271, 0.257577598,
+  16000, 20,
+  0, 1, 0, 2, 1, 0.944444478,
+  1, 2, 2, 4, 0.0555555038, 0.722222328,
+  2, 2, 4, 6, 0.277777672, 0.5,
+  3, 2, 6, 8, 0.5, 0.27777797,
+  4, 2, 8, 10, 0.72222203, 0.0555559993,
+  5, 1, 10, 11, 0.944444001, 0.833333313,
+  6, 3, 11, 14, 0.166666672, 0.203703582,
+  7, 3, 14, 17, 0.796296418, 0.166666687,
+  8, 3, 17, 20, 0.833333313, 0.54166698,
+  9, 3, 20, 23, 0.458333015, 0.652778625,
+  10, 4, 23, 27, 0.347221375, 0.166667163,
+  11, 3, 27, 30, 0.833332837, 0.722222924,
+  12, 4, 30, 34, 0.277777106, 0.277778625,
+  13, 3, 34, 37, 0.722221375, 0.604167938,
+  14, 3, 37, 40, 0.395832062, 0.627778649,
+  15, 3, 40, 43, 0.37222138, 0.542736351,
+  16, 3, 43, 46, 0.457263649, 0.371528625,
+  17, 3, 46, 49, 0.628471375, 0.00833433867,
+  18, 2, 49, 51, 0.991665661, 0.500001311,
+  19, 2, 51, 53, 0.499998659, 0.886832893,
+  20, 2, 53, 55, 0.113167092, 0.629034221,
+  48000.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 4, 15, 19, 0.833, 0.583,
+  6, 3, 19, 22, 0.417, 0.917,
+  7, 4, 22, 26, 0.083, 0.944,
+  8, 4, 26, 30, 0.055, 0.042,
+  9, 2, 30, 32, 0.958, 0.567,
+  10, 3, 32, 35, 0.433, 0.167,
+  11, 2, 35, 37, 0.833, 0.618,
+  44100.0, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 3, 20, 23, 0.750, 0.583,
+  7, 4, 23, 27, 0.417, 0.055,
+  8, 3, 27, 30, 0.944, 0.375,
+  9, 3, 30, 33, 0.625, 0.300,
+  10, 3, 33, 36, 0.700, 0.167,
+  11, 2, 36, 38, 0.833, 1.000,
+  32000, 11,
+  0, 2, 0, 2, 1.000, 0.167,
+  1, 2, 3, 5, 0.833, 0.833,
+  2, 3, 5, 8, 0.167, 0.500,
+  3, 3, 8, 11, 0.500, 0.167,
+  4, 4, 11, 15, 0.833, 0.167,
+  5, 5, 15, 20, 0.833, 0.250,
+  6, 4, 20, 24, 0.750, 0.250,
+  7, 5, 24, 29, 0.750, 0.055,
+  8, 4, 29, 33, 0.944, 0.375,
+  9, 4, 33, 37, 0.625, 0.472,
+  10, 3, 37, 40, 0.528, 0.937,
+  11, 1, 40, 41, 0.062, 1.000,
+  24000, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 5, 13, 18, 0.5, 0.833333969,
+  5, 5, 18, 23, 0.166666031, 0.25,
+  6, 4, 23, 27, 0.75, 0.25,
+  7, 3, 27, 30, 0.75, 0.611111999,
+  8, 4, 30, 34, 0.388888031, 0.208333969,
+  9, 3, 34, 37, 0.791666031, 0.766667187,
+  10, 4, 37, 41, 0.233332828, 0.45238167,
+  11, 4, 41, 45, 0.54761833, 0.277778625,
+  22050, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 4, 13, 17, 0.5, 0.5,
+  5, 4, 17, 21, 0.5, 0.916666985,
+  6, 4, 21, 25, 0.0833330154, 0.25,
+  7, 4, 25, 29, 0.75, 0.611111999,
+  8, 4, 29, 33, 0.388888031, 0.458333969,
+  9, 4, 33, 37, 0.541666031, 0.633334339,
+  10, 4, 37, 41, 0.366665661, 0.583334565,
+  11, 4, 41, 45, 0.416665405, 0.437500954,
+  16000, 11,
+  0, 3, 0, 4, 1, 0.166666746,
+  1, 2, 4, 6, 0.833333254, 0.833333492,
+  2, 3, 6, 9, 0.166666508, 0.5,
+  3, 4, 9, 13, 0.5, 0.5,
+  4, 5, 13, 18, 0.5, 0.833333969,
+  5, 5, 18, 23, 0.166666031, 0.75,
+  6, 4, 23, 27, 0.25, 0.75,
+  7, 4, 27, 31, 0.25, 0.611111999,
+  8, 4, 31, 35, 0.388888031, 0.458333969,
+  9, 4, 35, 39, 0.541666031, 0.166667163,
+  10, 3, 39, 42, 0.833332837, 0.805555999,
+  11, 4, 42, 46, 0.194444016, 0.4375};
+ 
+ double enwindow[] = 
+ {0.000000000, -0.000000477, -0.000000477, -0.000000477,
+  -0.000000477, -0.000000477, -0.000000477, -0.000000954,
+  -0.000000954, -0.000000954, -0.000000954, -0.000001431,
+  -0.000001431, -0.000001907, -0.000001907, -0.000002384,
+  -0.000002384, -0.000002861, -0.000003338, -0.000003338,
+  -0.000003815, -0.000004292, -0.000004768, -0.000005245,
+  -0.000006199, -0.000006676, -0.000007629, -0.000008106,
+  -0.000009060, -0.000010014, -0.000011444, -0.000012398,
+  -0.000013828, -0.000014782, -0.000016689, -0.000018120,
+  -0.000019550, -0.000021458, -0.000023365, -0.000025272,
+  -0.000027657, -0.000030041, -0.000032425, -0.000034809,
+  -0.000037670, -0.000040531, -0.000043392, -0.000046253,
+  -0.000049591, -0.000052929, -0.000055790, -0.000059605,
+  -0.000062943, -0.000066280, -0.000070095, -0.000073433,
+  -0.000076771, -0.000080585, -0.000083923, -0.000087261,
+  -0.000090599, -0.000093460, -0.000096321, -0.000099182,
+  0.000101566, 0.000103951, 0.000105858, 0.000107288,
+  0.000108242, 0.000108719, 0.000108719, 0.000108242,
+  0.000106812, 0.000105381, 0.000102520, 0.000099182,
+  0.000095367, 0.000090122, 0.000084400, 0.000077724,
+  0.000069618, 0.000060558, 0.000050545, 0.000039577,
+  0.000027180, 0.000013828, -0.000000954, -0.000017166,
+  -0.000034332, -0.000052929, -0.000072956, -0.000093937,
+  -0.000116348, -0.000140190, -0.000165462, -0.000191212,
+  -0.000218868, -0.000247478, -0.000277042, -0.000307560,
+  -0.000339031, -0.000371456, -0.000404358, -0.000438213,
+  -0.000472546, -0.000507355, -0.000542164, -0.000576973,
+  -0.000611782, -0.000646591, -0.000680923, -0.000714302,
+  -0.000747204, -0.000779152, -0.000809669, -0.000838757,
+  -0.000866413, -0.000891685, -0.000915051, -0.000935555,
+  -0.000954151, -0.000968933, -0.000980854, -0.000989437,
+  -0.000994205, -0.000995159, -0.000991821, -0.000983715,
+  0.000971317, 0.000953674, 0.000930786, 0.000902653,
+  0.000868797, 0.000829220, 0.000783920, 0.000731945,
+  0.000674248, 0.000610352, 0.000539303, 0.000462532,
+  0.000378609, 0.000288486, 0.000191689, 0.000088215,
+  -0.000021458, -0.000137329, -0.000259876, -0.000388145,
+  -0.000522137, -0.000661850, -0.000806808, -0.000956535,
+  -0.001111031, -0.001269817, -0.001432419, -0.001597881,
+  -0.001766682, -0.001937389, -0.002110004, -0.002283096,
+  -0.002457142, -0.002630711, -0.002803326, -0.002974033,
+  -0.003141880, -0.003306866, -0.003467083, -0.003622532,
+  -0.003771782, -0.003914356, -0.004048824, -0.004174709,
+  -0.004290581, -0.004395962, -0.004489899, -0.004570484,
+  -0.004638195, -0.004691124, -0.004728317, -0.004748821,
+  -0.004752159, -0.004737377, -0.004703045, -0.004649162,
+  -0.004573822, -0.004477024, -0.004357815, -0.004215240,
+  -0.004049301, -0.003858566, -0.003643036, -0.003401756,
+  0.003134727, 0.002841473, 0.002521515, 0.002174854,
+  0.001800537, 0.001399517, 0.000971317, 0.000515938,
+  0.000033379, -0.000475883, -0.001011848, -0.001573563,
+  -0.002161503, -0.002774239, -0.003411293, -0.004072189,
+  -0.004756451, -0.005462170, -0.006189346, -0.006937027,
+  -0.007703304, -0.008487225, -0.009287834, -0.010103703,
+  -0.010933399, -0.011775017, -0.012627602, -0.013489246,
+  -0.014358521, -0.015233517, -0.016112804, -0.016994476,
+  -0.017876148, -0.018756866, -0.019634247, -0.020506859,
+  -0.021372318, -0.022228718, -0.023074150, -0.023907185,
+  -0.024725437, -0.025527000, -0.026310921, -0.027073860,
+  -0.027815342, -0.028532982, -0.029224873, -0.029890060,
+  -0.030526638, -0.031132698, -0.031706810, -0.032248020,
+  -0.032754898, -0.033225536, -0.033659935, -0.034055710,
+  -0.034412861, -0.034730434, -0.035007000, -0.035242081,
+  -0.035435200, -0.035586357, -0.035694122, -0.035758972,
+  0.035780907, 0.035758972, 0.035694122, 0.035586357,
+  0.035435200, 0.035242081, 0.035007000, 0.034730434,
+  0.034412861, 0.034055710, 0.033659935, 0.033225536,
+  0.032754898, 0.032248020, 0.031706810, 0.031132698,
+  0.030526638, 0.029890060, 0.029224873, 0.028532982,
+  0.027815342, 0.027073860, 0.026310921, 0.025527000,
+  0.024725437, 0.023907185, 0.023074150, 0.022228718,
+  0.021372318, 0.020506859, 0.019634247, 0.018756866,
+  0.017876148, 0.016994476, 0.016112804, 0.015233517,
+  0.014358521, 0.013489246, 0.012627602, 0.011775017,
+  0.010933399, 0.010103703, 0.009287834, 0.008487225,
+  0.007703304, 0.006937027, 0.006189346, 0.005462170,
+  0.004756451, 0.004072189, 0.003411293, 0.002774239,
+  0.002161503, 0.001573563, 0.001011848, 0.000475883,
+  -0.000033379, -0.000515938, -0.000971317, -0.001399517,
+  -0.001800537, -0.002174854, -0.002521515, -0.002841473,
+  0.003134727, 0.003401756, 0.003643036, 0.003858566,
+  0.004049301, 0.004215240, 0.004357815, 0.004477024,
+  0.004573822, 0.004649162, 0.004703045, 0.004737377,
+  0.004752159, 0.004748821, 0.004728317, 0.004691124,
+  0.004638195, 0.004570484, 0.004489899, 0.004395962,
+  0.004290581, 0.004174709, 0.004048824, 0.003914356,
+  0.003771782, 0.003622532, 0.003467083, 0.003306866,
+  0.003141880, 0.002974033, 0.002803326, 0.002630711,
+  0.002457142, 0.002283096, 0.002110004, 0.001937389,
+  0.001766682, 0.001597881, 0.001432419, 0.001269817,
+  0.001111031, 0.000956535, 0.000806808, 0.000661850,
+  0.000522137, 0.000388145, 0.000259876, 0.000137329,
+  0.000021458, -0.000088215, -0.000191689, -0.000288486,
+  -0.000378609, -0.000462532, -0.000539303, -0.000610352,
+  -0.000674248, -0.000731945, -0.000783920, -0.000829220,
+  -0.000868797, -0.000902653, -0.000930786, -0.000953674,
+  0.000971317, 0.000983715, 0.000991821, 0.000995159,
+  0.000994205, 0.000989437, 0.000980854, 0.000968933,
+  0.000954151, 0.000935555, 0.000915051, 0.000891685,
+  0.000866413, 0.000838757, 0.000809669, 0.000779152,
+  0.000747204, 0.000714302, 0.000680923, 0.000646591,
+  0.000611782, 0.000576973, 0.000542164, 0.000507355,
+  0.000472546, 0.000438213, 0.000404358, 0.000371456,
+  0.000339031, 0.000307560, 0.000277042, 0.000247478,
+  0.000218868, 0.000191212, 0.000165462, 0.000140190,
+  0.000116348, 0.000093937, 0.000072956, 0.000052929,
+  0.000034332, 0.000017166, 0.000000954, -0.000013828,
+  -0.000027180, -0.000039577, -0.000050545, -0.000060558,
+  -0.000069618, -0.000077724, -0.000084400, -0.000090122,
+  -0.000095367, -0.000099182, -0.000102520, -0.000105381,
+  -0.000106812, -0.000108242, -0.000108719, -0.000108719,
+  -0.000108242, -0.000107288, -0.000105858, -0.000103951,
+  0.000101566, 0.000099182, 0.000096321, 0.000093460,
+  0.000090599, 0.000087261, 0.000083923, 0.000080585,
+  0.000076771, 0.000073433, 0.000070095, 0.000066280,
+  0.000062943, 0.000059605, 0.000055790, 0.000052929,
+  0.000049591, 0.000046253, 0.000043392, 0.000040531,
+  0.000037670, 0.000034809, 0.000032425, 0.000030041,
+  0.000027657, 0.000025272, 0.000023365, 0.000021458,
+  0.000019550, 0.000018120, 0.000016689, 0.000014782,
+  0.000013828, 0.000012398, 0.000011444, 0.000010014,
+  0.000009060, 0.000008106, 0.000007629, 0.000006676,
+  0.000006199, 0.000005245, 0.000004768, 0.000004292,
+  0.000003815, 0.000003338, 0.000003338, 0.000002861,
+  0.000002384, 0.000002384, 0.000001907, 0.000001907,
+  0.000001431, 0.000001431, 0.000000954, 0.000000954,
+  0.000000954, 0.000000954, 0.000000477, 0.000000477,
+  0.000000477, 0.000000477, 0.000000477, 0.000000477};
+ 
diff -r -c -N encoder/tables.h lame3.50/tables.h
*** encoder/tables.h	Wed Dec 31 17:00:00 1969
--- lame3.50/tables.h	Fri Sep 10 09:52:07 1999
***************
*** 0 ****
--- 1,25 ----
+ /*
+ ** Copyright (C) 1999 Albert L. Faber
+ **  
+ ** This program is free software; you can redistribute it and/or modify
+ ** it under the terms of the GNU General Public License as published by
+ ** the Free Software Foundation; either version 2 of the License, or
+ ** (at your option) any later version.
+ ** 
+ ** This program is distributed in the hope that it will be useful,
+ ** but WITHOUT ANY WARRANTY; without even the implied warranty of
+ ** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ ** GNU General Public License for more details.
+ ** 
+ ** You should have received a copy of the GNU General Public License
+ ** along with this program; if not, write to the Free Software 
+ ** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+ 
+ #ifndef TABLES_H_INCLUDED
+ #define TABLES_H_INCLUDED
+ 
+ extern double enwindow[];
+ extern double psy_data[];
+ 
+ #endif
diff -r -c -N encoder/takehiro.c lame3.50/takehiro.c
*** encoder/takehiro.c	Wed Dec 31 17:00:00 1969
--- lame3.50/takehiro.c	Sun Oct 24 19:50:53 1999
***************
*** 0 ****
--- 1,530 ----
+ /*
+  *	MP3 huffman table selecting and bit counting
+  *
+  *	Copyright (c) 1999 Takehiro TOMINAGA
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "util.h"
+ #include "l3side.h"
+ #include "huffman.h"
+ #include "quantize.h"
+ 
+ 
+ extern int *scalefac_band_long; 
+ extern int *scalefac_band_short;
+ 
+ 
+ 
+ struct
+ {
+     unsigned region0_count;
+     unsigned region1_count;
+ } subdv_table[ 23 ] =
+ {
+ {0, 0}, /* 0 bands */
+ {0, 0}, /* 1 bands */
+ {0, 0}, /* 2 bands */
+ {0, 0}, /* 3 bands */
+ {0, 0}, /* 4 bands */
+ {0, 1}, /* 5 bands */
+ {1, 1}, /* 6 bands */
+ {1, 1}, /* 7 bands */
+ {1, 2}, /* 8 bands */
+ {2, 2}, /* 9 bands */
+ {2, 3}, /* 10 bands */
+ {2, 3}, /* 11 bands */
+ {3, 4}, /* 12 bands */
+ {3, 4}, /* 13 bands */
+ {3, 4}, /* 14 bands */
+ {4, 5}, /* 15 bands */
+ {4, 5}, /* 16 bands */
+ {4, 6}, /* 17 bands */
+ {5, 6}, /* 18 bands */
+ {5, 6}, /* 19 bands */
+ {5, 7}, /* 20 bands */
+ {6, 7}, /* 21 bands */
+ {6, 7}, /* 22 bands */
+ };
+ 
+ 
+ /*************************************************************************/
+ /*	      ix_max							 */
+ /*************************************************************************/
+ 
+ static int ix_max_takehiro(int *ix, int *end) 
+ {
+     int max = 0;
+ 
+     while (ix < end) {
+ 	int x =	 *ix++;
+ 	if (max < x) 
+ 	    max = x;
+     }
+     return max;
+ }
+ 
+ 
+ /*************************************************************************/
+ /*	      count_bit							 */
+ /*************************************************************************/
+ 
+ /*
+  Function: Count the number of bits necessary to code the subregion. 
+ */
+ 
+ static int count_bit_ESC(int *ix, int *end, unsigned int table) 
+ {
+     /* ESC-table is used */
+     unsigned char *hlen = ht[table].hlen;
+     int linbits = ht[table].linbits;
+     int	sum = 0;
+ 
+     while (ix < end) {
+ 	int x = *ix++;
+ 	int y = *ix++;
+ 
+ 	if (x != 0) {
+ 	    sum++;
+ 	    if (x > 14) {
+ 		x = 15;
+ 		sum += linbits;
+ 	    }
+ 	    x *= 16;
+ 	}
+ 
+ 	if (y != 0) {
+ 	    sum++;
+ 	    if (y > 14) {
+ 		y = 15;
+ 		sum += linbits;
+ 	    }
+ 	    x += y;
+ 	}
+ 
+ 	sum += hlen[x];
+     }
+ 
+     return sum;
+ }
+ 
+ 
+ 
+ static int count_bit_noESC(int *ix, int *end, unsigned int table) 
+ {
+     /* No ESC-words */
+     int	sum = 0;
+     unsigned char *hlen = ht[table].hlen;
+ 
+     while (ix < end) {
+ 	int x = *ix++;
+ 	int y = *ix++;
+ 	if (x != 0) {
+ 	    sum++;
+ 	    x *= 16;
+ 	}
+ 
+ 	if (y != 0) {
+ 	    sum++;
+ 	    x += y;
+ 	}
+ 
+ 	sum += hlen[x];
+     }
+ 
+     return sum;
+ }
+ 
+ 
+ 
+ static int count_bit_short_ESC(int *ix, int *end, unsigned int table)
+ {
+     /* ESC-table is used */
+     unsigned char *hlen = ht[table].hlen;
+     unsigned int linbits = ht[table].linbits;
+     int	sum = 0;
+ 
+     while (ix < end) {
+ 	int i;
+ 	for (i = 0; i < 3; i++) {
+ 	    int y = *(ix + 3);
+ 	    int x = *ix++;
+ 
+ 	    if (x != 0) {
+ 		sum++;
+ 		if (x > 14) {
+ 		    x = 15;
+ 		    sum += linbits;
+ 		}
+ 		x *= 16;
+ 	    }
+ 
+ 	    if (y != 0) {
+ 		sum++;
+ 		if (y > 14) {
+ 		    y = 15;
+ 		    sum += linbits;
+ 		}
+ 		x += y;
+ 	    }
+ 
+ 	    sum += hlen[x];
+ 	}
+ 	ix += 3;
+     }
+ 
+     return sum;
+ }
+ 
+ 
+ 
+ static int count_bit_short_noESC(int *ix, int *end, unsigned int table) 
+ {
+     /* No ESC-words */
+     int	sum = 0;
+     unsigned char *hlen = ht[table].hlen;
+ 
+     while (ix < end) {
+ 	int i;
+ 	for (i = 0; i < 3; i++) {
+ 	    int y = *(ix + 3);
+ 	    int x = *ix++;
+ 	    if (x != 0) {
+ 		sum++;
+ 		x *= 16;
+ 	    }
+ 
+ 	    if (y != 0) {
+ 		sum++;
+ 		x += y;
+ 	    }
+ 
+ 	    sum += hlen[x];
+ 	}
+ 	ix += 3;
+     }
+ 
+     return sum;
+ }
+ 
+ 
+ 
+ /*************************************************************************/
+ /*	      new_choose table						 */
+ /*************************************************************************/
+ 
+ /*
+   Choose the Huffman table that will encode ix[begin..end] with
+   the fewest bits.
+ 
+   Note: This code contains knowledge about the sizes and characteristics
+   of the Huffman tables as defined in the IS (Table B.7), and will not work
+   with any arbitrary tables.
+ */
+ 
+ int choose_table_takehiro(int *ix, int *end, int * s)
+ {
+     int max;
+     int choice0, choice1;
+     int sum0, sum1;
+ 
+     max = ix_max_takehiro(ix, end);
+ 
+     if (max <= 15)  {
+ 	if (max == 0) {
+ 	    return 0;
+ 	}
+ 	/* try tables with no linbits */
+ 	for (choice0 = 1; choice0 < 14; choice0++) {
+ 	    if (ht[choice0].xlen > max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	sum0 = count_bit_noESC(ix, end, choice0);
+ 	choice1 = choice0;
+ 
+ 	switch (choice0) {
+ 	case 7:
+ 	case 10:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    /*fall*/
+ 	case 2:
+ 	case 5:
+ 	    choice1++;
+ 	    sum1 = count_bit_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	case 13:
+ 	    choice1 += 2;
+ 	    sum1 = count_bit_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	default:
+ 	    break;
+ 	}
+     } else {
+ 	/* try tables with linbits */
+ 	max -= 15;
+ 
+ 	for (choice0 = 15; choice0 < 24; choice0++) {
+ 	    if (ht[choice0].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	for (choice1 = 24; choice1 < 32; choice1++) {
+ 	    if (ht[choice1].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	sum0 = count_bit_ESC(ix, end, choice0);
+ 	sum1 = count_bit_ESC(ix, end, choice1);
+ 
+ 	if (sum0 > sum1)  {
+ 	    sum0 = sum1;
+ 	    choice0 = choice1;
+ 	}
+     }
+ 
+     *s += sum0;
+     return choice0;
+ }
+ 
+ 
+ int choose_table_takehiro_short(int *ix, int *end, int * s)
+ {
+     int max;
+     int choice0, sum0;
+ #define TAKEHIRO_SHORT
+ #ifdef TAKEHIRO_SHORT
+     int choice1, sum1;
+ #endif
+ 
+     max = ix_max_takehiro(ix, end);
+ 
+     if (max <= 15)  {
+ 	if (max == 0) {
+ 	    return 0;
+ 	}
+ 	/* try tables with no linbits */
+ 	for (choice0 = 1; choice0 < 14; choice0++) {
+ 	    if (ht[choice0].xlen > max) {
+ 		break;
+ 	    }
+ 	}
+ 
+ 	sum0 = count_bit_short_noESC(ix, end, choice0);
+ 
+ #ifdef TAKEHIRO_SHORT
+ 	choice1 = choice0;
+ 
+ 	switch (choice0) {
+ 	case 7:
+ 	case 10:
+ 	    choice1++;
+ 	    sum1 = count_bit_short_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    /*fall*/
+ 	case 2:
+ 	case 5:
+ 	    choice1++;
+ 	    sum1 = count_bit_short_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	case 13:
+ 	    choice1 += 2;
+ 	    sum1 = count_bit_short_noESC(ix, end, choice1);
+ 	    if (sum0 > sum1) {
+ 		sum0 = sum1;
+ 		choice0 = choice1;
+ 	    }
+ 	    break;
+ 
+ 	default:
+ 	    break;
+ 	}
+ #endif
+     } else {
+ 	/* try tables with linbits */
+ 	max -= 15;
+ 
+ 	for (choice0 = 15; choice0 < 24; choice0++) {
+ 	    if (ht[choice0].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 	sum0 = count_bit_short_ESC(ix, end, choice0);
+ 
+ #ifdef TAKEHIRO_SHORT
+ 	for (choice1 = 24; choice1 < 32; choice1++) {
+ 	    if (ht[choice1].linmax >= max) {
+ 		break;
+ 	    }
+ 	}
+ 	sum1 = count_bit_short_ESC(ix, end, choice1);
+ 
+ 	if (sum0 > sum1)  {
+ 	    sum0 = sum1;
+ 	    choice0 = choice1;
+ 	}
+ #endif
+     }
+ 
+     *s += sum0;
+     return choice0;
+ }
+ 
+ 
+ static int count_bits_long(int ix[576], gr_info *gi)
+ {
+     int i, a1, a2;
+     int bits = 0;
+ 
+     i=576;
+     for (; i > 1; i -= 2) 
+ 	if (ix[i - 1] | ix[i - 2])
+ 	    break;
+ 
+     /* Determines the number of bits to encode the quadruples. */
+     gi->count1 = i;
+     {
+ 	int sum0 = 0, sum1 = 0;
+ 	for (; i > 3; i -= 4) {
+ 	    int p, v;
+ 	    if ((unsigned int)(ix[i-1] | ix[i-2] | ix[i-3] | ix[i-4]) > 1)
+ 		break;
+ 
+ 	    v = ix[i-1];
+ 	    p = v;
+ 	    bits += v;
+ 
+ 	    v = ix[i-2];
+ 	    if (v != 0) {
+ 		p += 2;
+ 		bits++;
+ 	    }
+ 
+ 	    v = ix[i-3];
+ 	    if (v != 0) {
+ 		p += 4;
+ 		bits++;
+ 	    }
+ 
+ 	    v = ix[i-4];
+ 	    if (v != 0) {
+ 		p += 8;
+ 		bits++;
+ 	    }
+ 
+ 	    sum0 += ht[32].hlen[p];
+ 	    sum1 += ht[33].hlen[p];
+ 	}
+ 
+ 	if (sum0 < sum1) {
+ 	    bits += sum0;
+ 	    gi->count1table_select = 0;
+ 	} else {
+ 	    bits += sum1;
+ 	    gi->count1table_select = 1;
+ 	}
+     }
+ 
+     gi->big_values = i;
+     if (i == 0)
+ 	return bits;
+ 
+     if (gi->block_type == 0) {
+ 	int index;
+ 	int scfb_anz = 0;
+ 
+ 	while (scalefac_band_long[++scfb_anz] < i) 
+ 	    ;
+ 
+ 	index = subdv_table[scfb_anz].region0_count;
+ 	while (scalefac_band_long[index + 1] > i)
+ 	    index--;
+ 	gi->region0_count = index;
+ 
+ 	index = subdv_table[scfb_anz].region1_count;
+ 	while (scalefac_band_long[index + gi->region0_count + 2] > i)
+ 	    index--;
+ 	gi->region1_count = index;
+ 
+ 	a1 = scalefac_band_long[gi->region0_count + 1];
+ 	a2 = scalefac_band_long[index + gi->region0_count + 2];
+ 	gi->table_select[2] = choose_table_takehiro(ix + a2, ix + i, &bits);
+     } else {
+ 	gi->region0_count = 7;
+ 	//gi->region1_count = SBMAX_l - 7 - 1;
+ 	gi->region1_count = SFB_LMAX -1 - 7 - 1;
+ 	a1 = scalefac_band_long[7 + 1];
+ 	a2 = i;
+ 	if (a1 > a2) {
+ 	    a1 = a2;
+ 	}
+     }
+ 
+     /* Count the number of bits necessary to code the bigvalues region. */
+     gi->table_select[0] = choose_table_takehiro(ix, ix + a1, &bits);
+     gi->table_select[1] = choose_table_takehiro(ix + a1, ix + a2, &bits);
+     return bits;
+ }
+ 
+ 
+ 
+ 
+ int count_bits(int *ix,gr_info *cod_info)  
+ {
+   int bits=0,i;
+   for ( i = 0; i < 576; i++ )  {
+      if ( ix[i] > 8191 + 14) return 100000;/* report unsuitable quantizer */
+   }
+ 
+ 
+   if (cod_info->block_type==2) {
+     cod_info->table_select[0] = choose_table_takehiro_short(ix, ix + 36, &bits);
+     cod_info->table_select[1] = choose_table_takehiro_short(ix + 36, ix + 576, &bits);
+   }else{
+     bits=count_bits_long(ix, cod_info);
+     cod_info->count1 = (cod_info->count1 - cod_info->big_values) / 4;
+     cod_info->big_values /= 2;
+   }
+   return bits;
+ 
+ }
+ 
diff -r -c -N encoder/timestatus.c lame3.50/timestatus.c
*** encoder/timestatus.c	Wed Dec 31 17:00:00 1969
--- lame3.50/timestatus.c	Thu Oct 28 22:52:55 1999
***************
*** 0 ****
--- 1,150 ----
+ #include "timestatus.h"
+ #include "util.h"
+ #include <time.h>
+ 
+ 
+ #if defined(CLOCKS_PER_SEC)
+ /* ANSI/ISO systems */
+ # define TS_CLOCKS_PER_SEC CLOCKS_PER_SEC
+ #elif defined(CLK_TCK)
+ /* Non-standard systems */
+ # define TS_CLOCKS_PER_SEC CLK_TCK
+ #elif defined(HZ)
+ /* Older BSD systems */
+ # define TS_CLOCKS_PER_SEC HZ
+ #else
+ # error no suitable value for TS_CLOCKS_PER_SEC
+ #endif
+ 
+ /*********************************************************/
+ /* ts_real_time: real time elapsed in seconds            */
+ /*********************************************************/
+ double ts_real_time(long frame) {
+ 
+   static time_t initial_time;
+   time_t current_time;
+ 
+   time(&current_time);
+ 
+   if (frame==0) {
+     initial_time = current_time;
+   }
+ 
+   return difftime(current_time, initial_time);
+ }
+ 
+ /*********************************************************/
+ /* ts_process_time: process time elapsed in seconds      */
+ /*********************************************************/
+ double ts_process_time(long frame) {
+   static clock_t initial_time;
+   clock_t current_time;
+ 
+ #if ( defined(_MSC_VER) || defined(__BORLANDC__) ) 
+ 
+   { static HANDLE hProcess;
+     FILETIME Ignored1, Ignored2, KernelTime, UserTime;
+ 
+     if ( frame==0 ) {
+       hProcess = GetCurrentProcess();
+     }
+         
+     /* GetProcessTimes() always fails under Win9x */
+     if (GetProcessTimes(hProcess, &Ignored1, &Ignored2, &KernelTime, &UserTime)) {
+       LARGE_INTEGER Kernel = { KernelTime.dwLowDateTime, KernelTime.dwHighDateTime };
+       LARGE_INTEGER User = { UserTime.dwLowDateTime, UserTime.dwHighDateTime };
+ 
+       current_time = (clock_t)((double)(Kernel.QuadPart + User.QuadPart) * TS_CLOCKS_PER_SEC / 10000000);
+     } else {
+       current_time = clock();
+ 	}
+   }
+ #else
+   current_time = clock();
+ #endif
+ 
+   if (frame==0) {
+     initial_time = current_time;
+   }
+ 
+   return (double)(current_time - initial_time) / TS_CLOCKS_PER_SEC;
+ }
+ 
+ #undef TS_CLOCKS_PER_SEC
+ 
+ typedef struct ts_times {
+   double so_far;
+   double estimated;
+   double speed;
+   double eta;
+ } ts_times;
+ 
+ /*********************************************************/
+ /* ts_calc_times: calculate time info (eta, speed, etc.) */
+ /*********************************************************/
+ void ts_calc_times(ts_times *time, int samp_rate, long frame, long frames, 
+ int framesize) 
+ {
+   if (frame > 0) {
+     time->estimated = time->so_far * frames / frame;
+     if (samp_rate * time->estimated > 0) {
+       time->speed = frames * framesize / (1000.0 * samp_rate * time->estimated);
+     } else {
+       time->speed = 0;
+     }
+     time->eta = time->estimated - time->so_far;
+   } else {
+     time->estimated = 0;
+ 	time->speed = 0;
+ 	time->eta = 0;
+   }
+ }
+ 
+ /*********************************************************/
+ /* timestatus: display encoding process time information */
+ /*********************************************************/
+ void timestatus(layer *info,long frameNum,long totalframes)
+ {
+   const int samp_rate = (int)s_freq[info->version][info->sampling_frequency];
+   ts_times real_time, process_time;
+   int percent;
+   int framesize = (info->version==0) ? 576 : 1152;
+ 
+   real_time.so_far = ts_real_time(frameNum);
+   process_time.so_far = ts_process_time(frameNum);
+ 
+   if (frameNum == 0) {
+     fprintf(stderr, "    Frame          |  CPU/estimated  |  time/estimated | play/CPU |   ETA\n");
+     return;
+   }  
+ 
+   ts_calc_times(&real_time, samp_rate, frameNum, totalframes,framesize);
+   ts_calc_times(&process_time, samp_rate, frameNum, totalframes,framesize);
+ 
+   if (totalframes > 1) {
+     percent = (int)(100.0 * frameNum / (totalframes - 1));
+   } else {
+     percent = 100;
+   }
+ 
+   #define TS_TIME_DECOMPOSE(time) \
+     (int)((long)(time+.5) / 3600), \
+     (int)((long)((time+.5) / 60) % 60), \
+     (int)((long)(time+.5) % 60)
+ 
+   fprintf(stderr,
+     "\r%6ld/%6ld(%3d%%)|%2d:%02d:%02d/%2d:%02d:%02d|%2d:%02d:%02d/%2d:%02d:%02d|%10.4f|%2d:%02d:%02d ",
+     frameNum,
+     totalframes - 1,
+     percent,
+     TS_TIME_DECOMPOSE(process_time.so_far),
+     TS_TIME_DECOMPOSE(process_time.estimated),
+     TS_TIME_DECOMPOSE(real_time.so_far),
+ 	TS_TIME_DECOMPOSE(real_time.estimated),
+     process_time.speed,
+     TS_TIME_DECOMPOSE(real_time.eta)
+   );
+ 
+   fflush(stderr);
+ }
+ 
diff -r -c -N encoder/timestatus.h lame3.50/timestatus.h
*** encoder/timestatus.h	Wed Dec 31 17:00:00 1969
--- lame3.50/timestatus.h	Wed Oct 20 22:58:21 1999
***************
*** 0 ****
--- 1,9 ----
+ #ifndef TIMESTATUS_H_INCLUDED
+ #define TIMESTATUS_H_INCLUDED
+ 
+ #include "util.h"
+ 
+ void timestatus(layer *info,long frameNum,long totalframes);
+ 
+ 
+ #endif
diff -r -c -N encoder/tonal.c lame3.50/tonal.c
*** encoder/tonal.c	Wed Jan 22 02:43:23 1997
--- lame3.50/tonal.c	Wed Dec 31 17:00:00 1969
***************
*** 1,1051 ****
- /**********************************************************************
-  * ISO MPEG Audio Subgroup Software Simulation Group (1996)
-  * ISO 13818-3 MPEG-2 Audio Encoder - Lower Sampling Frequency Extension
-  *
-  * $Id: tonal.c,v 1.1 1996/02/14 04:04:23 rowlands Exp $
-  *
-  * $Log: tonal.c,v $
-  * Revision 1.1  1996/02/14 04:04:23  rowlands
-  * Initial revision
-  *
-  * Received from Mike Coleman
-  **********************************************************************/
- /**********************************************************************
-  *   date   programmers         comment                               *
-  * 2/25/91  Douglas Wong        start of version 1.1 records          *
-  * 3/06/91  Douglas Wong        rename: setup.h to endef.h            *
-  *                              updated I_psycho_one and II_psycho_one*
-  * 3/11/91  W. J. Carter        Added Douglas Wong's updates dated    *
-  *                              3/9/91 for I_Psycho_One() and for     *
-  *                              II_Psycho_One().                      *
-  * 5/10/91  W. Joseph Carter    Ported to Macintosh and Unix.         *
-  *                              Located and fixed numerous software   *
-  *                              bugs and table data errors.           *
-  * 6/11/91  Davis Pan           corrected several bugs                *
-  *                              based on comments from H. Fuchs       *
-  * 01jul91  dpwe (Aware Inc.)   Made pow() args float                 *
-  *                              Removed logical bug in I_tonal_label: *
-  *                              Sometimes *tone returned == STOP      *
-  * 7/10/91  Earle Jennings      no change necessary in port to MsDos  *
-  * 11sep91  dpwe@aware.com      Subtracted 90.3dB from II_f_f_t peaks *
-  * 10/1/91  Peter W. Farrett    Updated II_Psycho_One(),I_Psycho_One()*
-  *                              to include comments.                  *
-  *11/29/91  Masahiro Iwadare    Bug fix regarding POWERNORM           *
-  *                              fixed several other miscellaneous bugs*
-  * 2/11/92  W. Joseph Carter    Ported new code to Macintosh.  Most   *
-  *                              important fixes involved changing     *
-  *                              16-bit ints to long or unsigned in    *
-  *                              bit alloc routines for quant of 65535 *
-  *                              and passing proper function args.     *
-  *                              Removed "Other Joint Stereo" option   *
-  *                              and made bitrate be total channel     *
-  *                              bitrate, irrespective of the mode.    *
-  *                              Fixed many small bugs & reorganized.  *
-  * 2/12/92  Masahiro Iwadare    Fixed some potential bugs in          *
-  *          Davis Pan           subsampling()                         *
-  * 2/25/92  Masahiro Iwadare    Fixed some more potential bugs        *
-  * 6/24/92  Tan Ah Peng         Modified window for FFT               * 
-  *                              (denominator N-1 to N)                *
-  *                              Updated all critical band rate &      *
-  *                              absolute threshold tables and critical*
-  *                              boundaries for use with Layer I & II  *  
-  *                              Corrected boundary limits for tonal   *
-  *                              component computation                 *
-  *                              Placement of non-tonal component at   *
-  *                              geometric mean of critical band       *
-  *                              (previous placement method commented  *
-  *                               out - can be used if desired)        *
-  * 3/01/93  Mike Li             Infinite looping fix in noise_label() *
-  * 3/19/93  Jens Spille         fixed integer overflow problem in     *
-  *                              psychoacoutic model 1                 *
-  * 3/19/93  Giorgio Dimino      modifications to better account for   *
-  *                              tonal and non-tonal components        *
-  * 5/28/93 Sriram Jayasimha     "London" mod. to psychoacoustic model1*
-  * 8/05/93 Masahiro Iwadare     noise_label modification "option"     *
-  * 1/21/94 Seymore Shlien       fixed another infinite looping problem*
-  * 7/12/95 Soeren H. Nielsen    Changes for LSF, new tables           *
-  **********************************************************************/
- 
- #include "common.h"
- #include "encoder.h"
- #define LONDON                  /* enable "LONDON" modification */
- #define MAKE_SENSE              /* enable "MAKE_SENSE" modification */
- #define MI_OPTION               /* enable "MI_OPTION" modification */
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer II. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- int crit_band;
- int FAR *cbound;
- int sub_size;
- 
- void read_cbound(lay,freq)  /* this function reads in critical */
- int lay, freq;              /* band boundaries                 */
- {
-  int i,j,k;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2cb1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){       /* check boundary values */
-     printf("Please check %s boundary table\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);               /* read input for critical bands */
-  sscanf(t,"%d\n",&crit_band);
-  cbound = (int FAR *) mem_alloc(sizeof(int) * crit_band, "cbound");
-  for(i=0;i<crit_band;i++){   /* continue to read input for */
-     fgets(t,80,fp);            /* critical band boundaries   */
-     sscanf(t,"%d %d\n",&j, &k);
-     if(i==j) cbound[j] = k;
-     else {                     /* error */
-        printf("Please check index %d in cbound table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }        
- 
- void read_freq_band(ltg,lay,freq)  /* this function reads in   */
- int lay, freq;                     /* frequency bands and bark */
- g_ptr FAR *ltg;                /* values                   */
- {
-  int i,j, k;
-  double b,c;
-  FILE *fp;
-  char r[16], t[80];
- 
-  strcpy(r, "2th1");
-  r[0] = (char) lay + '0';
-  r[3] = (char) freq + '0';
-  if( !(fp = OpenTableFile(r)) ){   /* check freq. values  */
-     printf("Please check frequency and cband table %s\n",r);
-     exit(1);
-  }
-  fgets(t,80,fp);              /* read input for freq. subbands */
-  sscanf(t,"%d\n",&sub_size);
-  *ltg = (g_ptr FAR ) mem_alloc(sizeof(g_thres) * sub_size, "ltg");
-  (*ltg)[0].line = 0;          /* initialize global masking threshold */
-  (*ltg)[0].bark = 0;
-  (*ltg)[0].hear = 0;
-  for(i=1;i<sub_size;i++){    /* continue to read freq. subband */
-     fgets(t,80,fp);          /* and assign                     */
-     sscanf(t,"%d %d %lf %lf\n",&j, &k, &b, &c);
-     if(i == j){
-        (*ltg)[j].line = k;
-        (*ltg)[j].bark = b;
-        (*ltg)[j].hear = c;
-     }
-     else {                   /* error */
-        printf("Please check index %d in freq-cb table %s\n",i,r);
-        exit(1);
-     }
-  }
-  fclose(fp);
- }
- 
- void make_map(power, ltg)       /* this function calculates the */
- mask FAR power[HAN_SIZE];   /* global masking threshold     */
- g_thres FAR *ltg;
- {
-  int i,j;
- 
-  for(i=1;i<sub_size;i++) for(j=ltg[i-1].line;j<=ltg[i].line;j++)
-     power[j].map = i;
- }
- 
- double add_db(a,b)
- double a,b;
- {
-  a = pow(10.0,a/10.0);
-  b = pow(10.0,b/10.0);
-  return 10 * log10(a+b);
- }
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void II_f_f_t(sample, power)      /* this function calculates an */
- double FAR sample[FFT_SIZE];  /* FFT analysis for the freq.  */
- mask FAR power[HAN_SIZE];     /* domain                      */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT), "energy");
-  for(i=0;i<FFT_SIZE;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT), "rev");
-     w_r = (double *) mem_alloc(sizeof(D10), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D10), "w_i");
-     M = 10;
-     MM1 = 9;
-     N = FFT_SIZE;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE;rev[i] = l,i++) for(j=0,l=0;j<10;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(9-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE;i++){    /* calculate power density spectrum */
-     if (energy[i] < 1E-20) energy[i] = 1E-20;
-     power[i].x = 10 * log10(energy[i]) + POWERNORM;
-     power[i].next = STOP;
-     power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void II_hann_win(sample)          /* this function calculates a  */
- double FAR sample[FFT_SIZE];  /* Hann window for PCM (input) */
- {                                 /* samples for a 1024-pt. FFT  */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE;i++){
-        /* Hann window formula */
-        window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE)))/FFT_SIZE;
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double max;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = max, i+=16)      /* calculate the      */
-  for(j=0, max = DBMIN;j<16;j++)                    /* maximum spectral   */
-     max = (max>power[i+j].x) ? max : power[i+j].x; /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #else
- void II_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE;spike[i>>4] = 10.0*log10(sum), i+=16)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<16;j++)      /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
-                                                    /* 4-16               */
- #endif
- 
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void II_tonal_label(power, tone)  /* this function extracts (tonal) */
- mask FAR power[HAN_SIZE];     /* sinusoidals from the spectrum  */
- int *tone;
- {
-  int i,j, last = LAST, first, run, last_but_one = LAST; /* dpwe */
-  double max;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE-12;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){               /* the conditions for the tonal          */
-     if(first<3 || first>500) run = 0;/* otherwise k+/-j will be out of bounds */
-     else if(first<63) run = 2;       /* components in layer II, which         */
-     else if(first<127) run = 3;      /* are the boundaries for calc.          */
-     else if(first<255) run = 6;      /* the tonal components                  */
-     else run = 12;
-     max = power[first].x - 7;        /* after calculation of tonal   */
-     for(j=2;j<=run;j++)              /* components, set to local max */
-        if(max < power[first-j].x || max < power[first+j].x){
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){   /* extract tonal components */
-        int help=first;
-        if(*tone==LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<500){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP;
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST); /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function groups all the remaining non-tonal
- * spectral lines into critical band where they are replaced by
- * one single line.
- *
- ****************************************************************/
-         
- void noise_label(power, noise, ltg)
- g_thres FAR *ltg;
- mask FAR *power;
- int *noise;
- {
-  int i,j, centre, last = LAST;
-  double index, weight, sum;
-                               /* calculate the remaining spectral */
-  for(i=0;i<crit_band-1;i++){  /* lines for non-tonal components   */
-      for(j=cbound[i],weight = 0.0,sum = DBMIN;j<cbound[i+1];j++){
-         if(power[j].type != TONE){
-            if(power[j].x != DBMIN){
-               sum = add_db(power[j].x,sum);
- /* the line below and others under the "MAKE_SENSE" condition are an alternate
-    interpretation of "geometric mean". This approach may make more sense but
-    it has not been tested with hardware. */
- #ifdef MAKE_SENSE
- /* weight += pow(10.0, power[j].x/10.0) * (ltg[power[j].map].bark-i);
-    bad code [SS] 21-1-93
-  */
-     weight += pow(10.0,power[j].x/10.0) * (double) (j-cbound[i]) /
-      (double) (cbound[i+1]-cbound[i]);  /* correction */
- #endif
-               power[j].x = DBMIN;
-            }
-         }   /*  check to see if the spectral line is low dB, and if  */
-      }      /* so replace the center of the critical band, which is */
-             /* the center freq. of the noise component              */
- 
- #ifdef MAKE_SENSE
-      if(sum <= DBMIN)  centre = (cbound[i+1]+cbound[i]) /2;
-      else {
-         index = weight/pow(10.0,sum/10.0);
-         centre = cbound[i] + (int) (index * (double) (cbound[i+1]-cbound[i]) );
-      } 
- #else
-      index = (double)( ((double)cbound[i]) * ((double)(cbound[i+1]-1)) );
-      centre = (int)(pow(index,0.5)+0.5);
- #endif
- 
-     /* locate next non-tonal component until finished; */
-     /* add to list of non-tonal components             */
- #ifdef MI_OPTION
-      /* Masahiro Iwadare's fix for infinite looping problem? */
-      if(power[centre].type == TONE) 
-        if (power[centre+1].type == TONE) centre++; else centre--;
- #else
-      /* Mike Li's fix for infinite looping problem */
-      if(power[centre].type == FALSE) centre++;
- 
-      if(power[centre].type == NOISE){
-        if(power[centre].x >= ltg[power[i].map].hear){
-          if(sum >= ltg[power[i].map].hear) sum = add_db(power[j].x,sum);
-          else
-          sum = power[centre].x;
-        }
-      }
- #endif
-      if(last == LAST) *noise = centre;
-      else {
-         power[centre].next = LAST;
-         power[last].next = centre;
-      }
-      power[centre].x = sum;
-      power[centre].type = NOISE;        
-      last = centre;
-  }        
- }
- 
- /****************************************************************
- *
- *        This function reduces the number of noise and tonal
- * component for further threshold analysis.
- *
- ****************************************************************/
- 
- void subsampling(power, ltg, tone, noise)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise;
- {
-  int i, old;
- 
-  i = *tone; old = STOP;    /* calculate tonal components for */
-  while(i!=LAST){           /* reduction of spectral lines    */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *tone = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *noise; old = STOP;    /* calculate non-tonal components for */
-  while(i!=LAST){            /* reduction of spectral lines        */
-     if(power[i].x < ltg[power[i].map].hear){
-        power[i].type = FALSE;
-        power[i].x = DBMIN;
-        if(old == STOP) *noise = power[i].next;
-        else power[old].next = power[i].next;
-     }
-     else old = i;
-     i = power[i].next;
-  }
-  i = *tone; old = STOP;
-  while(i != LAST){                              /* if more than one */
-     if(power[i].next == LAST)break;             /* tonal component  */
-     if(ltg[power[power[i].next].map].bark -     /* is less than .5  */
-        ltg[power[i].map].bark < 0.5) {          /* bark, take the   */
-        if(power[power[i].next].x > power[i].x ){/* maximum          */
-           if(old == STOP) *tone = power[i].next;
-           else power[old].next = power[i].next;
-           power[i].type = FALSE;
-           power[i].x = DBMIN;
-           i = power[i].next;
-        }
-        else {
-           power[power[i].next].type = FALSE;
-           power[power[i].next].x = DBMIN;
-           power[i].next = power[power[i].next].next;
-           old = i;
-        }
-     }
-     else {
-       old = i;
-       i = power[i].next;
-     }
-  }
- }
- 
- /****************************************************************
- *
- *        This function calculates the individual threshold and
- * sum with the quiet threshold to find the global threshold.
- *
- ****************************************************************/
- 
- void threshold(power, ltg, tone, noise, bit_rate)
- mask FAR power[HAN_SIZE];
- g_thres FAR *ltg;
- int *tone, *noise, bit_rate;
- {
-  int k, t;
-  double dz, tmps, vf;
- 
-  for(k=1;k<sub_size;k++){
-     ltg[k].x = DBMIN;
-     t = *tone;          /* calculate individual masking threshold for */
-     while(t != LAST){   /* components in order to find the global     */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 && /*threshold (LTG)*/
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value*/
-           tmps = -1.525-0.275*ltg[power[t].map].bark - 4.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;        
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
- 
-     t = *noise;        /* calculate individual masking threshold  */
-     while(t != LAST){  /* for non-tonal components to find LTG    */
-        if(ltg[k].bark-ltg[power[t].map].bark >= -3.0 &&
-           ltg[k].bark-ltg[power[t].map].bark <8.0){
-           dz = ltg[k].bark-ltg[power[t].map].bark; /* distance of bark value */
-           tmps = -1.525-0.175*ltg[power[t].map].bark -0.5 + power[t].x;
-              /* masking function for lower & upper slopes */
-           if(-3<=dz && dz<-1) vf = 17*(dz+1)-(0.4*power[t].x +6);
-           else if(-1<=dz && dz<0) vf = (0.4 *power[t].x + 6) * dz;
-           else if(0<=dz && dz<1) vf = (-17*dz);
-           else if(1<=dz && dz<8) vf = -(dz-1) * (17-0.15 *power[t].x) - 17;
-           tmps += vf;
-           ltg[k].x = add_db(ltg[k].x, tmps);
-        }
-        t = power[t].next;
-     }
-     if(bit_rate<96)ltg[k].x = add_db(ltg[k].hear, ltg[k].x);
-     else ltg[k].x = add_db(ltg[k].hear-12.0, ltg[k].x);
-  }
- }
- 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void II_minimum_mask(ltg,ltmin,sblimit)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- int sblimit;
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<sblimit;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>4 == i && j < sub_size){
-        if(min>ltg[j].x)  min = ltg[j].x;
-        j++;
-     }
-     ltmin[i] = min;
-  }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void II_smr(ltmin, spike, scale, sblimit)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- int sblimit;
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<sblimit;i++){                     /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10; /* level for each subband */
-     if(spike[i]>max) max = spike[i];         /* for the maximum scale  */
-     max -= ltmin[i];                         /* factors                */
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void II_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  layer *info = fr_ps->header;
-  int   stereo = fr_ps->stereo;
-  int   sblimit = fr_ps->sblimit;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D1408 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-      /* call functions for critical boundaries, freq. */
-  if(!init){  /* bands, bark values, and mapping */
-     fft_buf = (D1408 *) mem_alloc((long) sizeof(D1408) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for (i=0;i<1408;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){  /* check pcm input for 3 blocks of 384 samples */
-     for(i=0;i<1152;i++) fft_buf[k][(i+off[k])%1408]= (double)buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE;i++) sample[i] = fft_buf[k][(i+1216+off[k])%1408];
-     off[k] += 1152;
-     off[k] %= 1408;
-                             /* call functions for windowing PCM samples,*/
-     II_hann_win(sample);    /* location of spectral components in each  */
-     for(i=0;i<HAN_SIZE;i++) power[i].x = DBMIN;  /*subband with labeling*/
-     II_f_f_t(sample, power);                     /*locate remaining non-*/
-     II_pick_max(power, &spike[k][0]);            /*tonal sinusoidals,   */
-     II_tonal_label(power, &tone);                /*reduce noise & tonal */
-     noise_label(power, &noise, ltg);             /*components, find     */
-     subsampling(power, ltg, &tone, &noise);      /*global & minimal     */
-     threshold(power, ltg, &tone, &noise,         /*threshold, and sgnl- */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo); /*to-mask ratio*/
-     II_minimum_mask(ltg, &ltmin[k][0], sblimit);
-     II_smr(&ltmin[k][0], &spike[k][0], &scale[k][0], sblimit);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
- 
- /**********************************************************************
- *
- *        This module implements the psychoacoustic model I for the
- * MPEG encoder layer I. It uses simplified tonal and noise masking
- * threshold analysis to generate SMR for the encoder bit allocation
- * routine.
- *
- **********************************************************************/
- 
- /****************************************************************
- *
- *        Fast Fourier transform of the input samples.
- *
- ****************************************************************/
- 
- void I_f_f_t(sample, power)         /* this function calculates */
- double FAR sample[FFT_SIZE/2];  /* an FFT analysis for the  */
- mask FAR power[HAN_SIZE/2];     /* freq. domain             */
- {
-  int i,j,k,L,l=0;
-  int ip, le, le1;
-  double t_r, t_i, u_r, u_i;
-  static int M, MM1, init = 0, N;
-  double *x_r, *x_i, *energy;
-  static int *rev;
-  static double *w_r, *w_i;
- 
-  x_r = (double *) mem_alloc(sizeof(DFFT2), "x_r");
-  x_i = (double *) mem_alloc(sizeof(DFFT2), "x_i");
-  energy = (double *) mem_alloc(sizeof(DFFT2), "energy");
-  for(i=0;i<FFT_SIZE/2;i++) x_r[i] = x_i[i] = energy[i] = 0;
-  if(!init){
-     rev = (int *) mem_alloc(sizeof(IFFT2), "rev");
-     w_r = (double *) mem_alloc(sizeof(D9), "w_r");
-     w_i = (double *) mem_alloc(sizeof(D9), "w_i");
-     M = 9;
-     MM1 = 8;
-     N = FFT_SIZE/2;
-     for(L=0;L<M;L++){
-        le = 1 << (M-L);
-        le1 = le >> 1;
-        w_r[L] = cos(PI/le1);
-        w_i[L] = -sin(PI/le1);
-     }
-     for(i=0;i<FFT_SIZE/2;rev[i] = l,i++) for(j=0,l=0;j<9;j++){
-        k=(i>>j) & 1;
-        l |= (k<<(8-j));                
-     }
-     init = 1;
-  }
-  memcpy( (char *) x_r, (char *) sample, sizeof(double) * FFT_SIZE/2);
-  for(L=0;L<MM1;L++){
-     le = 1 << (M-L);
-     le1 = le >> 1;
-     u_r = 1;
-     u_i = 0;
-     for(j=0;j<le1;j++){
-        for(i=j;i<N;i+=le){
-           ip = i + le1;
-           t_r = x_r[i] + x_r[ip];
-           t_i = x_i[i] + x_i[ip];
-           x_r[ip] = x_r[i] - x_r[ip];
-           x_i[ip] = x_i[i] - x_i[ip];
-           x_r[i] = t_r;
-           x_i[i] = t_i;
-           t_r = x_r[ip];
-           x_r[ip] = x_r[ip] * u_r - x_i[ip] * u_i;
-           x_i[ip] = x_i[ip] * u_r + t_r * u_i;
-        }
-        t_r = u_r;
-        u_r = u_r * w_r[L] - u_i * w_i[L];
-        u_i = u_i * w_r[L] + t_r * w_i[L];
-     }
-  }
-  for(i=0;i<N;i+=2){
-     ip = i + 1;
-     t_r = x_r[i] + x_r[ip];
-     t_i = x_i[i] + x_i[ip];
-     x_r[ip] = x_r[i] - x_r[ip];
-     x_i[ip] = x_i[i] - x_i[ip];
-     x_r[i] = t_r;
-     x_i[i] = t_i;
-     energy[i] = x_r[i] * x_r[i] + x_i[i] * x_i[i];
-  }
-  for(i=0;i<FFT_SIZE/2;i++) if(i<rev[i]){
-     t_r = energy[i];
-     energy[i] = energy[rev[i]];
-     energy[rev[i]] = t_r;
-  }
-  for(i=0;i<HAN_SIZE/2;i++){                     /* calculate power  */
-     if(energy[i] < 1E-20) energy[i] = 1E-20;    /* density spectrum */
-        power[i].x = 10 * log10(energy[i]) + POWERNORM;
-        power[i].next = STOP;
-        power[i].type = FALSE;
-  }
-  mem_free((void **) &x_r);
-  mem_free((void **) &x_i);
-  mem_free((void **) &energy);
- }
- 
- /****************************************************************
- *
- *         Window the incoming audio signal.
- *
- ****************************************************************/
- 
- void I_hann_win(sample)             /* this function calculates a  */
- double FAR sample[FFT_SIZE/2];  /* Hann window for PCM (input) */
- {                                   /* samples for a 512-pt. FFT   */
-  register int i;
-  register double sqrt_8_over_3;
-  static int init = 0;
-  static double FAR *window;
- 
-  if(!init){  /* calculate window function for the Fourier transform */
-     window = (double FAR *) mem_alloc(sizeof(DFFT2), "window");
-     sqrt_8_over_3 = pow(8.0/3.0, 0.5);
-     for(i=0;i<FFT_SIZE/2;i++){
-       /* Hann window formula */
-       window[i]=sqrt_8_over_3*0.5*(1-cos(2.0*PI*i/(FFT_SIZE/2)))/(FFT_SIZE/2);
-     }
-     init = 1;
-  }
-  for(i=0;i<FFT_SIZE/2;i++) sample[i] *= window[i];
- }
- 
- /*******************************************************************
- *
- *        This function finds the maximum spectral component in each
- * subband and return them to the encoder for time-domain threshold
- * determination.
- *
- *******************************************************************/
- #ifndef LONDON
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE/2];
- {
-  double max;
-  int i,j;
- 
-  /* calculate the spectral component in each subband */
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = max, i+=8)
-     for(j=0, max = DBMIN;j<8;j++) max = (max>power[i+j].x) ? max : power[i+j].x;
- }
- #else
- void I_pick_max(power, spike)
- double FAR spike[SBLIMIT];
- mask FAR power[HAN_SIZE];
- {
-  double sum;
-  int i,j;
- 
-  for(i=0;i<HAN_SIZE/2;spike[i>>3] = 10.0*log10(sum), i+=8)
-                                                    /* calculate the      */
-  for(j=0, sum = pow(10.0,0.1*DBMIN);j<8;j++)       /* sum of spectral   */
-    sum += pow(10.0,0.1*power[i+j].x);              /* component in each  */
- }                                                  /* subband from bound */
- #endif
- /****************************************************************
- *
- *        This function labels the tonal component in the power
- * spectrum.
- *
- ****************************************************************/
- 
- void I_tonal_label(power, tone)     /* this function extracts   */
- mask FAR power[HAN_SIZE/2];     /* (tonal) sinusoidals from */
- int *tone;                          /* the spectrum             */
- {
-  int i,j, last = LAST, first, run;
-  double max;
-  int last_but_one= LAST;
- 
-  *tone = LAST;
-  for(i=2;i<HAN_SIZE/2-6;i++){
-     if(power[i].x>power[i-1].x && power[i].x>=power[i+1].x){
-        power[i].type = TONE;
-        power[i].next = LAST;
-        if(last != LAST) power[last].next = i;
-        else first = *tone = i;
-        last = i;
-     }
-  }
-  last = LAST;
-  first = *tone;
-  *tone = LAST;
-  while(first != LAST){                /* conditions for the tonal     */
-     if(first<3 || first>250) run = 0; /* otherwise k+/-j will be out of bounds*/
-     else if(first<63) run = 2;        /* components in layer I, which */
-     else if(first<127) run = 3;       /* are the boundaries for calc.   */
-     else run = 6;                     /* the tonal components          */
-     max = power[first].x - 7;
-     for(j=2;j<=run;j++)  /* after calc. of tonal components, set to loc.*/
-        if(max < power[first-j].x || max < power[first+j].x){   /* max   */
-           power[first].type = FALSE;
-           break;
-        }
-     if(power[first].type == TONE){    /* extract tonal components */
-        int help=first;
-        if(*tone == LAST) *tone = first;
-        while((power[help].next!=LAST)&&(power[help].next-first)<=run)
-           help=power[help].next;
-        help=power[help].next;
-        power[first].next=help;
-        if((first-last)<=run){
-           if(last_but_one != LAST) power[last_but_one].next=first;
-        }
-        if(first>1 && first<255){     /* calculate the sum of the */
-           double tmp;                /* powers of the components */
-           tmp = add_db(power[first-1].x, power[first+1].x);
-           power[first].x = add_db(power[first].x, tmp);
-        }
-        for(j=1;j<=run;j++){
-           power[first-j].x = power[first+j].x = DBMIN;
-           power[first-j].next = power[first+j].next = STOP; /*dpwe: 2nd was .x*/
-           power[first-j].type = power[first+j].type = FALSE;
-        }
-        last_but_one=last;
-        last = first;
-        first = power[first].next;
-     }
-     else {
-        int ll;
-        if(last == LAST) ; /* *tone = power[first].next; dpwe */
-        else power[last].next = power[first].next;
-        ll = first;
-        first = power[first].next;
-        power[ll].next = STOP;
-     }
-  }
- }                        
-                                 
- /****************************************************************
- *
- *        This function finds the minimum masking threshold and
- * return the value to the encoder.
- *
- ****************************************************************/
- 
- void I_minimum_mask(ltg,ltmin)
- g_thres FAR *ltg;
- double FAR ltmin[SBLIMIT];
- {
-  double min;
-  int i,j;
- 
-  j=1;
-  for(i=0;i<SBLIMIT;i++)
-     if(j>=sub_size-1)                   /* check subband limit, and       */
-        ltmin[i] = ltg[sub_size-1].hear; /* calculate the minimum masking  */
-     else {                              /* level of LTMIN for each subband*/
-        min = ltg[j].x;
-        while(ltg[j].line>>3 == i && j < sub_size){
-           if (min>ltg[j].x)  min = ltg[j].x;
-           j++;
-        }
-        ltmin[i] = min;
-     }
- }
- 
- /*****************************************************************
- *
- *        This procedure is called in musicin to pick out the
- * smaller of the scalefactor or threshold.
- *
- *****************************************************************/
- 
- void I_smr(ltmin, spike, scale)
- double FAR spike[SBLIMIT], scale[SBLIMIT], ltmin[SBLIMIT];
- {
-  int i;
-  double max;
-                 
-  for(i=0;i<SBLIMIT;i++){                      /* determine the signal   */
-     max = 20 * log10(scale[i] * 32768) - 10;  /* level for each subband */
-     if(spike[i]>max) max = spike[i];          /* for the scalefactor    */
-     max -= ltmin[i];
-     ltmin[i] = max;
-  }
- }
-         
- /****************************************************************
- *
- *        This procedure calls all the necessary functions to
- * complete the psychoacoustic analysis.
- *
- ****************************************************************/
- 
- void I_Psycho_One(buffer, scale, ltmin, fr_ps)
- short FAR buffer[2][1152];
- double FAR scale[2][SBLIMIT], ltmin[2][SBLIMIT];
- frame_params *fr_ps;
- {
-  int stereo = fr_ps->stereo;
-  the_layer info = fr_ps->header;
-  int k,i, tone=0, noise=0;
-  static char init = 0;
-  static int off[2] = {256,256};
-  double *sample;
-  DSBL *spike;
-  static D640 *fft_buf;
-  static mask_ptr FAR power;
-  static g_ptr FAR ltg;
- 
-  sample = (double *) mem_alloc(sizeof(DFFT2), "sample");
-  spike = (DSBL *) mem_alloc(sizeof(D2SBL), "spike");
-             /* call functions for critical boundaries, freq. */
-  if(!init){ /* bands, bark values, and mapping              */
-     fft_buf = (D640 *) mem_alloc(sizeof(D640) * 2, "fft_buf");
-     power = (mask_ptr FAR ) mem_alloc(sizeof(mask) * HAN_SIZE/2, "power");
-     if (info->version == MPEG_AUDIO_ID) {
-       read_cbound(info->lay, info->sampling_frequency);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency);
-     } else {
-       read_cbound(info->lay, info->sampling_frequency + 4);
-       read_freq_band(&ltg, info->lay, info->sampling_frequency + 4);
-     }
-     make_map(power,ltg);
-     for(i=0;i<640;i++) fft_buf[0][i] = fft_buf[1][i] = 0;
-     init = 1;
-  }
-  for(k=0;k<stereo;k++){    /* check PCM input for a block of */
-     for(i=0;i<384;i++)     /* 384 samples for a 512-pt. FFT  */
-        fft_buf[k][(i+off[k])%640]= (double) buffer[k][i]/SCALE;
-     for(i=0;i<FFT_SIZE/2;i++)
-        sample[i] = fft_buf[k][(i+448+off[k])%640];
-     off[k] += 384;
-     off[k] %= 640;
-                         /* call functions for windowing PCM samples,   */
-     I_hann_win(sample); /* location of spectral components in each     */
-     for(i=0;i<HAN_SIZE/2;i++) power[i].x = DBMIN;   /* subband with    */
-     I_f_f_t(sample, power);              /* labeling, locate remaining */
-     I_pick_max(power, &spike[k][0]);     /* non-tonal sinusoidals,     */
-     I_tonal_label(power, &tone);         /* reduce noise & tonal com., */
-     noise_label(power, &noise, ltg);     /* find global & minimal      */
-     subsampling(power, ltg, &tone, &noise);  /* threshold, and sgnl-   */
-     threshold(power, ltg, &tone, &noise,     /* to-mask ratio          */
-       bitrate[info->version][info->lay-1][info->bitrate_index]/stereo);
-     I_minimum_mask(ltg, &ltmin[k][0]);
-     I_smr(&ltmin[k][0], &spike[k][0], &scale[k][0]);        
-  }
-  mem_free((void **) &sample);
-  mem_free((void **) &spike);
- }
--- 0 ----
diff -r -c -N encoder/util.c lame3.50/util.c
*** encoder/util.c	Wed Dec 31 17:00:00 1969
--- lame3.50/util.c	Tue Oct 26 12:14:29 1999
***************
*** 0 ****
--- 1,413 ----
+ #include "util.h"
+ #include "globalflags.h"
+ #include <assert.h>
+ 
+ /***********************************************************************
+ *
+ *  Global Variable Definitions
+ *
+ ***********************************************************************/
+ 
+ 
+ /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
+ double  s_freq[2][4] = {{22.05, 24, 16, 0}, {44.1, 48, 32, 0}};
+ 
+ /* 1: MPEG-1, 0: MPEG-2 LSF, 1995-07-11 shn */
+ int     bitrate[2][3][15] = {
+           {{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256},
+            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160},
+            {0,8,16,24,32,40,48,56,64,80,96,112,128,144,160}},
+ 	  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448},
+            {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384},
+            {0,32,40,48,56,64,80,96,112,128,160,192,224,256,320}}
+         };
+ 
+ 
+ enum byte_order NativeByteOrder = order_unknown;
+ 
+ /***********************************************************************
+ *
+ *  Global Function Definitions
+ *
+ ***********************************************************************/
+ 
+ int nint2( double in )
+ {
+     int    temp;
+ 
+     if( in < 0 )  temp = (int)(in - 0.5);
+     else    temp = (int)(in + 0.5);
+ 
+     return(temp);
+ }
+ 
+ 
+ 
+ /***********************************************************************
+  * compute bitsperframe and mean_bits for a layer III frame 
+  **********************************************************************/
+ void getframebits(layer *info, int stereo, int *bitsPerFrame, int *mean_bits) {
+   int whole_SpF;
+   double bit_rate,samp;
+   int samplesPerFrame,bitsPerSlot;
+   int sideinfo_len;
+   int mode_gr;
+   
+   samp =      s_freq[info->version][info->sampling_frequency];
+   bit_rate = bitrate[info->version][info->lay-1][info->bitrate_index];
+   samplesPerFrame = info->version == 1 ? 1152 : 576;
+   bitsPerSlot = 8;
+   mode_gr = (info->version == 1) ? 2 : 1;  /* mode_gr = 2 */
+   
+   /* determine the mean bitrate for main data */
+   sideinfo_len = 32;
+   if ( info->version == 1 )
+     {   /* MPEG 1 */
+       if ( stereo == 1 )
+ 	sideinfo_len += 136;
+       else
+ 	sideinfo_len += 256;
+     }
+   else
+     {   /* MPEG 2 */
+       if ( stereo == 1 )
+ 	sideinfo_len += 72;
+       else
+ 	sideinfo_len += 136;
+     }
+   
+   if (info->error_protection) sideinfo_len += 16;
+   
+   
+   whole_SpF =  (samplesPerFrame /samp)*(bit_rate /  (double)bitsPerSlot);
+   *bitsPerFrame = 8 * whole_SpF + (info->padding * 8);
+   *mean_bits = (*bitsPerFrame - sideinfo_len) / mode_gr;
+ }
+ 
+ 
+ 
+ 
+ void display_bitrates(int layr)
+ {
+   int index,version;
+ 
+   version = MPEG_AUDIO_ID;
+   fprintf(stderr,"\n");
+   fprintf(stderr,"MPEG1 samplerates(kHz): 32 44.1 48 \n");
+   fprintf(stderr,"bitrates(kbs): ");
+   for (index=1;index<14;index++) {
+     fprintf(stderr,"%i ",bitrate[version][layr-1][index]);
+   }
+   fprintf(stderr,"\n");
+ 
+   version = MPEG_PHASE2_LSF; 
+   fprintf(stderr,"\n");
+   fprintf(stderr,"MPEG2 samplerates(kHz): 16 22.05 24 \n");
+   fprintf(stderr,"bitrates(kbs): ");
+   for (index=1;index<15;index++) {
+     fprintf(stderr,"%i ",bitrate[version][layr-1][index]);
+   }
+   fprintf(stderr,"\n");
+ }
+ 
+ 
+ int BitrateIndex(
+ int layr,         /* 1 or 2 */
+ int bRate,        /* legal rates from 32 to 448 */
+ int version,      /* MPEG-1 or MPEG-2 LSF */
+ int samplerate)   /* convert bitrate in kbps to index */
+ {
+ int     index = 0;
+ int     found = 0;
+ 
+     while(!found && index<15)   {
+         if(bitrate[version][layr-1][index] == bRate)
+             found = 1;
+         else
+             ++index;
+     }
+     if(found)
+         return(index);
+     else {
+         fprintf(stderr,"Bitrate %dkbs not legal for %iHz output sampling.\n",
+                 bRate, samplerate);
+         return(-1);     /* Error! */
+     }
+ }
+ 
+ int SmpFrqIndex(  /* convert samp frq in Hz to index */
+ long sRate,             /* legal rates 16000, 22050, 24000, 32000, 44100, 48000 */
+ int  *version)
+ {
+     if (sRate == 44100L) {
+         *version = MPEG_AUDIO_ID; return(0);
+     }
+     else if (sRate == 48000L) {
+         *version = MPEG_AUDIO_ID; return(1);
+     }
+     else if (sRate == 32000L) {
+         *version = MPEG_AUDIO_ID; return(2);
+     }
+     else if (sRate == 24000L) {
+         *version = MPEG_PHASE2_LSF; return(1);
+     }
+     else if (sRate == 22050L) {
+         *version = MPEG_PHASE2_LSF; return(0);
+     }
+     else if (sRate == 16000L) {
+         *version = MPEG_PHASE2_LSF; return(2);
+     }
+     else {
+         fprintf(stderr, "SmpFrqIndex: %ldHz is not a legal sample rate\n", sRate);
+         return(-1);     /* Error! */
+     }
+ }
+ 
+ /*******************************************************************************
+ *
+ *  Allocate number of bytes of memory equal to "block".
+ *
+ *******************************************************************************/
+ /* exit(0) changed to exit(1) on memory allocation
+  * error -- 1999/06 Alvaro Martinez Echevarria */
+ 
+ void  *mem_alloc(unsigned long block, char *item)
+ {
+ 
+     void    *ptr;
+ 
+     /* what kind of shit does ISO put out?  */
+     ptr = (void *) malloc((size_t) block/*<<1*/); /* allocate twice as much memory as needed. fixes dodgy
+ 					    memory problem on most systems */
+ 
+ 
+     if (ptr != NULL) {
+         memset(ptr, 0, (size_t) block);
+     } else {
+         fprintf(stderr,"Unable to allocate %s\n", item);
+         exit(1);
+     }
+     return(ptr);
+ }
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  Routines to determine byte order and swap bytes
+ *
+ *****************************************************************************/
+ 
+ enum byte_order DetermineByteOrder(void)
+ {
+     char s[ sizeof(long) + 1 ];
+     union
+     {
+         long longval;
+         char charval[ sizeof(long) ];
+     } probe;
+     probe.longval = 0x41424344L;  /* ABCD in ASCII */
+     strncpy( s, probe.charval, sizeof(long) );
+     s[ sizeof(long) ] = '\0';
+     /* fprintf( stderr, "byte order is %s\n", s ); */
+     if ( strcmp(s, "ABCD") == 0 )
+         return order_bigEndian;
+     else
+         if ( strcmp(s, "DCBA") == 0 )
+             return order_littleEndian;
+         else
+             return order_unknown;
+ }
+ 
+ void SwapBytesInWords( short *loc, int words )
+ {
+     int i;
+     short thisval;
+     char *dst, *src;
+     src = (char *) &thisval;
+     for ( i = 0; i < words; i++ )
+     {
+         thisval = *loc;
+         dst = (char *) loc++;
+         dst[0] = src[1];
+         dst[1] = src[0];
+     }
+ }
+ 
+ 
+ 
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  bit_stream.c package
+ *  Author:  Jean-Georges Fritsch, C-Cube Microsystems
+ *
+ *****************************************************************************/
+ 
+ /********************************************************************
+   This package provides functions to write (exclusive or read)
+   information from (exclusive or to) the bit stream.
+ 
+   If the bit stream is opened in read mode only the get functions are
+   available. If the bit stream is opened in write mode only the put
+   functions are available.
+ ********************************************************************/
+ 
+ /*open_bit_stream_w(); open the device to write the bit stream into it    */
+ /*open_bit_stream_r(); open the device to read the bit stream from it     */
+ /*alloc_buffer();      open and initialize the buffer;                    */
+ /*desalloc_buffer();   empty and close the buffer                         */
+ /*back_track_buffer();     goes back N bits in the buffer                 */
+ /*unsigned int get1bit();  read 1 bit from the bit stream                 */
+ /*unsigned long look_ahead(); grep the next N bits in the bit stream without*/
+ /*                            changing the buffer pointer                   */
+ /*putbits(); write N bits from the bit stream */
+ /*int seek_sync(); return 1 if a sync word was found in the bit stream      */
+ /*                 otherwise returns 0                                      */
+ 
+ 
+ 
+ /* empty the buffer to the output device when the buffer becomes full */
+ /* mt 3/99: modified so we can call empty_buffer even if buffer is not full */
+ /* add error checking -- 1999/06 Alvaro Martinez Echevarria */
+ /* someone gimme a good reason for writing bytes one by
+  * one; changed -- 1999/06 Alvaro Martinez Echevarria */
+ void write_buffer(bs)
+ Bit_stream_struc *bs;   /* bit stream structure */
+ {
+    register int i,j;
+    int minimum=1+bs->buf_byte_idx;    /* end of the buffer to empty */
+    unsigned char *tmpbuf;
+    if (bs->buf_size-minimum <= 0) return;
+ 
+    tmpbuf=(unsigned char *)malloc(bs->buf_size-minimum);
+    if (tmpbuf==NULL) {
+      // fprintf(stderr,"error in malloc(): %s\n",sys_errlist[errno]);
+      perror("error in malloc()\n");
+      exit(1);
+    }
+    for (i=bs->buf_size-1,j=0;i>=minimum;i--,j++) {
+      tmpbuf[j]=bs->buf[i];
+    }
+    fwrite(tmpbuf,1,bs->buf_size-minimum,bs->pt);
+    if (ferror(bs->pt)) {
+      fprintf(stderr,"error en fwrite()\n");
+      exit(1);
+    }
+    free(tmpbuf);
+ }
+ 
+ int copy_buffer(char *buffer,Bit_stream_struc *bs)
+ {
+   int i,j=0;
+   for (i=bs->buf_size-1 ; i > bs->buf_byte_idx ; (i-- ))
+     buffer[j++]=bs->buf[i];
+   return j;
+ }
+ 
+ 
+ void empty_buffer(Bit_stream_struc *bs)
+ {
+    int minimum=1+bs->buf_byte_idx;    /* end of the buffer to empty */
+    if (bs->buf_size-minimum <= 0) return;
+    bs->buf_byte_idx = bs->buf_size -1;
+    bs->buf_bit_idx = 8;
+ 
+    bs->buf[bs->buf_byte_idx] = 0;  /* what does this do? */
+ 
+ }
+ 
+ 
+ 
+ /* open the device to write the bit stream into it */
+ void open_bit_stream_w(	
+ Bit_stream_struc* bs,	/* bit stream structure */
+ char* bs_filenam,	/* name of the bit stream file */
+ int size,              /* size of the buffer */
+ int nowrite             /* =1 to disable output */)
+ {
+   if (!nowrite) {
+     if (!strcmp(bs_filenam, "-")) {
+       /* Write to standard output. */
+ #ifdef __EMX__
+       _fsetmode(stdout,"b");
+ #elif (defined  __BORLANDC__)
+       setmode(_fileno(stdout), O_BINARY);
+ #elif (defined  __CYGWIN__)
+       setmode(fileno(stdout), _O_BINARY);
+ #elif (defined _WIN32)
+       _setmode(_fileno(stdout), _O_BINARY);
+ #endif
+       bs->pt = stdout;
+     } else {
+       if ((bs->pt = fopen(bs_filenam, "wb")) == NULL) {
+ 	fprintf(stderr,"Could not create \"%s\".\n", bs_filenam);
+ 	exit(1);
+       }
+     }
+   }
+ 
+    alloc_buffer(bs, size);
+    bs->buf_byte_idx = size-1;
+    bs->buf_bit_idx=8;
+    bs->totbit=0;
+ }
+ 
+ 
+ /*open and initialize the buffer; */
+ void alloc_buffer(
+ Bit_stream_struc *bs,   /* bit stream structure */
+ int size)
+ {
+    bs->buf = (unsigned char *)
+ 	mem_alloc((unsigned long) (size * sizeof(unsigned char)), "buffer");
+    bs->buf_size = size;
+ }
+ 
+ /*empty and close the buffer */
+ void desalloc_buffer(Bit_stream_struc *bs)   /* bit stream structure */
+ {
+    free(bs->buf);
+ }
+ 
+ int putmask[9]={0x0, 0x1, 0x3, 0x7, 0xf, 0x1f, 0x3f, 0x7f, 0xff};
+ 
+ 
+ /*write N bits into the bit stream */
+ void putbits(
+ Bit_stream_struc *bs,   /* bit stream structure */
+ unsigned int val,       /* val to write into the buffer */
+ int N)                  /* number of bits of val */
+ {
+  register int j = N;
+  register int k, tmp;
+ 
+  if (N > MAX_LENGTH)
+     fprintf(stderr,"Cannot read or write more than %d bits at a time.\n", MAX_LENGTH);
+ 
+  bs->totbit += N;
+  while (j > 0) {
+    k = Min(j, bs->buf_bit_idx);
+    tmp = val >> (j-k);
+    bs->buf[bs->buf_byte_idx] |= (tmp&putmask[k]) << (bs->buf_bit_idx-k);
+    bs->buf_bit_idx -= k;
+    if (!bs->buf_bit_idx) {
+        bs->buf_bit_idx = 8;
+        bs->buf_byte_idx--;
+        assert(bs->buf_byte_idx >= 0);
+        bs->buf[bs->buf_byte_idx] = 0;
+    }
+    j -= k;
+  }
+ }
+ 
+ 
+ 
+ /*****************************************************************************
+ *
+ *  End of bit_stream.c package
+ *
+ *****************************************************************************/
+ 
diff -r -c -N encoder/util.h lame3.50/util.h
*** encoder/util.h	Wed Dec 31 17:00:00 1969
--- lame3.50/util.h	Tue Oct 26 23:52:01 1999
***************
*** 0 ****
--- 1,181 ----
+ #ifndef UTIL_DOT_H
+ #define UTIL_DOT_H
+ /***********************************************************************
+ *
+ *  Global Include Files
+ *
+ ***********************************************************************/
+ #include "machine.h"
+ 
+ 
+ /***********************************************************************
+ *
+ *  Global Definitions
+ *
+ ***********************************************************************/
+ 
+ /* General Definitions */
+ #ifndef FALSE
+ #define         FALSE                   0
+ #endif
+ 
+ #ifndef TRUE
+ #define         TRUE                    1
+ #endif
+ 
+ #define         MAX_U_32_NUM            0xFFFFFFFF
+ #ifdef M_PI
+ #define		PI			M_PI
+ #endif
+ #ifndef PI
+ #define         PI                      3.14159265358979
+ #endif
+ #ifdef M_PI_4
+ #define		PI4			M_PI_4
+ #else
+ #define         PI4                     (PI/4)
+ #endif
+ #define         PI64                    (PI/64)
+ 
+ #define         SQRT2                   1.4142135623730951454746218587388284504414
+ 
+ #define         MPEG_AUDIO_ID           1
+ #define		MPEG_PHASE2_LSF		0	/* 1995-07-11 SHN */
+ 
+ #define         BITS_IN_A_BYTE          8
+ #define         MAX_NAME_SIZE           300
+ #define         SBLIMIT                 32
+ #define         SSLIMIT                 18
+ #define         FFT_SIZE                1024
+ #define         HAN_SIZE                512
+ #define         CRC16_POLYNOMIAL        0x8005
+ 
+ /* MPEG Header Definitions - Mode Values */
+ 
+ #define         MPG_MD_STEREO           0
+ #define         MPG_MD_JOINT_STEREO     1
+ #define         MPG_MD_DUAL_CHANNEL     2
+ #define         MPG_MD_MONO             3
+ 
+ /* Mode Extention */
+ 
+ #define         MPG_MD_LR_LR             0
+ #define         MPG_MD_LR_I              1
+ #define         MPG_MD_MS_LR             2
+ #define         MPG_MD_MS_I              3
+ 
+ 
+ /* "bit_stream.h" Definitions */
+ 
+ #define         MINIMUM         4    /* Minimum size of the buffer in bytes */
+ #define         MAX_LENGTH      32   /* Maximum length of word written or
+                                         read from bit stream */
+ #define         BUFFER_SIZE     16384
+ 
+ #define         Min(A, B)       ((A) < (B) ? (A) : (B))
+ #define         Max(A, B)       ((A) > (B) ? (A) : (B))
+ 
+ /***********************************************************************
+ *
+ *  Global Type Definitions
+ *
+ ***********************************************************************/
+ 
+ /* Structure for Reading Layer II Allocation Tables from File */
+ 
+ typedef struct {
+     unsigned int    steps;
+     unsigned int    bits;
+     unsigned int    group;
+     unsigned int    quant;
+ } sb_alloc, *alloc_ptr;
+ 
+ typedef sb_alloc        al_table[SBLIMIT][16];
+ 
+ /* Header Information Structure */
+ 
+ typedef struct {
+     int version;
+     int lay;
+     int error_protection;
+     int bitrate_index;
+     int sampling_frequency;
+     int padding;
+     int extension;
+     int mode;
+     int mode_ext;
+     int copyright;
+     int original;
+     int emphasis;
+ } layer, *the_layer;
+ 
+ /* Parent Structure Interpreting some Frame Parameters in Header */
+ 
+ typedef struct {
+     layer       *header;        /* raw header information */
+     int         actual_mode;    /* when writing IS, may forget if 0 chs */
+     al_table    *alloc;         /* bit allocation table read in */
+     int         tab_num;        /* number of table as loaded */
+     int         stereo;         /* 1 for mono, 2 for stereo */
+     int         jsbound;        /* first band of joint stereo coding */
+     int         sblimit;        /* total number of sub bands */
+ } frame_params;
+ 
+ 
+ enum byte_order { order_unknown, order_bigEndian, order_littleEndian };
+ extern enum byte_order NativeByteOrder;
+ 
+ /* "bit_stream.h" Type Definitions */
+ 
+ typedef struct  bit_stream_struc {
+     unsigned char*		pbtOutBuf;   /* for .DLL code */
+     int 			nOutBufPos;  /* for .DLL code */
+     FILE        *pt;            /* pointer to bit stream device */
+     unsigned char *buf;         /* bit stream buffer */
+     int         buf_size;       /* size of buffer (in number of bytes) */
+     unsigned long        totbit;         /* bit counter of bit stream */
+     int         buf_byte_idx;   /* pointer to top byte in buffer */
+     int         buf_bit_idx;    /* pointer to top bit of top byte in buffer */
+     
+     /* format of file in rd mode (BINARY/ASCII) */
+ } Bit_stream_struc;
+ 
+ #include "l3side.h"
+ 
+ /***********************************************************************
+ *
+ *  Global Variable External Declarations
+ *
+ ***********************************************************************/
+ 
+ extern double   s_freq[2][4];
+ extern int      bitrate[2][3][15];
+ 
+ /***********************************************************************
+ *
+ *  Global Function Prototype Declarations
+ *
+ ***********************************************************************/
+ 
+ extern void           display_bitrates(int layr);
+ extern int            BitrateIndex(int, int, int,int);
+ extern int            SmpFrqIndex(long, int*);
+ extern void           *mem_alloc(unsigned long, char*);
+ extern void           empty_buffer(Bit_stream_struc*);
+ extern int            copy_buffer(char *buffer,Bit_stream_struc *bs);
+ extern void           write_buffer(Bit_stream_struc*);
+ extern void           open_bit_stream_w(Bit_stream_struc*, char*, int, int);
+ extern void           close_bit_stream_w(Bit_stream_struc*);
+ extern void           alloc_buffer(Bit_stream_struc*, int);
+ extern void           desalloc_buffer(Bit_stream_struc*);
+ extern void           putbits(Bit_stream_struc*, unsigned int, int);
+ 
+ extern enum byte_order DetermineByteOrder(void);
+ extern void SwapBytesInWords( short *loc, int words );
+ 
+ extern void 
+ getframebits(layer *info, int stereo, int *bitsPerFrame, int *mean_bits);
+ int nint2( double in );
+ 
+ void timestatus(layer *info,long frameNum,long totalframes);
+ #endif
diff -r -c -N encoder/version.c lame3.50/version.c
*** encoder/version.c	Wed Dec 31 17:00:00 1969
--- lame3.50/version.c	Mon Sep 27 17:49:08 1999
***************
*** 0 ****
--- 1,57 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #include "version.h"
+ #include <stdio.h>
+ 
+ static char lpszVersion[80];
+ 
+ char* get_lame_version(void)
+ {
+ 	if (LAME_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_ALPHAVERSION);
+ 	else if (LAME_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",LAME_MAJOR_VERSION,LAME_MINOR_VERSION,LAME_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",LAME_MAJOR_VERSION,LAME_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_psy_version(void)
+ {
+ 	if (PSY_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (alpha %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_ALPHAVERSION);
+ 	else if (PSY_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d.%02d (beta %d)",PSY_MAJOR_VERSION,PSY_MINOR_VERSION,PSY_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d.%02d",PSY_MAJOR_VERSION,PSY_MINOR_VERSION);
+ 	return lpszVersion;
+ }
+ 
+ char* get_mp3x_version(void)
+ {
+ 	if (MP3X_ALPHAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (alpha %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_ALPHAVERSION);
+ 	else if (MP3X_BETAVERSION>0)
+ 		sprintf(lpszVersion,"%d:%02d (beta %d)",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION,MP3X_BETAVERSION);
+ 	else
+ 		sprintf(lpszVersion,"%d:%02d",MP3X_MAJOR_VERSION,MP3X_MINOR_VERSION);
+ 	return lpszVersion;
+ }
diff -r -c -N encoder/version.h lame3.50/version.h
*** encoder/version.h	Wed Dec 31 17:00:00 1969
--- lame3.50/version.h	Mon Nov  1 18:22:45 1999
***************
*** 0 ****
--- 1,44 ----
+ /*
+  *	Version numbering for LAME.
+  *
+  *	Copyright (c) 1999 A.L. Faber
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program; see the file COPYING.  If not, write to
+  * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+  */
+ 
+ #ifndef LAME_H_INCLUDED
+ #define LAME_H_INCLUDED
+ 
+ #define LAME_MAJOR_VERSION	3	/* Major version number */
+ #define LAME_MINOR_VERSION	50	/* Minor version number */
+ #define LAME_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define LAME_BETAVERSION        0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define PSY_MAJOR_VERSION	0	/* Major version number */
+ #define PSY_MINOR_VERSION	74	/* Minor version number */
+ #define PSY_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define PSY_BETAVERSION		0	/* Set number if this is a beta version, otherwise zero */
+ 
+ #define MP3X_MAJOR_VERSION	0	/* Major version number */
+ #define MP3X_MINOR_VERSION	73	/* Minor version number */
+ #define MP3X_ALPHAVERSION	0	/* Set number if this is an alpha version, otherwise zero */
+ #define MP3X_BETAVERSION	0	/* Set number if this is a beta version, otherwise zero */
+ 
+ 
+ char* get_lame_version(void);		/* returns lame version number string */
+ char* get_psy_version(void);		/* returns psy model version number string */
+ char* get_mp3x_version(void);		/* returns mp3x version number string */
+ 
+ #endif
